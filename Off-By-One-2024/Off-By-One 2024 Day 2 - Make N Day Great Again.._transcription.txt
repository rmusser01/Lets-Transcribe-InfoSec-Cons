{
  "webpage_url": "https://www.youtube.com/watch?v=u_2sRheRYkQ",
  "title": "Off-By-One 2024 Day 2 -  Make N Day Great Again..",
  "description": "Make N-Day Great Again - The Story of N-Day Full Chain from browser in guest to SYSTEM in host\n\nAbstract\n\nDuring the last year, numerous vulnerabilities were patched, and some of them were proven to be exploitable, as they were exploited in the wild, Pwn2Own, and so on.\n\nWe have continuously tracked these issues and written the Proof-of-Concepts and exploits to keep them in our vulnerability database.\n\nAlthough each vulnerability itself has a critical impact, we think it would become more powerful if they are chained into a full chain exploit.\n\nTherefore, we wrote an exploit chaining several vulnerabilities chosen from our database and demonstrated the exploit on X; the exploit starts from a Chrome browser running in a VMware guest and then manages to achieve SYSTEM privileges in a Windows host.\n\nThis scenario mimics a situation where a security analyst clicks a malicious link in a virtual machine. The N-Day full chain includes six unique vulnerabilities; three of them were exploited in the wild, two of them were used in Pwn2Own 2023, and the last one, a variant of a Pwn2Own 2023 vulnerability, was found by one of our team members.\n\nIn this presentation, we will explain the root causes and the exploit techniques of each vulnerability and how we connected them into a full chain exploit.\n\nWe will also discuss chaining details to glue our exploit pieces together successfully, including how to bypass V8 pointer compression, implant browser sandbox escape vulnerability in JavaScript code, escape the browser sandbox with the pickup window, and drop the exploit binary on the host of VMware.\n\nThis presentation will cover overall concepts from browser to virtualization and OS, and you will have a comprehensive understanding of them after this talk.\n\nSpeakers\nJeongOh Kyea is a researcher at Theori Korea and has an interest in automatic vulnerability detection, binary analysis, and exploit techniques. He received a BS and MS degree in KAIST. He was selected as the Most Valuable Researcher(MVR) in 2020, 2021, 2022 from Microsoft.\n\nGwangun Jung is a security researcher at Theori. His main research areas are operating systems, virtualization, red teaming. He is the Pwn2own Vancouver 2024 Virtualization category winner targeting VMware Workstation and received CVEs from Linux/VMware/etc.\n\nFollow Gwangun on X @pr0ln.\n\nYeonghun Kim is a security researcher working at Theori. His main research areas are web browsers and JavaScript engines, especially Chrome and V8.",
  "channel_url": "https://www.youtube.com/channel/UCmrsIbKdxEMBEefD8v8RigQ",
  "duration": 2121,
  "channel": "Off-By-One Comms Team",
  "uploader": "Off-By-One Comms Team",
  "upload_date": "20240901"
}

This text was transcribed using whisper model: large-v2

 Good afternoon. Welcome to my presentation.  This is the last session of O5-1 conference.  My topic is about the story of creating NDAful chain.  First, let us introduce ourselves.  My name is Jungwoo Gae, and I collaborated this project with Kwanghoon Jung and Younghoon Kim.  We are the vulnerability research team of Deory.  Before I start our story, I will first show you the NDAful chain we have created.  I think some of you may have already seen it, because this video is also posted in our company's SNS.  We started the vendor in the guest.  Finally, we got the system shell in the host.  This is our NDAful chain.  Now, let me tell you about the story.  This is the content of this presentation.  To tell why we started this research, I can't leave the fairing service, our threat intelligence service.  This service is the vulnerability report database since 2019.  Until now, 486 reports exist and half of them has working exploits.  You can check the information of the fairing service in our company's blog.  This is the simple statistics for the reports in 2023.  71 reports were written and 37 reports have own working exploits.  Also, some of these reports have been proven to be exploitable because they are used for in the wild or exploit competition like hunter-hunter.  There are tons of reports on Fermion, so we thought that we can do something interesting with them.  Also, we wanted to get some advertising for Fermion service.  Here are the ingredients for a delicious exploit.  First, we thought about the fruit chain.  This situation is someone uses a Chrome browser inside a virtual box inside a VR.  Maybe we already have all the ingredients for this fruit exploit.  But we thought that this situation is not practical.  Moreover, this research seems to need too much work.  Therefore, we changed the situation a little simple.  We just removed the layer of virtual box.  The situation seems to be similar like when the researcher opens the malicious link in VMware.  So the exploit starts from the renderer in guest and ends at the system in host.  So it is the ingredients.  Let's take a look for each vulnerability and its exploitation.  We used 6 unique vulnerabilities.  Three are used in the wild and two are used in Punt1.2023.  And the last is the variant of Punt1.2023.  Because of the time limitation, describing all details about this vulnerability is almost impossible.  However, because all reports are also posted on our blog, you can check if you want.  Let's start from JavaScript code in renderer.  This vulnerability is cv20233079, which is used in the wild.  This is type confusion bug in inline cache for JSStrictArgument object.  First, what is the inline cache?  It is the optimization method for the bytecode v8.  It will register the faster handler according to the time feedback while executing.  Let's look at this example.  After feedback is collected here 10 times, the handler will be registered on the feedback.  Then, if the second time is used again in the future, the registered handler will be used directly to speed up.  In this example, the store handler for SMI is registered as a handler.  Second, what is the JSStrictArgument object?  JSStrictArgument object is a type of argument object used in strict JavaScript code.  Argument object is used to represent the arguments of a function, and it is like array object.  It has elements accessed by index, and also the length is defined.  JSArray looks like this.  There are two size values, length and capacity.  Length represents the number of elements, and capacity is the location size of element's area.  Then, what values are stored in the area between length and capacity?  It is whole object.  This object should not be exposed to JavaScript itself, so VA has to convert it into JavaScript value,  such as undefined or false, according to the situation.  As mentioned before, JSStrictArgument object is like array, but there are many differences.  Among several differences, the main difference related to this vulnerability is the behavior  when a new element is added to the end of array.  As shown in this code, the element kind of JSArgument object will be changed to holy by this code,  but while the JSArray does not.  Let's walk through with this example.  I created an empty array and added one element at the end.  The element kind remains packed element for the JSArray.  But similarly, I create argument object with no element and added one element at the end.  Then, the element kind changes to holy element from packed element.  This vulnerability occurs because improper handler is registered for argument object.  Because of this vulnerability, this storeFastElementIc, growNo, blah blah handler can be registered  as a handler for JSStrictArgument object.  This handler will not change the element kind to holy.  So, in this situation, JSStrictArgument with packed element is possible.  So, what happens in this case?  Unlike JSArray, argument object uses the capacity as the length.  Because the element kind is packed element, the element will be returned directly.  If you access index 1 for this corrupted argument object,  the whole object will be read to JavaScript because the index 1 is less than the capacity.  Then, how can I use the whole object for exploit?  We need to use another bug in JIT compiler.  As shown in this picture, the whole or range-1 and minus-1,  this node will be changed to range-1 and minus-1.  This bug is caused by the JIT compiler not handling the whole object properly  because the whole object does not expose to JavaScript normally.  And then, this wrong assumption will remove the bound check.  However, in the actual execution, the whole object will be interpreted as 0, not minus-1.  So, it causes out-of-bound access in the compiled code.  After then, you can apply the typical way to achieve read-write primitive in V8 heap sandbox.  Yes, there is one more mountain to climb, V8 sandbox.  Because of this mitigation, we cannot read or write beyond the V8 object area.  Obviously, the RWX area is also outside the V8 sandbox.  So, how can we escape this?  The common and popular method is exploiting the low pointer in V8 sandbox.  For our exploit chain, we exploited the low pointer in WASM object.  This is patched now.  The target field of WASM object here remains as a low pointer.  And there is also the function to write arbitrary value to the address of target field in this function.  So, this allows us to arbitrary value to the arbitrary address outside the V8 sandbox.  Also, we can get the address of RWX area because it is stored inside V8 sandbox.  And then, we write the shellcode to RWX area using arbitrary write primitive as I described just before.  And call the WASM function.  Then, we got the code execution.  So, we are now here.  And we can execute arbitrary code in Chrome Renderer.  So now, we must escape the browser sandbox of Chrome.  To escape the browser sandbox, we exploited the Windows kernel vulnerability CVE-2023-21674.  This vulnerability existed in the Advanced Local Procedure Core, ALPC.  ALPC is one of the communication methods between processes on Windows.  In the Chrome Renderer, ALPC is also available including creating port, sending and receiving messages, and so on.  The vulnerability occurs while processing this flag, ALPC message flag and sync request flag in the ALPC message.  As the name of the flag suggests, the flag means that the message requests are processed synchronously.  In other words, the sending and receiving the message should be done consecutively.  When you send a message with this flag, the current thread address will be stored in the waiting thread field,  which represents the thread that will receive the response.  Because of sync flag, the reply process will be executed consecutively while the current thread 1 is blocked.  When the thread 2 replies, the waiting thread field should be changed depending on the state of thread 2.  It will be null or the address of thread 2.  The important thing is that the waiting thread field must not be the address of sender thread, thread 1.  However, there is a way to make the thread field remain the sender thread's address, although the sync flag is set.  That is, the anti-wait for worker factory system call.  This system call only sends the ALPC message without validating the sync flag.  Therefore, if the thread is terminated just returning from this system call,  the waiting thread field will remain as a dangling pointer.  To exploit this vulnerability, we have checked the code that references the waiting thread field.  Using this code shown on the screen, we can change the value at an arbitrary address.  However, as you know, another vulnerability is needed to get the kernel address in the sandbox.  It is hard to apply this method directly, but this method can be used in medium integrity.  Here is another code which references the waiting thread field.  LPCPCOPYREQUESTDATA will get the process address from the waiting thread field, which is already freed memory.  And then it calls mmCopyVirtualMemory to read from or write to the data of that process.  So if you can place the higher privileged thread in the freed memory,  you can make read-write primitive on the higher privileged process.  Using this code, we can make the code execution in medium integrity.  I will talk about the details later.  Anyway, now we are at the user privilege in the guest here.  So to trigger the VMWare vulnerability, we need to elevate the privilege to the system.  For LPE, we used CVE-2023-29360, which is used in Pantone-2023 by Synaptic.  This vulnerability is a beautiful logic bug that allows attackers to map arbitrary addresses.  As shown in this code, attackers can control the address, this value.  And this value will be mapped with kernel mode.  That is, attackers can also map the kernel address by using this vulnerability.  And then we can read from or write to the address through the mapping area.  So we get the read-write primitive combining the address read by anti-query system information.  This will be gone soon.  We can easily get the system privilege.  So now we are at the system of guests.  Let's escape VMWare.  First, we need to know the address information.  For this, we exploited CVE-2023-34044, which is a variant of Pantone-2023.  First, let's take a look at the Pantone vulnerability, CVE-2023-20870, which was found by starapps.  This is a simple uninitialized bug which occurs while handling the USB request block for virtual Bluetooth.  As shown in this code, when the buffer for URB is created, the data is not initialized.  After then, this header part will be set to the appropriate value, but the data part remains uninitialized.  This URB data is finally delivered to the guest as many as the user requested.  Therefore, the uninitialized data is also delivered to the guest and we can get the information in it.  This is the patch.  The patch is quite simple.  The actual length field is set to 8 before response.  8 is the size of header.  But is this code in the red rectangle safe?  It executed before the patch code.  Let's check it.  If the length of buffer's calculated value is greater than 255, an error is thrown without changing the actual length field.  Then, response proceeds.  This is the same situation as previous vulnerability.  To place a meaningful value in the uninitialized area, we use the virtual mouse URB because it has the data section address of VMware VMX.  The exploit process is like this.  First, send the URB package for the virtual mouse device.  Then, after these URB packages are freed, the URB package or Bluetooth device to trigger this vulnerability.  Finally, we can get the address information from the buffer.  Yeah, we are almost there.  Let's escape the VMware.  We exploited the CVE-2023-20869, which was used in Punt1-2023 and also found by Starex.  This vulnerability occurs while processing the Service Discovery Protocol, SDP, of Bluetooth.  This code is the handler for the SDP package.  As you can see in this code, the ElmetType and ElmetSize are both user controllable because they are calculated from user buffer.  If ElmetType is SDPDE unit, that is 1, then SDPData.readLowInt() function is called.  In this function, because we can control the alien value, two buffer flows will occur.  The first buffer flow for the buffer TMP by RBufferCopyOutHeader() function and the second buffer flow occurs by ManCopy() function.  More important part is the second buffer flow.  Because the ManCopy() function doesn't use its own stack, so no stack cookie exists for the ManCopy() function.  In addition, since the minus index is used for the destination buffer, we can override the return address of ManCopy() function.  So by ROP, we can execute WinEXEC API.  Here is the RPChain for our exploit.  As mentioned before, there are two copying processes.  The first copy process is done for the TMP buffer.  And then the state will be like this.  The second copy process is done at a negative index away from SRC.  In this case, because the length is 0x90, the copy will start from SRC-0x80.  So the final state is like this.  After the first article is executed, the state has been changed like this.  And finally, the state is like this, so we can execute Kark command by WinEXEC API.  Finally, we are down to the last step.  The final vulnerability which is used for elevating the privilege on the host is CVE-2023-36802.  It exists in the same driver as the vulnerability used for guest LPE.  As shown in this code, when the publishRx dysfunction is called,  the fscontext2 as the first argument, which is this value.  At this point, we can infer that fscontext2 is a type of fsStringReq.  Because the name is a StringReq object.  Before calling publishRx, the findObject function validates fscontext2.  Let's take a look at the findObject function.  I omitted lots of code, but as shown in this code, fscontext2 can be of two types.  After analyzing this binary, we can find that they are of type fscontextReq and fsStringReq.  fscontextReq has been initialized in this code and the size of the object is  0x78 bytes.  fsStringReq has been initialized in this code and the size of the object is 0x1d8 bytes.  This object is the value that code expects.  So, what will happen if it is fscontextReq, not fsStringReq?  The type confusion can occur.  Because of the size difference, the type confusion will trigger out-of-bound access.  Because the vulnerable object is in a non-paged pool, we can use the named pipe object to control memory layout.  Also, as shown in this code, you can create arbitrary decrement primitives if the attacker can control the value at the offset 0x1c8.  However, we sprayed with the named pipe object.  The header of the object has been located at the offset 0x1c8.  Because the value in the header is hard to control by attackers, we need to use another way.  To solve this, we took the approach of utilizing other objects.  We utilized thread name object instead of named pipe object.  Similar to named pipe object, with this object, we can create the memory of any size and store the data you want and release it when you want.  But this object has only 0x10 bytes header, while the named pipe has 0x30 bytes.  Therefore, the layout will be changed like this.  Because we can control the data in offset 0x1c8, we are able to trigger arbitrary decrement primitive.  Eventually, you can change the previous mode of current thread to 0 by this primitive and then duplicate the system token to get the system privilege.  Finally, we reach to the system host.  This concludes the introduction of vulnerabilities and its exploits.  After then, we need to chain these vulnerabilities.  There are many ways for chaining them.  This section will describe about what we have tried.  First, chaining the renderer and sandbox escape exploit.  We need to make the shellcode about whole exploit process to chain them.  But it is so difficult and inconvenient.  So many exploits utilize the helper class, which allows attackers to write their exploit code as JavaScript.  Punjs is one of the helper class for exploit.  It was developed by our company, but sadly, it is not maintained for 5 years.  So I wrote own helper class for this.  This is the power of the exploit code.  With the own helper class, I can embed the sandbox escape exploit code as JavaScript, like this.  And then, I will pick up where I left off.  For the sandbox escape, I have set up the strategy like this.  To achieve this, we should spread the threat of the higher privilege process.  Which process is suitable?  We first try to find a way to create the system threat, but it is not easy.  We try to find a way to create the system threat, but it is something hard due to the limited permission in the sandbox.  So we turned our attention to another processes.  One candidate was audio process of Chrome.  We can easily create the threat of that process by this code.  However, when the audio threat is created, the renderer threat is also created.  It reduces the probability of audio threat taking up the free memory.  In addition, audio threat has many mitigations, which makes exploit more difficult.  The second option is file picker process.  Just calling this function should open file picker.  The file picker window is created as a new process.  This process is medium integrity with few mitigations.  File picker windows will generate 25 to 30 threats, and they have been placed at the free memory with high probability when I pass it.  Now we select the target process and we can rewrite on that process.  Then how can we run the arbitrary code?  To make the arbitrary code, we overwrite the global variable which contains the object address.  Using the arbitrary redirect primitive, construct the fake object at the empty area,  and then overwrite the global object to the address of fake object.  When the global object returns, the exploit will be triggered.  There are some candidates for global variable to overwrite.  We have used the GActive verifier for our exploit.  This is referenced when the file picker window is closed.  Next, how did we construct the fake object?  There are many ways to construct.  In my case, to construct the fake object, we used two gadgets.  The first gadget is this function.  This gadget can be used to connect function calls of two objects.  The second gadget is this function.  This gadget allows attackers to invoke an arbitrary function with desired arguments.  So this is the full structure of our fake object.  First, the function calls of object 1 and object 2 will be connected by the first gadget.  Object 1 is used to allocate RWX memory.  Object 2 is used to connect object 3 and object 4.  Object 3 will copy the share code into the RWX area.  Finally, object 4 will jump to the share code.  So we got the arbitrary code execution outside the Chrome sandbox.  The LP is easily connected.  I skipped the part.  The final problem is the limited space for the commands in WinEXE's API.  To chain with LP exploit on host, we need to create a directory, download the exploit binary, and execute it.  Maybe the powershell command is the best option, but the space is too small.  So this space is only possible for the command line.  To solve this problem, elaborating the outer chain is an option.  But we choose to use different memory space for the command line.  So we use the physical memory of guest OS.  From the host OS perspective, the physical memory of guest OS is treated as a mapped memory.  And each address can be obtained from VMWare VMX memory.  So we just need to add one more RP gadget, which gets the address of mapped memory and puts it into the RCS register.  The rest of the RP chain is the same.  So that's the full story for our exploit chain.  It's been a good experience for us, and we learned a lot for each system.  Connecting each vulnerability makes them much more powerful and lots of fun.  So maybe we'll be back with more interesting research, since we still have lots of ingredients in our database.  I will end my presentation. Thank you very much.  Wonderful. Thank you, Jahal.