{
  "webpage_url": "https://www.youtube.com/watch?v=tOwSet1RVkU",
  "title": "Off-By-One 2024 Day 1- Ghost in the BLF:A 2 year journey of chasing in the wild LPE exploits",
  "description": "Ghost in the BLF: A two-year journey of chasing in-the-wild LPE exploits in Windows CLFS\n\nAbstract\n\nSince October 2021, we have been continuously chasing the latest in-the-wild Windows CLFS (Common Log File System) LPE exploits. During this process, we captured two in-the-wild Windows CLFS 0days and at least seven in-the-wild Windows CLFS 1days.\n\nMeanwhile, through variant analysis of the itw exploits, we identified two new CLFS vulnerabilities and reported them to Microsoft. Interestingly, two of the captured 1day exploits utilized the vulnerabilities that we discovered through variant analysis.\n\nIn this talk, we will share how we are using the combination of \u201cthreat hunting\u201d and \u201cvariant analysis\u201d to assist Microsoft in patching four CLFS 0day vulnerabilities (two in-the-wild 0days and two independently discovered 0days).\n\nWe believe that the approach combining \u201cthreat hunting\u201d and \u201cvariant analysis\u201d is more effective than traditional defense methods, and we want to share our practical and insights into this process: why we selected CLFS vulnerabilities, how we chased in-the-wild CLFS exploits, how we analyzed captured vulnerability exploits, and how we conduct variant analysis. At the end of this talk, we will incorporate the latest findings to give some insights on the in-the-wild Windows LPE 0days trends.\n\nSpeakers\nQuan Jin is a security research expert from DBAPPSecurity WeBin Lab. His interests are vulnerability research and itw 0day hunting.\n\nHe has received more than 40 CVE acknowledgments from Microsoft/Adobe/Apple, and has been listed as a MSRC Most Valuable Security Researcher for three years(2020-2022).\n\nHe once spoke at Bluehat Shanghai 2019, HITB2021AMS/HITB2023AMS and BlackHat USA 2022/BlackHat Asia 2024.\n\nYingqi Shi is an undergraduate senior majoring in Computer Science, currently serving as a security research intern at DBAPPSecurity. His main research areas include binary analysis, vulnerability discovery & exploitation and reverse engineering.\n\nHe excels particularly in reverse engineering. He is a core member of the Nu1L Team, achieving excellent results in numerous top-tier CTF (Capture The Flag) events both domestically and internationally. He once spoke at BlackHat Asia 2024\n\nGuoxian Zhong is a senior security engineer at DBAPPSecurity WeBin Lab. His main research areas include binary analysis, reverse engineering and vulnerability discovery & exploitation. He once spoke at BlackHat Asia 2024.",
  "channel_url": "https://www.youtube.com/channel/UCmrsIbKdxEMBEefD8v8RigQ",
  "duration": 2170,
  "channel": "Off-By-One Comms Team",
  "uploader": "Off-By-One Comms Team",
  "upload_date": "20240831"
}

This text was transcribed using whisper model: large-v2

 Hi, everyone.  We are happy to be here at the BionConference.  Today we are going to talk about Ghost in the DLM, a two-year journey of testing in  the wild LPX road in the North Commonwealth Fire Sector.  My name is Chuan Jin.  They are my two team members, Xi Shi and Guo Xianzhong.  We are from BBATP Security Weaving Lab.  This slide outlines the key points of our presentation.  First, we will talk about our journey of testing in the wild LPX roads in the North Commonwealth  Fire Sector.  Second, we will review a Pandora's box of the North Commonwealth Fire Sector X roads  and compare them with the work of other vendors.  Third, we will discuss some samples that other vendors have overlooked.  Finally, we will provide some insights into the transport in the wild Windows LP0 days.  This page lists some previous researches on Windows Commonwealth Fire System, including  Death Note of Microsoft Windows Kernel by Ken Lam, Commonwealth Fire System Internals  by Alex.  Tracking the Commonwealth Fire System by 360 and Windows Commonwealth Fire System and  file X roads used by ransomware operators by Kaspersky.  Similarity with these words will help you better understand our talk.  Next, we will divide our presentation into five parts.  The first part is Start, where we will discuss how we began this work.  The second part is Hunt, where we will explain how we hunt the first eight Commonwealth Fire  System X roads.  We will provide a brief overview of each X road, including basic information and the  vulnerability root cause.  The third part is Analyzing, focusing on our painful experience in analyzing the first  Commonwealth Fire System X roads and how we developed some tools to speed up the analysis.  And share two more unpublished Commonwealth Fire System X roads.  The first part is Variant, where we will share two Commonwealth Fire System vulnerabilities  that we discovered through variant analysis.  The last part is Summary, where we will provide the relations between different Commonwealth  Fire System X roads and make a summary.  Now, let's step into the Start section.  We began our journey by catching the first Commonwealth Fire System X road in October  2021, which triggered a YARA report we wrote for Pipe Tribute.  This X road, with its CV under, achieved control flow hijacking by modifying the P  container pointer.  For more details about this step, you can refer to my Black Hat USA 2022 presentation.  Here, I want to highlight the P container member, which is illustrated in a diagram  from a blog of Kaspersky.  This diagram is easy to understand, so I will close it here.  P container is a key pointer exploited by the first and all subsequent Commonwealth  Fire System X roads we caught.  All the X roads we caught focus on how to modify this member.  So, let's see how the first X road modifies the P container.  It modifies the P container by performing a 1-bit flip inside the Commonwealth Fire  System logSVB physical FlashMatterData function.  Through this operation, it changed 1-bit of an offset, causing the Commonwealth Fire  System driver to load a fake P container.  In April 2022, several Commonwealth Fire System vulnerabilities were reported, including one  reported by NSN and CrowdStrike.  Additionally, the research paper on 360 attacking the Commonwealth Fire System was presented  at Black Hat Asia 2022 this month.  At that time, we realized that more X roads in the Commonwealth Fire System may appear  in the future.  When we realized this, we began a serious hunt journey.  So, how do we better hunt these X roads?  First, let's review how the first X road was caught.  It was detected by a YARA work we wrote for the pipe tribute technique.  For more details, please refer to my presentation at Black Hat USA 2022.  The Chinese philosopher Lao Tzu once said, the way backs one, one backs two, two backs  three, and three backs all things.  By carefully studying the first X road, we can quickly find the second and the third.  So, how did we analyze the first X road?  We studied it from multiplying dimensions, such as code similarity, PVB paths, X road  techniques, and strings.  Additionally, Steve Jobs once said, stay hungry, stay foolish, means one should remain  humble and eager.  Therefore, we actively collected and carefully studied information about Commonwealth Fire  System vulnerabilities disclosed by other vendors.  Another month passed, and we caught the second Commonwealth Fire System X road, which also  triggered the pipe tribute work.  This stamper was caught in May 2022.  One interesting aspect of this stamper is that its PVB paths indicate that the author  believed he was writing an X road for CVE 2022-24521, but he's not.  This X road was labeled by Kaspersky as X road 1.  Let's take a look at where the P container point is modified in this stamper.  It's still within CLFS, not CVE physical flush mentor data, but this time it's using  The third Commonwealth Fire System X road we caught was in a wild stamper of CVE 2022-24521.  This was the real CVE 2022-24521.  The vulnerability origin from a lack of proper validation on the signature's movie set of  CLFS log block header.  Let's see how the stamper tampered with the P container.  It modified the P container within the CLFS encode block function, and the CLFS encode  block function was called by the CLFS base file persisted write metadata block.  In the same month, we also caught another in the wild Commonwealth Fire System X road.  This time is a really zero day.  The CVE number is CVE 2022-37969.  This stamper also hit our pipe tribute row and many other rows.  The X road code of the stamper used a different technique from the previous stampers.  It employed the NTSC set access state generate matching and the CLFS earlier LSN function.  For those interested, this galler had published two high-quality blog posts you can read there.  Let's see how the stamper modified the P container.  This time it was done in CLFS base file persisted a log symbol by using memory set.  It particularly zeroed out the P container.  One month later, we caught another new Commonwealth Fire System one day X road, which was also  detected by the pipe tribute row.  We couldn't identify the CVE number for this X road.  But what's interesting is that it introduced some new X road techniques, this including  hijacking virtual function codes in CLFS base file persisted check secure access and using  functions such as CLFS, MGMT to register management client, NTPOFX processor notification  and NTRK or clear read.  Kaspersky had also discussed this stamper in their blog labelled as X road 2.  Readers interested can refer to their blog.  Let's see how the fifth stamper modified the P container.  This time, it returned to the CLFS log FCP physical flush meter data function, but used  the F attributes instead.  Another month passed and we caught the sixth CLFS X road, which also didn't have a CVE number.  The X road technique used in this stamper is similar to the previous one.  Kaspersky had also discussed this stamper in their blog labelled as X road 3.  Let's see how the stamper modified the P container.  This time, it was still within the CLFS log FCP physical flush meter data function, but  it used the LSTM restart number.  By summarizing the strengths and X road techniques of different X roads, we can clearly identify  two different developers.  We can roughly categorize the first and the top of thirds on the developer A and the second,  the first, the fifth, the sixth and a later one on the developer B.  The next stamper we caught was CVE-2023-28252, but we decided to first discuss in the wild  sample of CVE-2023-23376, which we discovered when analyzing the CVE-2023-28252 X road.  This is a zero day that was caught by Microsoft itself.  Due to Kaspersky had provided detailed information about this vulnerability in their blog, and  they labelled it as X road 4, so I won't talk too much about this X road here.  Interested readers can refer to their blog.  The eighth X road we caught was CVE-2023-28258, another in the wild zero days.  It was reported to Microsoft by us, Kaspersky and Mandiant.  Kaspersky has also discussed this X road in their blog, labelled as X road 5.  Again, I won't talk too much about this X road here.  Interested readers can refer to their blog.  After briefly sharing the eight common log file system X roads, we can move to the analyze section.  First, I'd like to share with you how we analyzed the first common log file system X road.  At that time, we were completely unfamiliar with Windows common log file system and BLF file format,  and there were few materials available for them.  To analyze the first X road, we did a lot of debugging and reverse engineering, made us exhausted.  Afterwards, we started developing a 010 enter template for parsing the BLF file format.  With the template, analyzing the BLF log files became much easier.  This greatly accelerated our analyzed speed.  In addition to the 010 enter template, we also wrote a common log file system structure header file  that could be imported into Header.  After importing the header file, reverse engineering of the common log file system driver became much easier.  This greatly facilitated our analysis of common log file system X roads.  Next, let's discuss a few questions.  The first question is how to define whether a sample is a 0-day, 1-day, or N-day.  The second question is how to determine the root cause of a common log file system vulnerability.  The third question is how to classify a new X road under a specific common CDE.  For the first question, we used the simplest method, creating three environments to distinguish the three types of X roads.  For the second question, we typically used the 010 template to parse the fields of the tampered BLF file  to locate the files that facilitate the identification of the vulnerability's root cause.  For cases where 010 template is not enough, we will use reverse engineering and debugging for further confirmation.  During the analysis process, we also discovered some interesting samples.  For example, in the wild X roads of CDE-2023-23376 and CDE-2023-28252 at Packard and to evade detection,  some samples are also obfuscated, like the 28258 in the middle of this slide.  Additionally, there are some samples that do not work properly or cause a BSOD after running.  Next, let's look at the 9th common log file system X road, which we caught in November 2023.  Interestingly, its compilation time was also in November 2023, but the corresponding vulnerability was patched in January 2022.  The code style of this sample is significantly different from the two developers mentioned before,  and the code quality is a bit low. After running the sample, the winlog process will crash.  Additionally, this sample is not compatible with the Windows 11 operating system.  All signs indicate that this sample was written by a non-professional developer.  This sample has not been publicly disclosed before.  Let's see how this X road modifies the P contender.  This sample also modifies the P contender when assigning the query time number in the CLFF logFCB,  physical flush mental data function. It's in the same point as I mentioned in the second X road.  In the same month, we also caught another common log file system X road.  It is a vulnerability that was patched in September 2022.  We found that this sample's X road techniques are basically the same to the second X road.  So it can also be considered as being written by the developer B.  This sample has not been published disclosed before.  Next, let my partner Yingqi Shi explain how to look for the root cause of this X road.  Since we have many malicious samples, the next question is how to analyze the malicious exploit.  We must know how they do, how they construct the P of file.  Let's look for root cause of about 10 exploits.  The first thing we do when we get a malicious sample is to reverse it.  But unfortunately, our sample has been obfuscated by counterflow.  There are too many junk instructions, too big stack frames, and this assembler is too slow.  How to solve it?  Let's try to think as an exploit developer.  We allocate memory to store our shared code locally.  In Windows, we use virtual log generally.  So we look up import tables and try to find the code.  You can see our guess was right.  Next, we set a hardware breakpoint in the allocate memory region.  You can see interrupt success.  They still use decontainer to hijack the counterflow and elevate their privileges from user level to kernel.  Then, we have a question.  Where does decontainer change?  After some reversing works and debugging, we noticed the function writeMeetDataBlock  placed the decontainer in the class instance into the file count block.  Let's see where decontainer comes from.  As you see, container context contains decontainer.  Context comes from the function acquireContainerContext.  Now, let's see more about this function.  In this function, it gets the base log recorder and retrievals named rgContainers according to the index.  rgContainers is an array of the container symbols offset.  Then, it will call function getSymbol to get container context.  New question arrives.  Where does the container symbol change?  Before we continue our question and answer, we must know what symbol.  What is the structure of symbol?  You can see the picture on the screen.  It's still referring from Kaspersky's log.  As you see, this structure means hash symbol and has field named cbOffset,  means count of bytes offset.  This offset points to all contexts, including client and container.  And cfS driver according symbol offset to get context.  The function symbol tells us we have another function to hash symbol.  Continue.  According to the input tables and reference code,  there are function chain called by addLogContainer.  That means our idea is right.  We can call function aLogSymbol to create a new symbol.  Let's see that.  It's getting more and more interesting.  After reading, we can see that the initial symbol has part cbSymbolZoom.  That offset of symbolZoom.  I think it can be called symbol cursor.  It's offset of nextSymbolOffset.  That means it's offset to all of all exist symbol ended position.  This function initializes the memory region to the symbol according to cbSymbolZoom.  You can see my blue comment marks the offset in my comment block.  Remember it.  Be careful.  If you use format template path file, you will be stressed.  So you can see on the screen, I have marked the points corresponding to cbSymbolZoom.  Clamp context overlaps with container symbol.  It's magic.  OK.  Next, let's move on.  Back to Kotlin.  You can see the highlighted code.  It's construct structure of cfsHashSymbol.  This structure includes cbOffset.  Remember it's offset of context.  OK.  Back to Kotlin again.  We create symbol after calling and symbol next function.  AddContainer will use cbOffset and locate to symbol and read offset of context.  And the key point, setToClampDistance will end rgContainers.  Do you remember that a few minutes ago, I mentioned the rgContainers in function acquireContainerContext.  Let's see it again.  Yeah.  We use cbSymbolZoom to control offset of symbol.  So when we call acquireContainerContext, the driver will get valid container context under our control.  Back to the code.  It's then will call to the function named writeMeetDateBlock.  Does it look familiar?  We are back to the beginning.  So now, we control driver to write a new container context as a special case.  The last question is, where modify the container in the structure of container context?  In order to answer this question, we notice the function, flashMeetDate.  As you see, this symbol modifies the container.  cbOffsetDriver restores client context from class instance.  By the way, the reason I mentioned the restore also means that there must be backup.  So in this case, I omit backup part.  The corresponding field view comes from raw file con cloud in fact.  The modification occurs when the LSN last and LSN restart member was assigned.  Finally, you can see the container has been modified.  At this point, we have synonymously identified the root cause of this vulnerability.  Next, I will get my under-training and you shall read the rest of our presentation.  After discussing the 10 in the wild common log file system exploits, we will now talk about variant analysis.  Why variant analysis is important?  I think this slide by Manny Stow gives us a reason.  How do we conduct variant analysis?  I think it can be divided into two situations.  The first is when the vulnerability itself hasn't disappeared,  but a patch accidentally prevents the triggering of this vulnerability, causing the exploit to fail.  A typical example is CVE-2022-24481.  The second is when the developer seems to understand the root cause of the vulnerability and fix the bug,  but they have not completely fixed or made a mistake.  A typical example is CVE-2022-35803, which we found by auditing the patch for CVE-2022-24481.  Let's first look at the example of CVE-2022-24481.  A key point of this exploit is that there is a 1-bit flip at this location.  However, in the September 2021 patch, an added validation accidentally blocked this vulnerability.  The patch only checked the value of ClientContextOffset,  to make sure it couldn't be less than 3068.  So what if we construct a ClientContextOffset that is greater than this value  and make the ClientContextOffset point to a forward container context?  But after some simple modification, a new 1-bit flip was born.  And this leads to BSOD.  Now we can see the familiar BSOD again.  This variant is CVE-2022-24481.  And now let's look at the example of CVE-2022-35803.  This vulnerability was discovered while analyzing the patch for CVE-2022-24480.  In the April 2022 patch, the Common Log File System driver added a new function  CLFSBaseFileValidateRgOffsets.  Due to this patch, the method of directly modifying the ClientContextOffset was fixed.  However, there was still no check for CIDNode.ctype.  Therefore, we only need to set the CIDNode.ctype file  of a ClientContext to ContainerContext to bypass this patch.  Lucky Yu has written a wonderful blog about this vulnerability.  Anyone interested in this case can read his blog.  By the way, the in-the-web-exploits mentioned in Lucky Yu's blog  is actually the second exploit discussed in this talk.  From the figure, we can see that by changing the type of different contexts,  we successfully hijacked a function point to a non-executable memory, triggering a BSOD.  Finally, let's briefly summarize this presentation.  From October 2021 to November 2022,  we caught 10 different Common Log File Systems in the wild exploits over 2 years.  The table shows the CVE numbers of these exploits,  their corresponding neighbors by Kaspersky's blog, and their hashes.  During the journey of tracking Common Log File Systems,  we have caught two Windows-in-the-wild zero-days  and independently discovered two Common Log File Systems zero-days through variant analysis.  All these four vulnerabilities received acknowledgments from Microsoft.  And finally, combining with recent observations,  we can predict the trends of Windows-in-the-wild exploits.  We believe that the battle with Windows Common Log File System is nearing end,  while vulnerabilities in Desktop Window Manager and other models will gradually increase.  Thanks to these guys for assisting in this journey.  And bingo, it's another stage.  Thank you for listening to our presentation.  Does anyone have any questions?  Thank you for the presentation.  Can you open the floor for any questions?  Do you think there's a systemic issue with the CLFS,  or was it just bad at the start?  Do you think there's a systemic issue?  In the sense of, is there a methodology in the way that it's implemented  that creates a series of security issues,  that they're just sort of putting band-aids over,  or was it just bad at the start?  Is there something systemic in the way that it was built that leads to security issues?  Okay, due to my English,  your question is a bit complex to me.  And you can ask under this stage,  and we can talk one-to-one.  Oh, okay.  Because I have to think about this question.  I think when Microsoft developed this common log file system driver,  they made some mistakes on the desire level.  Actually, many of the exploits were successful  due to this peak and end pointer.  But if you do better in the desired level,  I think they can prevent this at a very early time.  But for now, Microsoft,  they only fix every case,  and they never disable this driver  in order to introduce some implications for this question.  But the good thing is that these exploits have a line like this.  So I think this battle with the common log file system is near the end.  Because in the past six months,  we have called two Windows Desktop Manager zero days.  So I think maybe the target now pays attention to DWM and other models.  I think these models will have a trend like this.  There's another question.  Why do you say that the battle with CLFS is nearing its end,  and why do you see Desktop Window Manager being more vulnerable over time?  Okay, I have just answered this question, and I'll answer it again.  From our presentation, you can find that  the first eight common log file system exploits caught by us  happened in November 2021 to November 2023.  And the last two were caught in November 2023.  If you draw a picture,  by time and the catch time,  you can figure a picture like this.  So based on it,  we can predict that the battle with common log file system is near the end.  And why do I think Windows Desktop Manager vulnerability will have more in the future?  Because in November 2023 and in April 2024,  we have caught two DWM in the last zero days.  And due to the complexity of the Desktop Window Manager model,  it's DWM code, not Dell,  or the 132k model,  we think there are more vulnerabilities under this model.  So I think maybe this is just the start of the next battle.  Any more questions?  Looks like that's about it. Thank you very much, guys.