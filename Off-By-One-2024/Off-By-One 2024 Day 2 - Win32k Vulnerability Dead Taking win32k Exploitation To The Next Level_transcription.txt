{
  "webpage_url": "https://www.youtube.com/watch?v=rrll0g5giV0",
  "title": "Off-By-One 2024 Day 2 - Win32k Vulnerability Dead Taking win32k Exploitation To The Next Level",
  "description": "Abstract\n\nAs a well-known attack surface in Windows system, the Win32k has caused many security problems in history. But with the efforts of Microsoft and security researchers, peoples believe that Win32k has become secure enough that it\u2019s no longer harmful.\n\nEspecially with the continuous updates of the mitigation measures added by Microsoft, vulnerabilities in Win32k have become difficult to exploit, It has caused attackers to lose interest in the Win32k.\n\nIn this topic, we will present the results of our work, which will completely bypass all security mitigation mechanisms and revitalize the ancient attack surface of the Win32k, so we named it \u201cNext Level\u201d.\n\nMore specifically, We will present 5 Win32k vulnerabilities we discovered, which can lead to privilege escalation not only in normal environments. And it can also be used in the sandbox environment, causing the escape of the security sandbox.\n\nAlso, we will introduce the various restrictions Microsoft has imposed on Win32k and how to bypass them.\n\nFinally, we will also summarize whether there is universality in vulnerability exploitation and vulnerability mining methods, and what suggestions we have for future win32k security.\n\nSpeakers\nYanZiShuang is a Windows security researcher at CyberKunlun. His main research areas are Web and OS, Red Team and Penetration Testing.\n\nFollow Yan on X @ YanZiShuang\n\nDeng YunLong is a reseacher specialising in Windows Security, Tor traffic and Deep learning methods. He is currently attached to the information security laboratory at WTU.",
  "channel_url": "https://www.youtube.com/channel/UCmrsIbKdxEMBEefD8v8RigQ",
  "duration": 1899,
  "channel": "Off-By-One Comms Team",
  "uploader": "Off-By-One Comms Team",
  "upload_date": "20240901"
}

This text was transcribed using whisper model: large-v2

 Okay, hello everyone. Today we are going to talk about the topic of the insertive key vulnerability.  My name is Ethan and my colleague is Yang.  This slide shows the personal profiles of our study category.  Yang is a good researcher in this category,  but I am a speaker to make today's speech.  And we belong to CyberConnect.  That's that.  All right.  Let's kick things off by talking about the history of insertive key.  The insertive key came into play with Windows 24  to boost the web performance of Windows applications and memory usage.  The user interface management and the web-based device interface  were split off from the standard server runtime subsystem.  The CSRSS2 becomes a standalone kernel module.  And the backend Windows NDE 3.5 CSRSS  handles both graphic rendering and user interface management  using fast counter-process communication.  But because Windows demanded heavy graphics,  developers moved to a kernel-based design for recursive protocols.  And the insertive key is made up of three main components.  The graphic device interface, that means GDI,  and the user interface management.  We mentioned both USBR and auxiliary routines,  that means SANS and for the DirectX API.  This was the display driver model in Windows XP 2008.  The window manager takes care of the UI elements like  Windows Display, Screen Output and Input Collection,  and Mass Processing, and many more.  GDI handles graphic rendering, GDI objects,  things like color matching and mathematical libraries,  even the phone support.  In each user session, there is a separate map copy  of the insertive key voices,  which ensures session isolation and security.  Starting with the Windows ListTask service,  we moved to non-interactive sessions.  And user interface privilege isolation  was introduced to stop low-privilege process  from messing with high-integrity processes.  The insertive key rejects multiple callback functions  to interact with the community executive,  and exports the GUI-oriented objects like desktops,  Windows stations, and defined structures,  which provide a GUI sub-system for threads and processes.  We finished the introduction of the insertive key.  Let's look at classical CVE.  It's a classical CVE about the insertive key.  As a typer, you need to carefully define  neural state callback function,  causing the kernel to incorrectly  interpret arbitrary neural state values  as kernel addresses when assessing Windows extended memory.  Thus bypassing normal memory assess checks  and achieving out-of-bounds real-time values.  Now this slide showcases a classical vulnerability  called CVE-2021-1332 in insertive key.  These derivative laws were employed  by the beta-entity group in a disclosed attack.  Locally escalating originally imputed process  to the highest system privilege.  The first function with Windows EX function  in the insertive key full.js module  called the user-mode function.  User 3, 2, then allocate Windows class attributes  via the empty function in user-mode callback function,  which returns the user-defined Windows  extended memory to the kernel.  And a typer can hook the function  and user 3, 2, then allocate Windows class  extra-bias function to manipulate the extra flag  to include the level x 800 attribute.  So we can then call NDDLL callback  return function to return an arbitrary value  to the kernel.  After the callback, the extra flag is cleared  and the unchecked return value is used for  deep memory addressing into a memory access violation.  The figure can be used as a procedure  and won't be repeated.  Next slide.  We will dive into the topic  and explore how to uncover new vulnerabilities  from historical patches.  Okay, in the insertive key driver,  every window is divvied by the tagwind structure,  which includes a function ID field  or we call it fnid.  This field specifies the Windows class  with possible classes,  being in Scrollable, Manual, Desktop, and others.  When a function callback occurs,  the Windows function ID is assigned  a numerical value,  and this permits additional or extra data  to the window from the hook.  More practically,  it allows us to modify the request  of the Windows value  that we write after the output.  The mining lies in the tagwind  to function ID attribute  and the transformation relationship  corresponding to the RTL key  and desktop.  Next slide.  Okay, now we explore the mitigation mechanism  of missing key by Microsoft.  About the mitigation mechanism,  these four methods are usually used  in recipe key related vulnerabilities.  I will briefly describe these four methods.  The first is type isolation.  This is also shown as a CV we need to bypass  in a later presentation.  The first type isolation is implemented  through several interconnected structures.  The four primary data structures  involved in this mitigation  are C-type isolation, C-section entry,  C-section bitmap allocator,  and the RTL bitmap.  The type isolation mitigation  is introduced in the research2k command  of Windows 10 version 17.9.  Changes how GDI bitmap objects  are located in the kernel space.  Specifically, the surface header  is located in a section view,  where the piece of data buffer  is placed in the page4 section view.  This change effectively prevents  the kernel exploitation technique  of using bitmaps as targets  for limiting memory corruption.  It's no longer possible to create  an alliance tree of adjacent bitmaps  where the end of one piece of data buffer  directly follows the header of the next surface object.  If you want more information,  you can visit the ParseLabs website  where it's explained in the video.  The next, KD-SLR,  means Kernel Address Based Layout Optimization.  Also, it acts as a kernel-based application  to make combo flow checking and task harder  by remapping the base address of the kernel on boot.  By remapping the base address,  we can no longer hard-code values  to jump into the kernel.  Just like R-Space, KD-SLR,  we need some form of link  to know where to jump to next.  That's the way we produce  the kernel control flowchart.  KCFG is a highly optimized  transform security feature  that was created to combat  memory corruption vulnerabilities  by placing time registration  on where an application can execute the code from.  It makes it much harder for exploits  to execute the arbitrary code through vulnerabilities  such as buffer overflows.  Kernel Data Execution Prevention  is a system-level memory protection feature  that is built into the operating system  starting with Windows SP  and Windows Server 2003.  DEP enables the system  to mark one or more pages of memory  as non-insertable.  Mark memory regions as non-insertable  means that the code can't be run  from that region of memory,  which makes it harder for the exploitation  of buffer overflows.  Let's finish the presentation.  We will cover five CVEs  related to M32T.  There are the CVEs we will discuss today.  Next, I will provide a brief analysis  of each CVE.  The first CVE,  2021-41357,  is a vulnerability based on  a twin-structure UVFM.  Because of the lambda function,  I have checked the reference count  and the free template directly  and processed the UVF.  The second CVE,  2023-2274,  and its vulnerability's predictability  is to use multiplexed CVE callback  to reduce if-view-windows, etc.  and truncated-function segregation  and callback to R3.  The last three vulnerabilities  which are mainly about patch bypass  and vulnerabilities caused by  segmented addressing through FNID  and RTLP sending extra address.  Okay.  Let's introduce the first CVE,  2021-41357,  and about the CVE,  the following exploit,  Sagger, is a type-association bypass.  When the first function,  M32T,  through this function,  M32T for window.js  callback to R3,  using the function  locate-window-class-appropriate-function  and set the allocated  extended-window-and-read-address  to 0.  It triggers a lambda function  on a failed application.  This lambda function first uses  thread-unlocked-one-deprecise  to return the window's primary address.  After some  read-pull operations and  deferencing,  this function directly  returns the object function  to possibly delete the window.  If there are other references  to the window at that time,  the process will immediately crash  at the end.  There are many ways to exploit this function.  For example,  by setting up the callback  to the R3 function  for parallel window  in the  silent-allocated-window-class-appropriate-function.  This function  will clean up  the child window  using VFD.  The parent window  can have many child windows.  There are alternatives  for the end of the main window handle.  If we want to modify  the parent window of the child window,  we can modify the initial  parent window reference class.  After the parent window is released,  the exploited many windows  are created to override  the kernel address  of the initial parent window,  and at which point  the memory of the initial parent window  has been overrided by other windows.  Calling the function console.control  and creating a small RTL kit  to do the desktop login function.  Since there is an extended window handle,  the function console.control  will call back to R3  using the exec3-windows-class-appropriate-function.  Here we can hijack the stash  by using a hook  and modify the parent window  of the child window  using the reference count  and then call the exploit window  to be cleared.  This will cause a UEF  because the reference count  becomes asymmetric.  After the cleanup is completed,  due to type oscillation,  we can't do tool injection  to occupy the space  of the screen type window structure.  Therefore,  we can only create  a large number of type window structures  again to occupy the  initial type window structure  and set the extended window memory  to a very large value  to end the function.  After the function clears,  we can modify the device  of the PIST desktop pointer  in the type window structure  that holds the extended memory  and the type bit.  This has already been changed  to some other window  such as the auto-bounce real-time  for PIST desktop A  by passing the type oscillation  to the callback function  and the special addressing method  of RKR A.  This allows us to achieve  kernel pool of auto-bounce  with invite  and convert it to arbitrary address  with invite.  This video shows the  exploit in Windows 10 H2.  You can compare it.  It works well in Windows.  The video comes back backwards.  That's CVE-2003-28274.  This exploit process is  used in Windows.  You can compare the process  to RTLB, auto-bounce real-time invite,  automation, type oscillation.  Then let's dive into it.  First is to create a window.  Adjust the check TLS structure  with extended window memory  using PIST window.  Then adjust it as a DDE server  in the subsequent code  and call console control  to set the flag base  for the window memory  allowing it to be managed  as a RTL heap.  And then in the function  with windows,  after the RTL base releases the memory,  it sets the memory location  and draws the offset of R3 heap to 0  indicating that the memory has been released.  Later in the function execution flow,  the function KLDB function  provides an opportunity for the R3 callback.  The specific code snippet  deals with dynamic data exchanging,  which is a form of inter-process communication in Windows.  The code snippet handles the DDE message  in a Windows application.  It creates and deletes global patterns  that handle DDE initial and device message  and sends the deployment message  back to the initialing or advising window  and destroys the window  upon receiving a DDE device message.  This code handles the DDE message  in a Windows application.  It focuses on assessing the DDE management message.  It allocates and loads global memory  for a DDE device structure,  sets various fails in the DDE device structure  to configure the DDE device options,  adds a string to the global pattern table  and sends the DDE device message  to the Windows testing site Wpera.  Handles memory cleanup  if sending this message fails for other messages  in a default Windows procedure.  And then by coping the DDE callback,  we get a single shot at rescuing the population.  We immediately trigger the vulnerability  by calling the function of non-PTR.  However, instead of the rest of the standard  extra address, non-start and offset  is addressed by RTL-HEAP.  Since the offset is 0,  it doesn't affect the function.  We then provide access to the data structure  stored in RTL-HEAP.  Start retrieving,  and all our runs will arrive  in the kernel's RTL-HEAP.  And last, we introduce a CVE  that our team uses in CTF computation  named the TenFootCalc.  It's a bypass of CVE-2021-1732  type call function vulnerability  in the VSWP framework.  And the tagger can make kernel calls  by calling relevant QI APIs in the node,  such as the function Windows Probe,  switch Windows Probe,  and two-tip Windows Probe.  This kernel function triggers a callback.  The tagger can interpret this callback  by cooking a function named  allocateWindowClassAdvice in kernel.  And they use the  NTUserConsoleControl method  to set the console window flag  of the tagging key object,  thereby modifying the Linux tag.  After the callback,  the system doesn't check if the window tag  has changed due to the tag computation.  In reference to incorrect data,  the differences between before and after  flag computation is that  before setting the flag,  the system deletes the tagging key  for the key attribute of the  related node pointer.  After setting the flag,  the system deletes the tagging key  for the key attribute.  We then offset the kernel.  That call is reached by the tagger  control and then used to  all of our suite advices.  This is a brief analysis,  and the most  specific information is this.  First is the link  that the function callback  and the insert new key  can be called in a  custom callback function  to set the related node to mode 1  with the passive argument set as bold.  The first argument 1  does not exist,  and argument 2 must point to the buffer  because the first two words  must be valid when it's handled,  and argument 3 must not be  there when executed.  The next object  calling NTU callback return  enables the return to the kernel  for the offset of XLP  with the window table  assigned to a PS drive  based on these two  and the side window line  Tagged key structure  of the window table can be modified  and then we need to get the offset  to the desktop heap.  The crucial point  to understand really well  is that the CS progress value  of the window table must be smaller  than the offset  to the desktop heap  value of windows  and 1 and 2  start with the  restriction of a small  with extra  parameter of pins level  bypassed. A large value  can be written to the structure of  the Tagged key of windows 1  and its true bypassing  parameter of the  side window slot function  where window level is called.  And the  CPE 2022  66914 and the series  pinpoint is based on the function  pin switch window.  The vulnerability  requires booking the  processor to call back table  on either the key  specifically this function.  And the vulnerability  calls the switch  window code to invoke  the validate class  and the size. The first  time switch window code  is called, it passes the  WM3 message before  accessing its module.  It calls validate class  and size function.  At this point, the window  doesn't have an ID  size. The assignment  of an ID occurs  at the end of the function  class and size. So  it enters the function logic  or locates the user mode part  of the extra bytes for the window.  However, by this time  the machine has already initialized  and set the  kernel mode part of the window extra bytes.  And the  nest has also been reassigned  in this logic  to call to the function  extra bytes  where we have triggered the user mode  through the vulnerability attack.  The function stores the  extended memory in the FID  in non-set and  in less than several extra bytes  the content is stored  in the server extra bytes.  Now it modifies the  kernel pointer text which we  named for stored in the  server extra bytes in the  user mode callback  of  and  the method is to call  setLimitBDRAsync  to callback to change the pointer  state in the kernel to an arbitrary  user byte class.  Next,  to achieve this relation,  the function here  switchViews  is to be called by  sendUserMessageNumber  efs1  according to the switchView  which will perform memory operations  on the datastore in the  text switch dimension 4.  Since the memory  is controllable at this point,  I will show you a graph  which is created  and related to the arbitrary  address that we call it as  modifyMemoryPoint  and offsetBit  offsetLimitBDRAsync  in the text switch dimension 4 pointer  is stored as the  server extra address  lastBit  and the last term, CVE  let's talk about the CVE  202.4.1.1.3  and  the key function  about this CVE is put on the top of the  slide  and triggering  the vulnerability requires opening  the process internal  kernel callback table  and  this function  in the  inVisibility, this callback  triggers the function  class and size inVisibility  to trigger  the class and size function  the vulnerability calls  the  sbWin()  on the first call to  the WAN  message is passed  and  in this logic, I showed you  the call to windows  class s4bys will trigger the  user motorbook through a vulnerability attack  and this book will call  the WF-dialog pointer  which will change the window  FID to FID-dialog  and add the  WF-dialog-wint  the windows flag  because the window is set with  the WF-dialog-wint flag  that window non-CVR  will interpret the windows as a  dialog box  allowing the code to replace the first field  with a controllable value  and this also makes it possible  to leak the kernel address of the  TechWin structure and  achieve information disclosure  Let's make a brief summary  Mr. Duque has been  a critical commenter of the  Windows operating system  since 1994  and I admire the efficient  graphic performance and  user interface management  except it's impossible  to ignore its importance  and it has also been  a frequent target for vulnerabilities  so it's always  the hot sauce of vulnerabilities  and the methods for  discovering vulnerabilities are generally  more universal  and techniques such as following  tests, static or dynamic  analysis, symbolic  explanation and so on  one more vulnerability can be shown  on the ground  so I'm open  my speech is over  thank you  applause  we give  another round of applause because this is  actually one of the first time he's presenting in public  so some encouragement  thank you  applause  any questions from the  floor?  alright  this vulnerability  can be used to escape sandbox  from browser  actually  it can cross the  sandbox  in many environments  even  currently in 2034  can you repeat again?  currently  can  Win32k be  exploited in the sandbox?  I need you to check it  I need you to check it  it may work there  can you check it  after the conference?  thank you  thank you  were these bugs  that you found mostly found via  static analysis  or fuzzing  how do you see  the future of Win32k bugs?  the future of Win32k?  yes  I recently read some  academic papers  in user needs security  one more funny truth  about the Windows kernel  even the other platforms  such as Linux, Android  I think this way  is more frequent  to use in this  Windows kernel  because the Microsoft  application  has its limits  so I think this method  even the  artificial intelligence  method can affect  the Win32k  Win32k modules  to find more vulnerabilities  or to protect  or attack  it's all ok  thank you  that's all your questions  thank you  alright  if not then  one final applause for Yit Long  thank you so much