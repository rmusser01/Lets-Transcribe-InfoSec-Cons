{
  "segments": [
    {
      "Time_Start": 0.0,
      "Time_End": 4.2,
      "Text": "This text was transcribed using whisper model: large-v2\n\n Good afternoon everyone and welcome to the talk."
    },
    {
      "Time_Start": 4.2,
      "Time_End": 11.120000000000001,
      "Text": " So the title says that it is just in time compilation, but most of what we discussed"
    },
    {
      "Time_Start": 11.120000000000001,
      "Time_End": 15.56,
      "Text": " is going to be applicable for all other browsers as well."
    },
    {
      "Time_Start": 15.56,
      "Time_End": 25.64,
      "Text": " So thanks Rana for the introduction, we can get straight away to the content."
    },
    {
      "Time_Start": 25.64,
      "Time_End": 29.64,
      "Text": " So JavaScript, I think most of you are familiar with JavaScript."
    },
    {
      "Time_Start": 29.64,
      "Time_End": 32.68,
      "Text": " JavaScript is an untyped and an interpreted language."
    },
    {
      "Time_Start": 32.68,
      "Time_End": 38.0,
      "Text": " So if we have a statement that looks like let x is equal to a to b, what happens is"
    },
    {
      "Time_Start": 38.0,
      "Time_End": 40.44,
      "Text": " that it is first converted into byte code."
    },
    {
      "Time_Start": 40.44,
      "Time_End": 46.519999999999996,
      "Text": " Byte code is a form of representation of code that is a bit lower level than the original"
    },
    {
      "Time_Start": 46.519999999999996,
      "Time_End": 51.120000000000005,
      "Text": " source code and the byte code is actually executed by the JavaScript virtual machine"
    },
    {
      "Time_Start": 51.120000000000005,
      "Time_End": 53.64,
      "Text": " which is the interpreter."
    },
    {
      "Time_Start": 53.64,
      "Time_End": 62.760000000000005,
      "Text": " Now JavaScript code, short, this is JSC short for JavaScript code and JavaScript code is"
    },
    {
      "Time_Start": 62.760000000000005,
      "Time_End": 66.04,
      "Text": " the WebKit, is WebKit's JavaScript engine."
    },
    {
      "Time_Start": 66.04,
      "Time_End": 69.2,
      "Text": " The byte code for JavaScript code looks something like this."
    },
    {
      "Time_Start": 69.2,
      "Time_End": 74.84,
      "Text": " So you can see that each byte code consists of an opcode followed by a couple of, a few"
    },
    {
      "Time_Start": 74.84,
      "Time_End": 75.84,
      "Text": " operands."
    },
    {
      "Time_Start": 75.84,
      "Time_End": 79.6,
      "Text": " So it is kind of like assembly, but it is a bit higher level."
    },
    {
      "Time_Start": 79.6,
      "Time_End": 83.56,
      "Text": " So now let us talk about the interpreter first."
    },
    {
      "Time_Start": 84.48,
      "Time_End": 90.96000000000001,
      "Text": " So the interpreter is the code that actually executes the JavaScript byte code."
    },
    {
      "Time_Start": 90.96000000000001,
      "Time_End": 95.8,
      "Text": " To visualize this, you can just think of the interpreter as a huge switch case that switches"
    },
    {
      "Time_Start": 95.8,
      "Time_End": 100.68,
      "Text": " on the opcode and each case is a handler for that byte code op."
    },
    {
      "Time_Start": 100.68,
      "Time_End": 103.08,
      "Text": " Let us just see that in action."
    },
    {
      "Time_Start": 103.08,
      "Time_End": 107.4,
      "Text": " So typically JavaScript code is first converted into byte code."
    },
    {
      "Time_Start": 107.4,
      "Time_End": 113.48,
      "Text": " Byte code is represented as an array, where for example the first one is add, first one"
    },
    {
      "Time_Start": 113.48,
      "Time_End": 118.08,
      "Text": " was add and the interpreter, what it will do is that it will fetch one instruction"
    },
    {
      "Time_Start": 118.08,
      "Time_End": 119.08,
      "Text": " from the byte code."
    },
    {
      "Time_Start": 119.08,
      "Time_End": 124.36,
      "Text": " It will resolve the handler for this instruction and execute it and after that it will update"
    },
    {
      "Time_Start": 124.36,
      "Time_End": 130.76,
      "Text": " the PC to point to the next instruction in the byte code and this loop is going to go"
    },
    {
      "Time_Start": 130.76,
      "Time_End": 131.76,
      "Text": " on."
    },
    {
      "Time_Start": 131.76,
      "Time_End": 134.76,
      "Text": " So this is basically a fetch, resolve, update."
    },
    {
      "Time_Start": 134.76,
      "Time_End": 139.64000000000001,
      "Text": " First fetch the byte code, resolve the handler, update the PC."
    },
    {
      "Time_Start": 139.64000000000001,
      "Time_End": 141.76,
      "Text": " However, this has a few problems."
    },
    {
      "Time_Start": 142.04,
      "Time_End": 146.92,
      "Text": " One of the main problems is that the fetch, resolve, update cycle that this is following"
    },
    {
      "Time_Start": 146.92,
      "Time_End": 153.0,
      "Text": " is actually pretty slow performance wise, especially when we are talking about repeated"
    },
    {
      "Time_Start": 153.0,
      "Time_End": 154.0,
      "Text": " code execution."
    },
    {
      "Time_Start": 154.0,
      "Time_End": 157.67999999999998,
      "Text": " For example like your JavaScript code has a for loop."
    },
    {
      "Time_Start": 157.67999999999998,
      "Time_End": 162.64,
      "Text": " So each instruction is going to be fetched, resolved and updated like thousands of times."
    },
    {
      "Time_Start": 162.64,
      "Time_End": 167.28,
      "Text": " So this makes a lot of, for a lot of performance loss."
    },
    {
      "Time_Start": 167.28,
      "Time_End": 170.66,
      "Text": " Another issue is that JavaScript does not have types."
    },
    {
      "Time_Start": 170.66,
      "Time_End": 176.34,
      "Text": " So the interpreter needs, so if we have a statement like this, A and B can be any type."
    },
    {
      "Time_Start": 176.34,
      "Time_End": 182.38,
      "Text": " So the interpreter has to provide for all possible types of the statement."
    },
    {
      "Time_Start": 182.38,
      "Time_End": 187.78,
      "Text": " Another issue is that byte code does not have any dependency between opcodes."
    },
    {
      "Time_Start": 187.78,
      "Time_End": 192.66,
      "Text": " For example, if take this JavaScript code, we are actually, if you think, if you assume"
    },
    {
      "Time_Start": 192.66,
      "Time_End": 197.42,
      "Text": " that A and B are integers, we are actually computing A plus B three times, whereas we"
    },
    {
      "Time_Start": 197.42000000000002,
      "Time_End": 202.46,
      "Text": " could have ideally done something like that, add A plus B and store it three times."
    },
    {
      "Time_Start": 202.46,
      "Time_End": 204.3,
      "Text": " But instead we are going to compute it three times."
    },
    {
      "Time_Start": 204.3,
      "Time_End": 209.02,
      "Text": " So this is again leaving performance on the table."
    },
    {
      "Time_Start": 209.02,
      "Time_End": 214.42000000000002,
      "Text": " The solution for this is to compile, compile the byte code into native assembly."
    },
    {
      "Time_Start": 214.42000000000002,
      "Time_End": 217.62,
      "Text": " But this is only viable if that byte code is going to run multiple times."
    },
    {
      "Time_Start": 217.62,
      "Time_End": 221.74,
      "Text": " For example, if there is a for loop in the JavaScript function, then it is viable to"
    },
    {
      "Time_Start": 221.74,
      "Time_End": 226.70000000000002,
      "Text": " compile the, compile JavaScript into assembly."
    },
    {
      "Time_Start": 226.70000000000002,
      "Time_End": 231.14000000000001,
      "Text": " So in order to do, solve the various problems that are faced by the interpreter, we have"
    },
    {
      "Time_Start": 231.14000000000001,
      "Time_End": 234.06000000000003,
      "Text": " multiple JIT compilers implemented in browsers."
    },
    {
      "Time_Start": 234.06000000000003,
      "Time_End": 240.86,
      "Text": " One of the first compilers, the baseline compiler, which solves the repeated for, repeated cycle"
    },
    {
      "Time_Start": 240.86,
      "Time_End": 241.86,
      "Text": " issue."
    },
    {
      "Time_Start": 241.86,
      "Time_End": 245.9,
      "Text": " Let's see that in action."
    },
    {
      "Time_Start": 245.9,
      "Time_End": 250.70000000000002,
      "Text": " So let's take this very simple JavaScript code, addition, multiplication, object creation."
    },
    {
      "Time_Start": 250.70000000000002,
      "Time_End": 255.22000000000003,
      "Text": " This is first converted into byte code, and what the baseline compiler is going to do"
    },
    {
      "Time_Start": 255.22,
      "Time_End": 260.3,
      "Text": " is that, it is going to take one instruction of the byte code and convert that to assembly."
    },
    {
      "Time_Start": 260.3,
      "Time_End": 266.7,
      "Text": " So here, just load the arguments into the registers, and call the handler function."
    },
    {
      "Time_Start": 266.7,
      "Time_End": 270.9,
      "Text": " It does the same for the store, and it does the same for the rest of the instructions."
    },
    {
      "Time_Start": 270.9,
      "Time_End": 273.34,
      "Text": " So this is the pseudo x86 assembly."
    },
    {
      "Time_Start": 273.34,
      "Time_End": 277.78,
      "Text": " Now the interesting point is that in the baseline compiled code, there is no fetch."
    },
    {
      "Time_Start": 277.78,
      "Time_End": 280.66,
      "Text": " In fact, there is no reference to the byte code area at all."
    },
    {
      "Time_Start": 280.66,
      "Time_End": 281.66,
      "Text": " It's all assembly."
    },
    {
      "Time_Start": 281.66,
      "Time_End": 286.34000000000003,
      "Text": " So there is no update, there is no, there is no handler resolution."
    },
    {
      "Time_Start": 286.34000000000003,
      "Time_End": 288.70000000000005,
      "Text": " So the entire fetch result cycle is gone."
    },
    {
      "Time_Start": 288.70000000000005,
      "Time_End": 292.34000000000003,
      "Text": " We just have assembly code, raw assembly code."
    },
    {
      "Time_Start": 292.34000000000003,
      "Time_End": 298.14000000000004,
      "Text": " So this provides considerable speed up over base, over the interpreter."
    },
    {
      "Time_Start": 298.14000000000004,
      "Time_End": 303.74,
      "Text": " However, the baseline compiler makes very little optimizations, very few optimizations."
    },
    {
      "Time_Start": 303.74,
      "Time_End": 306.38,
      "Text": " We are going to see a couple of them."
    },
    {
      "Time_Start": 306.38,
      "Time_End": 308.18,
      "Text": " So the resultant code is not the most efficient."
    },
    {
      "Time_Start": 308.18,
      "Time_End": 314.18,
      "Text": " You don't have to read this, but this is how, this is how the JavaScript code's baseline"
    },
    {
      "Time_Start": 314.18,
      "Time_End": 315.62,
      "Text": " jetted code looks like."
    },
    {
      "Time_Start": 315.62,
      "Time_End": 319.46,
      "Text": " You have the add instruction, and followed by the assembly for that."
    },
    {
      "Time_Start": 319.46,
      "Time_End": 323.54,
      "Text": " One point to note here is that you don't see that call instructions that we actually saw"
    },
    {
      "Time_Start": 323.54,
      "Time_End": 324.54,
      "Text": " there."
    },
    {
      "Time_Start": 324.54,
      "Time_End": 327.54,
      "Text": " Call handles some, you don't see that call instruction anywhere here."
    },
    {
      "Time_Start": 327.54,
      "Time_End": 332.98,
      "Text": " That is because baseline is a bit smarter, and when I was compiling this, I used both"
    },
    {
      "Time_Start": 332.98,
      "Time_End": 335.66,
      "Text": " the operands for this add as integers."
    },
    {
      "Time_Start": 335.66,
      "Time_End": 339.42,
      "Text": " So when I took the baseline, what it did is that it actually emitted an add instruction"
    },
    {
      "Time_Start": 339.42,
      "Time_End": 344.86,
      "Text": " directly, instead of having a call, and followed by a store."
    },
    {
      "Time_Start": 344.86,
      "Time_End": 346.86,
      "Text": " However, it also has checks."
    },
    {
      "Time_Start": 346.86,
      "Time_End": 352.78000000000003,
      "Text": " If either of the operands are not integers, it goes to something called a slow path, and"
    },
    {
      "Time_Start": 352.78000000000003,
      "Time_End": 358.34000000000003,
      "Text": " in the slow path, we have that call to the hand resolution function, the interpreter."
    },
    {
      "Time_Start": 358.34000000000003,
      "Time_End": 361.1,
      "Text": " This is the generic code."
    },
    {
      "Time_Start": 361.1,
      "Time_End": 367.14000000000004,
      "Text": " Now this is, now this optimize, this fast path, slow path thing is the, is one of the"
    },
    {
      "Time_Start": 367.14000000000004,
      "Time_End": 370.18,
      "Text": " optimizations that are, that is done by the baseline compiler."
    },
    {
      "Time_Start": 370.18,
      "Time_End": 373.18,
      "Text": " Basically optimize the fast, optimize the common case."
    },
    {
      "Time_Start": 373.18,
      "Time_End": 374.18,
      "Text": " That's what this is doing."
    },
    {
      "Time_Start": 374.18,
      "Time_End": 379.02000000000004,
      "Text": " Another thing it does is inline caches, but before that we need to look at how objects"
    },
    {
      "Time_Start": 379.02000000000004,
      "Time_End": 381.34000000000003,
      "Text": " are represented in JavaScript."
    },
    {
      "Time_Start": 381.34000000000003,
      "Time_End": 387.3,
      "Text": " Consider this object X, which has two properties and two elements."
    },
    {
      "Time_Start": 387.3,
      "Time_End": 394.90000000000003,
      "Text": " In memory, this is actually represented as a pointer, as a combination of three pointers,"
    },
    {
      "Time_Start": 394.90000000000003,
      "Time_End": 395.90000000000003,
      "Text": " the shape, properties, and elements."
    },
    {
      "Time_Start": 395.90000000000003,
      "Time_End": 401.86,
      "Text": " Just keep in mind that I'm just talking generically here, so each engine might have, might tweak"
    },
    {
      "Time_Start": 401.86,
      "Time_End": 402.86,
      "Text": " this a bit."
    },
    {
      "Time_Start": 402.86,
      "Time_End": 407.94,
      "Text": " For example, Chrome might have a slightly different notation, but in essence, it remains"
    },
    {
      "Time_Start": 407.94,
      "Time_End": 408.94,
      "Text": " the same."
    },
    {
      "Time_Start": 408.94,
      "Time_End": 412.42,
      "Text": " The shape is something that contains the property names."
    },
    {
      "Time_Start": 412.42,
      "Time_End": 416.66,
      "Text": " You can see prop1, prop2, but it does not contain the property values."
    },
    {
      "Time_Start": 417.02000000000004,
      "Time_End": 422.5,
      "Text": " The property values are contained in the properties pointer, and the elements are contained, 1,"
    },
    {
      "Time_Start": 422.5,
      "Time_End": 426.5,
      "Text": " 2 are contained in the elements pointer."
    },
    {
      "Time_Start": 426.5,
      "Time_End": 431.02000000000004,
      "Text": " You can see that in the shape, we have a few offset, and you might have guessed what it"
    },
    {
      "Time_Start": 431.02000000000004,
      "Time_End": 432.02000000000004,
      "Text": " is already."
    },
    {
      "Time_Start": 432.02000000000004,
      "Time_End": 437.54,
      "Text": " Prop1 is mapped to 0, that means that if you, if I want the value that is associated with"
    },
    {
      "Time_Start": 437.54,
      "Time_End": 442.3,
      "Text": " prop1, all I have to do is look at the 0th index in the property setting, and same for"
    },
    {
      "Time_Start": 442.3,
      "Time_End": 443.3,
      "Text": " the 1."
    },
    {
      "Time_Start": 444.02000000000004,
      "Time_End": 449.06,
      "Text": " So how do I actually access, find the, for example, there you can see 8, we are accessing"
    },
    {
      "Time_Start": 449.06,
      "Time_End": 450.06,
      "Text": " 8.property."
    },
    {
      "Time_Start": 450.06,
      "Time_End": 452.94,
      "Text": " What does the engine do, JavaScript engine do?"
    },
    {
      "Time_Start": 452.94,
      "Time_End": 457.34000000000003,
      "Text": " It first fetches the shape, then it iterates through all the properties in the shape, it"
    },
    {
      "Time_Start": 457.34000000000003,
      "Time_End": 462.58000000000004,
      "Text": " sees prop2 there, fetches the index, goes to the properties array, and goes to the required"
    },
    {
      "Time_Start": 462.58000000000004,
      "Time_End": 468.66,
      "Text": " index, which is 1, and fetches, and gets 1, 3, 3, 7, which is the value of prop2."
    },
    {
      "Time_Start": 468.66,
      "Time_End": 472.18,
      "Text": " However, this is a little bit slow and can be optimized."
    },
    {
      "Time_Start": 472.18,
      "Time_End": 478.34000000000003,
      "Text": " In order to optimize this, JavaScript has something called inline caching, and it attaches"
    },
    {
      "Time_Start": 478.34000000000003,
      "Time_End": 482.22,
      "Text": " a cache to that property there, property access there."
    },
    {
      "Time_Start": 482.22,
      "Time_End": 484.7,
      "Text": " This is a cache with 3 slots."
    },
    {
      "Time_Start": 484.7,
      "Time_End": 491.02,
      "Text": " So what happens now is that the shape is accessed, it checks the cache, but the cache is empty."
    },
    {
      "Time_Start": 491.02,
      "Time_End": 495.7,
      "Text": " So it goes by the default way, the one we just discussed, however, after the default"
    },
    {
      "Time_Start": 495.7,
      "Time_End": 499.38,
      "Text": " way finishes, it updates the cache."
    },
    {
      "Time_Start": 499.38,
      "Time_End": 503.94,
      "Text": " The cache is updated with the shape as well as the property offset of prop2, which is"
    },
    {
      "Time_Start": 503.94,
      "Time_End": 504.94,
      "Text": " 1."
    },
    {
      "Time_Start": 504.94,
      "Time_End": 510.42,
      "Text": " So the next time we see a shape S1, it will check the shape in the cache with the shape"
    },
    {
      "Time_Start": 510.42,
      "Time_End": 511.42,
      "Text": " of the object."
    },
    {
      "Time_Start": 511.42,
      "Time_End": 516.5,
      "Text": " If that shape matches, if that shape matches, we have a cache hit."
    },
    {
      "Time_Start": 516.5,
      "Time_End": 520.3,
      "Text": " So now we don't have to access the shape on top at all, we can straight away go to the"
    },
    {
      "Time_Start": 520.3,
      "Time_End": 523.3,
      "Text": " properties and access the first index."
    },
    {
      "Time_Start": 523.3,
      "Time_End": 526.7,
      "Text": " However, what if there is a different shape?"
    },
    {
      "Time_Start": 526.7,
      "Time_End": 531.0600000000001,
      "Text": " If there is a different shape, then it's a cache miss, because S2 does not match what"
    },
    {
      "Time_Start": 531.0600000000001,
      "Time_End": 534.22,
      "Text": " is there in the inline cache, so this is a cache miss."
    },
    {
      "Time_Start": 534.22,
      "Time_End": 540.26,
      "Text": " And if there's a cache miss, we go to the default interpreter out, and fill the slot"
    },
    {
      "Time_Start": 540.26,
      "Time_End": 541.86,
      "Text": " with the new index."
    },
    {
      "Time_Start": 541.86,
      "Time_End": 548.1,
      "Text": " So basically this cache keeps track of all the structures that are seen at this point"
    },
    {
      "Time_Start": 548.1,
      "Time_End": 552.38,
      "Text": " along with the property offset number."
    },
    {
      "Time_Start": 552.38,
      "Time_End": 557.22,
      "Text": " So from the problems that we discussed with the interpreter, the first one is solved by"
    },
    {
      "Time_Start": 557.22,
      "Time_End": 558.22,
      "Text": " the baseline JIT."
    },
    {
      "Time_Start": 558.22,
      "Time_End": 563.9,
      "Text": " The second one is also kind of solved with baseline JIT's fast path slow path approach"
    },
    {
      "Time_Start": 563.9,
      "Time_End": 568.06,
      "Text": " as well as, as well as the inline caching approach."
    },
    {
      "Time_Start": 568.06,
      "Time_End": 573.34,
      "Text": " However, the third part is never solved, there's still no, the baseline JIT still has no dependence"
    },
    {
      "Time_Start": 573.34,
      "Time_End": 574.34,
      "Text": " between objects."
    },
    {
      "Time_Start": 574.34,
      "Time_End": 579.46,
      "Text": " For this, we have something called optimizing compilers."
    },
    {
      "Time_Start": 579.46,
      "Time_End": 583.14,
      "Text": " Optimizing compilers are slow to generate code."
    },
    {
      "Time_Start": 583.14,
      "Time_End": 588.86,
      "Text": " Optimizing compilers do not work with the bytecode because bytecode is not optimal here."
    },
    {
      "Time_Start": 588.86,
      "Time_End": 595.62,
      "Text": " So optimizing compilers always have their own representation of code."
    },
    {
      "Time_Start": 595.62,
      "Time_End": 601.46,
      "Text": " However, the code that optimizing compilers emit is very much more, much much more faster"
    },
    {
      "Time_Start": 601.46,
      "Time_End": 603.6600000000001,
      "Text": " than any of the other ones."
    },
    {
      "Time_Start": 603.66,
      "Time_End": 609.9,
      "Text": " Slower the optimizations, more efficient is the code, but slower is the compilation."
    },
    {
      "Time_Start": 609.9,
      "Time_End": 616.6999999999999,
      "Text": " So typically to offset for the slow compilation, what browsers do is that they have multiple"
    },
    {
      "Time_Start": 616.6999999999999,
      "Time_End": 619.86,
      "Text": " compilers, not a single compiler, multiple compilers."
    },
    {
      "Time_Start": 619.86,
      "Time_End": 624.1,
      "Text": " Each compiler doing more optimizations than the previous one."
    },
    {
      "Time_Start": 624.1,
      "Time_End": 631.42,
      "Text": " Also this, for compiling code, you need types and JavaScript is an untyped language."
    },
    {
      "Time_Start": 631.42,
      "Time_End": 636.2199999999999,
      "Text": " So all the, all the optimizing compilers are going to speculate on types, just like"
    },
    {
      "Time_Start": 636.2199999999999,
      "Time_End": 638.74,
      "Text": " the baseline compiler did."
    },
    {
      "Time_Start": 638.74,
      "Time_End": 643.0999999999999,
      "Text": " So pictorially, the previous slide represent is, it looks like this."
    },
    {
      "Time_Start": 643.0999999999999,
      "Time_End": 647.3,
      "Text": " Source code is now parsed into the, by the parser into the bytecode."
    },
    {
      "Time_Start": 647.3,
      "Time_End": 649.06,
      "Text": " Bytecode is consumed by the interpreter."
    },
    {
      "Time_Start": 649.06,
      "Time_End": 654.18,
      "Text": " The interpreter executes the bytecode and the baseline also executes the bytecode there."
    },
    {
      "Time_Start": 654.18,
      "Time_End": 659.0999999999999,
      "Text": " And the profiled bytecode is now parsed to the JIT compiler, which emits an optimized"
    },
    {
      "Time_Start": 659.0999999999999,
      "Time_End": 660.0999999999999,
      "Text": " code."
    },
    {
      "Time_Start": 660.3000000000001,
      "Time_End": 664.5,
      "Text": " And if there is a speculation failure, it goes back to the interpreter or the baseline"
    },
    {
      "Time_Start": 664.5,
      "Time_End": 665.5,
      "Text": " compiler."
    },
    {
      "Time_Start": 667.1,
      "Time_End": 672.7,
      "Text": " Now let's shift gears to focus more on JavaScript core and less on the other browsers."
    },
    {
      "Time_Start": 672.7,
      "Time_End": 675.7,
      "Text": " JavaScript core has four tiers of execution."
    },
    {
      "Time_Start": 675.7,
      "Time_End": 679.3000000000001,
      "Text": " We already saw the LLN, which is the base, which is the interpreter."
    },
    {
      "Time_Start": 679.3000000000001,
      "Time_End": 681.3000000000001,
      "Text": " Then we also saw the baseline JIT."
    },
    {
      "Time_Start": 681.3000000000001,
      "Time_End": 685.5,
      "Text": " However, the other two, DFG and FTL are optimizing compilers."
    },
    {
      "Time_Start": 685.5,
      "Time_End": 695.78,
      "Text": " So the FTL is the fastest, emits the fastest code, but it also takes the longest to compile."
    },
    {
      "Time_Start": 695.78,
      "Time_End": 702.98,
      "Text": " If there is a speculation failure in DFG or FTL, control flow shifts back into baseline."
    },
    {
      "Time_Start": 702.98,
      "Time_End": 707.46,
      "Text": " So you can think that, you can see all this complexity there and more the complexity,"
    },
    {
      "Time_Start": 707.46,
      "Time_End": 710.82,
      "Text": " more the chances of bugs."
    },
    {
      "Time_Start": 710.82,
      "Time_End": 714.06,
      "Text": " I was saying that interpreter always works with bytecode."
    },
    {
      "Time_Start": 714.0600000000001,
      "Time_End": 716.46,
      "Text": " We also saw that baseline also works with bytecode."
    },
    {
      "Time_Start": 716.46,
      "Time_End": 722.0600000000001,
      "Text": " However, DFG works with a different representation of code called DFG IR and the FTL works with"
    },
    {
      "Time_Start": 722.0600000000001,
      "Time_End": 723.0600000000001,
      "Text": " three IRs."
    },
    {
      "Time_Start": 723.0600000000001,
      "Time_End": 728.46,
      "Text": " It works with the DFG IR of course, but it also has two unique IRs of its own called"
    },
    {
      "Time_Start": 728.46,
      "Time_End": 731.6600000000001,
      "Text": " D3 and DIR."
    },
    {
      "Time_Start": 731.6600000000001,
      "Time_End": 735.86,
      "Text": " Now let's talk about typing in DFG."
    },
    {
      "Time_Start": 735.86,
      "Time_End": 743.0600000000001,
      "Text": " In DFG, types of a, JavaScript has variables and types of a variables in DFG is represented"
    },
    {
      "Time_Start": 743.0600000000001,
      "Time_End": 747.22,
      "Text": " using two things, speculated type and abstract value."
    },
    {
      "Time_Start": 747.22,
      "Time_End": 752.94,
      "Text": " Now speculated, both of them represent the type of a variable in JavaScript."
    },
    {
      "Time_Start": 752.94,
      "Time_End": 757.5000000000001,
      "Text": " Now speculated type actually signifies the most possible value of the type."
    },
    {
      "Time_Start": 757.5000000000001,
      "Time_End": 763.4200000000001,
      "Text": " For example, if I have a JavaScript variable that has the speculated type int, it basically"
    },
    {
      "Time_Start": 763.4200000000001,
      "Time_End": 767.46,
      "Text": " means that most probably this variable is going to be an int, but it can also be anything"
    },
    {
      "Time_Start": 767.46,
      "Time_End": 768.46,
      "Text": " else."
    },
    {
      "Time_Start": 768.46,
      "Time_End": 773.14,
      "Text": " However, if an abstract value says that the JavaScript variable has type int, it is going"
    },
    {
      "Time_Start": 773.14,
      "Time_End": 774.14,
      "Text": " to be int."
    },
    {
      "Time_Start": 774.14,
      "Time_End": 775.14,
      "Text": " It can be nothing else."
    },
    {
      "Time_Start": 775.14,
      "Time_End": 780.7800000000001,
      "Text": " This means that speculated type needs to be checked at run time because it's for all purposes"
    },
    {
      "Time_Start": 780.7800000000001,
      "Time_End": 781.7800000000001,
      "Text": " it's just a guess."
    },
    {
      "Time_Start": 781.7800000000001,
      "Time_End": 785.74,
      "Text": " Educated guess for just a guess, so it has to be checked at run time."
    },
    {
      "Time_Start": 785.74,
      "Time_End": 791.7800000000001,
      "Text": " The abstract value is a compile time pro, compiler proves it at the compile time, so"
    },
    {
      "Time_Start": 791.7800000000001,
      "Time_End": 793.46,
      "Text": " it never needs to be verified."
    },
    {
      "Time_Start": 793.46,
      "Time_End": 796.5400000000001,
      "Text": " It is trusted by the compiler."
    },
    {
      "Time_Start": 796.54,
      "Time_End": 801.8199999999999,
      "Text": " Speculated type is calculated using profiling data, whereas abstract types are calculated"
    },
    {
      "Time_Start": 801.8199999999999,
      "Time_End": 803.8199999999999,
      "Text": " using something called DFG AI."
    },
    {
      "Time_Start": 803.8199999999999,
      "Time_End": 811.3,
      "Text": " AI stands for abstract interpreter not artificial intelligence, and speculated type is used"
    },
    {
      "Time_Start": 811.3,
      "Time_End": 815.5,
      "Text": " to construct RIR, whereas abstract values used to optimize RIR."
    },
    {
      "Time_Start": 815.5,
      "Time_End": 821.66,
      "Text": " They have their own functions and they don't conflict with each other."
    },
    {
      "Time_Start": 821.66,
      "Time_End": 829.42,
      "Text": " Now let's look at how abstract values are actually represented in memory."
    },
    {
      "Time_Start": 829.42,
      "Time_End": 836.4599999999999,
      "Text": " So if you look at the source code for JavaScript code, everything is in C++."
    },
    {
      "Time_Start": 836.4599999999999,
      "Time_End": 842.9,
      "Text": " This is the structure that actually has the abstract value, that actually defines that"
    },
    {
      "Time_Start": 842.9,
      "Time_End": 843.9,
      "Text": " abstract value."
    },
    {
      "Time_Start": 843.9,
      "Time_End": 851.78,
      "Text": " So it has a field called mstructure, which has a list of all possible shapes an object"
    },
    {
      "Time_Start": 851.78,
      "Time_End": 852.78,
      "Text": " can have."
    },
    {
      "Time_Start": 852.78,
      "Time_End": 856.78,
      "Text": " In JavaScript code that shape thing that we saw earlier is also called a structure."
    },
    {
      "Time_Start": 856.78,
      "Time_End": 859.78,
      "Text": " We are going to use that interchangeably."
    },
    {
      "Time_Start": 859.78,
      "Time_End": 861.78,
      "Text": " Structure means shape, shape means structure."
    },
    {
      "Time_Start": 861.78,
      "Time_End": 866.78,
      "Text": " So this mstructure is a list of all possible structures a variable can have, and mtype"
    },
    {
      "Time_Start": 866.78,
      "Time_End": 870.78,
      "Text": " is a list of all possible types this variable can have, kind of conflicting right?"
    },
    {
      "Time_Start": 870.78,
      "Time_End": 872.78,
      "Text": " So let's do this with an example."
    },
    {
      "Time_Start": 873.66,
      "Time_End": 879.66,
      "Text": " Let's say a variable has mstructure as let's say S1, structure S1 and a type int."
    },
    {
      "Time_Start": 879.66,
      "Time_End": 885.66,
      "Text": " What this means is that this variable can either be an integer or an object with type"
    },
    {
      "Time_Start": 885.66,
      "Time_End": 886.66,
      "Text": " S1."
    },
    {
      "Time_Start": 886.66,
      "Time_End": 889.66,
      "Text": " It can be nothing else, integer or an object with type S1."
    },
    {
      "Time_Start": 889.66,
      "Time_End": 896.66,
      "Text": " We are going to skip the next two objects for the purpose of this presentation."
    },
    {
      "Time_Start": 897.54,
      "Time_End": 903.54,
      "Text": " Finally we have the mvalue, mvalue field what it signifies is that it holds the address"
    },
    {
      "Time_Start": 903.54,
      "Time_End": 905.54,
      "Text": " of an object if an object is const."
    },
    {
      "Time_Start": 905.54,
      "Time_End": 907.54,
      "Text": " Let's do that with an example."
    },
    {
      "Time_Start": 907.54,
      "Time_End": 911.54,
      "Text": " Take this JavaScript statement for example."
    },
    {
      "Time_Start": 911.54,
      "Time_End": 915.54,
      "Text": " This is, this has the const specifier added to it."
    },
    {
      "Time_Start": 915.54,
      "Time_End": 921.54,
      "Text": " What this means, what this const tells is that this object can never be modified."
    },
    {
      "Time_Start": 921.54,
      "Time_End": 925.54,
      "Text": " So if you try to do object equal to 5 later, that's a JavaScript error."
    },
    {
      "Time_Start": 926.42,
      "Time_End": 932.42,
      "Text": " So that means the abstract value of this object will have the mvalue field as the address"
    },
    {
      "Time_Start": 932.42,
      "Time_End": 935.42,
      "Text": " of this object because it's never going to change."
    },
    {
      "Time_Start": 935.42,
      "Time_End": 939.42,
      "Text": " So the mvalue is the address of the object."
    },
    {
      "Time_Start": 939.42,
      "Time_End": 944.42,
      "Text": " It's important to note that mvalue and structure do not conflict with each other."
    },
    {
      "Time_Start": 944.42,
      "Time_End": 950.42,
      "Text": " Mainly because I can modify the value of the object however the structure, so that the"
    },
    {
      "Time_Start": 950.42,
      "Time_End": 951.42,
      "Text": " structure changes."
    },
    {
      "Time_Start": 951.42,
      "Time_End": 953.42,
      "Text": " However the address of object is still constant."
    },
    {
      "Time_Start": 954.3000000000001,
      "Time_End": 959.3000000000001,
      "Text": " So mvalue and mstructure do not conflict with each other."
    },
    {
      "Time_Start": 959.3000000000001,
      "Time_End": 964.3000000000001,
      "Text": " There are two special type, special values that each of those fields can hold."
    },
    {
      "Time_Start": 964.3000000000001,
      "Time_End": 969.3000000000001,
      "Text": " One is called the top which is, which stands for anything and one is called the bottom"
    },
    {
      "Time_Start": 969.3000000000001,
      "Time_End": 971.3000000000001,
      "Text": " which stands for nothing, another thing."
    },
    {
      "Time_Start": 971.3000000000001,
      "Time_End": 977.3000000000001,
      "Text": " So which, this means that if mstructure is top, this means that this variable can be"
    },
    {
      "Time_Start": 977.3000000000001,
      "Time_End": 979.3000000000001,
      "Text": " any type, any type."
    },
    {
      "Time_Start": 979.3000000000001,
      "Time_End": 982.3000000000001,
      "Text": " It's an object but it can have any type."
    },
    {
      "Time_Start": 983.1800000000001,
      "Time_End": 987.1800000000001,
      "Text": " So if the variable is, if the mstructure is bottom, then it basically signifies that this"
    },
    {
      "Time_Start": 987.1800000000001,
      "Time_End": 990.1800000000001,
      "Text": " variable can be, it will have no shape at all."
    },
    {
      "Time_Start": 990.1800000000001,
      "Time_End": 995.1800000000001,
      "Text": " That means it's a primitive value, integer, flow, whatever."
    },
    {
      "Time_Start": 995.1800000000001,
      "Time_End": 1000.1800000000001,
      "Text": " The abstract interpreter is used to find the concrete type of the node."
    },
    {
      "Time_Start": 1000.1800000000001,
      "Time_End": 1003.1800000000001,
      "Text": " It has all, it also has other implications."
    },
    {
      "Time_Start": 1003.1800000000001,
      "Time_End": 1009.1800000000001,
      "Text": " For example, it's used for constant folding but, constant propagation but we are not going"
    },
    {
      "Time_Start": 1009.1800000000001,
      "Time_End": 1011.1800000000001,
      "Text": " to discuss that here."
    },
    {
      "Time_Start": 1012.0600000000001,
      "Time_End": 1015.0600000000001,
      "Text": " The other thing is that if you are reading the source code, it's always called DFG-AI"
    },
    {
      "Time_Start": 1015.0600000000001,
      "Time_End": 1018.0600000000001,
      "Text": " or AI in the source code."
    },
    {
      "Time_Start": 1018.0600000000001,
      "Time_End": 1021.0600000000001,
      "Text": " AI stands for abstract interpretation."
    },
    {
      "Time_Start": 1021.0600000000001,
      "Time_End": 1027.0600000000002,
      "Text": " Now we're going to look at a bug in the abstract interpreter itself but to do that"
    },
    {
      "Time_Start": 1027.0600000000002,
      "Time_End": 1032.0600000000002,
      "Text": " we have to be more familiar with property accesses in DFG."
    },
    {
      "Time_Start": 1032.0600000000002,
      "Time_End": 1035.0600000000002,
      "Text": " You are probably familiar with this now."
    },
    {
      "Time_Start": 1035.0600000000002,
      "Time_End": 1039.0600000000002,
      "Text": " We are accessing a property P1 on that object."
    },
    {
      "Time_Start": 1039.94,
      "Time_End": 1044.94,
      "Text": " Whenever interpreter sees something like this, it attaches an inline cache, IC."
    },
    {
      "Time_Start": 1044.94,
      "Time_End": 1047.94,
      "Text": " And the IC right now is populated with S1, 0."
    },
    {
      "Time_Start": 1047.94,
      "Time_End": 1049.94,
      "Text": " Shape S1, offset 0."
    },
    {
      "Time_Start": 1049.94,
      "Time_End": 1056.94,
      "Text": " So when DFG tries to optimize this, it splits it into two, sorry, it splits it into two"
    },
    {
      "Time_Start": 1056.94,
      "Time_End": 1057.94,
      "Text": " opcodes."
    },
    {
      "Time_Start": 1057.94,
      "Time_End": 1060.94,
      "Text": " One is the check structure and one is the get by offset."
    },
    {
      "Time_Start": 1060.94,
      "Time_End": 1065.94,
      "Text": " The check structure checks the structure of the object, this object, with S1."
    },
    {
      "Time_Start": 1065.94,
      "Time_End": 1067.94,
      "Text": " Where did it get S1 from?"
    },
    {
      "Time_Start": 1067.94,
      "Time_End": 1068.94,
      "Text": " It got it from the cache."
    },
    {
      "Time_Start": 1068.94,
      "Time_End": 1073.94,
      "Text": " And the get by offset fetches the actual property from offset 0."
    },
    {
      "Time_Start": 1073.94,
      "Time_End": 1076.94,
      "Text": " Where did it get the 0 from?"
    },
    {
      "Time_Start": 1076.94,
      "Time_End": 1077.94,
      "Text": " From the cache."
    },
    {
      "Time_Start": 1077.94,
      "Time_End": 1081.94,
      "Text": " So DFG basically bakes the inline cache into the IR."
    },
    {
      "Time_Start": 1081.94,
      "Time_End": 1088.94,
      "Text": " An interesting point to note about check structure is that if that comparison fails, this is"
    },
    {
      "Time_Start": 1088.94,
      "Time_End": 1092.94,
      "Text": " basically a comparison, compare, check if object structure is same as S1."
    },
    {
      "Time_Start": 1092.94,
      "Time_End": 1099.94,
      "Text": " If that comparison fails, this is a speculation failure and no further code is executed."
    },
    {
      "Time_Start": 1099.94,
      "Time_End": 1103.94,
      "Text": " So, now let us look at an example."
    },
    {
      "Time_Start": 1103.94,
      "Time_End": 1106.94,
      "Text": " Just take a moment to read this JavaScript code."
    },
    {
      "Time_Start": 1106.94,
      "Time_End": 1109.94,
      "Text": " It is just creating three objects, X1, X2, X3."
    },
    {
      "Time_Start": 1109.94,
      "Time_End": 1114.94,
      "Text": " X1 has the shape S1, where P1 is at offset 0."
    },
    {
      "Time_Start": 1114.94,
      "Time_End": 1119.94,
      "Text": " This one has shape S2, P1 is at offset 0 again, even though shape is different."
    },
    {
      "Time_Start": 1119.94,
      "Time_End": 1120.94,
      "Text": " Offset is same."
    },
    {
      "Time_Start": 1121.94,
      "Time_End": 1122.94,
      "Text": " This one is X3."
    },
    {
      "Time_Start": 1122.94,
      "Time_End": 1129.94,
      "Text": " Shape again is different, but offset is again the, in this case the offset is also different."
    },
    {
      "Time_Start": 1129.94,
      "Time_End": 1130.94,
      "Text": " P1 has the offset 1."
    },
    {
      "Time_Start": 1130.94,
      "Time_End": 1133.94,
      "Text": " The other two had an offset of 0."
    },
    {
      "Time_Start": 1133.94,
      "Time_End": 1140.94,
      "Text": " And a point to note is that we are going to be studying the property access arg.p1."
    },
    {
      "Time_Start": 1140.94,
      "Time_End": 1148.94,
      "Text": " Now we know that arg.p1 is going to have, arg.p1 is going to have an inline cache."
    },
    {
      "Time_Start": 1148.94,
      "Time_End": 1155.94,
      "Text": " The data in that inline cache is represented in JavaScript code using a class called GetByStatus."
    },
    {
      "Time_Start": 1155.94,
      "Time_End": 1161.94,
      "Text": " So, this is again a class and this is used to track the property access."
    },
    {
      "Time_Start": 1161.94,
      "Time_End": 1167.94,
      "Text": " GetByStatus is used to track the property access of that issue, of that property access."
    },
    {
      "Time_Start": 1167.94,
      "Time_End": 1171.94,
      "Text": " And now we can forget about all the other fields."
    },
    {
      "Time_Start": 1171.94,
      "Time_End": 1174.94,
      "Text": " The only field that we care about is this vector."
    },
    {
      "Time_Start": 1174.94,
      "Time_End": 1177.94,
      "Text": " This is a vector of GetByVariant."
    },
    {
      "Time_Start": 1177.94,
      "Time_End": 1184.94,
      "Text": " So, now we have to go into GetByVariant and we have to disassemble it."
    },
    {
      "Time_Start": 1184.94,
      "Time_End": 1185.94,
      "Text": " It's a complicated structure."
    },
    {
      "Time_Start": 1185.94,
      "Time_End": 1188.94,
      "Text": " You do not have to read any of that."
    },
    {
      "Time_Start": 1188.94,
      "Time_End": 1193.94,
      "Text": " What you have to note is that the GetByVariant is something that keeps track of structures"
    },
    {
      "Time_Start": 1193.94,
      "Time_End": 1195.94,
      "Text": " with similar property offsets."
    },
    {
      "Time_Start": 1195.94,
      "Time_End": 1201.94,
      "Text": " Again, we will see this with an example rather than this thing."
    },
    {
      "Time_Start": 1201.94,
      "Time_End": 1206.94,
      "Text": " So, let's bring that example which we saw earlier."
    },
    {
      "Time_Start": 1207.94,
      "Time_End": 1210.94,
      "Text": " X1 and X2 have a shape S1 and S2."
    },
    {
      "Time_Start": 1210.94,
      "Time_End": 1216.94,
      "Text": " And the point to note is that both have P1 at offset 0 even though their shape is different."
    },
    {
      "Time_Start": 1216.94,
      "Time_End": 1220.94,
      "Text": " So, this means that V1 is a variant."
    },
    {
      "Time_Start": 1220.94,
      "Time_End": 1227.94,
      "Text": " So, GetByIdVariant with, that holds S1 and S2."
    },
    {
      "Time_Start": 1227.94,
      "Time_End": 1230.94,
      "Text": " And V2 is a variant that holds S3."
    },
    {
      "Time_Start": 1230.94,
      "Time_End": 1237.94,
      "Text": " The point here is that if your offset is same, you have a single variant."
    },
    {
      "Time_Start": 1237.94,
      "Time_End": 1240.94,
      "Text": " If your offset differs, you have a new variant."
    },
    {
      "Time_Start": 1240.94,
      "Time_End": 1244.94,
      "Text": " So, S1 and S2 have the same offset, offset 0."
    },
    {
      "Time_Start": 1244.94,
      "Time_End": 1247.94,
      "Text": " So, they are both clumped together in a single variant."
    },
    {
      "Time_Start": 1247.94,
      "Time_End": 1249.94,
      "Text": " Whereas, S3 has a different variant."
    },
    {
      "Time_Start": 1249.94,
      "Time_End": 1252.94,
      "Text": " So, it has, S3 has a different offset."
    },
    {
      "Time_Start": 1252.94,
      "Time_End": 1254.94,
      "Text": " So, it has a different variant."
    },
    {
      "Time_Start": 1254.94,
      "Time_End": 1258.94,
      "Text": " The GetByStatus is a vector of all these variants."
    },
    {
      "Time_Start": 1260.94,
      "Time_End": 1269.94,
      "Text": " Now, what we are going to do is, we are trying to ask how do we create this GetByStatus using."
    },
    {
      "Time_Start": 1269.94,
      "Time_End": 1275.94,
      "Text": " To create a GetBy, to create all these variants, statuses and all, what we need is that at"
    },
    {
      "Time_Start": 1275.94,
      "Time_End": 1282.94,
      "Text": " this point, arg.p1, we need to know what is the structures that arg can have."
    },
    {
      "Time_Start": 1282.94,
      "Time_End": 1284.94,
      "Text": " What are the structures that arg can have?"
    },
    {
      "Time_Start": 1284.94,
      "Time_End": 1287.94,
      "Text": " One way to find that out is the inline cache."
    },
    {
      "Time_Start": 1287.94,
      "Time_End": 1293.94,
      "Text": " The inline cache associated with that arg.p1 access will hold all the structures that it"
    },
    {
      "Time_Start": 1293.94,
      "Time_End": 1295.94,
      "Text": " has ever seen."
    },
    {
      "Time_Start": 1295.94,
      "Time_End": 1302.94,
      "Text": " But, another way that we can compute that is using what we just discussed are abstract"
    },
    {
      "Time_Start": 1302.94,
      "Time_End": 1303.94,
      "Text": " values."
    },
    {
      "Time_Start": 1303.94,
      "Time_End": 1312.94,
      "Text": " Because abstract values also, abstract values also signifies more or less the same thing."
    },
    {
      "Time_Start": 1312.94,
      "Time_End": 1316.94,
      "Text": " Speaking of abstract values, let us actually look at some buggy C++ code."
    },
    {
      "Time_Start": 1316.94,
      "Time_End": 1320.94,
      "Text": " So, this is the code for abstract interpretation of GetById."
    },
    {
      "Time_Start": 1320.94,
      "Time_End": 1321.94,
      "Text": " What is GetById?"
    },
    {
      "Time_Start": 1321.94,
      "Time_End": 1324.94,
      "Text": " Let us say we have an object.p1 access."
    },
    {
      "Time_Start": 1324.94,
      "Time_End": 1333.94,
      "Text": " Then, object, then if we have an object.p1 access, then the GetById is an opcode that"
    },
    {
      "Time_Start": 1333.94,
      "Time_End": 1338.94,
      "Text": " is, I mean, is the DFG opcode that signifies that property access."
    },
    {
      "Time_Start": 1339.94,
      "Time_End": 1344.94,
      "Text": " So, first we fetch the abstract value of object."
    },
    {
      "Time_Start": 1344.94,
      "Time_End": 1346.94,
      "Text": " Then, we fetch the p1 as a string."
    },
    {
      "Time_Start": 1346.94,
      "Time_End": 1348.94,
      "Text": " It is string implementation p1."
    },
    {
      "Time_Start": 1348.94,
      "Time_End": 1349.94,
      "Text": " We fetch that."
    },
    {
      "Time_Start": 1349.94,
      "Time_End": 1354.94,
      "Text": " We compute the GetByStatus that we just discussed using the abstract value."
    },
    {
      "Time_Start": 1354.94,
      "Time_End": 1360.94,
      "Text": " We already discussed that one GetByStatus has multiple variants and each variant now"
    },
    {
      "Time_Start": 1360.94,
      "Time_End": 1364.94,
      "Text": " has to be, the for loop has to traverse over each of the variants."
    },
    {
      "Time_Start": 1364.94,
      "Time_End": 1366.94,
      "Text": " Now, this is a complicated bug."
    },
    {
      "Time_Start": 1366.94,
      "Time_End": 1370.94,
      "Text": " I am trying to simplify it as much as possible, but still it is a complicated bug."
    },
    {
      "Time_Start": 1370.94,
      "Time_End": 1381.94,
      "Text": " So, now each variant as it is traversing, it is calling this inferred value for property."
    },
    {
      "Time_Start": 1381.94,
      "Time_End": 1388.94,
      "Text": " What this whole code is trying to do is to predict the abstract value of the result,"
    },
    {
      "Time_Start": 1388.94,
      "Time_End": 1389.94,
      "Text": " object.p1."
    },
    {
      "Time_Start": 1389.94,
      "Time_End": 1391.94,
      "Text": " We know the abstract value of object."
    },
    {
      "Time_Start": 1391.94,
      "Time_End": 1393.94,
      "Text": " What is the abstract value of object.p1?"
    },
    {
      "Time_Start": 1393.94,
      "Time_End": 1397.94,
      "Text": " This whole code is essentially trying to find that out."
    },
    {
      "Time_Start": 1397.94,
      "Time_End": 1403.94,
      "Text": " So, that is found by this property, inferred value for property."
    },
    {
      "Time_Start": 1403.94,
      "Time_End": 1411.94,
      "Text": " Now, what this function does is that it checks if object is a constant, conspecifier for"
    },
    {
      "Time_Start": 1411.94,
      "Time_End": 1412.94,
      "Text": " example."
    },
    {
      "Time_Start": 1412.94,
      "Time_End": 1417.94,
      "Text": " And if it is a constant, then it goes directly and fetches the option that it has passed"
    },
    {
      "Time_Start": 1417.94,
      "Time_End": 1419.94,
      "Text": " and fetches that value."
    },
    {
      "Time_Start": 1419.94,
      "Time_End": 1422.94,
      "Text": " So, it knows the type of object.p."
    },
    {
      "Time_Start": 1422.94,
      "Time_End": 1428.94,
      "Text": " And it does that for all the variants and the results are merged together."
    },
    {
      "Time_Start": 1428.94,
      "Time_End": 1431.94,
      "Text": " However, this has a problem here."
    },
    {
      "Time_Start": 1431.94,
      "Time_End": 1437.94,
      "Text": " We are actually doing, in the previous couple of slides, we are actually doing, making an"
    },
    {
      "Time_Start": 1437.94,
      "Time_End": 1441.94,
      "Text": " array access on the property offset in this code."
    },
    {
      "Time_Start": 1441.94,
      "Time_End": 1446.94,
      "Text": " But we are, but the offset is keeping on changing in the for loop."
    },
    {
      "Time_Start": 1446.94,
      "Time_End": 1451.94,
      "Text": " Initially it will be 0, then it will be 1, offset comes from the for loop."
    },
    {
      "Time_Start": 1451.94,
      "Time_End": 1456.94,
      "Text": " And that should not happen because we are trying to access object.p1, which p1 is at"
    },
    {
      "Time_Start": 1456.94,
      "Time_End": 1458.94,
      "Text": " offset 0."
    },
    {
      "Time_Start": 1458.94,
      "Time_End": 1461.94,
      "Text": " But this code is trying to access offset at 1."
    },
    {
      "Time_Start": 1461.94,
      "Time_End": 1464.94,
      "Text": " So, this will essentially lead to an out of bounds error."
    },
    {
      "Time_Start": 1464.94,
      "Time_End": 1466.94,
      "Text": " It will lead to all kinds of error."
    },
    {
      "Time_Start": 1466.94,
      "Time_End": 1469.94,
      "Text": " Long story short, this code makes no sense here."
    },
    {
      "Time_Start": 1469.94,
      "Time_End": 1471.94,
      "Text": " No sense."
    },
    {
      "Time_Start": 1472.94,
      "Time_End": 1482.94,
      "Text": " So, this is actually going to give incorrect results of the resulting abstract value."
    },
    {
      "Time_Start": 1482.94,
      "Time_End": 1487.94,
      "Text": " Because we can see that with an example again."
    },
    {
      "Time_Start": 1487.94,
      "Time_End": 1494.94,
      "Text": " Let us say we have an object, let us say we have an object obj1 with two properties s1,"
    },
    {
      "Time_Start": 1494.94,
      "Time_End": 1497.94,
      "Text": " two properties p1 and p2."
    },
    {
      "Time_Start": 1497.94,
      "Time_End": 1502.94,
      "Text": " Then both of the properties here are actually this pointing to the same value."
    },
    {
      "Time_Start": 1502.94,
      "Time_End": 1506.94,
      "Text": " And we have an access object here, property access."
    },
    {
      "Time_Start": 1506.94,
      "Time_End": 1509.94,
      "Text": " We are going, trying to exploit all property accesses."
    },
    {
      "Time_Start": 1509.94,
      "Time_End": 1514.94,
      "Text": " So, let us say that somehow, we do not know how, but somehow that property access has"
    },
    {
      "Time_Start": 1514.94,
      "Time_End": 1516.94,
      "Text": " the abstract value that is shown here."
    },
    {
      "Time_Start": 1516.94,
      "Time_End": 1521.94,
      "Text": " Two structures s1, s2 and a value, and a const value of obj1."
    },
    {
      "Time_Start": 1521.94,
      "Time_End": 1527.94,
      "Text": " So, this value is effectively obj1 and the offsets are going to be 0 and 1."
    },
    {
      "Time_Start": 1527.94,
      "Time_End": 1533.94,
      "Text": " So, what is going to happen here is that, first we try to get the property at offset"
    },
    {
      "Time_Start": 1533.94,
      "Time_End": 1537.94,
      "Text": " 0, which is, this is going to be p1, it is correct."
    },
    {
      "Time_Start": 1537.94,
      "Time_End": 1541.94,
      "Text": " In the next iteration of the for loop, this is going to be 1."
    },
    {
      "Time_Start": 1541.94,
      "Time_End": 1544.94,
      "Text": " This is an out of, this will, might or might not."
    },
    {
      "Time_Start": 1544.94,
      "Time_End": 1548.94,
      "Text": " In this case, at offset 1 we have p2."
    },
    {
      "Time_Start": 1549.94,
      "Time_End": 1554.94,
      "Text": " And we are trying to compile an access to p1, but the compiler is reading other property"
    },
    {
      "Time_Start": 1554.94,
      "Time_End": 1555.94,
      "Text": " p2."
    },
    {
      "Time_Start": 1555.94,
      "Time_End": 1558.94,
      "Text": " The compiler itself is confused at this point."
    },
    {
      "Time_Start": 1558.94,
      "Time_End": 1565.94,
      "Text": " So, it reads some incorrect value, the resulting abstract value is also incorrect now."
    },
    {
      "Time_Start": 1566.94,
      "Time_End": 1573.94,
      "Text": " So, just to take a moment, abstract value is something that is trusted by the compiler,"
    },
    {
      "Time_Start": 1573.94,
      "Time_End": 1576.94,
      "Text": " but due to a bug, as abstract value is now wrong."
    },
    {
      "Time_Start": 1576.94,
      "Time_End": 1582.94,
      "Text": " So, a trusted internal value is now wrongly computed."
    },
    {
      "Time_Start": 1582.94,
      "Time_End": 1587.94,
      "Text": " This means that we have avenues for type confusions everywhere here, from here."
    },
    {
      "Time_Start": 1587.94,
      "Time_End": 1593.94,
      "Text": " So, one of the main places to look for type, where abstract values are used is constant"
    },
    {
      "Time_Start": 1593.94,
      "Time_End": 1596.94,
      "Text": " folding, because it is a constant folding case."
    },
    {
      "Time_Start": 1596.94,
      "Time_End": 1598.94,
      "Text": " So, what is constant folding?"
    },
    {
      "Time_Start": 1598.94,
      "Time_End": 1602.94,
      "Text": " Constant folding is basically an optimization case in the DFG IR."
    },
    {
      "Time_Start": 1602.94,
      "Time_End": 1606.94,
      "Text": " And let us see what it does for the check structure opcode."
    },
    {
      "Time_Start": 1606.94,
      "Time_End": 1612.94,
      "Text": " To recap, when we have a property access like this, DFG converts it into two access."
    },
    {
      "Time_Start": 1612.94,
      "Time_End": 1615.94,
      "Text": " One is a check structure, one is a get by offset."
    },
    {
      "Time_Start": 1615.94,
      "Time_End": 1620.94,
      "Text": " Get by offset is basically fetching the property value, whereas the structure check is done"
    },
    {
      "Time_Start": 1620.94,
      "Time_End": 1622.94,
      "Text": " by the check structure."
    },
    {
      "Time_Start": 1622.94,
      "Time_End": 1627.94,
      "Text": " And what this code is going to do here is that, it first fetches the abstract value"
    },
    {
      "Time_Start": 1627.94,
      "Time_End": 1628.94,
      "Text": " of object."
    },
    {
      "Time_Start": 1628.94,
      "Time_End": 1631.94,
      "Text": " What does the abstract value of object contain?"
    },
    {
      "Time_Start": 1631.94,
      "Time_End": 1637.94,
      "Text": " It contains all possible structures object can have."
    },
    {
      "Time_Start": 1637.94,
      "Time_End": 1640.94,
      "Text": " And then it fetches S1 from here."
    },
    {
      "Time_Start": 1640.94,
      "Time_End": 1643.94,
      "Text": " This set is basically S1."
    },
    {
      "Time_Start": 1643.94,
      "Time_End": 1647.94,
      "Text": " Now, if the, now the compiler asks the abstract value."
    },
    {
      "Time_Start": 1647.94,
      "Time_End": 1655.94,
      "Text": " What are the set of structures that, structures that this can have?"
    },
    {
      "Time_Start": 1655.94,
      "Time_End": 1658.94,
      "Text": " What are the set of structures that object can have?"
    },
    {
      "Time_Start": 1658.94,
      "Time_End": 1667.94,
      "Text": " And if all, if the abstract value reports to the compiler that object can only have"
    },
    {
      "Time_Start": 1667.94,
      "Time_End": 1673.94,
      "Text": " one structure, S1, then this entire check structure, entire check structure can actually"
    },
    {
      "Time_Start": 1673.94,
      "Time_End": 1675.94,
      "Text": " be eliminated here."
    },
    {
      "Time_Start": 1675.94,
      "Time_End": 1679.94,
      "Text": " Which we, and now coming back to our code."
    },
    {
      "Time_Start": 1679.94,
      "Time_End": 1684.94,
      "Text": " Our bug was that we have an incorrect abstract value for this."
    },
    {
      "Time_Start": 1684.94,
      "Time_End": 1696.94,
      "Text": " And if we access a property on that, on that value, then check structure, this is, a property"
    },
    {
      "Time_Start": 1696.94,
      "Time_End": 1702.94,
      "Text": " access is actually split into two DFT opcodes."
    },
    {
      "Time_Start": 1702.94,
      "Time_End": 1707.94,
      "Text": " The check structure is incorrectly eliminated because the abstract value is incorrect, the"
    },
    {
      "Time_Start": 1707.94,
      "Time_End": 1709.94,
      "Text": " check structure is incorrectly eliminated."
    },
    {
      "Time_Start": 1709.94,
      "Time_End": 1714.94,
      "Text": " Because check structure is, elimination is based on the abstract value which is now incorrect."
    },
    {
      "Time_Start": 1714.94,
      "Time_End": 1716.94,
      "Text": " So we have an incorrect elimination."
    },
    {
      "Time_Start": 1716.94,
      "Time_End": 1722.94,
      "Text": " So we just have a get by offset which is a direct pointer access without any checks."
    },
    {
      "Time_Start": 1722.94,
      "Time_End": 1727.94,
      "Text": " In reality, what happens is that the compiler thinks access object can only have the structure"
    },
    {
      "Time_Start": 1727.94,
      "Time_End": 1728.94,
      "Text": " S1."
    },
    {
      "Time_Start": 1728.94,
      "Time_End": 1733.94,
      "Text": " However, in reality it can also have the structure S2."
    },
    {
      "Time_Start": 1733.94,
      "Time_End": 1740.94,
      "Text": " So which means that if it has the structure S2, which we, I did not even show S2 here."
    },
    {
      "Time_Start": 1740.94,
      "Time_End": 1743.94,
      "Text": " It is just some random structure S2."
    },
    {
      "Time_Start": 1743.94,
      "Time_End": 1747.94,
      "Text": " Then object.p1 can be a random access, can be a random number."
    },
    {
      "Time_Start": 1747.94,
      "Time_End": 1749.94,
      "Text": " It can be 1, 2, 3, 4."
    },
    {
      "Time_Start": 1749.94,
      "Time_End": 1752.94,
      "Text": " For all I know, access can be 1, 2, 3, 4."
    },
    {
      "Time_Start": 1752.94,
      "Time_End": 1757.94,
      "Text": " And this one is now trying to access, do a pointer dereference on 1, 2, 3, 4."
    },
    {
      "Time_Start": 1757.94,
      "Time_End": 1759.94,
      "Text": " Which is, which is why."
    },
    {
      "Time_Start": 1759.94,
      "Time_End": 1762.94,
      "Text": " So if I run that in GDB, this is how it looks like."
    },
    {
      "Time_Start": 1762.94,
      "Time_End": 1767.94,
      "Text": " I crash with rcx as 1, 2, 3, 4."
    },
    {
      "Time_Start": 1767.94,
      "Time_End": 1773.94,
      "Text": " Because this crashed the entire engine by doing an arbitrary pointer dereference."
    },
    {
      "Time_Start": 1773.94,
      "Time_End": 1777.94,
      "Text": " So I am from here writing an exploit is actually simple from here."
    },
    {
      "Time_Start": 1777.94,
      "Time_End": 1783.94,
      "Text": " So we are not going to talk about writing an exploit, but it is pretty simple."
    },
    {
      "Time_Start": 1783.94,
      "Time_End": 1787.94,
      "Text": " And this bug was patched in, I think November last year."
    },
    {
      "Time_Start": 1787.94,
      "Time_End": 1789.94,
      "Text": " It was introduced in 2014."
    },
    {
      "Time_Start": 1789.94,
      "Time_End": 1794.94,
      "Text": " This is a bug, this is a bug so complex that it lived in the compiler for 8 years."
    },
    {
      "Time_Start": 1794.94,
      "Time_End": 1797.94,
      "Text": " So 8 years Safari was vulnerable to this."
    },
    {
      "Time_Start": 1797.94,
      "Time_End": 1800.94,
      "Text": " Safari could have been exploited using this bug."
    },
    {
      "Time_Start": 1800.94,
      "Time_End": 1802.94,
      "Text": " Only in November it was patched."
    },
    {
      "Time_Start": 1802.94,
      "Time_End": 1807.94,
      "Text": " So that is the advantages of complex bugs."
    },
    {
      "Time_Start": 1807.94,
      "Time_End": 1810.94,
      "Text": " Now let us look at a simpler bug, much more simpler bug."
    },
    {
      "Time_Start": 1810.94,
      "Time_End": 1813.94,
      "Text": " For this we need to know what is a JS value."
    },
    {
      "Time_Start": 1813.94,
      "Time_End": 1816.94,
      "Text": " We know, we know that if object is equal to,"
    },
    {
      "Time_Start": 1816.94,
      "Time_End": 1819.94,
      "Text": " if we have JavaScript statement like this,"
    },
    {
      "Time_Start": 1819.94,
      "Time_End": 1827.94,
      "Text": " internally JavaScript statements, JavaScript core actually stores obj as a pointer."
    },
    {
      "Time_Start": 1827.94,
      "Time_End": 1831.94,
      "Text": " Pointer means all upper 15 bits are null."
    },
    {
      "Time_Start": 1831.94,
      "Time_End": 1833.94,
      "Text": " Because that is how virtual memory works."
    },
    {
      "Time_Start": 1833.94,
      "Time_End": 1835.94,
      "Text": " Virtual memory only uses the lower 48 bits."
    },
    {
      "Time_Start": 1835.94,
      "Time_End": 1838.94,
      "Text": " So upper 16 bits are actually null."
    },
    {
      "Time_Start": 1838.94,
      "Time_End": 1841.94,
      "Text": " If you are storing a number,"
    },
    {
      "Time_Start": 1842.94,
      "Time_End": 1847.94,
      "Text": " JavaScript core actually uses this FFFE."
    },
    {
      "Time_Start": 1847.94,
      "Time_End": 1850.94,
      "Text": " So upper 15 bits are set."
    },
    {
      "Time_Start": 1850.94,
      "Time_End": 1858.94,
      "Text": " And finally if we have a float, float is imported using the IEEE 754 format."
    },
    {
      "Time_Start": 1858.94,
      "Time_End": 1864.94,
      "Text": " This is the 1.1 IEEE 754 will give us some value."
    },
    {
      "Time_Start": 1864.94,
      "Time_End": 1867.94,
      "Text": " And JavaScript core what it will do in turn is that"
    },
    {
      "Time_Start": 1867.94,
      "Time_End": 1873.94,
      "Text": " it will add 2 to the power 49 to our IEEE imported thing."
    },
    {
      "Time_Start": 1873.94,
      "Time_End": 1876.94,
      "Text": " Now if you have done bug hunting before,"
    },
    {
      "Time_Start": 1876.94,
      "Time_End": 1879.94,
      "Text": " every addition is suspicious to,"
    },
    {
      "Time_Start": 1879.94,
      "Time_End": 1884.94,
      "Text": " every addition is suspect to integer overflows."
    },
    {
      "Time_Start": 1884.94,
      "Time_End": 1893.94,
      "Text": " This means that if the upper bits of an IEEE 754 are all set,"
    },
    {
      "Time_Start": 1893.94,
      "Time_End": 1895.94,
      "Text": " then this can overflow."
    },
    {
      "Time_Start": 1896.94,
      "Time_End": 1898.94,
      "Text": " So the compiler has to protect against it."
    },
    {
      "Time_Start": 1898.94,
      "Time_End": 1900.94,
      "Text": " In theory it can overflow, in practical it will,"
    },
    {
      "Time_Start": 1900.94,
      "Time_End": 1902.94,
      "Text": " in practice it will never overflow."
    },
    {
      "Time_Start": 1902.94,
      "Time_End": 1905.94,
      "Text": " This is because the IEEE 754 format says that"
    },
    {
      "Time_Start": 1905.94,
      "Time_End": 1908.94,
      "Text": " if the upper bits are all set, it is not a number."
    },
    {
      "Time_Start": 1908.94,
      "Time_End": 1911.94,
      "Text": " This is not a number."
    },
    {
      "Time_Start": 1911.94,
      "Time_End": 1917.94,
      "Text": " JavaScript only honors one not a number value and that is this one."
    },
    {
      "Time_Start": 1917.94,
      "Time_End": 1920.94,
      "Text": " Everything else it does not honor."
    },
    {
      "Time_Start": 1921.94,
      "Time_End": 1925.94,
      "Text": " So now let us go back into the code base."
    },
    {
      "Time_Start": 1925.94,
      "Time_End": 1929.94,
      "Text": " This is the code that converts JavaScript IR,"
    },
    {
      "Time_Start": 1929.94,
      "Time_End": 1932.94,
      "Text": " DFG IR into assembly."
    },
    {
      "Time_Start": 1932.94,
      "Time_End": 1935.94,
      "Text": " So this is the code that has been compiled."
    },
    {
      "Time_Start": 1935.94,
      "Time_End": 1938.94,
      "Text": " We have an array access and that array access is"
    },
    {
      "Time_Start": 1938.94,
      "Time_End": 1940.94,
      "Text": " being compiled to assembly."
    },
    {
      "Time_Start": 1940.94,
      "Time_End": 1942.94,
      "Text": " However this is not a simple array access,"
    },
    {
      "Time_Start": 1942.94,
      "Time_End": 1944.94,
      "Text": " it is a floating point array access."
    },
    {
      "Time_Start": 1944.94,
      "Time_End": 1947.94,
      "Text": " Speciality of float 64 arrays here is that"
    },
    {
      "Time_Start": 1948.94,
      "Time_End": 1952.94,
      "Text": " float 64 arrays hold raw floats, IEEE floats, not JS value."
    },
    {
      "Time_Start": 1952.94,
      "Time_End": 1954.94,
      "Text": " And another interesting point is that"
    },
    {
      "Time_Start": 1954.94,
      "Time_End": 1956.94,
      "Text": " they are completely user controlled."
    },
    {
      "Time_Start": 1956.94,
      "Time_End": 1958.94,
      "Text": " We control every single bit."
    },
    {
      "Time_Start": 1958.94,
      "Time_End": 1963.94,
      "Text": " So this means that when we do a get by val,"
    },
    {
      "Time_Start": 1963.94,
      "Time_End": 1965.94,
      "Text": " this means that when we compile it,"
    },
    {
      "Time_Start": 1965.94,
      "Time_End": 1970.94,
      "Text": " the compiler should actually check,"
    },
    {
      "Time_Start": 1970.94,
      "Time_End": 1973.94,
      "Text": " the compiler should actually check,"
    },
    {
      "Time_Start": 1974.94,
      "Time_End": 1976.94,
      "Text": " first convert the float into,"
    },
    {
      "Time_Start": 1976.94,
      "Time_End": 1979.94,
      "Text": " convert the float into a JS value"
    },
    {
      "Time_Start": 1979.94,
      "Time_End": 1982.94,
      "Text": " and also check each of the bits."
    },
    {
      "Time_Start": 1982.94,
      "Time_End": 1984.94,
      "Text": " The compiler does check,"
    },
    {
      "Time_Start": 1984.94,
      "Time_End": 1986.94,
      "Text": " convert the float into a JS value,"
    },
    {
      "Time_Start": 1986.94,
      "Time_End": 1990.94,
      "Text": " but it never checks whether the top bits are set or not."
    },
    {
      "Time_Start": 1990.94,
      "Time_End": 1993.94,
      "Text": " So this means that we have an overflow here,"
    },
    {
      "Time_Start": 1993.94,
      "Time_End": 1995.94,
      "Text": " which should never have happened."
    },
    {
      "Time_Start": 1995.94,
      "Time_End": 1999.94,
      "Text": " And we again have an arbitrary pointer dereference."
    },
    {
      "Time_Start": 2000.94,
      "Time_End": 2002.94,
      "Text": " We actually did a,"
    },
    {
      "Time_Start": 2002.94,
      "Time_End": 2004.94,
      "Text": " me and my colleague did a full talk on this."
    },
    {
      "Time_Start": 2004.94,
      "Time_End": 2007.94,
      "Text": " I assume you can watch this there."
    },
    {
      "Time_Start": 2007.94,
      "Time_End": 2009.94,
      "Text": " To conclude,"
    },
    {
      "Time_Start": 2009.94,
      "Time_End": 2012.94,
      "Text": " some takeaways here are"
    },
    {
      "Time_Start": 2012.94,
      "Time_End": 2014.94,
      "Text": " to hunt for assumptions in code"
    },
    {
      "Time_Start": 2014.94,
      "Time_End": 2017.94,
      "Text": " and to compare implementations between various compilers."
    },
    {
      "Time_Start": 2017.94,
      "Time_End": 2020.94,
      "Text": " Another idea is to look for variants."
    },
    {
      "Time_Start": 2020.94,
      "Time_End": 2024.94,
      "Text": " This is that get by, that nan value patch,"
    },
    {
      "Time_Start": 2024.94,
      "Time_End": 2027.94,
      "Text": " that was patched."
    },
    {
      "Time_Start": 2027.94,
      "Time_End": 2029.94,
      "Text": " It was patched two times,"
    },
    {
      "Time_Start": 2029.94,
      "Time_End": 2032.94,
      "Text": " three times, four times, five times."
    },
    {
      "Time_Start": 2032.94,
      "Time_End": 2033.94,
      "Text": " It was patched."
    },
    {
      "Time_Start": 2033.94,
      "Time_End": 2037.94,
      "Text": " This work has been there in the compiler since 2022."
    },
    {
      "Time_Start": 2037.94,
      "Time_End": 2039.94,
      "Text": " Every time in different parts."
    },
    {
      "Time_Start": 2039.94,
      "Time_End": 2043.94,
      "Text": " It's interesting to look at all the variants"
    },
    {
      "Time_Start": 2043.94,
      "Time_End": 2046.94,
      "Text": " and it's also interesting to look at the depth."
    },
    {
      "Time_Start": 2046.94,
      "Time_End": 2048.94,
      "Text": " The abstract value is so deep"
    },
    {
      "Time_Start": 2048.94,
      "Time_End": 2051.94,
      "Text": " that it's lived in the compiler for eight years."
    },
    {
      "Time_Start": 2051.94,
      "Time_End": 2053.94,
      "Text": " So finally, as a demo,"
    },
    {
      "Time_Start": 2053.94,
      "Time_End": 2056.94,
      "Text": " this is the nan exploit running on an iPhone."
    },
    {
      "Time_Start": 2056.94,
      "Time_End": 2058.94,
      "Text": " And it's iOS 15"
    },
    {
      "Time_Start": 2058.94,
      "Time_End": 2061.94,
      "Text": " and it's actually reading the slash etc slash password."
    },
    {
      "Time_Start": 2061.94,
      "Time_End": 2065.94,
      "Text": " So that's more or less it."
    },
    {
      "Time_Start": 2065.94,
      "Time_End": 2066.94,
      "Text": " I'm running out of time."
    },
    {
      "Time_Start": 2066.94,
      "Time_End": 2070.94,
      "Text": " I'm sorry for overrunning it by a few minutes."
    },
    {
      "Time_Start": 2070.94,
      "Time_End": 2075.94,
      "Text": " And I'll be around if anyone has doubts or questions,"
    },
    {
      "Time_Start": 2075.94,
      "Time_End": 2078.94,
      "Text": " then I'll be around the place."
    },
    {
      "Time_Start": 2079.94,
      "Time_End": 2086.94,
      "Text": " Thank you, Ignis."
    },
    {
      "Time_Start": 2086.94,
      "Time_End": 2090.94,
      "Text": " We can open the floor for a couple of questions very quickly."
    },
    {
      "Time_Start": 2090.94,
      "Time_End": 2092.94,
      "Text": " If anyone's got any questions,"
    },
    {
      "Time_Start": 2092.94,
      "Time_End": 2095.94,
      "Text": " you can use them now."
    },
    {
      "Time_Start": 2095.94,
      "Time_End": 2101.94,
      "Text": " Yeah."
    },
    {
      "Time_Start": 2101.94,
      "Time_End": 2105.94,
      "Text": " With such a complex code base like JavaScript core,"
    },
    {
      "Time_Start": 2105.94,
      "Time_End": 2109.94,
      "Text": " how do you find the ability to track virtual methods"
    },
    {
      "Time_Start": 2109.94,
      "Time_End": 2113.94,
      "Text": " being called in vtables deep and deep into the code base?"
    },
    {
      "Time_Start": 2113.94,
      "Time_End": 2116.94,
      "Text": " Do you usually use that dump disassembly"
    },
    {
      "Time_Start": 2116.94,
      "Time_End": 2117.94,
      "Text": " or dump bytecode thing?"
    },
    {
      "Time_Start": 2117.94,
      "Time_End": 2118.94,
      "Text": " Yeah."
    },
    {
      "Time_Start": 2118.94,
      "Time_End": 2122.94,
      "Text": " So typically what people do is that you read the source code."
    },
    {
      "Time_Start": 2122.94,
      "Time_End": 2125.94,
      "Text": " But rather than reading the source code,"
    },
    {
      "Time_Start": 2125.94,
      "Time_End": 2126.94,
      "Text": " I feel like reading the IR"
    },
    {
      "Time_Start": 2126.94,
      "Time_End": 2128.94,
      "Text": " and that dump disassembly is more helpful"
    },
    {
      "Time_Start": 2128.94,
      "Time_End": 2132.94,
      "Text": " than reading the go and reading the source code."
    },
    {
      "Time_Start": 2132.94,
      "Time_End": 2133.94,
      "Text": " So I would say, yeah,"
    },
    {
      "Time_Start": 2133.94,
      "Time_End": 2144.94,
      "Text": " read the IR and then read the source code."
    },
    {
      "Time_Start": 2144.94,
      "Time_End": 2146.94,
      "Text": " Thank you so much for your talk."
    },
    {
      "Time_Start": 2146.94,
      "Time_End": 2151.94,
      "Text": " I was just curious how these two bugs were found."
    },
    {
      "Time_Start": 2151.94,
      "Time_End": 2156.94,
      "Text": " Was it through auditing or fuzzing or things?"
    },
    {
      "Time_Start": 2156.94,
      "Time_End": 2158.94,
      "Text": " So the first bug was not mine."
    },
    {
      "Time_Start": 2158.94,
      "Time_End": 2160.94,
      "Text": " The abstract value bug is just a bug"
    },
    {
      "Time_Start": 2160.94,
      "Time_End": 2163.94,
      "Text": " that I thought was so very interesting."
    },
    {
      "Time_Start": 2163.94,
      "Time_End": 2165.94,
      "Text": " The second bug is mine."
    },
    {
      "Time_Start": 2165.94,
      "Time_End": 2167.94,
      "Text": " It was found by me and my colleague."
    },
    {
      "Time_Start": 2167.94,
      "Time_End": 2170.94,
      "Text": " So it was found partially by fuzzing,"
    },
    {
      "Time_Start": 2170.94,
      "Time_End": 2171.94,
      "Text": " partially by auditing"
    },
    {
      "Time_Start": 2171.94,
      "Time_End": 2172.94,
      "Text": " because we were auditing a code"
    },
    {
      "Time_Start": 2172.94,
      "Time_End": 2175.94,
      "Text": " where a fuzzer actually found the crash."
    },
    {
      "Time_Start": 2175.94,
      "Time_End": 2178.94,
      "Text": " The fuzzer crash was not exploitable,"
    },
    {
      "Time_Start": 2178.94,
      "Time_End": 2180.94,
      "Text": " but when we audited that code,"
    },
    {
      "Time_Start": 2180.94,
      "Time_End": 2181.94,
      "Text": " we found a different bug."
    },
    {
      "Time_Start": 2181.94,
      "Time_End": 2185.94,
      "Text": " So we found this by looking at just reading code"
    },
    {
      "Time_Start": 2186.94,
      "Time_End": 2190.94,
      "Text": " and yeah, mainly by source code auditing."
    },
    {
      "Time_Start": 2193.94,
      "Time_End": 2195.94,
      "Text": " Any more questions?"
    },
    {
      "Time_Start": 2198.94,
      "Time_End": 2199.94,
      "Text": " All right."
    },
    {
      "Time_Start": 2199.94,
      "Time_End": 2200.94,
      "Text": " For any other questions,"
    },
    {
      "Time_Start": 2200.94,
      "Time_End": 2202.94,
      "Text": " you can take your seat with Vignesh."
    },
    {
      "Time_Start": 2202.94,
      "Time_End": 2204.94,
      "Text": " Thank you very much, Vignesh."
    },
    {
      "Time_Start": 2204.94,
      "Time_End": 2205.94,
      "Text": " Thank you."
    }
  ]
}