**Introduction:**
- Speaker: **Zou Xiaochen**, Ph.D. candidate at the University of California, Riverside, advised by Professor Zhiyun Qian.
- Topic: Linux kernel bug exploitability assessment, exploring the gap between fuzzing-exposed bugs and real-world exploits.

**Linux Kernel Security:**
- Continuous fuzzing has become integral to the Linux kernel ecosystem, discovering thousands of bugs.
- However, only a small fraction of these bugs are exploited in downstream distributions (e.g., Ubuntu, Fedora).
- This talk aims to understand and bridge the gap between bug discovery and exploitation.

**Fuzzing and Exploitability:**
- Fuzzing is a dynamic approach to finding bugs, generating test cases based on randomness.
- While efficient, fuzzing is blind and may not focus on security bugs, leading to a gap between discovered bugs and exploits.
- Sysbot, a fuzzing platform by Google, has found over 10,000 kernel bugs in 6 years, with thousands still unfixed.
- Despite the large number of unfixed bugs, there are relatively few kernel exploits, indicating a need for better understanding.

**Upstream vs. Downstream:**
- Linux has **upstream** (development) and **downstream** (stable, daily-use) kernels.
- Upstream fuzzing exposes bugs that may not exist in downstream kernels due to differences in compilation and environment.
- The structure of the Linux community, with separate upstream and downstream kernels, contributes to the gap between bugs and exploits.

**Reproducibility and Exploitability:**
- An experiment was designed to understand the reproducibility of upstream bugs in downstream kernels (Ubuntu, Fedora, Debian, SUSE).
- Out of 200 bug-distro pairs, only 18 successfully triggered bugs, all requiring root privilege, indicating a lack of exploitability.
- Failure reasons included logic missing, code context change, and environment change, with the latter being the main focus of the talk.

**Environment Change:**
- Preparation failure: Downstream kernels may not have virtual interfaces, causing POCs to fail during environment preparation.
- Background noise: Downstream kernels have more background processes, making it harder for POCs to win data races and trigger bugs.
- Missing module: Downstream kernels often compile modules separately, and if a desired module is missing, the POC may fail to trigger the bug.

**Automated Solutions:**
- Preparation failure: Minimize environment preparation steps to retain only necessary ones, ensuring POCs reach the core function and trigger the bug.
- Background noise: Force data collision by allocating more resources (CPU cores, infinite loops, longer execution time) to the POC process.
- Missing module: Use ftrace to compare execution traces and identify missing modules, then find ways to load them as an unprivileged user.

**Privilege and Exploitability:**
- All previously triggered bugs required root privilege, so the focus shifts to making them triggerable by unprivileged users.
- Capability check: Kernel uses capabilities for fine-grained control, and some capabilities can be granted to unprivileged users in user namespaces.
- Module loading: Request module kernel function allows unprivileged users to load certain modules, but not all, by calling mode probe as root.
- Customized fuzzer: Built to identify modules loadable by unprivileged users, finding hundreds of such modules across all four distros.

**Number Crunching:**
- 282 likely exploitable bugs containing high-risk primitives were prepared for testing.
- Without adaptations, only 15.6% of bugs could be triggered on downstream kernels, and only 0.7% were exploitable by unprivileged users.
- After applying automated adaptations, the number of triggerable bugs increased to 25.8%, and exploitable bugs increased by 14 times.

**Case Studies:**
- Bug 1: Required an additional module, which could be loaded by an unprivileged user using a simple system call.
- Bug 2: Needed the RDMA UCM module, requiring two system calls and a well-prepared data structure to load.
- Bug 3: Involved loading IPv6 tables with a sophisticated data structure, using an alias (ICMP6) in the request module.

**Key Takeaways:**
- Upstream and downstream kernels have different environments, and fuzzing neglects privilege and environment factors.
- Fuzzing-generated POCs often fail on real-world OS, but adaptations can improve triggerability and exploitability.
- Techniques include removing unnecessary preparation steps, allocating more resources, finding missing modules, and downgrading privilege requirements.

**Conclusion:**
- Talk highlights the challenges of converting fuzzing-exposed bugs into real-world exploits, focusing on the gap between upstream and downstream kernels.
- Automated solutions and privilege adaptations improve the exploitability of discovered bugs, enhancing the effectiveness of fuzzing in Linux kernel security assessments.