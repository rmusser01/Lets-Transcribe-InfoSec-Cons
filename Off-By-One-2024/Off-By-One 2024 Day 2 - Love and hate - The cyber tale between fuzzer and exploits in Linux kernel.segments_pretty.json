{
  "segments": [
    {
      "Time_Start": 0.0,
      "Time_End": 4.88,
      "Text": "This text was transcribed using whisper model: large-v2\n\n Hello everyone, good morning or afternoon."
    },
    {
      "Time_Start": 4.88,
      "Time_End": 7.92,
      "Text": " I don't know what time is it in Singapore right now."
    },
    {
      "Time_Start": 7.92,
      "Time_End": 10.72,
      "Text": " I hope you have enjoyed the weather and the food."
    },
    {
      "Time_Start": 10.72,
      "Time_End": 15.84,
      "Text": " I really wish I could be there to watch all your talk and have great conversation with"
    },
    {
      "Time_Start": 15.84,
      "Time_End": 16.96,
      "Text": " you guys."
    },
    {
      "Time_Start": 16.96,
      "Time_End": 23.16,
      "Text": " But due to the visa issue, I am not allowed \u2013 like, I am allowed to leave U.S., but"
    },
    {
      "Time_Start": 23.16,
      "Time_End": 27.72,
      "Text": " I don't want to risk my visa to leave the U.S."
    },
    {
      "Time_Start": 27.72,
      "Time_End": 34.6,
      "Text": " That's why I give this video talk, and I'll have a live Q&A afterwards, I guess."
    },
    {
      "Time_Start": 34.6,
      "Time_End": 38.64,
      "Text": " So my name is Xiaochen Zhou, I'm a senior year PhD student at UC Riverside."
    },
    {
      "Time_Start": 38.64,
      "Time_End": 43.56,
      "Text": " Today I'll present my recent work about Linux kernel bug exploitability assessment."
    },
    {
      "Time_Start": 43.56,
      "Time_End": 48.76,
      "Text": " I call it Love and Hate, the cyber tale between father and exploits in Linux kernel."
    },
    {
      "Time_Start": 48.76,
      "Time_End": 52.2,
      "Text": " This work has done by me and Professor Jun Qian."
    },
    {
      "Time_Start": 53.2,
      "Time_End": 67.2,
      "Text": " Yeah, let's get to our \u2013 bugs are errors that cause computer program to behave unexpectedly."
    },
    {
      "Time_Start": 67.2,
      "Time_End": 71.56,
      "Text": " Most of the time the normal behavior only cause minor issues, or sometimes we don't"
    },
    {
      "Time_Start": 71.56,
      "Time_End": 72.56,
      "Text": " even notice."
    },
    {
      "Time_Start": 72.56,
      "Time_End": 75.88,
      "Text": " However, some bugs are much more severe."
    },
    {
      "Time_Start": 75.88,
      "Time_End": 83.56,
      "Text": " So one day people realize this severe behavior could lead to a total compromise of the application."
    },
    {
      "Time_Start": 83.56,
      "Time_End": 86.28,
      "Text": " We call it exploits."
    },
    {
      "Time_Start": 86.28,
      "Time_End": 92.6,
      "Text": " And for all these bugs that can lead to exploits, we call it exploitable bugs."
    },
    {
      "Time_Start": 92.6,
      "Time_End": 96.44,
      "Text": " Now all these years, security researchers have developed different ways to discover"
    },
    {
      "Time_Start": 96.44,
      "Time_End": 97.44,
      "Text": " exploitable bugs."
    },
    {
      "Time_Start": 97.44,
      "Time_End": 101.16,
      "Text": " So in the beginning, we start with manual code auditing."
    },
    {
      "Time_Start": 101.16,
      "Time_End": 107.78,
      "Text": " We read hundreds of thousands of lines of code with our bare eyes to just find one tiny"
    },
    {
      "Time_Start": 107.78,
      "Time_End": 111.56,
      "Text": " variable misuse or missing log."
    },
    {
      "Time_Start": 111.56,
      "Time_End": 116.44,
      "Text": " I really admire those people who can do the manual auditing, and they're the hero of cybersecurity."
    },
    {
      "Time_Start": 116.44,
      "Time_End": 123.19999999999999,
      "Text": " Well, in later stage, people find manual auditing is low-efficient, so they build program to"
    },
    {
      "Time_Start": 123.19999999999999,
      "Time_End": 124.19999999999999,
      "Text": " find bugs."
    },
    {
      "Time_Start": 124.2,
      "Time_End": 130.68,
      "Text": " Because we have two automated solutions for bug hunting, dynamic way, aka fuzzing, and"
    },
    {
      "Time_Start": 130.68,
      "Time_End": 134.2,
      "Text": " static analysis, the static way."
    },
    {
      "Time_Start": 134.2,
      "Time_End": 138.92000000000002,
      "Text": " But with the decades-long iteration, some software become shockingly huge."
    },
    {
      "Time_Start": 138.92000000000002,
      "Time_End": 148.6,
      "Text": " For example, Linux kernel source code contains 28 million lines of code and countless indirect"
    },
    {
      "Time_Start": 148.6,
      "Time_End": 152.2,
      "Text": " call and global cross-reference and dependencies."
    },
    {
      "Time_Start": 152.20000000000002,
      "Time_End": 157.20000000000002,
      "Text": " That creates plenty of problem to manual auditing and static analysis."
    },
    {
      "Time_Start": 157.20000000000002,
      "Time_End": 163.68,
      "Text": " However, by the nature of a dynamic approach, fuzzing won the competition with unbeatable"
    },
    {
      "Time_Start": 163.68,
      "Time_End": 169.88000000000002,
      "Text": " efficiencies and the lowest false negative rate."
    },
    {
      "Time_Start": 169.88000000000002,
      "Time_End": 176.08,
      "Text": " But one problem with fuzzing is the blindness, which means we have less control during the"
    },
    {
      "Time_Start": 176.08,
      "Time_End": 177.48000000000002,
      "Text": " fuzzing process."
    },
    {
      "Time_Start": 177.48,
      "Time_End": 182.56,
      "Text": " Randomness seeds are generated, and test cases are guided by coverage feedback."
    },
    {
      "Time_Start": 182.56,
      "Time_End": 186.44,
      "Text": " All these undeterminable factors add up to the blindness."
    },
    {
      "Time_Start": 186.44,
      "Time_End": 189.79999999999998,
      "Text": " So sometimes, we may find a lot of bugs."
    },
    {
      "Time_Start": 189.79999999999998,
      "Time_End": 193.88,
      "Text": " We find a lot of bugs, but none of them are security bugs."
    },
    {
      "Time_Start": 193.88,
      "Time_End": 199.04,
      "Text": " And less security bugs means less exploits."
    },
    {
      "Time_Start": 199.04,
      "Time_End": 205.04,
      "Text": " So this suspicious gap between the fuzzing-exposed bugs and the real-world exploits is what we"
    },
    {
      "Time_Start": 205.04,
      "Time_End": 207.28,
      "Text": " want to discuss in this talk."
    },
    {
      "Time_Start": 207.28,
      "Time_End": 215.08,
      "Text": " But can we make more fuzzing-exposed bugs to be exploitable?"
    },
    {
      "Time_Start": 215.08,
      "Time_End": 219.6,
      "Text": " So the first question is, is Linux kernel really safe?"
    },
    {
      "Time_Start": 219.6,
      "Time_End": 224.48,
      "Text": " Here is an excellent Linux kernel security channel on Telegram."
    },
    {
      "Time_Start": 224.48,
      "Time_End": 230.04,
      "Text": " They collect every Linux kernel exploit write-up that we can find online."
    },
    {
      "Time_Start": 230.04,
      "Time_End": 235.84,
      "Text": " And here are samples of kernel exploits from 2033 to 2024."
    },
    {
      "Time_Start": 235.84,
      "Time_End": 239.36,
      "Text": " That's like 10 to 20 exploits every year."
    },
    {
      "Time_Start": 239.36,
      "Time_End": 244.8,
      "Text": " Like 20, 10-ish, 20-ish exploits sounds like a reasonable amount."
    },
    {
      "Time_Start": 244.8,
      "Time_End": 250.28,
      "Text": " But if I tell you how many Linux kernel bugs out there, you will be shocked."
    },
    {
      "Time_Start": 250.28,
      "Time_End": 252.96,
      "Text": " So let's introduce Sysbot."
    },
    {
      "Time_Start": 252.96,
      "Time_End": 256.4,
      "Text": " So Sysbot is a fuzzing platform developed by Google."
    },
    {
      "Time_Start": 256.4,
      "Time_End": 262.92,
      "Text": " It deploys Google kernel fuzzer, syscaller, to fuzz Linux kernel 24 hours a day and seven"
    },
    {
      "Time_Start": 262.92,
      "Time_End": 263.92,
      "Text": " days a week."
    },
    {
      "Time_Start": 264.0,
      "Time_End": 270.40000000000003,
      "Text": " The Sysbot is so powerful, it funds so many bugs that even overwhelm the kernel developers."
    },
    {
      "Time_Start": 270.40000000000003,
      "Time_End": 275.88,
      "Text": " So they don't have enough time and resources and people to fix all these two to three new"
    },
    {
      "Time_Start": 275.88,
      "Time_End": 279.76,
      "Text": " bugs every day that are found by Sysbot."
    },
    {
      "Time_Start": 279.76,
      "Time_End": 285.56,
      "Text": " In the past six years, Sysbot has found more than 10,000 kernel bugs."
    },
    {
      "Time_Start": 285.56,
      "Time_End": 292.32,
      "Text": " And up to now, there's still a thousand bugs that are not fixed by Sysbot."
    },
    {
      "Time_Start": 292.56,
      "Time_End": 294.56,
      "Text": " Well, not fixed by the developer."
    },
    {
      "Time_Start": 294.56,
      "Time_End": 296.2,
      "Text": " They were found by Sysbot."
    },
    {
      "Time_Start": 296.2,
      "Time_End": 303.15999999999997,
      "Text": " So if you look at this graph, this graph, the red line is the new bugs, open bugs."
    },
    {
      "Time_Start": 303.15999999999997,
      "Time_End": 306.76,
      "Text": " And the green line is the fixed bugs."
    },
    {
      "Time_Start": 306.76,
      "Time_End": 311.4,
      "Text": " So you will notice there's a gap between the green line and the red line."
    },
    {
      "Time_Start": 311.4,
      "Time_End": 316.84,
      "Text": " That means the bugs is unfixed."
    },
    {
      "Time_Start": 316.88000000000005,
      "Time_End": 322.12,
      "Text": " And this gap expanding every year."
    },
    {
      "Time_Start": 322.12,
      "Time_End": 329.28000000000003,
      "Text": " In March 2003, the gap has become 6,000 bugs, that means 6,000 bugs has not been fixed at"
    },
    {
      "Time_Start": 329.28000000000003,
      "Time_End": 330.28000000000003,
      "Text": " that point."
    },
    {
      "Time_Start": 330.28000000000003,
      "Time_End": 338.68,
      "Text": " Well, this gap has been snubbed back due to multiple reasons, like after the code iterations,"
    },
    {
      "Time_Start": 338.68,
      "Time_End": 343.08000000000004,
      "Text": " so some bug may be silently fixed or become invalid."
    },
    {
      "Time_Start": 343.12,
      "Time_End": 350.35999999999996,
      "Text": " Despite the huge number of unfixed bugs, thousands of them, why we didn't see a clear spike of"
    },
    {
      "Time_Start": 350.35999999999996,
      "Time_End": 358.36,
      "Text": " kernel exploits in the past few years, still only 10 to 20 exploits in the past every year?"
    },
    {
      "Time_Start": 358.36,
      "Time_End": 364.28,
      "Text": " Well, so our current situation is like this picture."
    },
    {
      "Time_Start": 364.28,
      "Time_End": 370.79999999999995,
      "Text": " We have a significant amount of kernel bugs, but we have only so little exploits."
    },
    {
      "Time_Start": 370.8,
      "Time_End": 371.84000000000003,
      "Text": " Why did that happen?"
    },
    {
      "Time_Start": 371.84000000000003,
      "Time_End": 376.24,
      "Text": " To answer this question with confidence, we need to learn some background knowledge of"
    },
    {
      "Time_Start": 376.24,
      "Time_End": 380.64,
      "Text": " fuzzing and of Linux kernel."
    },
    {
      "Time_Start": 380.64,
      "Time_End": 382.56,
      "Text": " The fuzzing pros and cons."
    },
    {
      "Time_Start": 382.56,
      "Time_End": 387.40000000000003,
      "Text": " The syscaller is so efficient, it generates hundreds of valid test cases per second."
    },
    {
      "Time_Start": 387.40000000000003,
      "Time_End": 392.48,
      "Text": " I say valid test cases, that means syscaller knows the many kernel dependencies according"
    },
    {
      "Time_Start": 392.48,
      "Time_End": 394.28000000000003,
      "Text": " to the manual graph database."
    },
    {
      "Time_Start": 394.28000000000003,
      "Time_End": 399.0,
      "Text": " So on the left-hand side, this picture is what we call description."
    },
    {
      "Time_Start": 399.16,
      "Time_End": 403.0,
      "Text": " This describes the kernel dependencies to the syscaller."
    },
    {
      "Time_Start": 403.0,
      "Time_End": 404.72,
      "Text": " The syscaller will understand this."
    },
    {
      "Time_Start": 404.72,
      "Time_End": 411.04,
      "Text": " For example, this simple program, the socket will return a file descriptor, and this file"
    },
    {
      "Time_Start": 411.04,
      "Time_End": 413.88,
      "Text": " descriptor will be used by other system calls."
    },
    {
      "Time_Start": 413.88,
      "Time_End": 417.72,
      "Text": " This is one typical dependency."
    },
    {
      "Time_Start": 417.72,
      "Time_End": 422.24,
      "Text": " Because syscaller knows this dependency, it can generate the valid test case very fast"
    },
    {
      "Time_Start": 422.24,
      "Time_End": 425.32,
      "Text": " and find the bug with efficiency."
    },
    {
      "Time_Start": 425.32,
      "Time_End": 433.44,
      "Text": " For example, in order to find the bug hiding here, deep down in the kernel space, syscaller"
    },
    {
      "Time_Start": 433.44,
      "Time_End": 438.12,
      "Text": " will call different system calls in a sequence, and each system call will make the kernel"
    },
    {
      "Time_Start": 438.12,
      "Time_End": 443.76,
      "Text": " enter a specific state that's a dependency."
    },
    {
      "Time_Start": 443.76,
      "Time_End": 449.92,
      "Text": " So calling system call 1 will enter a kernel state, and calling system call 2, because"
    },
    {
      "Time_Start": 450.48,
      "Time_End": 456.0,
      "Text": " the kernel is set to write state, we can go to state 2, and call the final system call"
    },
    {
      "Time_Start": 456.0,
      "Time_End": 460.64000000000004,
      "Text": " will trigger the bugs."
    },
    {
      "Time_Start": 460.64000000000004,
      "Time_End": 468.08000000000004,
      "Text": " And more importantly, the dynamic approach fuzzing, it generates a concrete test case"
    },
    {
      "Time_Start": 468.08000000000004,
      "Time_End": 469.8,
      "Text": " after finding a bug."
    },
    {
      "Time_Start": 469.8,
      "Time_End": 474.32,
      "Text": " So we will have a concrete POC that can actually trigger the bug."
    },
    {
      "Time_Start": 474.32,
      "Time_End": 480.4,
      "Text": " Neither static analysis or manual auditing can do this job."
    },
    {
      "Time_Start": 480.4,
      "Time_End": 483.96,
      "Text": " So fuzzing is so efficient, but it's blind."
    },
    {
      "Time_Start": 483.96,
      "Time_End": 488.64,
      "Text": " It generates test case based on randomness, which means it does not do any favor of finding"
    },
    {
      "Time_Start": 488.64,
      "Time_End": 490.12,
      "Text": " security bugs."
    },
    {
      "Time_Start": 490.12,
      "Time_End": 496.71999999999997,
      "Text": " Actually, finding bugs is fuzzing all care about, regardless if they are security or"
    },
    {
      "Time_Start": 496.71999999999997,
      "Time_End": 497.96,
      "Text": " not."
    },
    {
      "Time_Start": 497.96,
      "Time_End": 503.2,
      "Text": " And even worse, in order to find more bugs, kernel fuzzers are developed by good privilege,"
    },
    {
      "Time_Start": 503.2,
      "Time_End": 505.71999999999997,
      "Text": " are deployed by root privilege."
    },
    {
      "Time_Start": 505.71999999999997,
      "Time_End": 512.64,
      "Text": " This equips fuzzer with better chance to explore bigger code space in kernel, without worrying"
    },
    {
      "Time_Start": 512.64,
      "Time_End": 515.92,
      "Text": " being rejected by the privilege problem."
    },
    {
      "Time_Start": 515.92,
      "Time_End": 522.4,
      "Text": " However, as security researcher, if a bug has to be root to trigger, we're not interested,"
    },
    {
      "Time_Start": 522.4,
      "Time_End": 525.2,
      "Text": " because they are not exploitable bugs."
    },
    {
      "Time_Start": 525.2,
      "Time_End": 530.48,
      "Text": " They request root, what's the value we exploit them."
    },
    {
      "Time_Start": 530.48,
      "Time_End": 537.88,
      "Text": " But okay, we've been talking to these two major problems about fuzzing, but even with"
    },
    {
      "Time_Start": 537.88,
      "Time_End": 544.52,
      "Text": " all these flaws and problems, C-Spot is still very efficient and still managed to find a"
    },
    {
      "Time_Start": 544.52,
      "Time_End": 547.84,
      "Text": " significant amount of security bugs in the past six years."
    },
    {
      "Time_Start": 547.84,
      "Time_End": 553.8000000000001,
      "Text": " So 24.1% bugs found by C-Spot are memory errors."
    },
    {
      "Time_Start": 553.84,
      "Time_End": 562.5600000000001,
      "Text": " And memory errors like use-after-free or auto-bound and double-free, they are memory errors."
    },
    {
      "Time_Start": 562.5600000000001,
      "Time_End": 568.8000000000001,
      "Text": " And among these memory error bugs, 18.2% are likely exploitable bugs."
    },
    {
      "Time_Start": 568.8000000000001,
      "Time_End": 573.9200000000001,
      "Text": " So we are talking about use-after-free write, auto-bound write, and double-free."
    },
    {
      "Time_Start": 573.9200000000001,
      "Time_End": 579.44,
      "Text": " So they are the most common exploitable bugs that are on the market."
    },
    {
      "Time_Start": 579.6400000000001,
      "Time_End": 583.44,
      "Text": " That gives us 232 likely exploitable bugs."
    },
    {
      "Time_Start": 583.44,
      "Time_End": 592.8000000000001,
      "Text": " Well, that's actually a very big number, considering we only have so little exploits every year."
    },
    {
      "Time_Start": 592.8000000000001,
      "Time_End": 599.44,
      "Text": " And another research, actually my previous research that published in Usenix Security 2022,"
    },
    {
      "Time_Start": 599.44,
      "Time_End": 609.0400000000001,
      "Text": " we assessed the bug capability, and we realized the bug initial capability does not represent"
    },
    {
      "Time_Start": 609.04,
      "Time_End": 611.28,
      "Text": " the most critical capability."
    },
    {
      "Time_Start": 611.28,
      "Time_End": 619.04,
      "Text": " So that means a lot of low-risk bugs, like memory read bugs or warning or other low-risk bugs,"
    },
    {
      "Time_Start": 619.04,
      "Time_End": 621.4,
      "Text": " they can be converted to high-risk bugs."
    },
    {
      "Time_Start": 621.4,
      "Time_End": 624.1999999999999,
      "Text": " So they contain the high-risk capability."
    },
    {
      "Time_Start": 624.1999999999999,
      "Time_End": 629.56,
      "Text": " The number can only be more than 232 bugs that are likely exploitable."
    },
    {
      "Time_Start": 629.56,
      "Time_End": 635.36,
      "Text": " So there are so many likely exploitable bugs, but we still find so little exploits."
    },
    {
      "Time_Start": 635.36,
      "Time_End": 643.96,
      "Text": " So for the bugs that originated from C-SPOT, there are only around seven that I can find on the internet."
    },
    {
      "Time_Start": 643.96,
      "Time_End": 650.76,
      "Text": " Well, there are more kernel exploits, of course, besides originating from C-SPOT,"
    },
    {
      "Time_Start": 650.76,
      "Time_End": 657.16,
      "Text": " but now we're only talking about the one big database, it's the upstream C-SPOT, upstream kernel bugs."
    },
    {
      "Time_Start": 657.16,
      "Time_End": 660.6800000000001,
      "Text": " So there's only around seven, 232 versus seven."
    },
    {
      "Time_Start": 660.6800000000001,
      "Time_End": 662.6800000000001,
      "Text": " That's kind of shocking."
    },
    {
      "Time_Start": 663.6800000000001,
      "Time_End": 674.6800000000001,
      "Text": " Well, another inconspicuous factor contributing to the gap between the bugs and exploits is the structure of the Linux community."
    },
    {
      "Time_Start": 674.6800000000001,
      "Time_End": 678.08,
      "Text": " So Linux has upstream and downstream."
    },
    {
      "Time_Start": 678.08,
      "Time_End": 683.48,
      "Text": " Upstream kernel is where people are developing and debugging, and it's not a daily-use kernel."
    },
    {
      "Time_Start": 683.48,
      "Time_End": 692.08,
      "Text": " But upstream kernel is ideal for bug-finding, and C-SPOT deploys its fuzzer only on upstream kernels."
    },
    {
      "Time_Start": 692.2800000000001,
      "Time_End": 696.48,
      "Text": " So here I mentioned upstream kernels, that includes all the upstream branches,"
    },
    {
      "Time_Start": 696.48,
      "Time_End": 702.6800000000001,
      "Text": " like long-term support branches or Linux Next branches, not just the upstream kernel."
    },
    {
      "Time_Start": 703.6800000000001,
      "Time_End": 707.6800000000001,
      "Text": " However, nobody used upstream kernel in production environment."
    },
    {
      "Time_Start": 707.6800000000001,
      "Time_End": 713.2800000000001,
      "Text": " The stable upstream kernel branches will be pushed to downstream once in a while."
    },
    {
      "Time_Start": 713.2800000000001,
      "Time_End": 719.6800000000001,
      "Text": " So based on those stable upstream branches, the downstream will have different distros,"
    },
    {
      "Time_Start": 719.8800000000001,
      "Time_End": 722.8800000000001,
      "Text": " and we have Ubuntu, Fedora, Debian."
    },
    {
      "Time_Start": 722.8800000000001,
      "Time_End": 726.2800000000001,
      "Text": " Most importantly, they are stable and well-maintained,"
    },
    {
      "Time_Start": 726.2800000000001,
      "Time_End": 734.2800000000001,
      "Text": " so people are using it on a daily basis in their production environment, and that's why it got attacked."
    },
    {
      "Time_Start": 734.2800000000001,
      "Time_End": 739.08,
      "Text": " So nobody attacks the upstream kernel because nobody is using it."
    },
    {
      "Time_Start": 739.08,
      "Time_End": 742.48,
      "Text": " That's why people are always attacking the downstream kernel."
    },
    {
      "Time_Start": 742.48,
      "Time_End": 750.88,
      "Text": " That causes a problem because upstream fuzzer-exposed bugs can trigger a bug on upstream kernel,"
    },
    {
      "Time_Start": 750.88,
      "Time_End": 754.08,
      "Text": " but it may not trigger the bug on downstream kernel."
    },
    {
      "Time_Start": 754.08,
      "Time_End": 758.48,
      "Text": " But this does not mean the downstream kernel is not affected by this bug."
    },
    {
      "Time_Start": 758.48,
      "Time_End": 765.88,
      "Text": " Their triggerability is not equal, but their POC can be adapted to downstream, making it triggerable."
    },
    {
      "Time_Start": 765.88,
      "Time_End": 771.6800000000001,
      "Text": " So we visualize this gap between upstream fuzzer-exposed bugs and kernel exploits."
    },
    {
      "Time_Start": 771.6800000000001,
      "Time_End": 774.2800000000001,
      "Text": " It's not just the imperfection of the bug itself."
    },
    {
      "Time_Start": 774.2800000000001,
      "Time_End": 778.8800000000001,
      "Text": " It's a long-existing gap between the upstream and downstream."
    },
    {
      "Time_Start": 778.8800000000001,
      "Time_End": 789.48,
      "Text": " The major difference in these two kernels causes the asymmetric number of upstream bugs and downstream exploits."
    },
    {
      "Time_Start": 789.48,
      "Time_End": 795.48,
      "Text": " So is it possible to turn more upstream fuzzer-exposed bugs to downstream exploitable bugs?"
    },
    {
      "Time_Start": 795.48,
      "Time_End": 799.6800000000001,
      "Text": " We want more bugs, more exploits, or even like this,"
    },
    {
      "Time_Start": 799.6800000000001,
      "Time_End": 802.48,
      "Text": " we want every upstream bug to be exploitable."
    },
    {
      "Time_Start": 802.48,
      "Time_End": 807.08,
      "Text": " Well, not quite possible, but we can think about it."
    },
    {
      "Time_Start": 807.08,
      "Time_End": 809.08,
      "Text": " So how to make it happen?"
    },
    {
      "Time_Start": 809.08,
      "Time_End": 817.08,
      "Text": " Our first step is to understand how many upstream bugs can actually be reproduced in downstream kernel."
    },
    {
      "Time_Start": 817.08,
      "Time_End": 819.08,
      "Text": " So we have designed an experiment."
    },
    {
      "Time_Start": 819.08,
      "Time_End": 824.8800000000001,
      "Text": " We prepared four downstream distros, Ubuntu, Fedora, Debian, and SUSE."
    },
    {
      "Time_Start": 825.08,
      "Time_End": 829.88,
      "Text": " Next, we gather 50 upstream kernel bugs from six bugs,"
    },
    {
      "Time_Start": 829.88,
      "Time_End": 834.88,
      "Text": " and then we run their POC against all four real-world distros."
    },
    {
      "Time_Start": 834.88,
      "Time_End": 841.88,
      "Text": " And we choose the major release that is close to the bug discovery date."
    },
    {
      "Time_Start": 841.88,
      "Time_End": 849.28,
      "Text": " So which means, for example, if a bug was found in September 2021,"
    },
    {
      "Time_Start": 849.28,
      "Time_End": 853.68,
      "Text": " we will choose, for example, a Ubuntu release that closes to September 2021,"
    },
    {
      "Time_Start": 853.6800000000001,
      "Time_End": 855.6800000000001,
      "Text": " which might be the June release."
    },
    {
      "Time_Start": 855.6800000000001,
      "Time_End": 861.6800000000001,
      "Text": " By doing this, we make sure the bug always reproduces on a vulnerable version,"
    },
    {
      "Time_Start": 861.6800000000001,
      "Time_End": 868.6800000000001,
      "Text": " or the patch will not exist in the prior version because the bug was found afterward."
    },
    {
      "Time_Start": 870.6800000000001,
      "Time_End": 872.6800000000001,
      "Text": " So 50 bugs for four distros."
    },
    {
      "Time_Start": 872.6800000000001,
      "Time_End": 875.6800000000001,
      "Text": " We got 200 bug and distro pairs."
    },
    {
      "Time_Start": 875.6800000000001,
      "Time_End": 878.6800000000001,
      "Text": " We found 120 pairs that failed to trigger the bug"
    },
    {
      "Time_Start": 878.6800000000001,
      "Time_End": 882.6800000000001,
      "Text": " because the distro does not have the bug you can meet."
    },
    {
      "Time_Start": 882.6800000000001,
      "Time_End": 885.6800000000001,
      "Text": " That means the bug was never introduced."
    },
    {
      "Time_Start": 885.6800000000001,
      "Time_End": 890.6800000000001,
      "Text": " For the rest 80 pairs that were vulnerable to the bugs,"
    },
    {
      "Time_Start": 890.6800000000001,
      "Time_End": 896.6800000000001,
      "Text": " we find only 18 of them have successfully triggered the bugs,"
    },
    {
      "Time_Start": 896.6800000000001,
      "Time_End": 899.6800000000001,
      "Text": " but all of them were triggered by root privilege."
    },
    {
      "Time_Start": 899.6800000000001,
      "Time_End": 904.6800000000001,
      "Text": " So none of them are exploitable bugs because they require root privilege."
    },
    {
      "Time_Start": 904.6800000000001,
      "Time_End": 909.6800000000001,
      "Text": " For the remaining 62 bugs that have failed,"
    },
    {
      "Time_Start": 909.6800000000001,
      "Time_End": 912.6800000000001,
      "Text": " we find 41 of them failed due to logic missing."
    },
    {
      "Time_Start": 912.6800000000001,
      "Time_End": 915.6800000000001,
      "Text": " That means the vulnerability code exists in the kernel source code,"
    },
    {
      "Time_Start": 915.6800000000001,
      "Time_End": 919.6800000000001,
      "Text": " but it does not exist in the kernel binary,"
    },
    {
      "Time_Start": 919.6800000000001,
      "Time_End": 921.6800000000001,
      "Text": " most likely because they are not compiled."
    },
    {
      "Time_Start": 921.6800000000001,
      "Time_End": 925.6800000000001,
      "Text": " This is a common case that the downstream distro"
    },
    {
      "Time_Start": 925.6800000000001,
      "Time_End": 928.6800000000001,
      "Text": " will not compile every single upstream kernel module,"
    },
    {
      "Time_Start": 928.6800000000001,
      "Time_End": 931.6800000000001,
      "Text": " even though the bug you can meet exists."
    },
    {
      "Time_Start": 931.6800000000001,
      "Time_End": 936.6800000000001,
      "Text": " But not compiling the kernel into the binary means the same as the no bug you can meet,"
    },
    {
      "Time_Start": 937.6800000000001,
      "Time_End": 942.6800000000001,
      "Text": " is that the distro is not affected by the bug."
    },
    {
      "Time_Start": 942.6800000000001,
      "Time_End": 947.6800000000001,
      "Text": " For the remaining, we find one pair failed due to the code context change."
    },
    {
      "Time_Start": 947.6800000000001,
      "Time_End": 952.6800000000001,
      "Text": " That means the vulnerability logic has been completely rewritten,"
    },
    {
      "Time_Start": 952.6800000000001,
      "Time_End": 955.6800000000001,
      "Text": " and thus the old POC cannot trigger the same bug,"
    },
    {
      "Time_Start": 955.6800000000001,
      "Time_End": 961.6800000000001,
      "Text": " and 20 other pairs have failed due to what we call environment change."
    },
    {
      "Time_Start": 961.6800000000001,
      "Time_End": 966.6800000000001,
      "Text": " The environment change will be the main topic for the following talk."
    },
    {
      "Time_Start": 966.6800000000001,
      "Time_End": 970.6800000000001,
      "Text": " We categorize the failure reason of the environment change."
    },
    {
      "Time_Start": 970.6800000000001,
      "Time_End": 974.6800000000001,
      "Text": " You will see their number adds up to be more than 100%"
    },
    {
      "Time_Start": 974.6800000000001,
      "Time_End": 978.6800000000001,
      "Text": " because one bug could fail due to multiple reasons."
    },
    {
      "Time_Start": 978.6800000000001,
      "Time_End": 983.6800000000001,
      "Text": " The first failure reason of the environment change is what we call preparation failure."
    },
    {
      "Time_Start": 983.6800000000001,
      "Time_End": 988.6800000000001,
      "Text": " One typical example is setting up the USB fuzzing."
    },
    {
      "Time_Start": 988.6800000000001,
      "Time_End": 992.6800000000001,
      "Text": " This caller will try to open a device called rawgadget."
    },
    {
      "Time_Start": 992.6800000000001,
      "Time_End": 995.6800000000001,
      "Text": " This rawgadget device exposes the USB interface,"
    },
    {
      "Time_Start": 995.6800000000001,
      "Time_End": 1001.6800000000001,
      "Text": " so you don't need actual USB hardware to interact with the kernel USB logic."
    },
    {
      "Time_Start": 1001.6800000000001,
      "Time_End": 1007.6800000000001,
      "Text": " Instead, directly interacting with this rawgadget virtual device,"
    },
    {
      "Time_Start": 1007.6800000000001,
      "Time_End": 1011.6800000000001,
      "Text": " it makes testing USB interface possible for the kernel fuzzing."
    },
    {
      "Time_Start": 1011.6800000000001,
      "Time_End": 1013.6800000000001,
      "Text": " However, due to the blindness of kernel fuzzer,"
    },
    {
      "Time_Start": 1013.6800000000001,
      "Time_End": 1017.6800000000001,
      "Text": " it may find a completely irrelevant bug rather than a USB bug."
    },
    {
      "Time_Start": 1017.6800000000001,
      "Time_End": 1021.6800000000001,
      "Text": " While fuzzer doesn't know that, it will still think it's a USB bug"
    },
    {
      "Time_Start": 1021.6800000000001,
      "Time_End": 1025.68,
      "Text": " and it will keep the USB preparation function in the POC."
    },
    {
      "Time_Start": 1025.68,
      "Time_End": 1030.68,
      "Text": " However, the downstream kernel will not have this virtual interface"
    },
    {
      "Time_Start": 1030.68,
      "Time_End": 1036.68,
      "Text": " because you always use actual hardware USB device when you're using Ubuntu."
    },
    {
      "Time_Start": 1036.68,
      "Time_End": 1041.68,
      "Text": " When the POC tried to open this rawgadget device, it failed"
    },
    {
      "Time_Start": 1041.68,
      "Time_End": 1044.68,
      "Text": " because this path does not exist."
    },
    {
      "Time_Start": 1044.68,
      "Time_End": 1048.68,
      "Text": " Oftentimes, if a POC fails, like the preparation has failed,"
    },
    {
      "Time_Start": 1048.68,
      "Time_End": 1051.68,
      "Text": " they will terminate itself and exit."
    },
    {
      "Time_Start": 1051.68,
      "Time_End": 1056.68,
      "Text": " That makes the POC not reaching the core POC function."
    },
    {
      "Time_Start": 1056.68,
      "Time_End": 1060.68,
      "Text": " They will terminate before reaching the POC core function"
    },
    {
      "Time_Start": 1060.68,
      "Time_End": 1063.68,
      "Text": " and make the bug not triggered."
    },
    {
      "Time_Start": 1063.68,
      "Time_End": 1069.68,
      "Text": " Another reason that upstream POC failed is because of the background noise."
    },
    {
      "Time_Start": 1069.68,
      "Time_End": 1075.68,
      "Text": " In upstream kernel, there are only a few background processes running"
    },
    {
      "Time_Start": 1075.68,
      "Time_End": 1078.68,
      "Text": " and the POC process can easily win the data race."
    },
    {
      "Time_Start": 1078.68,
      "Time_End": 1083.68,
      "Text": " If a risk can be found, it can easily win the data race and trigger the bug."
    },
    {
      "Time_Start": 1083.68,
      "Time_End": 1089.68,
      "Text": " However, in downstream, there are much more services running in the background,"
    },
    {
      "Time_Start": 1089.68,
      "Time_End": 1094.68,
      "Text": " so the chance of the POC process can win a data race is much lower"
    },
    {
      "Time_Start": 1095.68,
      "Time_End": 1098.68,
      "Text": " than in the upstream kernel."
    },
    {
      "Time_Start": 1098.68,
      "Time_End": 1106.68,
      "Text": " For example, we have SSH, we have APT, we have some desktop environment processes."
    },
    {
      "Time_Start": 1106.68,
      "Time_End": 1112.68,
      "Text": " If this kind of find, the minimal resource can trigger a bug in upstream,"
    },
    {
      "Time_Start": 1112.68,
      "Time_End": 1116.68,
      "Text": " it will generate the POC, only use that minimal resources."
    },
    {
      "Time_Start": 1116.68,
      "Time_End": 1122.68,
      "Text": " We are talking about the number of CPU cores, number of iterations and processes."
    },
    {
      "Time_Start": 1122.68,
      "Time_End": 1127.68,
      "Text": " Sometimes the upstream can even trigger a risk condition bug with only one attempt."
    },
    {
      "Time_Start": 1127.68,
      "Time_End": 1132.68,
      "Text": " At that point, SysConnect will even not think it's a risk condition,"
    },
    {
      "Time_Start": 1132.68,
      "Time_End": 1137.68,
      "Text": " but think it's just a normal bug and generate POC according to that."
    },
    {
      "Time_Start": 1137.68,
      "Time_End": 1140.68,
      "Text": " And the same POC likely failed on downstream."
    },
    {
      "Time_Start": 1142.68,
      "Time_End": 1148.68,
      "Text": " The third further reason, I always take 50% of the case, is the missing module."
    },
    {
      "Time_Start": 1148.68,
      "Time_End": 1153.68,
      "Text": " For further inconvenience, the kernel modules are always compiled into the kernel binary,"
    },
    {
      "Time_Start": 1153.68,
      "Time_End": 1158.68,
      "Text": " versus downstream distro often compile them as separate loadable modules."
    },
    {
      "Time_Start": 1158.68,
      "Time_End": 1163.68,
      "Text": " Therefore, the upstream kernel have every module ready to use."
    },
    {
      "Time_Start": 1163.68,
      "Time_End": 1171.68,
      "Text": " In this case, a valid case can always successfully interact with the desired module and trigger the bug."
    },
    {
      "Time_Start": 1171.68,
      "Time_End": 1177.68,
      "Text": " However, downstream kernel, choose another way, they compile such module but not load it by default."
    },
    {
      "Time_Start": 1177.68,
      "Time_End": 1180.68,
      "Text": " You have to load it yourself as needed on demand."
    },
    {
      "Time_Start": 1180.68,
      "Time_End": 1188.68,
      "Text": " If the desired module is missing, the kernel will choose either return an error,"
    },
    {
      "Time_Start": 1188.68,
      "Time_End": 1193.68,
      "Text": " or choose a default module to perform the operation."
    },
    {
      "Time_Start": 1193.68,
      "Time_End": 1200.68,
      "Text": " And because it's not doing anything to the vulnerable module, the same POC will fail to trigger the bug."
    },
    {
      "Time_Start": 1201.68,
      "Time_End": 1207.68,
      "Text": " So to overcome these three problems, we came up with three automated solutions."
    },
    {
      "Time_Start": 1209.68,
      "Time_End": 1216.68,
      "Text": " For the preparation failure, we minimized the environment preparation steps to rule out the unnecessary steps."
    },
    {
      "Time_Start": 1216.68,
      "Time_End": 1223.68,
      "Text": " So if a POC can still trigger the bugs in upstream without these preparation steps,"
    },
    {
      "Time_Start": 1223.68,
      "Time_End": 1232.68,
      "Text": " we think they are unnecessary steps, so we will rule out the unnecessary steps to only retain the necessary steps."
    },
    {
      "Time_Start": 1234.68,
      "Time_End": 1242.68,
      "Text": " And after removing the unnecessary preparation function, we can successfully reach the POC core function and trigger the bug."
    },
    {
      "Time_Start": 1243.68,
      "Time_End": 1255.68,
      "Text": " The second solution for the background noise is, well, the upstream kernel is the minimum kernel,"
    },
    {
      "Time_Start": 1255.68,
      "Time_End": 1263.68,
      "Text": " and it has so little services running in the background, and it's very easy to win the data race, as we already know."
    },
    {
      "Time_Start": 1263.68,
      "Time_End": 1268.68,
      "Text": " And here, this is the resources for the data race."
    },
    {
      "Time_Start": 1268.68,
      "Time_End": 1274.68,
      "Text": " So the POC process can easily win the resources and trigger the bug."
    },
    {
      "Time_Start": 1275.68,
      "Time_End": 1278.68,
      "Text": " But the same POC on downstream is very different."
    },
    {
      "Time_Start": 1278.68,
      "Time_End": 1282.68,
      "Text": " There's more processes competing the same resources,"
    },
    {
      "Time_Start": 1282.68,
      "Time_End": 1290.68,
      "Text": " so you will often find the POC function fail to win the data race with other processes."
    },
    {
      "Time_Start": 1290.68,
      "Time_End": 1294.68,
      "Text": " So our solution is we force the data collision."
    },
    {
      "Time_Start": 1294.68,
      "Time_End": 1301.68,
      "Text": " That means more CPU cores and infinite for loop and longer execution time."
    },
    {
      "Time_Start": 1301.68,
      "Time_End": 1307.68,
      "Text": " By doing that, you will find your POC process eventually win the data race and trigger the bug."
    },
    {
      "Time_Start": 1310.68,
      "Time_End": 1314.68,
      "Text": " Okay, for the third problem, the missing module."
    },
    {
      "Time_Start": 1314.68,
      "Time_End": 1322.68,
      "Text": " To find the missing module, we use ftrace to extract the execution trace from both upstream and downstream."
    },
    {
      "Time_Start": 1322.68,
      "Time_End": 1327.68,
      "Text": " Then we compare the execution trace to find the deviation point."
    },
    {
      "Time_Start": 1327.68,
      "Time_End": 1335.68,
      "Text": " In this example, we notice the deviation point start at node 3, where the upstream called xfrm since they notify,"
    },
    {
      "Time_Start": 1335.68,
      "Time_End": 1339.68,
      "Text": " while the ubuntu called another function."
    },
    {
      "Time_Start": 1339.68,
      "Time_End": 1342.68,
      "Text": " This caused the ubuntu fail to trigger the bug."
    },
    {
      "Time_Start": 1342.68,
      "Time_End": 1350.68,
      "Text": " But in order to trigger the bug in ubuntu, we need to first load the xfrm user module."
    },
    {
      "Time_Start": 1350.68,
      "Time_End": 1355.68,
      "Text": " Well, this module already compiled in the upstream kernel, so only ubuntu need to load this module."
    },
    {
      "Time_Start": 1355.68,
      "Time_End": 1359.68,
      "Text": " And a common way to load module is through mode probe."
    },
    {
      "Time_Start": 1359.68,
      "Time_End": 1366.68,
      "Text": " And that is the privileged operation, which means you have to be root user to load the module through mode probe."
    },
    {
      "Time_Start": 1366.68,
      "Time_End": 1372.68,
      "Text": " But we find a way to load this module by unprivileged user, which we will talk about later."
    },
    {
      "Time_Start": 1374.68,
      "Time_End": 1381.68,
      "Text": " If you still remember, all these previously triggered bugs were all triggered by root user."
    },
    {
      "Time_Start": 1381.68,
      "Time_End": 1386.68,
      "Text": " So we are thinking, is there a way to make them triggerable by unprivileged user?"
    },
    {
      "Time_Start": 1387.68,
      "Time_End": 1390.68,
      "Text": " There are several privileged checks."
    },
    {
      "Time_Start": 1390.68,
      "Time_End": 1394.68,
      "Text": " One is the capability check is well known."
    },
    {
      "Time_Start": 1394.68,
      "Time_End": 1399.68,
      "Text": " And the privileged downgrade technique is also well known."
    },
    {
      "Time_Start": 1399.68,
      "Time_End": 1404.68,
      "Text": " So kernel uses this capability to provide fine-grained control over the large code space."
    },
    {
      "Time_Start": 1404.68,
      "Time_End": 1409.68,
      "Text": " The low-level kernel function ns cable common checks the process capability."
    },
    {
      "Time_Start": 1409.68,
      "Time_End": 1414.68,
      "Text": " So the ns is the namespace, and the cap is the capability."
    },
    {
      "Time_Start": 1414.68,
      "Time_End": 1424.68,
      "Text": " For example, this code snippet checks if the current process namespace has the capability cap net admin."
    },
    {
      "Time_Start": 1424.68,
      "Time_End": 1435.68,
      "Text": " Luckily, this capability can be granted in user namespace by unprivileged user when the unprivileged user ns clone is set to 1."
    },
    {
      "Time_Start": 1435.68,
      "Time_End": 1442.68,
      "Text": " But most distros, like 1, 2, Fedora, Debian, Suse, they all allow unprivileged user namespace."
    },
    {
      "Time_Start": 1442.68,
      "Time_End": 1449.68,
      "Text": " So this is doable. It can be granted by normal unprivileged user."
    },
    {
      "Time_Start": 1449.68,
      "Time_End": 1453.68,
      "Text": " However, not every capability can be granted by user namespace."
    },
    {
      "Time_Start": 1453.68,
      "Time_End": 1464.68,
      "Text": " If a capability checks the initial namespace instead of the user namespace, a normal user cannot get such capability."
    },
    {
      "Time_Start": 1464.68,
      "Time_End": 1466.68,
      "Text": " Only a real root user can do that."
    },
    {
      "Time_Start": 1466.68,
      "Time_End": 1475.68,
      "Text": " So we monitor this low-level kernel function to know if POC requires a real root capability or user namespace capability."
    },
    {
      "Time_Start": 1475.68,
      "Time_End": 1480.68,
      "Text": " If it only requires a user namespace capability, we will grant them to the POC."
    },
    {
      "Time_Start": 1480.68,
      "Time_End": 1484.68,
      "Text": " Another privileged requirement is the module loading."
    },
    {
      "Time_Start": 1484.68,
      "Time_End": 1488.68,
      "Text": " As mentioned earlier, the universal way to load a module is through mode probe."
    },
    {
      "Time_Start": 1488.68,
      "Time_End": 1492.68,
      "Text": " Mode probe invokes the system called initial module."
    },
    {
      "Time_Start": 1492.68,
      "Time_End": 1501.68,
      "Text": " And the initial module checks whether the process has the cap system module capability."
    },
    {
      "Time_Start": 1501.68,
      "Time_End": 1507.68,
      "Text": " Unfortunately, this capability, this function checks the initial namespace."
    },
    {
      "Time_Start": 1507.68,
      "Time_End": 1515.68,
      "Text": " That means only root user can call mode probe and unprivileged user cannot have such capability."
    },
    {
      "Time_Start": 1515.68,
      "Time_End": 1521.68,
      "Text": " That's why the mode probe can only be run by root privilege."
    },
    {
      "Time_Start": 1522.68,
      "Time_End": 1529.68,
      "Text": " But we find another interesting kernel function called request module."
    },
    {
      "Time_Start": 1529.68,
      "Time_End": 1535.68,
      "Text": " And we find plenty of request module call sites across the whole Linux kernel."
    },
    {
      "Time_Start": 1535.68,
      "Time_End": 1545.68,
      "Text": " And some of these call sites even have a format string to pass the module, to pass the minor number to the actual module name."
    },
    {
      "Time_Start": 1545.68,
      "Time_End": 1550.68,
      "Text": " So you will see there are different number indicates different network modules."
    },
    {
      "Time_Start": 1550.68,
      "Time_End": 1557.68,
      "Text": " So one request module call site can load multiple module."
    },
    {
      "Time_Start": 1557.68,
      "Time_End": 1561.68,
      "Text": " To understand how request module load a module, we look at the source code."
    },
    {
      "Time_Start": 1561.68,
      "Time_End": 1566.68,
      "Text": " And we find it first get the mode probe user space pass."
    },
    {
      "Time_Start": 1566.68,
      "Time_End": 1571.68,
      "Text": " And then they get the final module name from the format string."
    },
    {
      "Time_Start": 1571.68,
      "Time_End": 1575.68,
      "Text": " And the module name will be passed to the call mode probe function."
    },
    {
      "Time_Start": 1575.68,
      "Time_End": 1578.68,
      "Text": " Well, from that name, you already guess what this function does."
    },
    {
      "Time_Start": 1578.68,
      "Time_End": 1581.68,
      "Text": " The call module name will prepare the arguments."
    },
    {
      "Time_Start": 1581.68,
      "Time_End": 1584.68,
      "Text": " The first argument is the pass."
    },
    {
      "Time_Start": 1584.68,
      "Time_End": 1587.68,
      "Text": " And then we have the module name over here."
    },
    {
      "Time_Start": 1587.68,
      "Time_End": 1591.68,
      "Text": " And then they do an op call to user space."
    },
    {
      "Time_Start": 1591.68,
      "Time_End": 1597.68,
      "Text": " So this op call will, interestingly, this op call will be executed as root."
    },
    {
      "Time_Start": 1597.68,
      "Time_End": 1600.68,
      "Text": " They will call the mode probe by root user."
    },
    {
      "Time_Start": 1600.68,
      "Time_End": 1604.68,
      "Text": " So we have a new concept of how to load a module."
    },
    {
      "Time_Start": 1605.68,
      "Time_End": 1613.68,
      "Text": " An unprivileged user somehow call a request module kernel function through some system calls."
    },
    {
      "Time_Start": 1613.68,
      "Time_End": 1618.68,
      "Text": " And this function proceeds an op call to user space and root user."
    },
    {
      "Time_Start": 1618.68,
      "Time_End": 1623.68,
      "Text": " This root user executes the mode probe to load the dedicated kernel module for us."
    },
    {
      "Time_Start": 1623.68,
      "Time_End": 1627.68,
      "Text": " So we are actually asking a root user to load module for us."
    },
    {
      "Time_Start": 1627.68,
      "Time_End": 1629.68,
      "Text": " Like very cool. That's very cool."
    },
    {
      "Time_Start": 1629.68,
      "Time_End": 1636.68,
      "Text": " So instead of calling mode probe XFRM user to load a module, which requires root privilege, by the way,"
    },
    {
      "Time_Start": 1636.68,
      "Time_End": 1642.68,
      "Text": " we can simply call this system call with unprivileged user."
    },
    {
      "Time_Start": 1642.68,
      "Time_End": 1645.68,
      "Text": " So that makes our unprivileged user very happy, you can see."
    },
    {
      "Time_Start": 1645.68,
      "Time_End": 1649.68,
      "Text": " And that's just one example."
    },
    {
      "Time_Start": 1649.68,
      "Time_End": 1658.68,
      "Text": " But we want to know how many, like what is the module that can be loaded by unprivileged user"
    },
    {
      "Time_Start": 1658.68,
      "Time_End": 1660.68,
      "Text": " and what module cannot."
    },
    {
      "Time_Start": 1660.68,
      "Time_End": 1669.68,
      "Text": " By simply searching the request module, we find there is 249 call sites across the kernel source code."
    },
    {
      "Time_Start": 1669.68,
      "Time_End": 1671.68,
      "Text": " And a lot of them, they are format string."
    },
    {
      "Time_Start": 1671.68,
      "Time_End": 1675.68,
      "Text": " That means one call site can load multiple kernel modules."
    },
    {
      "Time_Start": 1675.68,
      "Time_End": 1680.68,
      "Text": " So we're thinking, well, is there a possible we can load arbitrary module,"
    },
    {
      "Time_Start": 1680.68,
      "Time_End": 1685.68,
      "Text": " like we get a module name directly from user space"
    },
    {
      "Time_Start": 1685.68,
      "Time_End": 1688.68,
      "Text": " and we pass this argument directly to the request module."
    },
    {
      "Time_Start": 1688.68,
      "Time_End": 1691.68,
      "Text": " By doing that, we can load arbitrary modules."
    },
    {
      "Time_Start": 1691.68,
      "Time_End": 1696.68,
      "Text": " So we don't need root privilege to load even like very critical module."
    },
    {
      "Time_Start": 1696.68,
      "Time_End": 1700.68,
      "Text": " But the kernel developer found that stupid."
    },
    {
      "Time_Start": 1700.68,
      "Time_End": 1702.68,
      "Text": " So we couldn't do that."
    },
    {
      "Time_Start": 1702.68,
      "Time_End": 1704.68,
      "Text": " We didn't find anything like that."
    },
    {
      "Time_Start": 1704.68,
      "Time_End": 1713.68,
      "Text": " So we have to collect or categorize every single request module site and their loadable module."
    },
    {
      "Time_Start": 1714.68,
      "Time_End": 1720.68,
      "Text": " But this problem is very exhausting, but by the nature of the problem,"
    },
    {
      "Time_Start": 1720.68,
      "Time_End": 1725.68,
      "Text": " that makes us thinking about the only effective approach, which is fuzzing."
    },
    {
      "Time_Start": 1725.68,
      "Time_End": 1729.68,
      "Text": " Although we have been talking down about fuzzing all along,"
    },
    {
      "Time_Start": 1729.68,
      "Time_End": 1738.68,
      "Text": " but nothing can do the same job as providing concrete test case and invoking kernel call sites,"
    },
    {
      "Time_Start": 1738.68,
      "Time_End": 1739.68,
      "Text": " only fuzzing can do that."
    },
    {
      "Time_Start": 1739.68,
      "Time_End": 1742.68,
      "Text": " So we build our customized request module fuzzer."
    },
    {
      "Time_Start": 1742.68,
      "Time_End": 1746.68,
      "Text": " We intentionally instrument the request module function to notify the fuzzer"
    },
    {
      "Time_Start": 1746.68,
      "Time_End": 1754.68,
      "Text": " and we reproduce the results by unprivileged user to make sure that the normal user can load such module."
    },
    {
      "Time_Start": 1754.68,
      "Time_End": 1757.68,
      "Text": " Our fuzzing results turn out to be very good."
    },
    {
      "Time_Start": 1757.68,
      "Time_End": 1764.68,
      "Text": " We find hundreds of normal user loadable modules across all four distros."
    },
    {
      "Time_Start": 1764.68,
      "Time_End": 1770.68,
      "Text": " The number has the network has the most module."
    },
    {
      "Time_Start": 1770.68,
      "Time_End": 1775.68,
      "Text": " Well, this is a sample of the modules and that's not all of them."
    },
    {
      "Time_Start": 1775.68,
      "Time_End": 1781.68,
      "Text": " And next is the crypto."
    },
    {
      "Time_Start": 1781.68,
      "Time_End": 1784.68,
      "Text": " And then we have file system."
    },
    {
      "Time_Start": 1784.68,
      "Time_End": 1792.68,
      "Text": " Please note that loading a file system module by normal user does not essentially mean you can mount the file system by normal user."
    },
    {
      "Time_Start": 1792.68,
      "Time_End": 1797.68,
      "Text": " So mounting is another privilege operation that only a few file system can be mounted by normal user,"
    },
    {
      "Time_Start": 1797.68,
      "Time_End": 1802.68,
      "Text": " like fuse or overlay FS."
    },
    {
      "Time_Start": 1802.68,
      "Time_End": 1805.68,
      "Text": " And it's time to do some number crunching."
    },
    {
      "Time_Start": 1805.68,
      "Time_End": 1816.68,
      "Text": " We prepare 282 likely exploitable blocks that contain at least one of the following high-risk primitive used after free write,"
    },
    {
      "Time_Start": 1816.68,
      "Time_End": 1824.68,
      "Text": " out-of-bound write, double free, counterflow hijacking, arbitrary address write and constrained address write,"
    },
    {
      "Time_Start": 1824.68,
      "Time_End": 1827.68,
      "Text": " arbitrary value write and constrained value write."
    },
    {
      "Time_Start": 1827.68,
      "Time_End": 1834.68,
      "Text": " So they are all high-risk capability and make the bug to be likely exploitable bugs."
    },
    {
      "Time_Start": 1834.68,
      "Time_End": 1839.68,
      "Text": " So without any adaptation by running the original POC as root privilege,"
    },
    {
      "Time_Start": 1839.68,
      "Time_End": 1844.68,
      "Text": " we want to see how many bugs can be triggered on the downstream kernel."
    },
    {
      "Time_Start": 1844.68,
      "Time_End": 1848.68,
      "Text": " On average, 44 out of 282 can be triggered."
    },
    {
      "Time_Start": 1848.68,
      "Time_End": 1850.68,
      "Text": " And that's 15.6 percent."
    },
    {
      "Time_Start": 1850.68,
      "Time_End": 1857.68,
      "Text": " Ubuntu 54, Fedora 48, Debian 47, Suse 27."
    },
    {
      "Time_Start": 1857.68,
      "Time_End": 1864.68,
      "Text": " Then we applied our automated adaptation to all the 282 POCs."
    },
    {
      "Time_Start": 1864.68,
      "Time_End": 1867.68,
      "Text": " And we increased the number by a lot."
    },
    {
      "Time_Start": 1867.68,
      "Time_End": 1871.68,
      "Text": " And now, by average, we have 73 out of 282 bugs."
    },
    {
      "Time_Start": 1871.68,
      "Time_End": 1874.68,
      "Text": " That's 25.8 percent."
    },
    {
      "Time_Start": 1874.68,
      "Time_End": 1883.68,
      "Text": " We improved the result on average 65.9 more."
    },
    {
      "Time_Start": 1883.68,
      "Time_End": 1887.68,
      "Text": " We do the triggerability test by root privilege."
    },
    {
      "Time_Start": 1887.68,
      "Time_End": 1894.68,
      "Text": " But because they are likely exploitable bugs, we want to know how many of them are actually likely exploitable on downstream."
    },
    {
      "Time_Start": 1894.68,
      "Time_End": 1900.68,
      "Text": " So we have to run the POC again by normal user, by unprivileged user."
    },
    {
      "Time_Start": 1900.68,
      "Time_End": 1905.68,
      "Text": " So now we do it again by running them with unprivileged user."
    },
    {
      "Time_Start": 1905.68,
      "Time_End": 1907.68,
      "Text": " The result is very bad."
    },
    {
      "Time_Start": 1907.68,
      "Time_End": 1911.68,
      "Text": " Only 1331 bugs can be triggered on Ubuntu, Fedora, Debian, Suse."
    },
    {
      "Time_Start": 1911.68,
      "Time_End": 1914.68,
      "Text": " That's on average 0.7 percent."
    },
    {
      "Time_Start": 1914.68,
      "Time_End": 1924.68,
      "Text": " Well, we have this question why there's so little exploitable bugs on so many bug databases, so big bug databases."
    },
    {
      "Time_Start": 1924.68,
      "Time_End": 1931.68,
      "Text": " This result somehow proves that's why there's so little sysbug bugs were turned into real world exploits."
    },
    {
      "Time_Start": 1931.68,
      "Time_End": 1940.68,
      "Text": " However, after applying our privileged adaptation, we dramatically increased the number of normal user triggerable bugs."
    },
    {
      "Time_Start": 1940.68,
      "Time_End": 1951.68,
      "Text": " So for Ubuntu, we increased the number from 1 to 35, Fedora from 3 to 50, Debian from 3 to 31, and Suse from 1 to 9."
    },
    {
      "Time_Start": 1951.68,
      "Time_End": 1958.68,
      "Text": " Well, on average, 31 out of 282 bugs, that's 25.8 percent."
    },
    {
      "Time_Start": 1958.68,
      "Time_End": 1962.68,
      "Text": " We improved the results by 14 times."
    },
    {
      "Time_Start": 1962.68,
      "Time_End": 1966.68,
      "Text": " Note that these bugs are all likely exploitable bugs."
    },
    {
      "Time_Start": 1966.68,
      "Time_End": 1971.68,
      "Text": " Comparing the past, there's only 7 bugs were turned into real world exploits."
    },
    {
      "Time_Start": 1971.68,
      "Time_End": 1974.68,
      "Text": " The bugs from sysbug, only 7."
    },
    {
      "Time_Start": 1975.68,
      "Time_End": 1983.68,
      "Text": " To prove the effectiveness of our tool, we picked one unfixed bug at a time for our results."
    },
    {
      "Time_Start": 1983.68,
      "Time_End": 1990.68,
      "Text": " And we successfully developed n to n exploits to escalate the local privilege on the latest Ubuntu."
    },
    {
      "Time_Start": 1990.68,
      "Time_End": 1996.68,
      "Text": " And we plan to use that exploit, participate in the Pontoon event here."
    },
    {
      "Time_Start": 1996.68,
      "Time_End": 2001.68,
      "Text": " But unfortunately, the bug was tragically fixed one month before Pontoon."
    },
    {
      "Time_Start": 2001.68,
      "Time_End": 2011.68,
      "Text": " Well, so we didn't get a chance to participate, but at least the exploits proves the effectiveness of our adaptation method."
    },
    {
      "Time_Start": 2011.68,
      "Time_End": 2016.68,
      "Text": " So here are three case studies that we find interesting."
    },
    {
      "Time_Start": 2016.68,
      "Time_End": 2024.68,
      "Text": " Well, their original POC cannot trigger the bugs on any downstream."
    },
    {
      "Time_Start": 2025.68,
      "Time_End": 2028.68,
      "Text": " Bug 1 requires additional module."
    },
    {
      "Time_Start": 2028.68,
      "Time_End": 2038.68,
      "Text": " Except if I'm a user, we talk multiple times, you can use this simple system call to load such module and then you can trigger the bug."
    },
    {
      "Time_Start": 2038.68,
      "Time_End": 2042.68,
      "Text": " The bug 2 requires RDMA UCM module."
    },
    {
      "Time_Start": 2042.68,
      "Time_End": 2045.68,
      "Text": " Loading this module is a bit complicated."
    },
    {
      "Time_Start": 2045.68,
      "Time_End": 2049.6800000000003,
      "Text": " You need two system calls and a well-prepared data structure."
    },
    {
      "Time_Start": 2049.68,
      "Time_End": 2054.68,
      "Text": " After you run this program to load the module, you can trigger the bug."
    },
    {
      "Time_Start": 2054.68,
      "Time_End": 2057.68,
      "Text": " Well, bug 3 is even more complicated."
    },
    {
      "Time_Start": 2057.68,
      "Time_End": 2062.68,
      "Text": " It loads IPv6 tables, which require a sophisticated data structure."
    },
    {
      "Time_Start": 2062.68,
      "Time_End": 2068.68,
      "Text": " And this module uses alias in the request module, not the IPv6 table name."
    },
    {
      "Time_Start": 2068.68,
      "Time_End": 2070.68,
      "Text": " This alias is ICMP6."
    },
    {
      "Time_Start": 2070.68,
      "Time_End": 2078.68,
      "Text": " You have to use that alias, but our father managed to find a concrete POC to load that module."
    },
    {
      "Time_Start": 2078.68,
      "Time_End": 2083.68,
      "Text": " And after loading that module, we can trigger the bug."
    },
    {
      "Time_Start": 2083.68,
      "Time_End": 2091.68,
      "Text": " So the key takeaway from this talk, upstream and downstream have different environments."
    },
    {
      "Time_Start": 2091.68,
      "Time_End": 2095.68,
      "Text": " And fuzzing is efficient on upstream kernel."
    },
    {
      "Time_Start": 2095.68,
      "Time_End": 2099.68,
      "Text": " And fuzzing neglects the privilege and environment factors."
    },
    {
      "Time_Start": 2099.68,
      "Time_End": 2104.68,
      "Text": " And the fuzzer-generated POC often failed on real-world OS."
    },
    {
      "Time_Start": 2104.68,
      "Time_End": 2107.68,
      "Text": " But real-world OS may still be affected."
    },
    {
      "Time_Start": 2107.68,
      "Time_End": 2109.68,
      "Text": " And don't give up."
    },
    {
      "Time_Start": 2109.68,
      "Time_End": 2112.68,
      "Text": " Remove unnecessary preparation steps."
    },
    {
      "Time_Start": 2112.68,
      "Time_End": 2115.68,
      "Text": " And allocate more resources to the POC."
    },
    {
      "Time_Start": 2115.68,
      "Time_End": 2118.68,
      "Text": " Finding missing kernel modules."
    },
    {
      "Time_Start": 2118.68,
      "Time_End": 2121.68,
      "Text": " And the privilege requirement can be downgraded."
    },
    {
      "Time_Start": 2121.68,
      "Time_End": 2126.68,
      "Text": " Check whether the namespace can bypass the capability."
    },
    {
      "Time_Start": 2126.68,
      "Time_End": 2132.68,
      "Text": " And if there's any missing modules, check whether they can be loaded by unprivileged users."
    },
    {
      "Time_Start": 2132.68,
      "Time_End": 2138.68,
      "Text": " Because the unprivileged user is capable of loading hundreds of kernel modules."
    },
    {
      "Time_Start": 2138.68,
      "Time_End": 2141.68,
      "Text": " I think that's everything about my talk."
    },
    {
      "Time_Start": 2141.68,
      "Time_End": 2144.68,
      "Text": " And you can access my portfolio by scanning this QR code."
    },
    {
      "Time_Start": 2144.68,
      "Time_End": 2146.68,
      "Text": " I also have my CV."
    },
    {
      "Time_Start": 2146.68,
      "Time_End": 2148.68,
      "Text": " Also, I'm in the job market in 2025."
    },
    {
      "Time_Start": 2148.68,
      "Time_End": 2150.68,
      "Text": " I will be graduating soon."
    },
    {
      "Time_Start": 2150.68,
      "Time_End": 2153.68,
      "Text": " I'm looking for a security-related job."
    },
    {
      "Time_Start": 2153.68,
      "Time_End": 2157.68,
      "Text": " Well, I think I'll have a live Q&A somewhere here."
    },
    {
      "Time_Start": 2157.68,
      "Time_End": 2161.68,
      "Text": " I'm ready to take questions."
    }
  ]
}