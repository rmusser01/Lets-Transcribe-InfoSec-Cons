{
  "webpage_url": "https://www.youtube.com/watch?v=pTU6O3iua0k",
  "title": "Off-By-One 2024 Day 1- Unlocking Automotive Secrets Strategies & Tool for accessing hidden services",
  "description": "Abstract\n\nDuring car hacking, the first consideration typically revolves around the manufacturer or Tier 1 provider\u2019s hidden services. This spans from common engineer mode applications to deeply concealed mechanisms. However, due to regulatory requirements and increased manufacturer security awareness, high-level privilege hidden services have dramatically decreased. Through analyzing dozens of Intelligent Connected Vehicles, we\u2019ve discovered new tactics for managing hidden services.\n\nIn this talk, we\u2019ll demonstrate multiple methods to access hidden functions and thoroughly analyze underlying theories which involving both traditional and new era approaches. Once we understand the background mechanisms, we attempted to bypass security protections and share our journey, including some bypass skills. Such as use Fipper Zero crack the engineer mode pincode. Upon gaining access to hidden services, we\u2019ll show how to leverage these functions to attain root privileges, execute lateral movement to other Electronic Control Units (ECUs), and gain control of the vehicle.\n\nLastly, I\u2019ll introduce a self-developed graphical hacking tool designed to reveal hidden services. This tool extracts information from firmware and automatically generates a graphical representation of the hidden services relationships. By using this tool, we\u2019ve successfully identified entry paths for many vehicles, including deeply hidden ones.\n\nSpeaker\nPeng Fan (@delikely) is a Security Researcher and Tech Lead working at QAX STARV Lab, focusing on the automotive security. He has received CVEs from Tesla/Cybellum/Bender/etc. Hall of fame of GeekPwn( 2021-2022). Member of the Automobile Safety Research Organization - Qing Ji.The earliest automotive cybersecurity community in China, operating a WeChat Official accounts, has released a panorama of automotive security. Maintainer of Automotive Security Timeline.",
  "channel_url": "https://www.youtube.com/channel/UCmrsIbKdxEMBEefD8v8RigQ",
  "duration": 2548,
  "channel": "Off-By-One Comms Team",
  "uploader": "Off-By-One Comms Team",
  "upload_date": "20240831"
}

This text was transcribed using whisper model: large-v2

 Hello everyone, my name is Fan Peng from Tianjin's WeSecure Label.  Today I will...  Hello everyone.  My topic is Unlock the Motive Security, Security and Tools for Accessing Hacking Services.  Today I want to discuss hacking services.  What are hacking services?  What are the prerequisites for accessing?  And how to unlock them?  One can use dozens of ECUs.  In the case of country units, the services in the car are like asparagus.  We can only sell a small part of the income used.  Front-end services, which we are able to access the tip of the asparagus.  As a coupler, we can only access all of you, such as the entertainment system,  use a dash camera to record and view road conditions while driving.  We use driver information from the InstaCluster and use ADAS to access us while driving.  Thus, there are still some services reserved for maintainers or debuggers.  It's hard to load internet services to a normal user.  Much more hidden services are under the ice bridge.  Like a framework or operating system and all that.  IPC in ECU, RPC in ECU and RPC between ECUs.  Not only the traditional process system,  there are some complex car frameworks like AutoSAR.  AutoSAR is to correct and explain open and standard software achievements for automotive ECUs.  AutoSAR-AP for the process system.  AutoSAR-CP for simple microcontainer units.  AutoSAR only defends the standards and doesn't implement them.  The software supplier implements them by themselves.  There are many hidden services inside that that are worth to explore and do some deep research.  Here are three entrances to access these hidden services.  The first one is a disk environment to enjoy the best head units.  The car service is the main entrance.  For Linux-based head units, we will use the VLAN while the disk environment.  Some other uses are Qt, Twilio and QSCS.  The second one is a Spark interface.  For Android, we will use ADB.  For the process system, we will use SSH.  The QSCS is usually used for the instructor cluster or ADAS.  We usually use Qualcomm to debug.  The second one is a hardware interface, such as UART,  which is usually used for the SoC.  The GTAC is used for the MSU.  The ODB is used for the home card.  The intelligence context has a huge screen,  which serves as the main entrance point for user interaction.  Each cluster manufacturer has its own human interface, called IVI.  Some IVIs are based on Linux, some are based on QSCS.  But most are based on Android.  Android launches allow car makers to customize their home screen,  start new applications, make a home call, and perform other tasks on Android devices.  This custom essential context look and feel of the home screen and app journals  provide users with a tailored experience.  However, there are simplified differences in customer limited.  Each orange equipment manufacturer builds its own launcher.  With that, in a unique user interface,  one major difference is that the standard setting app is not displayed on the launcher.  Instead, there is a specific setting.  The setting includes a function for setting up a list of workers  who use system information and upgrade the firmware.  However, its unique search capability only allows the user to use the extension function.  Typically, the developer mode can't be enabled by the user.  Here is a car maker using the launcher's source code lead framework.  They have a big difference with each other.  They are based on Android launchers from the first generation to the third generation.  And some car makers built by them own some limited car launchers.  Unlike mobile launchers, some car launchers don't display the third-party placing on the desktop  such as the application named Joy2.  On the left side, we can see in the launcher's desktop.  But on the right, we can't get it.  Some systems built in AP are hidden from the launcher.  What happened?  I tried to figure it out.  I compared two applications.  The left one is the display on the launcher.  The right one is hidden from the launcher.  We found that in the Android manifesto, there is an interface category.  If the category is a launcher, it will show on the top-level launcher.  Without this category, it will be hidden.  I tried to build an app.  There are two activities.  The first one is the main activity.  The second is the third activity.  After we compared and installed into the car head unit,  there are two icons displayed on the launcher.  An application can display multiple icons on the launcher.  When an activity has a large category, it will display an icon on the launcher.  If no activity on an application has a large category, it will be hidden from the desktop.  We analyzed the Android launcher.  In the Apple filters, we can see an error.  Filter components.  This error defines the error.  If the package name is in this list, it will be hidden from the desktop.  But car makers almost never use this way.  They often use their own way to hide the apps.  They maintain their own whitelist.  This whitelist contains four lists of applications.  This will show on the launcher.  Sometimes, Apple applications are flawed again.  For example, this Apple engine mode.  If the package name is in this filter, it will be filtered.  Sometimes, we can make hidden apps appear on the launcher using system build functions.  For example, we found a hidden page such as developer switch.  When we click here, we are setting the Android launcher developer to true.  We can enable hidden apps to be visible on the launcher.  The function handleValueChanger is nested to the setting.  It can add more hidden pages to add desktop applications.  When we click more apps, we will have the ability to access the hidden apps.  Is there any way to see the hidden apps?  We can use our current launcher that doesn't fit any apps.  By now, we can access system downloads, web user tests, the launcher, or the native settings.  And other hidden apps with the default icon.  To access more hidden services, the first step is to break down the launcher and get free access to any service.  After all the steps are done, I have concluded that there are 18 methods to unlock hidden services.  Unlock hidden services based on the generation in a spare place, like MoneyClick or Lampress.  Some use password protection.  In the next session, we will discuss how to break it down.  The third method is a direct code.  This is another type of password protection.  The next one is voice control.  This is a new type of entrance.  The next one is to use USB over Diagnostic for command use.  The last one is to use Manicurist to call the apps.  Click is defined by MotionEvent.  MotionEvent describes motion in terms of action code and set of action values.  The action code specifies the state changes that occur, such as a pointer going down or up.  The pointer values viral position and other movement properties.  Press is acting down, release is acting up.  Lampress on the software is an example.  It will check the current time to test if the time less than 2 seconds will reset.  If bigger than 2 seconds, it will enable the hidden service.  As we know, Android can click on Lampress to open the developer mode.  Here, it defines the MDU headcount.  Initial value is 3.  Once we click, this value will decrease.  When it is equal to 0, we will show the developer mode enabled.  Sometimes, the click release is special.  We need to find the errors.  Use X and Y if 0 to 18.  X and Y if 0 to 18.  It is easy to find.  It is simple.  Red color.  Now, this color.  As we know, Android uses a series of panic codes.  There are 6 panic codes to show MEI.  Similarly, OEM or other vendors use Android-safe code to create hidden service.  Like this.  With this interface action, Android provides telephone security code.  To create code, we can use the direct app input panic code to call this.  They can get the URI from the intent, then check if it matches the defined URI.  Provide the Android-safe code to start the hidden service.  This is to start the hidden service.  However, some don't use Android-safe code URI.  Instead, use getTextString to check if it matches the defined code.  In the application Bluetooth, we can check the string between getString value to a predefined value.  We can look at this.  If the TLAG code equals to equal to 46, we will start the password activity.  Otherwise, enable the ODB activity.  There are 4 ways to use Android-safe code.  First is DARP.  Use this URI of Tails to open this hidden service.  Another way is to use DeepLink.  It has a different schema.  This uses Android-safe code.  If you have any VHL access, use M to open the hidden service.  Use Action, AndroidActionView, and UserData as DeepLink's URI.  The last one is to use BroadRaw or WebView to access.  I will discuss this in detail in the next section.  How to scan this code or other code?  We can use some open-source applications, such as SecretCode.  It allows us to scan the secret code available on the device through the DARP app.  But in some situations, the car doesn't allow to install any other apps.  We can use the register to get the secret code without the need to install the app.  Nowadays, WAZE is used more frequently in various services,  such as Control Air Conditioning or Open Windows.  Surprisingly, we just speak to the WAZE assessment  and open a head page in ASP.Adapter.  It will check the WAZE command, engineer mode, and open the engineer application.  Currently, it uses keywords to match with the use of GPT to enhance human interface capability in car WAZE assessment.  There is a similar risk to proposing a tag, which can influence unsafe operations.  The next one is to use USB to open the head service.  Maintenance engineers use commercial USB keys without the physical USB keys.  Others can access cars in their system.  However, if a key is lost, anyone who can access any car uses this security bug method.  We also encountered backdoors using USB stick plug-in.  The system will check the shift-swipe-drop with the speaker of the LAN.  If there is a shift-swipe-drop in the USB stick, it will automatically execute this shift-swipe-drop.  The next one is UDS routing.  We use UDS routing to open the head service.  UDS is a unified diagnostic service specified in ISO 14228 standard.  It is a prototype used in automotive infrastructure for vehicle diagnosis and programming.  The routing control service is used by the client to execute a defined sequence of steps  and obtain any related results.  Enabled head service sometimes requires a security access.  We found that we can exclude the manufacturer's own custom features.  First, we need to change to the extension session.  We use the diagnostic country session.  It is the 1.0.0 session.  After we enter the extension session,  first, we need to get the unlocked algorithm.  We need two algorithms.  The first algorithm is the set.  We can use the access 0.1.0 to get the set.  The second algorithm is the circuit.  We need to read it from the DID.  Using the 2.2.0 session,  we can read the UDS security concept.  We use the 2.7.0 security access to get the set  and use the set and security concept to calculate the K.  After we unlock this,  we can use the routing control to use this head service.  Here is an example.  We found that some car makers use routing control to open the SSU debug port.  Here, we can run CS5 jobs.  This function name is UDS dialog start up SSU.  We can look at this ADAS diagram.  This is the SSU called by UDS routing start up request.  The 18 unlocked methods are commonly used in the head service.  However, I have discovered three interesting and special methods.  First, users prefer to break down the password protection service.  The second one is to scapegoat to the native setting.  The third one is users blink to enable the head service.  We can test one card.  We found the engine mode.  We input the password.  When we input for digital,  it will show error password.  Only for digital password,  I try to if we can brute force.  It's hard to brute force manually,  but Beta USB may help us.  Before using Beta USB,  we must check whether the head user can use the extension devices.  Because some cards are limited to use extension devices.  I try to insert a wireless keyboard.  Insert into a USB port.  And it works.  Then, I use Beta USB to correct the password.  Here I write a little code.  First is the password.  Use the string.  And enter a password to check the password is right or wrong.  The backspace clears this error password.  And delay 5 milliseconds to the next loop.  Finally, we get the correct password  and unlock the engine mode application.  Here we use the fingerprint to correct the password.  We success to get the password and enter the engine mode.  The second one is escape to network settings.  Press the content in the press policy.  Show options like copy or share.  Selecting share, going to Bluetooth page.  There is a search icon.  Here.  Check if it can jump to network settings.  By inputting a specific word,  we can jump to system settings and develop options.  In the develop options,  we can open adb user to USB debugger.  The third part is deep link.  As most early,  Android and SQL codes are a type of deep link.  However, it is difficult to bypass restrictions.  We found an interesting filter.  And we intend to categorize it as bloatable.  Thus, we can trigger it from the bloatable web view.  Here we find the hidden service  to trigger the adb enable.  The deep link with this category is bloatable.  And the HDMI unit host is a separate code.  And the port is line 527.  And the pass is adb active.  We can click the URL to open this hidden service.  To test, we can open with bloatable.  We build a test app with intent filter.  Android intent category bloatable.  And declare the URL.  First, we use web browser to open it.  And it is successful to open the adb server.  First, we test in web browser.  After we click the Android UI,  and to the menu,  open the adb and jump to the test page.  Then, we try to use web view to verify it.  And it works.  Finally, we try to enable real car.  And we successfully enter the adb activities.  Use the same way,  we found a more interesting deep link page  to access the log, hidden activities,  open web case and console settings.  Here we use web view.  Because some cars don't have bloatable,  but usually have web view.  We have successfully used this method  to open hidden service in some cars.  Due to the confidentiality,  we can't show real case demonstration here.  After unlock the door and enter the inner system,  we discuss more interesting and useful things.  I have six four-tact example.  The first one is disabled activity.  The second is the property.  The third is the permission.  And the last is test boundary.  Disabled activity,  when the active event Android Android 2.4,  the activity can't be used.  We discovered a large number of hidden service  enable activities through scanning.  We can access many important and sensitive results.  Through this, we can access and obtain  many sensitive interfaces.  The second one is the property.  We know the Android automotive hack property  is only 129.  We can use this to view Windows partition  or to look at Windows.  But we found other car makers  will defend their own hack properties.  Some cars have more than 2,000 hack properties.  They can use the property to get solutions  such as the cabinet door open station  or to read data from the UART  or to get the UART SSID password.  Also, you can use the property to send some commands  such as MCU control.  Usually, to control the car,  we need to send the data through the MCU.  The other library,  we choose the property  we can directly send the raw code.  Sometimes, the cars use security storage.  We can't get sensitive data.  We can use this property  to write PKI or to read PKI.  The third one is the normal property setting.  The property usually has the permission  to limit other users to use.  But the car makers usually don't set the permission  to their own hack property.  Then, any app has the ability to use this  such as opening the charging guard  to use the setting board's property.  The second is the test binary.  The test binary may be available in RISC-V.  Android automotive uses WCAG HAL tools  to read and write properties.  The WCAG HAL tool is actually associated with Android Health.  This tool is used to preview or test  and interact with WCAG HAL  while acts as a bridge between the Android framework  and other WCAG HAL hardware,  such as using WCAG HAL to open the air conditioning  or standard engine.  Due to the limited permission,  ordinary applications can't control WCAG HAL.  If WCAG HAL is not found,  we can try to find standard applications  such as OEM cards.  They can use the set property like WCAG HAL tools.  To unlock the hidden service,  we can use various methods  defined by the card makers,  such as non-precise dial code, voice commands,  and other technologies.  Alternatively, we can automate the system and app's features  by path restrictions,  such as escaping to settings  or clicking the link to open hidden service.  After accessing the hidden service,  we can find hidden apps, disable activities,  and explore other valuable apps to dig deeper.  Using background services and RPCs,  we can collect data,  correct unused issues,  and automate takeover the card.  HAL is a real case,  demonstrating for stable to unlock hidden services to control cards.  First, we get some familiar from this work.  After we analyze the very deep link  with the blabber observable categories,  through click the deep link,  we start the hidden service engine mode successfully.  After we analyze the engine mode application,  we use overflow to get the UCCL.  At the first step,  we analyze the application to export data to USB.  We found this log to export  After the file is downloaded,  we get the file word.  After analyzing the file word,  we found the vulnerability,  and we use the vulnerability to get the ADAS CL.  In the ADAS,  we can find that all human cards work as a health tool  to use the compass to control the card.  HAL has plenty of services with complete solutions.  Think about the relationship you will challenge.  In order to help understand what happens and how data flows,  I try to visualize this relationship  and make it easier to analyze and understand the interaction with the system.  I built this user diagram to show the relationship  between Android application activities and services.  It also works nicely to use our binary files,  IPC for internet ECU communication,  and RPC for communication between ECUs.  Here is an example of the flag of our graph,  our ABD coin relationship.  The IPCs are exclusive from the system, data, and Windows products.  Each node perpendiculates on an IPC,  and each arrow represents the flow of data,  indicating which application can call which.  The application layer's IPC frequency calls the Android underlying service frequency.  The tool provides two modes.  One of four data includes the prefix android.android,  and the other didn't show Android's native-based application.  More consistent display,  able to spend less time to analyze the core relationship,  and this is for all of you.  You can also double-link to display only the core relationship between the two applications.  Timely use concerns include how to start the engine mode.  Here are two arrows pointing forward to the engine mode.  One from the engine mode index is one part from the engine mode app.  There is only one way from phone 3 to engine mode.  Using this diagram, we can easily find this entrance.  Only the entrance, we can use phone 3 to open the engine mode application.  As we mentioned before, it may be used as a secret code to access the head service.  Using this diagram, we can not only identify the entrance,  but also virtually observe the data flow.  For example, the OUI exchange data with the four applications.  Open web service config and notification center library is OTA service.  When hunting for bugs in OTS,  we have an overview of the app relationship,  help us quickly and easily understand this connection,  make it easier to find vulnerabilities.  The project's source code will be available on the GitHub.  It will take some time to detach this from the project,  but I will complete it as soon as possible.  Thank you for listening.  Sincerely thank you to our neighbors for the invitation.  Thank you, Peng Fan.  I would like to extend to the floor anyone with any questions.  Thanks.  My question is regarding the decompiler that you used,  so particularly when you decompiled the classes to DEX.  Which decompiler did you use?  No, which decompiler when you decompiled the classes to .DEX, the DEX file.  Because the output was very clean.  It had a bunch of intermediate variables.  I think it was like slide nine.  We used some application tool,  or less the source code.  We used some open source,  like JEDX or like this app to figure out the data workflow.  Thank you.  Any other questions?  Yes.  I'm just curious about the brute forcing part.  How safe is it to brute force?  Have you bricked any card by brute forcing?  Brute forcing the password.  Brute forcing the password?  Yes.  We found that in some situations,  the password is very good.  We found that when we input for digital,  we will show this type, the password error.  And then we can limit it to try times.  So we use the FlipZilla or BetaUSB to correct this.  If the password is conflicted,  we can't proof this.  But if we can get a firewall,  we can to analyze the binary and get this password.  Sometimes the card is conflicted,  provided by the tier 1 or tier 2.  We can analyze tier 1 or tier 2,  to tell us to conduct some type.  They use the same way.  So it's just time-deviant protection, is it?  So there's only a limited number of attempts.  You can't have unlimited.  In the old hack,  the computer didn't take this account.  If not, then let's thank Peng Fan again,  for his very insightful talk.  Thank you Peng Fan.  Thank you.