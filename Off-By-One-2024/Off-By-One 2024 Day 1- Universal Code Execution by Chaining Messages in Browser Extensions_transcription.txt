{
  "webpage_url": "https://www.youtube.com/watch?v=2Amrq7ydU44",
  "title": "Off-By-One 2024 Day 1- Universal Code Execution by Chaining Messages in Browser Extensions",
  "description": "Abstract\n\nBy chaining various messaging APIs in browsers and browser extensions, I demonstrate how we can jump from web pages to \u201cuniversal code execution\u201d, breaking both Same Origin Policy and the browser sandbox.\n\nI provide two new vulnerability disclosures affecting millions of users as examples. In addition, I demonstrate how such vulnerabilities can be discovered at scale with a combination of large dataset queries and static code analysis.\n\nSpeaker\nEugene Lim is a security researcher and white hat hacker. From Amazon to Zoom, he has helped secure applications from a range of vulnerabilities. His work has been featured at top conferences such as Black Hat, DEF CON, and industry publications like WIRED and The Register.\n\nIn 2021, he was 1 of 5 selected from a pool of 1 million white hat hackers for the H1-Elite Hall of Fame.",
  "channel_url": "https://www.youtube.com/channel/UCmrsIbKdxEMBEefD8v8RigQ",
  "duration": 1906,
  "channel": "Off-By-One Comms Team",
  "uploader": "Off-By-One Comms Team",
  "upload_date": "20240831"
}

This text was transcribed using whisper model: large-v2

 Great.  Can you guys hear me?  OK.  OK.  Great.  Yeah.  Thanks for coming, guys.  So I know I'm the last session for today.  So I'm kind of in a wake, but hopefully this  is useful and entertaining for you guys.  Part of the talk title is Universal Code Execution  for ByteChaining Messages in Browser Extension.  And this was kind of inspired of two things.  Firstly, I think the conference organizers really  wanted some web talks.  And it's kind of hard to think of a good web talk  in a zero-day kind of bound research conference.  So I was trying to do something different.  And the second thing is that I really  like client-side attacks.  I think it's interesting.  It gives you an opportunity to test,  do more white box and gray box stuff.  And that's kind of the reason for today's research.  So I'm Eugene.  So I kind of blog at this.  It's based on a food dog that I am a security engineering  lead in a day.  So I do good stuff for the government.  And we are hiring.  So just my little show for today.  And hacking is my hobby.  So I do like researching after hours at night.  And this is kind of one of the little projects  I worked on back then.  And so for today's talk, I'm just  going to go through a quick outline.  I'm going to give you some background and prior work  on extensions research.  Especially, I think, one of the more updated parts  is Manifest V3 and the Web Extensions API internals.  And I'm going to talk about the first part of the chain, which  is from postMessage to sendMessage.  So for those of you who are more familiar with web-based  attacks, you know that postMessage  is a client-side attack.  And how do I kind of bridge that gap from a web page out  of the sandbox into the extension context?  And the second part, I'm going to talk  about quick finding that in extension A,  just to illustrate how this can be exploited.  And then I'll go to the next part, which  is a bit more interesting.  How do you then cross the bridge from the browser extension  context to the desktop native context?  That's from sendMessage to sendNativeMessage.  And how that has changed with Manifest V3  from prior research.  And then I'll talk about extension hunting and scale.  So I think the part is, how do you then  scale this research across millions or hundreds  of thousands of browser extensions all at once?  And that's kind of one of the things  that I think is more exciting about this research.  And I'll talk about code execution in extension B.  So you know that these are not real names.  Unfortunately, I disclosed them in April.  But I don't know if I've patched it yet.  But I thought it would still be interesting to go through  and show you a video of the experiment.  And I'll go to the conclusion and further research.  Cool.  So let's start with some background.  I think some of you may have heard  about universal cross-site scripting.  And they probably have the most powerful exercise.  And why is that?  Because it's not a vulnerability in the web page,  not in the HTML, not in the scripts.  It's a vulnerability in the browser itself,  or in some cases, extensions.  Because people kind of use extension vulnerabilities  to trigger that.  And what this means is that the XSS triggers on any page,  regardless of what kind of scripts  are in the DOM of the target website.  So as long as you visit somewhere with a malicious website  or maybe it's part of the URI.  Recently, I think there was some really cool research  in the macOS Safari universal XSS.  You can check that out.  And then the JS is executed in the context of any website.  So it's no longer limited to one exit, one website,  but any website.  And that makes it almost like a same-origin policy bypass.  OK, we'll take it one step further.  And while I was actually halfway through my research,  I had an unfortunate experience where  you kind of search what you've been doing.  And you realize someone has done it a little bit before you.  And as early as 2017, researchers  have looked into extensions and have  found a lot of weaknesses.  So I think this is something that was presented  by Ed Waas in 2017.  Looking at the post-message security of extensions,  how do you bridge the gap from a web page  to the browser extension context?  And then we'll see how much has changed since then.  2017, the spoiler alert is not much.  It's still exploitable.  It's worse.  Somehow there seems to be a problem pattern these days.  So let's start with some background.  Browser extensions comprise of new key components.  The first is the manifest.  They tell you exactly what's in the extension.  It tells the browser how to interpret  the rest of the extension parts.  The second is the content script.  This is scripts that are injected into the web page  by an extension.  So how the extension can interact with your DOM,  if any web page that you give the permissions to.  And the second part is the background script  or the service worker.  Background scripts were used in the manifest v2.  The more recent manifest v3 uses service workers.  The main difference is that service workers are short-lived,  but you can still make them last a bit longer.  And finally, we can talk about the native messaging calls.  Some of you may use password extensions,  maybe use 1Password.  And you've always maybe wondered how the extension  can talk with your 1Password app  that you installed on your desktop.  This is how it does that.  And we'll investigate that a bit.  So let's do some code review.  So firstly, the manifest declares a few things.  It declares the service workers, the content scripts,  and more importantly, the content security policy  and permissions.  And there are a ton of boot camps available  where developers can make mistakes  or have overly permissive permissions.  One of the key things is...  Let's see if we can highlight that.  One of the key things in manifest v3  is that you no longer have a background script.  You have what we call a service worker.  This is what you define as the script that runs  in the browser extension context.  The second thing is the content script.  The content script is what's injected  into a web page by the extension.  Because sometimes the extension may need to interact  with your document object, although you don't.  What's on the web page may need to insert something,  read something.  And one of the fun things is that  you're not supposed to actually inject  the content script in every single page.  You're supposed to specify what URL  that you would then inject the content script into.  But what I've seen is that  a lot of developers just don't care.  And they set it as either all URLs  or they have a lot of content scripts  that appears in every single page.  But the great thing about all this  is that it makes it really easy  for you to identify potentially vulnerable extensions.  Because you can have this starting point  where you see manifest  and you parse all the manifest  to figure out if it may be something  that you may want to dig into a little bit.  So, the second part is content scripts.  So I mentioned that you can inject scripts  into any page, right?  Or extension.  Of course, that does sound a bit scary.  And that's why, actually, my extensions,  they are injected into what they call isolatables.  That's Chrome's terminology for that.  Basically, even though you inject it into a page,  it can access the DOM,  the document object model,  but it cannot access other JavaScript variables  like scripts that's running on a page  or even other content scripts.  A second thing with Manifest V3,  Manifest V3 is basically  the latest generation of extension specifications,  is that there's very strict  default contents-aside policy.  So it prevents most of the inline  JavaScript execution in XSS.  This was a big problem, maybe about five, six years ago,  where the extension would read something  on the DOM, on the document object model,  and then it would devalue it  and devalue to XSS at the extension browser context.  But this has been elevated a lot  by a strict default CSP.  And also, there's a limited browser extension API  available to the content scripts,  not the full browser extension API,  but just enough for them to talk with the background script.  So I'll talk about that.  So as I mentioned, the content script  that's injected in your page can't do a lot.  It can read the DOM, it can insert, change stuff.  I don't think they even make a fetch  unless you give it sufficient permissions.  So most of the time, for more complex functionality,  what they do is that they pass messages  to the service worker that's running  in the browser extension context.  So the content script will execute  chrome.runtime.sendMessage.  There are multiple APIs that allow them to communicate back.  And what the background script will do  is then take that message, do something with it,  and if necessary, call back to it  by just sending the message back  to the port or the subnetwork.  In this case, you can just look for addListener,  one message, very simple,  not very complex way of content message passing.  There is also cross-extension messaging.  It's possible in some extensions,  but it's fairly rare.  So most of the time, what you'll see  is a background script talking sendMessage  back to the content script and vice versa.  But you can see that the context is all kind of separate.  So it allows them to stay safe in isolated worlds.  So let's talk about the first part of the chain today,  which is the postMessage to sendMessage.  And to communicate from a page.js to the extension,  postMessage is used in the shared DOC.  So what do I mean by that?  Say, for example, you have a web page  that is supposed to interact with your extension  that you've installed.  Maybe you've installed a one-password extension,  and you're visiting the one-password homepage,  and maybe they kind of want to talk to your extension  when you're visiting the one-password homepage.  How does it do that?  Because, as mentioned, in the DOM itself,  there are isolated worlds in the JavaScript context,  so they can't actually talk to each other.  But they can both access the DOM.  And one of the great things that you can do with it  is then send a postMessage to yourself.  So the website will make a postMessage call to itself.  And this postMessage is actually able to be picked up  by both and all of the content scripts on that page as well.  And so this is actually a pattern that's recommended  by the Chrome documentation, where it's like,  hey, if you have a web page that you want to talk to  your extension, use the postMessage pattern  to talk to it.  So what you do is that you send a postMessage to yourself,  and the listener, in the isolated world of, say,  content script 8, will pick up that postMessage to itself,  sometimes with some validation, like making sure  that it's really from the same page.  And that's how you get that message from the DOM.  However, one of the things is that postMessage  was never really meant to be used like this.  I mean, you probably know that postMessage  is a pure browser client-side API.  It's just for frames to talk to one another  sometimes across origin.  It's never really meant to be used in the extension context.  It's kind of janky, but that's how we are able  to have that separation in isolated worlds,  but still share the same DOM.  And this means that typical ways of validating  the origin of a postMessage are now nullified  with weak manifest matches.  So in this case, for example, what you typically see  in a pure client-side pool with no extensions  is that you validate the event source  and make sure that it comes from the same window.  So it's like, OK, it's either my parent or a child window  or my own frame that's talking to myself.  It's not coming from another origin  that is trying to talk to me.  In the case where you're using this in a pattern  of page postMessage talking to the extension content script,  this is actually useless because it doesn't actually matter.  It's always going to be the same.  So now you can bypass that.  And this makes it even more dangerous.  And as I mentioned earlier, this is effectively nullified  when you have weak extension matches, manifest matches,  where the content script is injected in every single page  regardless of your DOM.  So very quickly, we can talk about a case study  with extension A.  And in this case, it has a very weak matcher.  You can see it here.  It has a few permissions.  It has a cookies permission.  And it can access the cookies of website A, website B,  and all the subdomains of website C.  So obviously, I think it was meant to just operate  on all these websites, but the matchers doesn't line up  with what permissions it's in front of.  So in this case, how this works is that we would have  an addEventListener on the web page,  in the content script.  And on receiving a postMessage,  it would actually forward it to the background script  using the chrome.runtime.sendMessage.  That's how it talks to the background context.  And in the background script, which is running  in the browser extension context,  it will get the listener.  It will check whether the action is a specific action  to this endpoint.  In this case, getCookie.  It will execute getCookie, retrieve it,  and then send it back using chrome.tabs.sendMessage.  And this is really super simple, straightforward exploit.  You'll see this a lot happen in more weaker extensions.  So this is something that you can exploit very easily.  It just runs on any domain.  So as long as you have this extension installed,  as long as you're visiting your payload  regardless of domain, you can then  get cookies of website A, website B, website C.  And this brings the same version policy.  So this is one of the extensions installed  by more than 300,000 users, and very simple to use.  We're still on very well-known ground here.  Most people looking at extensions would see this.  So let's talk about something more interesting.  How do we extend this exploit from just the same origin  bypass, policy bypass, to something more interesting  where you have a browser sandbox breakout?  Not exactly a breakout, but it's kind of an app-level breakout.  And that's by going from sendMessage  to sendNativeMessage.  So how does your one-password extension,  and again, one-password is not the application  that I'm talking about.  Don't worry.  You can keep it.  How does your one-password extension  talk to your desktop application that's  installed in your desktop?  How this is done is that there is a part of both the Manifest  V2 and the Manifest V3 browser extension  APIs called native messaging, where native applications can  register native messaging codes, which is just  a binary executable running using a manifest file as well.  And so for Chrome, you can register it at this registry key.  And you just tell them, this is the location  for this application of myManifest.  And in Manifest itself, you specify a few things.  Of course, you specify the host name, which in this case  is myApplication, and then the path  where the Chrome will help to forward those messages to,  in this case, ChromeNativeMessagingPost.exe.  And there are a few other additions  where you can add a lot of origins.  In this case, Chrome extension, which Chrome extension  can actually trigger this standard input.  They have a type of the input.  But actually, it's just standard idle,  which I'll talk about a bit later.  But this is basically how it's going to communicate.  It's going to be standard in, standard out.  Very simple.  Typically, just string JSON and Google Input.  So in this case, background scripts can then,  or extension service workers, in the case of Manifest V3,  communicate with this native application  host via the browser.  So this is very similar APIs, but for native messaging.  The second thing is just, as I mentioned,  just use a standard in and standard out.  So it's very simple parsing.  You don't really see very complex encoding.  Most of the time, it's either Base64 or just JSON.  It's just in text.  And if this message is handled dangerously,  then the native application can be exploited.  So in this case, we would see a very simple pattern.  Again, from the Chrome documentation,  this is running in your background script  or your service worker.  So in the browser extension context,  not the content script.  It will send a message to the host with your text.  And it will also be able to listen from it  to receive the output from your native host application.  And this is something that you can then string together  to get what we, you know, it's just a term,  a universal code execution.  Think of it as similar to universal XSS,  but in this case, you're making one more jump  from the browser extension context  now to the desktop code application context,  which means code execution, right,  outside the browser.  We start with step one,  where your browser extension has a wildcard pattern  for content script.  So it's kind of weak.  Not super necessary, right?  You can run on certain websites.  You can find all of it on your web page as well.  Put one more link in your chain earlier on.  Second is that the equal web page  or the injected script  then sends a post message to itself  in the same frame, right?  And in this case, the content script will be listening.  It will be able to pull that post message  and it will pass that message on  to the background script using sendMessage.  The background script gets that message,  it does some stuff with it,  and then finally forwards it  to your native host application  using sendNativeMessage.  And then, of course, the native application  handles the message dangerously,  leading to code execution.  So you might think,  okay, that's cool, right?  It probably only happens to  one or two web applications, extensions.  There's a lot of parts of this chain  that need to do that to work.  So let's talk about extension planning at scale.  I'm not going to go and look at  every single extension out there one by one  and try to figure this out.  So we can do this at scale,  and this is kind of one of the fun parts  of boundary research these days.  You can scale it using  whatever pipeline you have.  So there are a lot of  existing databases  that make it easy to query  browser extension manifests at scale.  One of these is the  Chrome extension manifest database  on GitHub.  It has a dataset of more than 100,000 extensions,  and basically this guy scripts  all of the manifests for all of the extensions  he could get his hands on  for you to make a query with.  It has quite useful scripts  for you to then parse all of this data  at scale, because you can use  breadth or  jQt,  but it's  going to be kind of not necessary  if you just use the script.  And then you can add a few filters to that.  So in this case, what I started with was that  hey, I want to find  extensions that may be used by  a lot of people, and I'm going to filter  whether they have a content script,  whether they include a permission that includes  native messaging. So there are two parts  of the chain that are available for me,  and there's some likely people  that are disconvinced about it.  So after filtering for  promising manifests, I would then  download and extract the extension, and then  scan them with a custom sender code,  because remember there are two other parts  in this chain that you want to connect.  The first part is the postMessage handler,  and then the second part is the sendNativeMessage  function.  And this is something you can do with the tools available  these days very easily at scale.  My favorite here in this case was SendRep.  You can use the TaintSource and  TaintSig, and then just do  a standard taint analysis at  scale across maybe how many  manifests that you've filtered down.  In this case,  I look for a few things.  I look for either ChromeRuntime.sendMessage,  or I search for port.postMessage,  because there are multiple ways  that you can express sending a native message  in the extension.  For pattern sources, I also had to  add a few more  filters. In this case, if you  use SendRep before,  you recognize focusMatterVariable,  patternNot, these are ways to just make sure  that I don't get false positives.  And so I think just with  large enough funnels,  you will always get results.  So I started with more than 100,000 extensions,  and then I did the quality-to-filter  potential manifests, in this case  of 200-plus.  And then by running my SendRep rule, I can then  narrow it down further into  31 service workers' background scripts  that seem to be vulnerable.  And followed by that, I kind of have  to make sure the last part of the chain is available,  which is manual review of the native force  application binaries for exploitability.  In this case, you start seeing  a few interesting patterns with the types of  applications  that would use this kind of pattern.  In this case, I found something  with PKI card extensions,  and I'll talk about  why that is.  So, let's start  with the case study here with  extension B.  Extension B is used by more than 2 million users,  and this is an extension that  kind of fills a common gap in browser  extensions, in that it adds PKI  smart card support in browsers.  As you may know,  the browsers, a lot of them don't  support PKI smart cards by default.  They support the Web App  standard, so that's  fetal pass keys,  but they don't support PKI smart cards.  The problem is that there are a lot of enterprises out there  that still use PKI smart cards, and  this is why extensions are very popular.  In this case, they have more than 2 million users,  but I'll tell you that this is not  the only extension that has this pattern,  that has this number of users, because everyone  kind of wants to fill the gap.  And by design,  in order to enable PKI card support  on whatever web page you use,  by design, you're going to have to have  a wildcard extension  match it. In this case, as you see,  they just use a star for the key,  the URI, and the path as well.  And fairly standard,  you can see that they have permissions for  page and messaging.  So let's try to link this up  all together. We'll start with the content script,  and what the content script does is  again, that it checks, I mean, they try  to be secure. They check whether the event source  matches the existing window,  which, as I mentioned earlier in this presentation,  is useless, right? Because once you have  a wildcard matcher, the event source  can be any page that you control.  And so you can send a message to yourself,  that's always going to pass the origin check.  The second thing is that it forwards  the event data to the background  with the sendMessage API.  The background script as well,  again, it does a few checks.  It checks for the action type,  but it doesn't really do much  more than that, so it immediately forwards that  to the open native  messaging port via the  chrome.runtime.connectNative  that is open previously.  And of course, your native host application  passes the standard input  as JSON, and then it  just, well, you can tell  this is just one of the actions that it  runs to load the DLL at the  provided value that is given  in the message.  So since native  messages are standard input,  it is really, really easy to identify  the entry point.  Again, this is part of the code  that was the handler for this.  What it does is that it just takes  the argument from your  native message,  parents it to C Windows System 32,  and then loads the DLL at this part.  And this is a very common traversal pattern  for DLL loading, not complex at all.  I'd just like to show that  I think Winston, you're here.  My former colleagues,  we worked on a C-scale client  that also had  DLL loading that  is interesting, so go read that.  But  other than requiring a known value path,  it's not overly complex, fairly simple,  and something that  I think for most attackers, you should be able to  run.  So in this case, what do you need to do?  You first need to trigger the download of a malicious DLL,  and then send a postMessage payload  that would then trigger  the native post application to load  and execute the malicious DLL.  Standard, I mean, you can use the DLL hijacking,  but in this case, it's not a DLL hijacking.  So it's a simple two-stage POC, as I mentioned.  The known download path  is an annoyance, but often native post  applications have very inexplicably  weird features like  getInfo or getUsername.  You see some weird things  in this space.  One of the side notes is that  there are some browser extension  APIs that allow you to specify  the download path and trigger a download  anywhere in the computer.  So keep an eye out for that.  In this case, the POC  triggers the download payload.  It just creates a form  and a link and clicks it.  This is a bypass that most people  use, because in order to trigger a download,  browsers make sure  that you have to click something  or have some kind of user interaction.  This is one way to quickly simulate that  using JavaScript without any user interaction.  The second thing is  you send a post message.  In this case, you have to add some  standard values that will help you  get around the various checks  of both the content script  as well as the background script,  as well as the native  post script.  In this case, we're going to select  an action, and we're going to specify  that I agree it's going to be in your  download folder and the payload  that you specified.  Okay, so  this is kind of what it looks like.  So again, I've given you  the extension, but  I don't have the function names.  It triggers the download for the payload.txt  and it's going to  pop the calculator.  This can be run on any page  as long as you have this extension installed.  You were hoping to use a smart card,  but I think you had a different surprise  that day, but this means that  your bar will rebalance when you visit.  You can inject it anywhere.  It's very simple to exploit.  There are even some features that inject the content script.  It's also fairly easy,  i.e. if someone is using this  extension that you want to exploit.  Okay, I'm just running out.  I'm going to talk about the conclusion and some of the  learning points for this.  As I mentioned, this is something that was  maybe raised a few years ago  at MacFest v3  for Chrome extensions, browser extensions,  MDM  also. MDM defines this  as MacFest v3. It was meant to  improve the security of browser extensions,  but this was mostly in  the client side where they added content  scripts and also limited  permissions to request  or even execute the browser APIs.  It seems that  powerful browser extensions  are a feature of the cloud.  I know there's been a lot of work  in browser extensions, especially in  critical space, primarily because of  Metamask and other similar  extensions, but it's really  hard to secure Chrome extensions.  For researchers,  it's great because  they are the white box in research  by default, so you have access to all  the code and you can analyze it from there.  They are built in  at every level.  For example, as I mentioned, with the  PKI card extension,  just because my  definition of PKI card  extension needs to run on any website,  they're going to have a wildcard extension.  There's a poor understanding  of risk posed by  extension permissions and messaging  chain. As mentioned, I  did a fairly strict  where I filtered  100,000 applications, but this  was because of professional time and  the CFP was coming up and I needed  to get a result quick. But if you  extend this a little bit bigger  in terms of what kind of  sources and sinks that you're willing to tolerate  as well as whether you're going to spend  some time to maybe  find a bug on the website instead of a wildcard  origin, you can actually find a lot of interesting  things.  There's poor understanding of risk by developers  of having this through train  a kind of a  pass-through from the content script  to the background script and finally to the  native host application.  What I see most of the time is that  there's a lot of trust at the  native host application level  of the messages they're getting from the Chrome extension.  Primarily because for native  host applications, the manifest  allows them to restrict messages  from a specific Chrome extension  and  most of the time, it's going to be there.  Another interesting thing here is  that just by  understanding that there is this  vulnerability in your native host application,  you are now also very aware of  the fact that  even if it's not coming from a Chrome extension,  this application  is vulnerable and it just needs to take it from  standard in. And this leads  to very interesting questions of  is this extension running in a very  privileged context? Is it a password  manager? Is it running as  a privileged user?  And this does happen,  especially for these kind of extensions  that need that interactivity  between the browser and the desktop.  And it's  still very under-researched. So I mentioned  as early as 2017, people have been  thinking about this, but  there's a lot more research that needs to be done in  Manifest V3 APIs.  Manifest V3 brings about a new set of APIs,  new set of permissions, restrictions,  but it also lets a lot more experimental  features, such as maybe credential  manager API. There's  some side work I've been doing on Web  70PM APIs,  but that's still in  exploration. So yeah, that's  it for the chain.  You should all get my hiring  properly. But if you  want to find out more, I'll put up a blog post  that summarizes the learnings  from today and on my blog.  So thank you very much.  Thank you, Eugene.  For the last session of Day 1,  we open the floor for any questions.  First question from Trevor.  Okay, so  have you monitored any  or observed any similar  type of issues in  communications in the WebSocket area?  Because there are also some  extensions we could have done  asynchronous communication instead.  And it's totally  different, but the delivery is still the same.  So have you  observed any of that?  I think that's interesting.  Mostly because the post message was the  recommended pattern for  page  document object model to  content script communication. I think  WebSocket might work. That's why I was interested in  Web70 as well, seeing if that's something  that opened up a channel between  content script and the page  document object model.  I have not looked as much into it, but it's definitely  one possible path to expand  the public cloud approach.  Thank you, Eugene.  Any other questions?  All right. Excellent.  Thank you very much.