{
  "webpage_url": "https://www.youtube.com/watch?v=mpRIvN5Kzhs",
  "title": "Off-By-One 2024 Day 2 -  Attacking the Samsung Galaxy A Boot Chain",
  "description": "Abstract\n\nDuring our past research analyzing the Android Data Encryption Scheme, we dived into the boot chain of Samsung low-end mobile devices, in particular the Galaxy A family, which is based on Mediatek System-on-Chips. These devices are often overlooked by the security research community, which usually targets high-end ones (e.g., the S family for Samsung). Nonetheless, these devices are extremely popular, and thus represent a big share of the phones in the wild.\n\nOn top of the Mediatek boot chain, Samsung added its own features including Knox Security Bit, support for their recovery tool Odin, a JPEG parser and so on.\n\nIn their latest system of chips, Mediatek have improved their security, and fixed an infamous BootROM vulnerability that used to impact most of their chips.\n\nYet, even with the security improvement done by Mediatek and the apparent security brought by Samsung, we were able to break the boot chain of most of the Samsung phones powered by Mediatek SoCs.\n\nWe will present several 0-day vulnerabilities that, chained together, can be used by an attacker with physical access to a wide range of Samsung devices (mainly from the A* family), to bypass the secure boot, execute code on the chip, reach persistency and ultimately leak the secret keys protected by the hardware-backed keystore.\n\nThis presentation brings together two important concepts of modern mobile architectures: the secure boot and the Trusted Execution Environment. It gives a comprehensive view of how these features work and how they can be targeted by security researchers, focusing on the offensive approach.\n\nSpeakers\nMaxime Rossi Bellom (@max_r_b) is a Security Researcher and Tech Lead working at Quarkslab, focusing on the hardware and low level software security of mobiles devices and embedded systems.\n\nHe likes playing with secure boot, and security chips embedded in smartphones.\n\nDamiano Melotti (@DamianoMelotti) is a security researcher. He is mostly interested in systems security, especially in mobile platforms (Android) and automated vulnerability research.\n\nGabrielle Viala (@pwissenlit) is a security engineer specialized in vulnerability research and exploitation at Quarkslab. She is usually focused on desktop-based components, but as long as the project involves low-level technology, any target can be a good playground for her.",
  "channel_url": "https://www.youtube.com/channel/UCmrsIbKdxEMBEefD8v8RigQ",
  "duration": 2553,
  "channel": "Off-By-One Comms Team",
  "uploader": "Off-By-One Comms Team",
  "upload_date": "20240901"
}

This text was transcribed using whisper model: large-v2

 All right, hello everyone, I hope you can hear me fine.  It's good to see many people here and we're happy to present the talk today that is going  to be on attacking Samsung Galaxy A family of devices and in particular their blockchain.  Well, we already received a very good introduction, so maybe I can go quickly on this slide, but  this is a research that started last year while working at QuartzLab and today here  we have me, Damiano and Maxime who is going to join me on stage shortly.  So this research actually started from a previous research that we had done the year before  on the Android data encryption scheme.  In this particular research we wanted to figure out the details of how data encryption at  rest works in modern Android.  So what we did was we took a form that had an existing known vulnerability that we could  exploit and we played with the various internal components that are involved with the encryption  of essentially the data that you end up storing on your device.  We wanted to know how an attacker would go and try to defeat the schema, how the password  or any authentication factor of the user is involved in the process and we ended up  kind of building a bit of a picture of how this whole thing was working.  What we're trying to show today is essentially the same thing, but instead of relying on  an existing vulnerability, we show how starting from the USB stack you can effectively obtain  the same results.  So we are working on, we said, the A family of Samsung Galaxy devices.  Here's the specific model we used.  It's sort of in the low end part of devices.  It's relatively cheap.  And it runs MediaTek SoC.  So there is this mix of MediaTek and Samsung code that is running on the phone.  Obviously Android is the OS and for the trusted execution environment that we will be talking  about in the talk, the device is Tigris, which is the one developed by Samsung.  And again, there is a node from Bug that is exploitable using MTK Client, a nice tool  that was built to exploit this bug and bypass the secure boot.  So we didn't use it in the chain, but it was definitely helpful to make debugging easier.  So before diving into our work, a bit of introduction.  And we start from the MediaTek secure boot process.  There are various components involved, obviously.  And the first one is the bootrom, obviously.  So the very first piece of software that starts executing.  The bootrom spawns the preloader, which is the second stage bootloader, which in turn  starts three different things.  On top you see the Arm Trusted Firmware, which is also known as Secure Monitor.  This will stay in execution in the highest privilege level of the secure environment.  Then we have Tigris.  Tigris is the trusted execution environment operating system.  It has both a user run and a kernel, so it runs on two different exception levels.  And then we have Little Kernel.  Little Kernel is the main Android bootloader running on VM1.  And this will launch Android, so the kernel can be deployed.  So we will start our talk from Little Kernel, so the main Android bootloader.  But before diving into that, another little bit of introduction on Android partitions.  This is just to say, this is just to kind of put everyone on the same page.  Android is usually shipped in different partitions that serve different functions,  and that you can flash or restore independently, more or less.  So for example, we have the boot image that has the kernel and run this.  VD meta is used for verified boot.  But then we have dynamic partitions that are only parsable by user run.  So the super partition is the best example with the system vendor.  If you are familiar with Android, these names ring a bell.  If you're not, just imagine these as the building blocks that you can flash on your operating system.  And yeah, Little Kernel has its own partition.  And Little Kernel in general is actually an OS by its own.  But it's very common as a bootloader in the Android world.  It implements some features to recover parts of the system.  And in particular, it implements Android verified boot,  which is the feature that allows to have secure boot and verification of Android images,  as well as broadband protection.  So Samsung took Little Kernel and modified it to include some custom features,  such as the Odin recovery protocol, which is Samsung's protocol to recover partitions and flash them.  Also to update, these kind of things.  Then we have the Knox security bit.  Knox is a suite of tools that is meant to improve the security of Samsung devices.  In particular, the Knox security bit is a way to essentially void warranty when a bootloader is unlocked.  And then we have also a JPEG parser and renderer,  which is used to render errors like the ones you see here on the right.  So in case something goes wrong at boot time, you have this nice message that tells you what happened.  So this version is closed source, honestly.  Since Little Kernel is open source,  various engineering is not too complicated because you can help yourself with the open source version.  So Max will promise this now and we'll get to the fun stuff.  Thank you, Leonardo. I hope we can do well.  So the first component that raised our interest was the JPEG parser,  the one implemented by Samsung.  And this is because the JPEGs are placed into a tar archive that you can find in the partition called app.params.  And this archive is signed, but the signature is never checked at boot.  So anyone with the ability to modify the internal memory of the device can actually modify this JPEG.  So as a security researcher, it's kind of an interesting primitive.  And we all know that sometimes parsing images can be a difficult task.  Here we are citing LogoFade, which is a research by Barnaby that was presented last year.  They fuzzed a couple of simple image parsers in different bootchains and they discovered many bugs.  So this is definitely something interesting for us.  And before we get into this parser, we need to understand how these JPEGs are loaded in Little Kernel.  So this is the code responsible for that.  And as you can see, the first step is that there is a constant size allocation on the buffer of one gigabyte.  Then you have this function that we call readJPEG file.  So the name is the one we get from reverse engineering.  But you get the idea.  This function will take the file name as the first parameter,  and it will read the corresponding file name as an archive,  and then load the content into the buffer that was previously allocated.  And finally, you have this big image function that will parse and render the JPEG on screen.  Now some of you may wonder why we have this 0 as the third argument of the readJPEG function.  Actually, this third argument is supposed to be the maximum size.  So whenever the system looks for a JPEG in the target,  it will first read the size from the header.  And if the size is bigger than the one provided, it will trigger an error.  So the size will not be read.  Unless the size provided is 0, in that case, well, the check is ignored,  and the file will be read in the buffer.  So we have here, first, a minorality for us.  It's a heap overflow.  The question for us now is, is it exploitable?  So to answer that question, we need to understand how the heap algorithm works.  And in this case, you can tell that by default, we have a mini-heap,  which relies on a double-heap list.  So we have a list of free chunks.  It's all actually all placed in the same memory pool.  They're all following each other.  And they all start with the header you see on the right.  So we have a pointer, prep, pointing to the previous free chunk,  and the pointer prep.  Then another pointer pointing to the next memory chunk,  and then the size, and then the contents of the chunk.  So if another flow happens, we may override the header of the next chunk,  which includes these pointers.  And we found a way to turn this into a mandatory write.  This is because of how the allocation routine works.  So when the system allocates a chunk, a memory buffer,  it will remove a chunk from the free list.  And to do so, it will dereference the next and prep pointers of the chunk being allocated  in order to access the previous and next chunks in the list  to, in turn, modify the pointers next and prep of these two chunks  so that they point to each other and not to the previous chunk.  So it means that, basically, we can control these two pointers next and prep  of the chunk being allocated.  It leads to a write that we are permitting,  with the only constraint that both values must be writeable addresses.  Now, a few words about the mitigations in our relative canaries.  There are not many, as you can see.  No AS at all, no canaries, and more importantly, the heap is executable,  which makes the exploitation rather simple.  It's quite convenient for us.  So the exploit strategy becomes something like this.  We use our primitive to overwrite a pointer which we call the chunk to,  such as the return address in the stack, in this case.  And we will make it point to a shellcode that we place inside our JPEG buffer.  So to highlight this with a nice schema,  here we have a representation of the free list.  And you see in purple the JPEG buffer that we just allocated.  So the next step is that the system will read the JPEG and will feel the buffer.  And at some point, it will overwrite.  We will overwrite to the next free chunk.  And we will replace it with a fake chunk, let's call it like this,  where the next pointer points to the return address in the stack,  and the prep pointer points to the shellcode.  Such that when the next allocation happens, the system will deliver chunks next,  and it will replace the return address with the address of the shellcode.  And you know what comes next, I guess.  When the function returns, we execute our shellcode.  So this is the theory.  And to validate that, we implemented a little emulator.  So we use Unicode for that.  I'm sure you're probably all familiar with Unicode.  It's a CPU emulator, meaning that it cannot be used to emulate a full system.  So, for example, no interruptions.  No hardware, no interaction with hardware.  But it's not really a problem in our case,  because we can really isolate the data that we want to emulate.  And it's also very straightforward and easy to use.  So we implemented this little emulator in which we exploited this variability.  But the problem we have then is that the same exploit will not work on the real device.  And there are a couple of things that are actually going wrong.  The first of them is that the heap and the stack will be present in both environments.  And the way we solved this was to use the bootramp variability that we described.  So we basically used this variability to bypass the sector boot.  We patched the exact same heap and stack and imported it into an emulator.  There is another way to do so, which we rely on reverse engineering,  because we don't really care about what is inside the memory.  We only care about the state of the heap in this context.  So we can actually recreate the exact same succession of 3N models.  Now, there is something interesting about this bootloader.  It is quite deterministic.  Without AS at all and with the fact that we are actually booting from more or less always the same state,  all the addresses, offsets, sizes that we find in the stack and in the heap will be the same every boot.  Which is why both functions will work in this case.  So, going back on what is going wrong in our exploits,  there is also the fact that the heap algorithm will write something at the address shelter plus 4.  This is because of the routine removing the check from the priest.  You can see here that we will dereference the thread pointer,  which is supposed to point to our shellcode and we will access the second pointer.  The system will override the second pointer, which is next, with something else.  So basically, we have the second value in our shellcode that is overwritten by the system.  There is an easy way to fix that.  We just need to skip the next instruction inside the shellcode.  If you are familiar with the Amazon, it looks like this.  So, we have the first node that will be skipped by the first instruction to happen on this program.  The final problem we have is that the heap after the exploits is in rematch with the priest.  So, it will crash after the next allocation or after the next boot.  There is no easy way to fix that.  We need to recreate the priest such that the heap is in a working state.  With all that being done, we have the same exploits that will work in the exact same way on both environments.  To sum up on this first vulnerability, we have the CD number you see here.  It leads to code execution in GitHub kernel and it is persistent.  It will survive reboots and factory resets because the partition containing the GPX will never be wiped.  Also, since GitHub kernel will load Android, so GitHub kernel is running in EL1,  but since it is loading Android, with a little amount of work,  we can bypass all the checks and take control over Android.  So, we will control the full number of objects in that part.  And it impacts at least all the Samsung devices we looked into that are based in MediaTek system on chips,  which includes those that are fixed in the boot run vulnerability.  Now, there is still one issue we have regarding the objecting,  which is to take control of the full system,  is that we need a way to flash this GPX on the device without being already privileged.  So, how to do this? This is the question we ask now and the one we try to answer.  For that, we will look into Odin, which is the recovery protocol designed by Samsung,  that is also implemented in GitHub kernel and it basically allows to flash partitions through USB.  We have a closed-source client that is called Sovodim,  that is the official one, let's say.  But there is also a low-cost one that is quite useful,  because it works very well on Linux, you can use it in common life,  it's angled and it's the one we use in our proof-of-concepts.  Internally, Odin works as the following.  So, first of all, all the images flashed to Odin must be authenticated.  They must contain a signature recruiter,  we have an example here of what the signature must look like.  Internally, there are two structures that Odin will use to do so.  The first one is the partition information table, that we'll call the bit,  and there is also a global array that indicates which partition to authenticate.  The partition information table is actually placed into a static address in the VMMC,  and it describes the partitions.  Each partition has an entry in the bit, you see an example on the right,  and it will give some information such as the size of the partition,  the name, where it starts, and so on.  And the partition that is not present in the bits cannot be flashed through Odin.  Although the bit can be updated, but as you can imagine, it requires a signed image.  Now, regarding authentication, we have this global array I mentioned,  and it will describe which partitions must be authenticated and how to authenticate them.  What is interesting, however, is that an image that is not part of this array  will not be authenticated, does not require authentication.  So if we compare the bits that give the list of all partitions that can be flashed,  and this array, indicating the one requiring authentication,  we end up with a list of partitions that we can flash without authentication.  Now, just a quick note on this list.  The up-param partition, the one containing the JPEG, is not part of them,  because it is authenticated.  But there are other interesting partitions that we can actually flash,  and two of them are eGPT and sGPT.  GPT stands for GeoID Partition Table.  So the GPT is similar to the bit in the sense that it describes the partitions.  You will find similar information, the names, the sizes, and so on.  And you can see that it's quite an interesting, quite a powerful primitive,  the fact that we can flash without authentication the headers of this GPT table.  It means that we can, through USB, reshape the GPT table.  Now, a few words about GPT versus bit.  As you know, as I explained, they are used for the same thing.  The bit is actually used for Samsung features, such as ODIN, such as JPEG loading.  So the up-param partition is actually retrieved through the bit and not through the GPT table.  And the GPT is used for the rest of the time, like for loading non-grid partitions, for example.  So when the system starts, it will execute this little routine you see in order to load the bit in memory.  So as I explained, we have this hard-coded address, which is where the system by default will read the bit from.  But there is also this interesting routine.  The system will try to look for a bit partition, and if there is one, it will read it from there.  So on all the devices we looked into, there was no such bit partition.  However, it's quite interesting because the code is there anyway, and these two functions rely on the GPT table.  And we can actually change this in this GPT table.  So we came up with a polling strategy.  Here is a representation of the flash memory.  You see the bit and GPT pointing to the same partitions.  And the first partition you see, mdflite-hdl, is actually one of those we can flash without authentication.  So we will replace this partition with a new apparam partition containing our managed-use GPT.  The second partition, dbmeta-bendo, isn't so flashable without authentication, and it's empty.  It seems not to be used, so we will replace it with a new bit, which is a copy of the original,  except that we will rename mdflite-hdl into apparam.  And we do the other way around with apparam.  And the final step is that we will modify the GPT table in order to rename dbmeta-bendo as a bit,  such that at the next boot, the system will not read the original bits, but will read the new one.  And whenever it will try to read GPT as a screen, it will look for the new apparam partition.  And it actually works.  You see on the screen dots showing up.  It means that the exposure worked.  So the GPEGs are loaded.  But we still have a little problem.  Unreal won't boot, and this is because the dbmeta-bendo partition is not present in the GPT table,  even though it's not really needed for anything.  So there is an easy way to overcome this problem.  We simply take another partition that seems to be useless, in this case the SP partition,  and we rename it to dbmeta-bendo.  And with that done, it actually works.  The device will boot and everything will be fine.  So to sum up on this second vulnerability,  we have an authentication bypass in Odin that we can use to flash more or less anything we want in the agency,  which includes the apparam partition.  And this vulnerability impacts most Samsung devices.  At least all of those we looked into.  That's all using MediaTek system issues.  Now before I get to the demo, a few words about post-exploitation,  because remember that our ultimate goal is to take control over the Android system,  and so far we are executing code in the Google kernel.  And the best way, the easiest way for us to control Android is to modify the partitions  that Daniel described at some point.  And the problem is that we have this ADB Unreal-Grid-fighting feature  that will complain if the partitions are different from the original ones.  So for that, we implemented a little routing in our shellcode  that will simply patch all the checks to basically not them.  And this is quite easy to do because the memory is already writable,  so code on the Google kernel is both executable and writable,  so no need to play with it.  I will call Daniel on stage to help me with the demo,  so there is a video in case it doesn't work, but I'm sure it will work.  Okay.  Okay, so we have to film actually the device.  I hope you can see the device. Okay.  So basically this is a normal device.  And let me first show you something.  Basically, obviously I enabled ADB for this demo,  and what I want to show you is that when I try to call SU,  which is used to get privileges on Android, it doesn't work,  which is the expected behavior for a normally standard Android device.  All right?  So far so good.  So what I will do now is simply shut down the device,  so like this.  So here I unlocked the device, but you can actually power off this device  by pressing all the buttons together for a couple of seconds.  Okay, then I will start it in the download mode,  so you can also do this without needing a privilege,  without having to edit the password.  So now I started the loading mode, and I will launch the exploit.  So basically the exploit will flash the partitions as I described it,  and here you should see the device rebooting,  because there is this little trick I'm not going to explain,  but basically we are flashing some Android partitions to take control over it.  And once it's done, the device will reboot,  and you should see Doge showing up, which means that the exploit worked.  Now we'll have to wait a bit for the device to take a bit of time to start,  so there are some Sumatois in the room.  Maybe this is one of the things that could be improved.  Okay, so I'll connect again to ADB, and we'll see as soon as it's working.  And we are good to start.  To conclude on the first part of this presentation,  we have a chain of two boxes,  which together leads to the execution of the kernel.  It's persistent.  It impacts many Samsung devices of the Galaxy family,  which is based on the Jetpack system and chips,  and we can trigger this through the USB  and take control over the full number as well, which includes Android.  But there are still some secrets in Android  that were stored and protected with the SQL block,  and they are still hidden from us.  So we wanted to show you something complete,  so Daniel will now show you how to decrypt these secrets.  Yes.  So, well, I mean, the talk could be over now, right?  We could all go for lunch and forget about this part.  But if you remember the system architecture from the slide I presented before,  there is this whole part of the system  that goes by the name of Secure World,  which we haven't touched yet,  and is, for the moment at least, still very secure.  We compromised everything that is in the bottom part,  so we took care of Android,  but we haven't touched anything on top of the drive.  So what we want to show for the next ten minutes or so  is that maybe secure is not the best word to describe this part of the world.  And to do so, we're going to start from the secure one.  So just to give you a little bit more context,  the secure monitor is the critical component  that makes sure there can be communication  between the non-secure world and the secure world.  So what happens?  Imagine that there is, at some point,  some application or some system service in the Android system  that wants to perform an operation that needs to happen in the secure world.  Well, there will be a chain of calls.  For example, it's an encryption with a key.  So you will have a chain of calls that end up in the HAL layer.  This, at some point, will also point out to a daemon  that will talk to the kernel,  and the kernel, at some point, will send an SMC,  which is a special instruction in ARM chips  that triggers an exception that will be handled by the DL3 monitor.  So the kernel triggers the SMC,  the monitor takes it,  and based on that, decides what to do.  Basically, either it solves whatever needs to be done internally in the monitor,  or it forwards the request to the deepest kernel,  which will probably, in turn, talk with the key master.  So, why do we want to look at the monitor?  Because that's the most critical component, right?  Whatever needs to go to the secure world passes through the monitor.  And also, because the code is pretty simple,  you have these handlers,  and these handlers are reachable from the kernel.  However, the code is, as I said, simple.  There's a lot of other interactions,  so fuzzing is not really feasible.  What we meant to do with this code was just static analysis.  So we talked about Tgress a little bit.  I'll go quickly over it, because we are actually running out of time.  But this is the OS for Tressall designed by Samsung.  It comes with different partitions that include different components  that magically come together.  If you want to learn more about it, actually,  we're not going to do much here.  But there are obviously very good references  from research that happened in the past,  for example, Rescure published a series of proposals  that were very interesting and useful.  So obviously, ATF is also a source, or at least this version.  So what we do is we take the image,  and we want to look for the part where there is a header  with a signature,  the very code starts where you see the MTKTB magic, in some sense.  And when you load it in your favorite disassembler,  the thing you want to look for is SMC headers.  So usually there's, well, in this case, there's two.  One is because there's two ways the communication can happen.  Either the header wants to talk to the secure board,  or the secure board wants to talk to the kernel.  The interesting one for us is the one exposed to the kernel.  And then you have these arguments that are literally the registers  that are set to be for encoding the SMC.  So we started looking at these SMC headers,  and we very quickly ended up on some interesting ones.  So this is the one corresponding to that SMC ID.  And as you can see, it almost feels like a read,  arbitrary read-read, right?  Because you have an argument that is fully controlled by the attacker,  fed into some array, and the header is returned.  But the argument isn't really ever checked.  Which means anyone can talk to this,  anyone that can talk to this SMC header  can essentially read the subheader in the SMC,  in the ATX memory.  So this means we have an interesting read primitive  that, however, only gives us access to the memory  of the other space of the monitor.  Which is still pretty interesting,  but it can't really give us much,  because of other software.  Because the interesting secrets actually  lay in the trusted applications, usually.  So it would be actually nice if we could map the secrets we wanted  right into the other space of DTF.  Well, it turns out that  there is actually a way to do that,  and it's actually not so complicated.  There is another SMC header  that corresponds to the ID you see on the slides now.  Here, SPM actions is, again, after your name.  It's the one we gave while doing reverse engineering.  But we guess it has something to do with power management.  And what happens is that  you can pass an address  and a size to this function  that comes from the arguments,  and basically go over every value.  So you can tell the monitor,  please map in your other space  from this address, this size.  And these arguments are actually the same.  So we get to another vulnerability,  which perhaps by itself is not extremely serious,  because you just map memory.  But given the fact that we have the previous vulnerability,  if we combine them,  it means that we can map arbitrary memory  from the secure world,  and then read it back.  The only limit is that we are limited to 8 megabytes.  Then, since we cannot unmap,  the system will start to be quite unstable.  But that's not a big deal.  That's still a lot of space,  a lot of stuff that we can do.  And actually, we can use this vulnerability  to end up leaking a key store of keys,  which is kind of the ultimate level  of things that you want to leak.  I will be quick, I swear.  There is three professional databases  that have 400 keys, essentially.  You can have software keys,  TEE protected keys,  which is the case we are going to describe now,  and then strongbox protected keys,  which are keys that will end up being used  in security chips for the phones that have them.  The idea is that the raw key material  should never be the protected environment  in the longest.  So the way it happens actually in practice  is that the normal world,  as we saw before,  at some point we want to perform  some operation with the key.  So the key is actually stored in the file system  in a printed form.  So it will send this key  to the environment of choice,  either the keymaster trusted application  or the trusted chip,  again, when the phone has one.  And this thing will take the key  out of this blob  using some secrets that are internal  to the TA of the chip,  use the key,  and then return the result of the operation  without ever revealing that key.  So the content of the key  is what we want to leak.  And how can we do that?  Again, we described the bugs before  and we want to look for the keymaster memory.  So we're going to ask,  where is the keymaster memory?  We have some logs that are easily available.  These are little kernel logs.  We know it says k-message  where k is little kernel in this case.  Or at least it's very good  if the little kernel messages end up here.  And we have some physical addresses  that are expressed here.  There's one that looks pretty interesting.  It says TEE reserve.  And when it turns out that  that's where keymaster  and the other trusted applications  are loaded in memory.  You can tell that because of the many strings  that the trusted applications have.  And again, the binaries are stored in memory,  so you can pretty much compare these strings  and make sure that you're looking at the right thing.  So at this point, our bug becomes  more or less clear, I guess.  We import a key into the Android Keystore.  We encrypt using that key.  But we stop the execution  right after we begin operations.  So in a moment where the key will be present  in plain text in the memory of the keymaster TA.  And then we need it.  So translated to code,  this is something like this.  We are importing, actually, a key that we already know.  And we will explain later why.  But obviously, any key can be used.  So going over the same schema again,  we cook the keymaster HAL  to intercept the execution  right at the moment where we can be.  And then, when we actually do the leak,  we see the key appearing  in the buffer that we read.  But yeah, so again, we are leaking a key we already knew.  So we could do better than this.  But again, this is really just for practicality.  The thing is that you see around,  there's a bunch of almost random things.  We could figure out the right offsets,  but maybe they change.  Who knows? It's easier to enforce.  At the end of the day, there are not that many options.  So we can try all possible keys  from the leak to the cipher,  the ciphertext that we actually have.  And we will be able to actually find the key  even if we didn't know.  So to show you this, we have another decoder  for which I'm going to need Max again.  So no need for the camera this time,  because we...  So we prepared a little demo application  which is going to appear on the screen soon,  which essentially does what you have seen from before.  So I'm going to wait for Max to launch the script  that will give us...  that will use Frida to intercept the messages  that we care about.  So here now he's launching the Frida server.  By the way, Frida is a common instrumentation framework  that I haven't introduced because  many people know about it.  But if you don't, have a look. It's really cool.  So when you look at the logs,  just because you are going to be logging  some, like the ciphertext,  just to make it easier to watch.  And can I...  So I'm going to write my dirty secret here.  Encrypt.  And here in the logs, if stuff is working...  Yes.  You're going to be able to see  the ciphertext and the initialization vector.  Now once we have done that,  we can use the script I explained about.  Actually, I haven't fully explained how to do it  because we have to be in the kernel, right?  So we wrote the custom kernel module  that will be able to send the SMC code.  We haven't gone over that part  because it's maybe the least interesting.  But anyway, we end up leaking some memory  out of the ATF address space,  which is stored in the sub-graphical file system.  So now Max is pulling it from...  the...  in this file system,  and then we launch a script  that will try all the possibilities in this link  to find the secret  using the ciphertext and ID that we...  that we got.  So yeah, that's just a little bit of Base64 magic.  A bit of pressure on Max  that missed the typo in this.  Maybe you can raise the sign with the time again.  Out of time.  All right.  And then...  Fingers crossed.  The terminalism is helpful once again.  So yeah, the key is...  I mean, we can show you the sources  if they weren't super dirty,  but I'm sure you can trust that we are not.  All right.  So let me go back to the presentation.  Yes.  So, to wrap up,  we presented a total of four vulnerabilities today  that led to bypassing the authentication  that happens in Odin.  And this allowed us to flash an image  that was malicious  and that will be able to execute the vulnerability  in the parsing logic on the meter kernel.  This gave us code execution in the book loader  and then allowed us to  shield backdoor algorithm.  And then using two other bugs in the secure world,  we need some memory  including keys that are supposed to be protected.  So all these vulnerabilities  have been found in low-end Samsung devices.  And as you can see,  they're relatively simple at the end of the day  but very impactful  also due to the lack of mitigations that we found  in the various components that we exploited.  So this kind of shows how challenging it is  to manufacture these devices  and maintain security features  especially when they're very good  but at the same time it's also unfortunate  because they were relatively low-end devices.  But anyway, all the vulnerabilities are now fixed  and we also thank Samsung that was super reactive  making sure that these get patches.  And with that, we are done.