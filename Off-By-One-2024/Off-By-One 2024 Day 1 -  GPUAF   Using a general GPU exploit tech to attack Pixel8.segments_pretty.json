{
  "segments": [
    {
      "Time_Start": 0.0,
      "Time_End": 10.0,
      "Text": "This text was transcribed using whisper model: large-v2\n\n Today, everyone, today we will research into a top-level GPU exploit technique to target"
    },
    {
      "Time_Start": 10.0,
      "Time_End": 12.0,
      "Text": " the PSoS kernel."
    },
    {
      "Time_Start": 12.0,
      "Time_End": 19.0,
      "Text": " GPU-UoF, short for GPU-Patch-Level-Use-Factor-Free, represents an approach to exploit vulnerability"
    },
    {
      "Time_Start": 19.0,
      "Time_End": 21.0,
      "Text": " within the PSoS kernel."
    },
    {
      "Time_Start": 21.0,
      "Time_End": 27.0,
      "Text": " In this presentation, we show that how GPU can exploit from a limited vulnerability,"
    },
    {
      "Time_Start": 27.0,
      "Time_End": 30.0,
      "Text": " transform into a full and complete exploit."
    },
    {
      "Time_Start": 31.0,
      "Time_End": 35.0,
      "Text": " Hi, I'm Billy, currently working at Star Labs."
    },
    {
      "Time_Start": 35.0,
      "Time_End": 38.0,
      "Text": " I am focused on the Linux kernel and Android kernel."
    },
    {
      "Time_Start": 38.0,
      "Time_End": 42.0,
      "Text": " Hi, everyone, I'm Peter, currently working at Star Labs."
    },
    {
      "Time_Start": 42.0,
      "Time_End": 45.0,
      "Text": " I'm focusing on iOS and Android kernel."
    },
    {
      "Time_Start": 47.0,
      "Time_End": 53.0,
      "Text": " Today, we will focus on two areas, ARP analysis and GPU-UoF exploit."
    },
    {
      "Time_Start": 53.0,
      "Time_End": 58.0,
      "Text": " In this introduction, we will briefly discuss how modern Android kernel can protect the"
    },
    {
      "Time_Start": 58.0,
      "Time_End": 60.0,
      "Text": " attacker from a privileged escalation."
    },
    {
      "Time_Start": 60.0,
      "Time_End": 67.0,
      "Text": " First, we will examine the recent ARP report, their root cause and demand, and the patch"
    },
    {
      "Time_Start": 67.0,
      "Time_End": 69.0,
      "Text": " to enhance the system security."
    },
    {
      "Time_Start": 69.0,
      "Time_End": 76.0,
      "Text": " Next, we will explore the GPU-UoF exploit, understand its mechanism, the vulnerability"
    },
    {
      "Time_Start": 76.0,
      "Time_End": 81.0,
      "Text": " exploit, and how we can get rid of the lost modern protection."
    },
    {
      "Time_Start": 81.0,
      "Time_End": 89.0,
      "Text": " Finally, in the conclusion, we will summarize our thoughts and their implementation on our technology."
    },
    {
      "Time_Start": 91.0,
      "Time_End": 98.0,
      "Text": " Our research focuses on Android 14 with Linux kernel 5.10 and up."
    },
    {
      "Time_Start": 98.0,
      "Time_End": 105.0,
      "Text": " Privileged access network and privileged execution network protect kernel space to intentionally"
    },
    {
      "Time_Start": 105.0,
      "Time_End": 108.0,
      "Text": " access and execute from the user space."
    },
    {
      "Time_Start": 108.0,
      "Time_End": 114.0,
      "Text": " UAO uses SS override against the common address limit override."
    },
    {
      "Time_Start": 114.0,
      "Time_End": 121.0,
      "Text": " PSE is a security feature that addresses and encrypts calls to the pointer to verify their"
    },
    {
      "Time_Start": 121.0,
      "Time_End": 125.0,
      "Text": " security and prevent control for hijacking attacks."
    },
    {
      "Time_Start": 125.0,
      "Time_End": 132.0,
      "Text": " MTE is a hardware-based security feature that adds memory tags to each data wall to detect"
    },
    {
      "Time_Start": 132.0,
      "Time_End": 139.0,
      "Text": " and mitigate memory-safe vulnerabilities such as buffer flow, overflow, and UAF errors."
    },
    {
      "Time_Start": 140.0,
      "Time_End": 146.0,
      "Text": " KSALR is a security technique that recognizes the location of the kernel memory to prevent"
    },
    {
      "Time_Start": 146.0,
      "Time_End": 152.0,
      "Text": " memory-based attacks, making it harder for the attacker to predict the memory layout"
    },
    {
      "Time_Start": 152.0,
      "Time_End": 153.0,
      "Text": " of the kernel."
    },
    {
      "Time_Start": 153.0,
      "Time_End": 160.0,
      "Text": " Configure initial stack or rerun to initialize everything on the stack with a rerun variable."
    },
    {
      "Time_Start": 160.0,
      "Time_End": 167.0,
      "Text": " Configure initial allocative OR to initialize everything on the heap with a rerun."
    },
    {
      "Time_Start": 167.0,
      "Time_End": 172.0,
      "Text": " Configure debug list to check the linked list activity."
    },
    {
      "Time_Start": 172.0,
      "Time_End": 179.0,
      "Text": " Select free list random, then pick a patch from the free list to prevent easily heap"
    },
    {
      "Time_Start": 179.0,
      "Time_End": 185.0,
      "Text": " overflow, and some other independent mitigations that Samsung cannot anticipate."
    },
    {
      "Time_Start": 186.0,
      "Time_End": 193.0,
      "Text": " UAO is a notable mitigation for the address limit issue involving overriding unprivileged"
    },
    {
      "Time_Start": 193.0,
      "Time_End": 198.0,
      "Text": " load, store, and instruction, typically used in a function like copy from user and copy"
    },
    {
      "Time_Start": 198.0,
      "Time_End": 201.0,
      "Text": " to user, when in the kernel DS."
    },
    {
      "Time_Start": 201.0,
      "Time_End": 207.0,
      "Text": " Before the introduction of the UAO, operations like the run to the kernel buffer followed"
    },
    {
      "Time_Start": 207.0,
      "Time_End": 211.0,
      "Text": " by the read to the user spec will function normally."
    },
    {
      "Time_Start": 211.0,
      "Time_End": 215.0,
      "Text": " However, with UAO enabled, this scenario will change."
    },
    {
      "Time_Start": 215.0,
      "Time_End": 221.0,
      "Text": " Run to the kernel buffer is unaffected, but read from the user spec will trigger a fault"
    },
    {
      "Time_Start": 221.0,
      "Time_End": 224.0,
      "Text": " due to the privileged access scenario."
    },
    {
      "Time_Start": 225.0,
      "Time_End": 232.0,
      "Text": " MTE memory tag extension has support in the KSAL app, represents one of the most powerful"
    },
    {
      "Time_Start": 232.0,
      "Time_End": 235.0,
      "Text": " mitigations available against memory-based attacks."
    },
    {
      "Time_Start": 235.0,
      "Time_End": 241.0,
      "Text": " By running the setProperty command, user can enable MTE."
    },
    {
      "Time_Start": 241.0,
      "Time_End": 246.0,
      "Text": " Many blocks have been mentioned already, such as MTE execution."
    },
    {
      "Time_Start": 246.0,
      "Time_End": 253.0,
      "Text": " Essentially, MTE function is a hardware-supported sanitizer, capable to detect and mitigate"
    },
    {
      "Time_Start": 253.0,
      "Time_End": 255.0,
      "Text": " memory-safe vulnerability."
    },
    {
      "Time_Start": 255.0,
      "Time_End": 262.0,
      "Text": " Even in the event of a fault during the check, MTE will cause the kernel to crash, but the"
    },
    {
      "Time_Start": 262.0,
      "Time_End": 264.0,
      "Text": " target process will be killed."
    },
    {
      "Time_Start": 265.0,
      "Time_End": 273.0,
      "Text": " This configure is a way to enhance security in more presentable use of virtual addresses"
    },
    {
      "Time_Start": 273.0,
      "Time_End": 275.0,
      "Text": " for the cache or ROM."
    },
    {
      "Time_Start": 275.0,
      "Time_End": 282.0,
      "Text": " Similar to the ROM BA sequencer feature found in iOS and macOS, this approach ensures that"
    },
    {
      "Time_Start": 282.0,
      "Time_End": 289.0,
      "Text": " the virtual addresses are pinned to the special cache or ROM region, with the physical memory"
    },
    {
      "Time_Start": 289.0,
      "Time_End": 293.0,
      "Text": " only recycled during the compilation process."
    },
    {
      "Time_Start": 293.0,
      "Time_End": 299.0,
      "Text": " Implementation of this feature will significantly mitigate the risk of the fault cache or ROM"
    },
    {
      "Time_Start": 299.0,
      "Time_End": 300.0,
      "Text": " exploit."
    },
    {
      "Time_Start": 300.0,
      "Time_End": 306.0,
      "Text": " Secondly, it is worth noting that this feature has not yet been introduced on the Android"
    },
    {
      "Time_Start": 306.0,
      "Time_End": 307.0,
      "Text": " platform."
    },
    {
      "Time_Start": 308.0,
      "Time_End": 313.0,
      "Text": " This configure is to introduce multiple general-use cache for each size."
    },
    {
      "Time_Start": 313.0,
      "Time_End": 321.0,
      "Text": " Similar to the KMLK type found on iOS and macOS, KMLK updates by the KMLK to one of"
    },
    {
      "Time_Start": 321.0,
      "Time_End": 323.0,
      "Text": " the multiple caches."
    },
    {
      "Time_Start": 323.0,
      "Time_End": 328.0,
      "Text": " This approach reduces the success rate of the hit-or-run bugs."
    },
    {
      "Time_Start": 329.0,
      "Time_End": 332.0,
      "Text": " Specifically, enhance the security."
    },
    {
      "Time_Start": 333.0,
      "Time_End": 337.0,
      "Text": " This feature has not yet been enabled on the Android platform."
    },
    {
      "Time_Start": 338.0,
      "Time_End": 347.0,
      "Text": " Cannot detect a physical cache, and enhanced SES networks could be a major security mitigation"
    },
    {
      "Time_Start": 347.0,
      "Time_End": 349.0,
      "Text": " in the Android ecosystem."
    },
    {
      "Time_Start": 349.0,
      "Time_End": 355.0,
      "Text": " KNOW-ELO2, performed at a high-hypervisor level, provides a security-execution environment"
    },
    {
      "Time_Start": 355.0,
      "Time_End": 360.0,
      "Text": " while defending only a long-run-to-do operation in the file list."
    },
    {
      "Time_Start": 360.0,
      "Time_End": 367.0,
      "Text": " Physical cache, as well, redundantizes the physical memory layout against memory-based"
    },
    {
      "Time_Start": 367.0,
      "Time_End": 368.0,
      "Text": " attacks."
    },
    {
      "Time_Start": 368.0,
      "Time_End": 376.0,
      "Text": " Additionally, enhanced SES networks that use more restricted policies or disable kernel"
    },
    {
      "Time_Start": 376.0,
      "Time_End": 377.0,
      "Text": " configurations."
    },
    {
      "Time_Start": 377.0,
      "Time_End": 382.0,
      "Text": " SES networks deliver, make kernels always enforced and could not be disabled."
    },
    {
      "Time_Start": 383.0,
      "Time_End": 389.0,
      "Text": " Many researches have uncovered exploit privileges within the kernel mainstream, particularly"
    },
    {
      "Time_Start": 389.0,
      "Time_End": 394.0,
      "Text": " targeting the vulnerability such as write-on-the-read-only-page bugs."
    },
    {
      "Time_Start": 395.0,
      "Time_End": 404.0,
      "Text": " Violations liberate structures like a structure buffer in a 30-page attack, or spring user"
    },
    {
      "Time_Start": 404.0,
      "Time_End": 410.0,
      "Text": " control data into the kernel structure, including the type data page, SK-bundled data and AIO"
    },
    {
      "Time_Start": 410.0,
      "Time_End": 411.0,
      "Text": " page."
    },
    {
      "Time_Start": 411.0,
      "Time_End": 417.0,
      "Text": " Additionally, there is a considered interest in exploiting vulnerability alone or obstructing"
    },
    {
      "Time_Start": 417.0,
      "Time_End": 422.0,
      "Text": " physical rewrites by compromising the page table."
    },
    {
      "Time_Start": 424.0,
      "Time_End": 430.0,
      "Text": " There is also an introduced target amount research in target GPU bugs."
    },
    {
      "Time_Start": 430.0,
      "Time_End": 436.0,
      "Text": " However, it is necessary to consider whether the GPU can be exploited by the bug or literally"
    },
    {
      "Time_Start": 436.0,
      "Time_End": 438.0,
      "Text": " outside of the GPU itself."
    },
    {
      "Time_Start": 438.0,
      "Time_End": 444.0,
      "Text": " A large GPU vulnerability used in the wild has been detected by the corporeal link as"
    },
    {
      "Time_Start": 444.0,
      "Time_End": 446.0,
      "Text": " shown in the picture."
    },
    {
      "Time_Start": 448.0,
      "Time_End": 450.0,
      "Text": " Let's start at the bug analysis."
    },
    {
      "Time_Start": 451.0,
      "Time_End": 458.0,
      "Text": " We recently do research into the bug hunting, a hardware device used by the Kerala subsystem"
    },
    {
      "Time_Start": 458.0,
      "Time_End": 460.0,
      "Text": " user for a certain purpose."
    },
    {
      "Time_Start": 460.0,
      "Time_End": 468.0,
      "Text": " This device, accessed through the device LWIS by a system user with Kerala health contents,"
    },
    {
      "Time_Start": 468.0,
      "Time_End": 474.0,
      "Text": " has been associated with the page table highlighted in the resource security printing."
    },
    {
      "Time_Start": 474.0,
      "Time_End": 478.0,
      "Text": " We decided to give it a shot since we are new to the Android."
    },
    {
      "Time_Start": 478.0,
      "Time_End": 480.0,
      "Text": " Here is how we uncovered."
    },
    {
      "Time_Start": 481.0,
      "Time_End": 491.0,
      "Text": " During our bug hunting, we discovered a denial-of-service vulnerability residing in the LWIS IOControlHandle"
    },
    {
      "Time_Start": 491.0,
      "Time_End": 493.0,
      "Text": " command packing function."
    },
    {
      "Time_Start": 493.0,
      "Time_End": 499.0,
      "Text": " This vulnerability arises from the usage of the file loop to copy IOControlMessaging links"
    },
    {
      "Time_Start": 499.0,
      "Time_End": 501.0,
      "Text": " from the user's back."
    },
    {
      "Time_Start": 501.0,
      "Time_End": 508.0,
      "Text": " Such an implementation leaves the system vulnerability to explode, potentially leading to the DOS"
    },
    {
      "Time_Start": 508.0,
      "Time_End": 509.0,
      "Text": " attack."
    },
    {
      "Time_Start": 510.0,
      "Time_End": 517.0,
      "Text": " By manipulating and using the linked list to point to the expel, the attack can trigger"
    },
    {
      "Time_Start": 517.0,
      "Time_End": 522.0,
      "Text": " a dead loop, resulting in a system-free and unresponsive state."
    },
    {
      "Time_Start": 523.0,
      "Time_End": 531.0,
      "Text": " We have identified another bug named IntegerOverflowVulnerability, which is a prepareResponseLock function."
    },
    {
      "Time_Start": 531.0,
      "Time_End": 539.0,
      "Text": " This vulnerability occurs when calculating to see if the maximum value of the integer"
    },
    {
      "Time_Start": 539.0,
      "Time_End": 541.0,
      "Text": " can be represented."
    },
    {
      "Time_Start": 542.0,
      "Time_End": 550.0,
      "Text": " Where the TransactionResponseBuffer was allocated based on the overflow response size value."
    },
    {
      "Time_Start": 552.0,
      "Time_End": 559.0,
      "Text": " LWIS process transaction in the queue is invoked by another kernel thread, leading to the call"
    },
    {
      "Time_Start": 559.0,
      "Time_End": 565.0,
      "Text": " to process IO entries, which triggers an outbound SS issue."
    },
    {
      "Time_Start": 566.0,
      "Time_End": 573.0,
      "Text": " To address this vulnerability, the patch involves incrementing a check step to check the read"
    },
    {
      "Time_Start": 573.0,
      "Time_End": 578.0,
      "Text": " buffer size before allocating memory for the read buffer type."
    },
    {
      "Time_Start": 578.0,
      "Time_End": 584.0,
      "Text": " Verify the read buffer size before allocating, the patch presents a potential integer overflow"
    },
    {
      "Time_Start": 584.0,
      "Time_End": 586.0,
      "Text": " or outbound SS."
    },
    {
      "Time_Start": 587.0,
      "Time_End": 593.0,
      "Text": " An outbound SS vulnerability within the LWIS InitializedTransactionBase function."
    },
    {
      "Time_Start": 593.0,
      "Time_End": 602.0,
      "Text": " This vulnerability arises due to the failure to properly initialize certain transaction"
    },
    {
      "Time_Start": 602.0,
      "Time_End": 610.0,
      "Text": " structures, such as those created by the structure TransactionFromCommit function used from the"
    },
    {
      "Time_Start": 610.0,
      "Time_End": 612.0,
      "Text": " CopyFromUser function."
    },
    {
      "Time_Start": 613.0,
      "Time_End": 620.0,
      "Text": " This vulnerability, from the fact that the value of the InforTriggerConfigurationNumber"
    },
    {
      "Time_Start": 620.0,
      "Time_End": 626.0,
      "Text": " node, which determines the number of nodes, is entirely controlled by the user."
    },
    {
      "Time_Start": 626.0,
      "Time_End": 633.0,
      "Text": " A tech can use this value, potentially lead to an outbound SS and memory compilation issue."
    },
    {
      "Time_Start": 634.0,
      "Time_End": 641.0,
      "Text": " To enhance the LWIS InitializedTransactionBase function, it adding a chain to keep the number"
    },
    {
      "Time_Start": 641.0,
      "Time_End": 648.0,
      "Text": " of nodes under the sum estimate value, if the number of nodes is type size, which cannot"
    },
    {
      "Time_Start": 648.0,
      "Time_End": 650.0,
      "Text": " be a whole additive value."
    },
    {
      "Time_Start": 651.0,
      "Time_End": 655.0,
      "Text": " I think there is no need to check for the active number."
    },
    {
      "Time_Start": 657.0,
      "Time_End": 663.0,
      "Text": " After the contractual transaction from the commit function, the canSenseTransactionValue"
    },
    {
      "Time_Start": 663.0,
      "Time_End": 666.0,
      "Text": " node is used and is sanitized."
    },
    {
      "Time_Start": 666.0,
      "Time_End": 674.0,
      "Text": " Immediately after work, perform another sanitization check, once it is successful to ensure the"
    },
    {
      "Time_Start": 674.0,
      "Time_End": 677.0,
      "Text": " integrity and security of the transaction data."
    },
    {
      "Time_Start": 679.0,
      "Time_End": 687.0,
      "Text": " We also have discovered a vulnerability in the LWIS AccomplishedFetch function, specifically"
    },
    {
      "Time_Start": 687.0,
      "Time_End": 689.0,
      "Text": " considered as a type confuse."
    },
    {
      "Time_Start": 689.0,
      "Time_End": 695.0,
      "Text": " This vulnerability arises from the pursuit of the file type without properly verification."
    },
    {
      "Time_Start": 697.0,
      "Time_End": 704.0,
      "Text": " To address this vulnerability in the LWIS EndingCompletionFetch function, to evoke type"
    },
    {
      "Time_Start": 704.0,
      "Time_End": 707.0,
      "Text": " confuse, a patch has been written."
    },
    {
      "Time_Start": 707.0,
      "Time_End": 714.0,
      "Text": " This patch evokes to modify the structural LWIS fetch to include a new field name, structural"
    },
    {
      "Time_Start": 714.0,
      "Time_End": 716.0,
      "Text": " ID as a possible file."
    },
    {
      "Time_Start": 716.0,
      "Time_End": 723.0,
      "Text": " By introducing this new field, the patch to provide a clearer indication of the structural"
    },
    {
      "Time_Start": 723.0,
      "Time_End": 724.0,
      "Text": " type."
    },
    {
      "Time_Start": 726.0,
      "Time_End": 731.0,
      "Text": " Then, directly access the LWIS EndingCompletionFetch field as a patch."
    },
    {
      "Time_Start": 731.0,
      "Time_End": 736.0,
      "Text": " The patch introduces a chain to the structural ID field."
    },
    {
      "Time_Start": 737.0,
      "Time_End": 743.0,
      "Text": " This chain ensures that the structural being patched as a patch is correctly identified"
    },
    {
      "Time_Start": 743.0,
      "Time_End": 746.0,
      "Text": " by its structural ID."
    },
    {
      "Time_Start": 747.0,
      "Time_End": 750.0,
      "Text": " Next, Bangden, Peter and Yu."
    },
    {
      "Time_Start": 753.0,
      "Time_End": 757.0,
      "Text": " I will explain the next four bugs and exploit techniques."
    },
    {
      "Time_Start": 758.0,
      "Time_End": 766.0,
      "Text": " Bug 5, this issue shares the same cause as the previous integer overflow, but is from"
    },
    {
      "Time_Start": 766.0,
      "Time_End": 768.0,
      "Text": " a different calling path."
    },
    {
      "Time_Start": 768.0,
      "Time_End": 776.0,
      "Text": " Both entry.readWriteBatchSizingBytes and info.numL entries are user control values, which can"
    },
    {
      "Time_Start": 776.0,
      "Time_End": 780.0,
      "Text": " lead to an overflow of the read buffer size."
    },
    {
      "Time_Start": 781.0,
      "Time_End": 787.0,
      "Text": " This patch mitigates the read buffer size overflow by checking in each loop if adding"
    },
    {
      "Time_Start": 787.0,
      "Time_End": 795.0,
      "Text": " the readWriteBatchSizingBytes to the read buffer size will cause an overflow."
    },
    {
      "Time_Start": 795.0,
      "Time_End": 801.0,
      "Text": " If an overflow is detected, the process will bail out and return an overflow error code."
    },
    {
      "Time_Start": 802.0,
      "Time_End": 807.0,
      "Text": " This type confusion bug shares the same root cause as before."
    },
    {
      "Time_Start": 807.0,
      "Time_End": 814.0,
      "Text": " It directly converts the 5-pointer private data to a specific struct without verifying"
    },
    {
      "Time_Start": 814.0,
      "Time_End": 816.0,
      "Text": " its actual type."
    },
    {
      "Time_Start": 816.0,
      "Time_End": 822.0,
      "Text": " Additionally, although there is a check to see if the LWIS FenceFD and the FenceFD are"
    },
    {
      "Time_Start": 822.0,
      "Time_End": 827.0,
      "Text": " the same, this can be easily faked and lead to further harm."
    },
    {
      "Time_Start": 828.0,
      "Time_End": 835.0,
      "Text": " Since it shares the same root cause, Google now uses its newly designed function LWIS"
    },
    {
      "Time_Start": 835.0,
      "Time_End": 840.0,
      "Text": " FenceGap to perform the root type check based on the structure ID and FenceFD."
    },
    {
      "Time_Start": 840.0,
      "Time_End": 846.0,
      "Text": " This approach is more robust and harder to bypass with a different type of private data."
    },
    {
      "Time_Start": 848.0,
      "Time_End": 854.0,
      "Text": " And bug 7 is an uninitialized bug in the constructTransactionFromCommand function."
    },
    {
      "Time_Start": 854.0,
      "Time_End": 861.0,
      "Text": " The kTransaction variable is allocated from kmerk from the kernel heap, while some fields"
    },
    {
      "Time_Start": 861.0,
      "Time_End": 866.0,
      "Text": " in it will later be used and they are never initialized."
    },
    {
      "Time_Start": 867.0,
      "Time_End": 874.0,
      "Text": " The transaction variable here is actually passed from the previously allocated kTransaction"
    },
    {
      "Time_Start": 874.0,
      "Time_End": 881.0,
      "Text": " and the nonTriggerFences field is not initialized since the nonTriggerFences is an integer type."
    },
    {
      "Time_Start": 882.0,
      "Time_End": 888.0,
      "Text": " So if it initializes with a negative value, it could bypass the highlighted check here"
    },
    {
      "Time_Start": 888.0,
      "Time_End": 890.0,
      "Text": " and cause an auto-unaccess."
    },
    {
      "Time_Start": 890.0,
      "Time_End": 896.0,
      "Text": " However, the config on pixel 8 reveals that the kernel is compiled with init all zero"
    },
    {
      "Time_Start": 896.0,
      "Time_End": 901.0,
      "Text": " mitigation, ensuring all stack and heap memory is initialized to zero."
    },
    {
      "Time_Start": 901.0,
      "Time_End": 905.0,
      "Text": " Therefore, this cannot be exploited under the current config."
    },
    {
      "Time_Start": 905.0,
      "Time_End": 909.0,
      "Text": " Nonetheless, other models without this config remain vulnerable."
    },
    {
      "Time_Start": 911.0,
      "Time_End": 917.0,
      "Text": " And I'm not sure which specific commit patched this, but after emerging from the Android"
    },
    {
      "Time_Start": 917.0,
      "Time_End": 924.0,
      "Text": " 15 DB branch, the kzalloc replaced the kmerk and this change ensures that even without"
    },
    {
      "Time_Start": 924.0,
      "Time_End": 928.0,
      "Text": " the init all zero mitigation, the bug cannot be used."
    },
    {
      "Time_Start": 929.0,
      "Time_End": 935.0,
      "Text": " And the final bug is the third type confusion bug caused by not checking the real type."
    },
    {
      "Time_Start": 935.0,
      "Time_End": 940.0,
      "Text": " It happens in the LWISTriggerEventAtWeek transaction."
    },
    {
      "Time_Start": 940.0,
      "Time_End": 947.0,
      "Text": " The preconditionedFenceFB here was added in the week transaction by fget."
    },
    {
      "Time_Start": 947.0,
      "Time_End": 952.0,
      "Text": " It seems okay for now because the preconditionedFenceFB is still a general structure."
    },
    {
      "Time_Start": 953.0,
      "Time_End": 960.0,
      "Text": " And later, this variable is used in the loop within the LWISEventTriggeredConditionReady."
    },
    {
      "Time_Start": 960.0,
      "Time_End": 969.0,
      "Text": " In a specific case where the info.triggerCondition.triggerNodes.eventCounter is equal to the LWISEventCounter"
    },
    {
      "Time_Start": 969.0,
      "Time_End": 975.0,
      "Text": " on next occurrence, it will directly take the preconditionedFenceFB's private data"
    },
    {
      "Time_Start": 975.0,
      "Time_End": 979.0,
      "Text": " and translate it to the LWISEvent without further checks."
    },
    {
      "Time_Start": 980.0,
      "Time_End": 987.0,
      "Text": " A fix involves replacing the fetch with the LWISEventFenceGet, of course, same as before."
    },
    {
      "Time_Start": 987.0,
      "Time_End": 991.0,
      "Text": " And additionally, it cracks the inaccurate error code return."
    },
    {
      "Time_Start": 992.0,
      "Time_End": 995.0,
      "Text": " And next comes to our exploit part."
    },
    {
      "Time_Start": 995.0,
      "Time_End": 1000.0,
      "Text": " Here I will introduce a general exploit method and use one of the bugs we discussed before"
    },
    {
      "Time_Start": 1000.0,
      "Time_End": 1004.0,
      "Text": " to get the physical memory read-write on PixelSeries."
    },
    {
      "Time_Start": 1005.0,
      "Time_End": 1010.0,
      "Text": " So in the mobile market, there are three main types of GPUs with its own driver,"
    },
    {
      "Time_Start": 1010.0,
      "Time_End": 1015.0,
      "Text": " the MediaTek's Mali, the Qualcomm's KGSL and Apple's own GPU driver,"
    },
    {
      "Time_Start": 1015.0,
      "Time_End": 1019.0,
      "Text": " and each used by different brands and models of phones."
    },
    {
      "Time_Start": 1019.0,
      "Time_End": 1027.0,
      "Text": " Although PowerVR GPU is there and I think they are not as popular as these three in the mobile market,"
    },
    {
      "Time_Start": 1027.0,
      "Time_End": 1029.0,
      "Text": " so therefore not discussed here."
    },
    {
      "Time_Start": 1031.0,
      "Time_End": 1035.0,
      "Text": " These GPUs share same functionality but implemented differently."
    },
    {
      "Time_Start": 1035.0,
      "Time_End": 1041.0,
      "Text": " For example, they both support memory allocation from the GPU driver, but name is different."
    },
    {
      "Time_Start": 1041.0,
      "Time_End": 1049.0,
      "Text": " Like Mali uses the KBaseAPMM analog, KGSL uses the KGSL IOControlGPU analog,"
    },
    {
      "Time_Start": 1049.0,
      "Time_End": 1054.0,
      "Text": " and Apple uses the C++ device user client new resource."
    },
    {
      "Time_Start": 1054.0,
      "Time_End": 1060.0,
      "Text": " And the difference in the Apple GPU name arises from the unique driver framework called IOKit,"
    },
    {
      "Time_Start": 1060.0,
      "Time_End": 1063.0,
      "Text": " which is the C++ subset."
    },
    {
      "Time_Start": 1065.0,
      "Time_End": 1070.0,
      "Text": " And of course, all these GPU drivers support importing memories from the CPU side."
    },
    {
      "Time_Start": 1070.0,
      "Time_End": 1074.0,
      "Text": " And Mali uses the function called KBaseAPMMImport,"
    },
    {
      "Time_Start": 1074.0,
      "Time_End": 1081.0,
      "Text": " and KGSL uses a flag called MAPFLAGSUSECPUMAP in GPU-alloc functions."
    },
    {
      "Time_Start": 1081.0,
      "Time_End": 1088.0,
      "Text": " As well, Apple uses the same function routine, just specifying a field called IOServiceID in the input struct."
    },
    {
      "Time_Start": 1090.0,
      "Time_End": 1096.0,
      "Text": " And technically, the shrink-layer interface is not specific to the GPUs."
    },
    {
      "Time_Start": 1096.0,
      "Time_End": 1102.0,
      "Text": " It's a mechanism within the memory management subsystem that allows for the freeing of cached items,"
    },
    {
      "Time_Start": 1102.0,
      "Time_End": 1104.0,
      "Text": " so their memory can be repurposed."
    },
    {
      "Time_Start": 1104.0,
      "Time_End": 1110.0,
      "Text": " In Linux, various drivers and subsystems will register their own shrink-layer callback functions,"
    },
    {
      "Time_Start": 1110.0,
      "Time_End": 1117.0,
      "Text": " and when the system is low on memory, these functions are invoked to release memory back to the kernel for other use."
    },
    {
      "Time_Start": 1117.0,
      "Time_End": 1124.0,
      "Text": " In the case of GPUs, we can leverage this mechanism to shrink memory and create a page-user-free primitive."
    },
    {
      "Time_Start": 1125.0,
      "Time_End": 1129.0,
      "Text": " And page-user-free is a strong primitive in Xbox."
    },
    {
      "Time_Start": 1129.0,
      "Time_End": 1137.0,
      "Text": " It can allow us to fake kernel objects from the user space, or fake the page table to read and write arbitrary physical addresses."
    },
    {
      "Time_Start": 1137.0,
      "Time_End": 1145.0,
      "Text": " Many mitigations are based on virtual memory, like KSR, heap isolation, and read-only mappings."
    },
    {
      "Time_Start": 1145.0,
      "Time_End": 1150.0,
      "Text": " If we can reuse the page as a kernel object, or even page tables,"
    },
    {
      "Time_Start": 1150.0,
      "Time_End": 1155.0,
      "Text": " we can easily bypass those mitigations and get a kernel-arbitrary read-write."
    },
    {
      "Time_Start": 1155.0,
      "Time_End": 1159.0,
      "Text": " After reviewing the GPU mechanism, it seems it can give us such a primitive,"
    },
    {
      "Time_Start": 1159.0,
      "Time_End": 1162.0,
      "Text": " and here we will dive into Mali driver for an example."
    },
    {
      "Time_Start": 1164.0,
      "Time_End": 1169.0,
      "Text": " In Mali, the structure kbase-v8-region represents a GPU memory region."
    },
    {
      "Time_Start": 1169.0,
      "Time_End": 1173.0,
      "Text": " It contains the attributes for CPU and GPU-side mapping."
    },
    {
      "Time_Start": 1174.0,
      "Time_End": 1181.0,
      "Text": " In the alloc function routine, Mali will use kbase-mem-alloc with a user-space-passed flag"
    },
    {
      "Time_Start": 1181.0,
      "Time_End": 1188.0,
      "Text": " to alloc memory and return the attributes to the rep variable, which is the kbase-v8-region."
    },
    {
      "Time_Start": 1190.0,
      "Time_End": 1200.0,
      "Text": " In the free function path, it will use the user-provide-gpu-v8 to find the rep structure on the arbitrary maintained kbase context."
    },
    {
      "Time_Start": 1204.0,
      "Time_End": 1211.0,
      "Text": " If the memory region is valid and not free, it will free the structure as well as the memory region represent value."
    },
    {
      "Time_Start": 1211.0,
      "Time_End": 1215.0,
      "Text": " If the memory is invalid, just log error and bail out."
    },
    {
      "Time_Start": 1217.0,
      "Time_End": 1221.0,
      "Text": " After knowing it's allocation and free, we can dive more into the structure itself."
    },
    {
      "Time_Start": 1221.0,
      "Time_End": 1228.0,
      "Text": " Here we can skip those irrelevant parts and only pay attention to the flags and the kbase-mem-physics alloc in here."
    },
    {
      "Time_Start": 1228.0,
      "Time_End": 1233.0,
      "Text": " Flags can show this region is free or not, and the attributes is read-only or read-write."
    },
    {
      "Time_Start": 1233.0,
      "Time_End": 1239.0,
      "Text": " And we can see there's two structure kbase-mem-physics alloc in the kbase-v8-region."
    },
    {
      "Time_Start": 1239.0,
      "Time_End": 1244.0,
      "Text": " It represents the physical memory mapped to CPU or GPU when mapping it."
    },
    {
      "Time_Start": 1246.0,
      "Time_End": 1254.0,
      "Text": " So the struct kbase-mem-physics alloc is a physical pages tracking object and its reference content."
    },
    {
      "Time_Start": 1254.0,
      "Time_End": 1258.0,
      "Text": " The k-reference will record the number of users of this alloc."
    },
    {
      "Time_Start": 1258.0,
      "Time_End": 1263.0,
      "Text": " The gpu-mapping will represent the count number of times mapped on GPU."
    },
    {
      "Time_Start": 1263.0,
      "Time_End": 1270.0,
      "Text": " For example, if we alloc a region in GPU, then we alias it this region, it will pass one for the alias operation."
    },
    {
      "Time_Start": 1271.0,
      "Time_End": 1277.0,
      "Text": " As for kernel-mappings, it's same like gpu-mappings but you record the CPU-side map times."
    },
    {
      "Time_Start": 1277.0,
      "Time_End": 1282.0,
      "Text": " Then comes to the next, it's the number of pages that is valid."
    },
    {
      "Time_Start": 1282.0,
      "Time_End": 1287.0,
      "Text": " Actually, there's other fields will be interesting in exploit, but here is what we need for the tech."
    },
    {
      "Time_Start": 1289.0,
      "Time_End": 1296.0,
      "Text": " More, the structure kbase-mem-physics alloc is an elastic object in the general snap patch."
    },
    {
      "Time_Start": 1296.0,
      "Time_End": 1302.0,
      "Text": " And the size is the base, which is the size of alloc plus 8 multiply the pages."
    },
    {
      "Time_Start": 1302.0,
      "Time_End": 1305.0,
      "Text": " And the pages is controllable by us."
    },
    {
      "Time_Start": 1305.0,
      "Time_End": 1311.0,
      "Text": " We can see from the red line place, it will use the calculated object size to alloc the memory from kzalloc"
    },
    {
      "Time_Start": 1311.0,
      "Time_End": 1316.0,
      "Text": " with the gap-kernel flag, which is also general for using."
    },
    {
      "Time_Start": 1317.0,
      "Time_End": 1323.0,
      "Text": " And one of the IO control called kbase-mem-commit can help us to reach the shrinker function."
    },
    {
      "Time_Start": 1323.0,
      "Time_End": 1327.0,
      "Text": " But to trigger the shrinker, we need to fulfill some requirements."
    },
    {
      "Time_Start": 1327.0,
      "Time_End": 1331.0,
      "Text": " First is gpu-mappings of our memory region should be 0 or 1."
    },
    {
      "Time_Start": 1331.0,
      "Time_End": 1337.0,
      "Text": " And the kernel-mappings should be 0, means a region that only mapped in GPU-side once"
    },
    {
      "Time_Start": 1337.0,
      "Time_End": 1340.0,
      "Text": " and never mapped in CPU-side can be shrinked."
    },
    {
      "Time_Start": 1340.0,
      "Time_End": 1342.0,
      "Text": " Otherwise, it will cause a side effect."
    },
    {
      "Time_Start": 1342.0,
      "Time_End": 1351.0,
      "Text": " Then the shrink new pages need to be less than the old pages to let us enter the kbase-mem-shrink path and shrink the pages."
    },
    {
      "Time_Start": 1353.0,
      "Time_End": 1359.0,
      "Text": " And after the background knowledge expanding, we will introduce the exploit we use here."
    },
    {
      "Time_Start": 1359.0,
      "Time_End": 1366.0,
      "Text": " So if we first allocate the native page from GPU and align this region, the gpu-mapping field should be 2."
    },
    {
      "Time_Start": 1366.0,
      "Time_End": 1373.0,
      "Text": " And since we allocate it in GPU and not imported by the CPU, so the kernel-mapping is always 0."
    },
    {
      "Time_Start": 1373.0,
      "Time_End": 1376.0,
      "Text": " Then we could use the bug to override it to 1."
    },
    {
      "Time_Start": 1376.0,
      "Time_End": 1379.0,
      "Text": " And then we trigger the kbase-mem-commit on it."
    },
    {
      "Time_Start": 1379.0,
      "Time_End": 1384.0,
      "Text": " GPU will shrink the page and return it back to the main pool."
    },
    {
      "Time_Start": 1384.0,
      "Time_End": 1390.0,
      "Text": " After the page is recycled, we will still hold the handle point to the free page by a large region."
    },
    {
      "Time_Start": 1390.0,
      "Time_End": 1393.0,
      "Text": " That's turned out of bound."
    },
    {
      "Time_Start": 1394.0,
      "Time_End": 1397.0,
      "Text": " Relative to a stronger page use of the free page."
    },
    {
      "Time_Start": 1397.0,
      "Time_End": 1403.0,
      "Text": " Another thing is the GPU mapping is usually less than 256."
    },
    {
      "Time_Start": 1403.0,
      "Time_End": 1407.0,
      "Text": " Which means we just write one byte and achieve this."
    },
    {
      "Time_Start": 1409.0,
      "Time_End": 1413.0,
      "Text": " After we have the UAM page, we need to read and write from it."
    },
    {
      "Time_Start": 1413.0,
      "Time_End": 1418.0,
      "Text": " Because we hold the large region handle, which is the GPU virtual memory region,"
    },
    {
      "Time_Start": 1418.0,
      "Time_End": 1422.0,
      "Text": " we can only issue the GPU read and write request to Debian."
    },
    {
      "Time_Start": 1422.0,
      "Time_End": 1425.0,
      "Text": " One of the ways is to use OpenCL."
    },
    {
      "Time_Start": 1425.0,
      "Time_End": 1435.0,
      "Text": " OpenCL is a framework for writing the programs that execute across platforms like CPU, GPU, DSP, FPGA,"
    },
    {
      "Time_Start": 1435.0,
      "Time_End": 1438.0,
      "Text": " and other processors or hardware accelerators."
    },
    {
      "Time_Start": 1438.0,
      "Time_End": 1446.0,
      "Text": " Programming language we use for above-mentioned devices is based on C99, C++14, those standards."
    },
    {
      "Time_Start": 1446.0,
      "Time_End": 1450.0,
      "Text": " Another way is to reverse engineering the GPU instruction set."
    },
    {
      "Time_Start": 1450.0,
      "Time_End": 1453.0,
      "Text": " Luckily, we don't have to do that ourselves."
    },
    {
      "Time_Start": 1453.0,
      "Time_End": 1455.0,
      "Text": " Thanks to the Panverse project."
    },
    {
      "Time_Start": 1455.0,
      "Time_End": 1460.0,
      "Text": " And the IO control for running GPU instructions is the KBase IO control job submit."
    },
    {
      "Time_Start": 1460.0,
      "Time_End": 1463.0,
      "Text": " Each job contains a header and a payload."
    },
    {
      "Time_Start": 1463.0,
      "Time_End": 1466.0,
      "Text": " The type of the job is specified in the header."
    },
    {
      "Time_Start": 1466.0,
      "Time_End": 1472.0,
      "Text": " And the job type write value provides a simple way to write to the GPU address."
    },
    {
      "Time_Start": 1473.0,
      "Time_End": 1476.0,
      "Text": " After knowing how to read and write the UAM pages..."
    },
    {
      "Time_Start": 1481.0,
      "Time_End": 1484.0,
      "Text": " I think we're being attacked by GPU."
    },
    {
      "Time_Start": 1485.0,
      "Time_End": 1491.0,
      "Text": " We need to know how to reuse the pages as an other object, like path struct or page tables."
    },
    {
      "Time_Start": 1491.0,
      "Time_End": 1496.0,
      "Text": " When we allocate memory from GPU, we first allocate from the KContext mempool."
    },
    {
      "Time_Start": 1497.0,
      "Time_End": 1507.0,
      "Text": " If insufficient, we will allocate from the KBDevice mempool."
    },
    {
      "Time_Start": 1507.0,
      "Time_End": 1511.0,
      "Text": " If also insufficient, we will allocate from the kernel."
    },
    {
      "Time_Start": 1511.0,
      "Time_End": 1514.0,
      "Text": " And the free process is like the same sequence."
    },
    {
      "Time_Start": 1514.0,
      "Time_End": 1518.0,
      "Text": " We first add the pages to KContext mempool."
    },
    {
      "Time_Start": 1518.0,
      "Time_End": 1522.0,
      "Text": " If the mempool is full, we add to the KBDevice mempool."
    },
    {
      "Time_Start": 1522.0,
      "Time_End": 1526.0,
      "Text": " If also full, we free the remaining pages back to kernel."
    },
    {
      "Time_Start": 1527.0,
      "Time_End": 1529.0,
      "Text": " To exploit it, we have two options."
    },
    {
      "Time_Start": 1529.0,
      "Time_End": 1533.0,
      "Text": " Option one is to reuse it as GPU PGD."
    },
    {
      "Time_Start": 1533.0,
      "Time_End": 1538.0,
      "Text": " In the structure KBase MMU table, we can see there is a PGD field."
    },
    {
      "Time_Start": 1538.0,
      "Time_End": 1544.0,
      "Text": " It represents the physical address of the page allocated at the top level of each table of the context."
    },
    {
      "Time_Start": 1544.0,
      "Time_End": 1550.0,
      "Text": " In fact, every context maintains their own GPU MMU translation table."
    },
    {
      "Time_Start": 1550.0,
      "Time_End": 1554.0,
      "Text": " And the KContext pointer is pointing to its corresponding KBase context."
    },
    {
      "Time_Start": 1554.0,
      "Time_End": 1560.0,
      "Text": " Just like every user space on the CPU side will have different address space."
    },
    {
      "Time_Start": 1561.0,
      "Time_End": 1567.0,
      "Text": " And in function MMU.getNextPGD, which is called when we try to access the GPU memory."
    },
    {
      "Time_Start": 1567.0,
      "Time_End": 1575.0,
      "Text": " If target PGD is not accessed before, we will allocate now by the KBase MMU allocate PGD from the KBDevice."
    },
    {
      "Time_Start": 1575.0,
      "Time_End": 1579.0,
      "Text": " Then it will add the new allocated PGD to PTE."
    },
    {
      "Time_Start": 1579.0,
      "Time_End": 1583.0,
      "Text": " You may wondering why here is like set PGD to PTE."
    },
    {
      "Time_Start": 1583.0,
      "Time_End": 1592.0,
      "Text": " Since on CPU side, the PGD is the page global directory that manages PMD and PMD manages PD."
    },
    {
      "Time_Start": 1592.0,
      "Time_End": 1595.0,
      "Text": " But I think here is just naming problems."
    },
    {
      "Time_Start": 1595.0,
      "Time_End": 1598.0,
      "Text": " So we don't need to confuse about this part."
    },
    {
      "Time_Start": 1598.0,
      "Time_End": 1603.0,
      "Text": " We can consider the PGD we talk about next as the PTU in CPU."
    },
    {
      "Time_Start": 1604.0,
      "Time_End": 1607.0,
      "Text": " As the code shown before, most address are unused."
    },
    {
      "Time_Start": 1607.0,
      "Time_End": 1611.0,
      "Text": " PGD and PTE are only created when they needed for an access."
    },
    {
      "Time_Start": 1611.0,
      "Time_End": 1616.0,
      "Text": " So the page that inspecting PGD is allocated from the KBDevice mempool."
    },
    {
      "Time_Start": 1616.0,
      "Time_End": 1619.0,
      "Text": " And which is shared by all KContext."
    },
    {
      "Time_Start": 1619.0,
      "Time_End": 1626.0,
      "Text": " Which means with proper mempool function, we can reuse our free pages as GPU PGD."
    },
    {
      "Time_Start": 1628.0,
      "Time_End": 1633.0,
      "Text": " So our step will be first reserve page for spraying PGD later."
    },
    {
      "Time_Start": 1633.0,
      "Time_End": 1636.0,
      "Text": " And arrange the memory to fill up the free list."
    },
    {
      "Time_Start": 1637.0,
      "Time_End": 1645.0,
      "Text": " Then we spray this KBaseMemPhysicAllocStructure and trigger the outer bound to overwrite one of the GPU memory."
    },
    {
      "Time_Start": 1645.0,
      "Time_End": 1650.0,
      "Text": " After KBaseMemCommit shrink and free the page because KContext mempool is full."
    },
    {
      "Time_Start": 1650.0,
      "Time_End": 1653.0,
      "Text": " It will return to KBDevice mempool."
    },
    {
      "Time_Start": 1653.0,
      "Time_End": 1658.0,
      "Text": " Then we allocate some free pages again which we previously reserved."
    },
    {
      "Time_Start": 1658.0,
      "Time_End": 1665.0,
      "Text": " And we will take the memory page we just freed into the KBDevice mempool as the PGD of our new allocated pages."
    },
    {
      "Time_Start": 1667.0,
      "Time_End": 1674.0,
      "Text": " After we use UI page as GPU PGD, we can make GPU virtual address point to arbitrary physical address."
    },
    {
      "Time_Start": 1674.0,
      "Time_End": 1683.0,
      "Text": " By reversing firmware, we can calculate to know kernel global variable physical address such as AC Linux state or code pattern."
    },
    {
      "Time_Start": 1683.0,
      "Time_End": 1688.0,
      "Text": " Use GPU write to modify the AC Linux 0 to disable AC Linux."
    },
    {
      "Time_Start": 1689.0,
      "Time_End": 1694.0,
      "Text": " Even config static user mode helper path is read-only on CPU."
    },
    {
      "Time_Start": 1694.0,
      "Time_End": 1697.0,
      "Text": " But we can mark it as read-write in the GPU PGD."
    },
    {
      "Time_Start": 1697.0,
      "Time_End": 1700.0,
      "Text": " And we can overwrite it with BeanShell."
    },
    {
      "Time_Start": 1700.0,
      "Time_End": 1704.0,
      "Text": " Then we overwrite code pattern to the payload we want to execute by BeanShell."
    },
    {
      "Time_Start": 1704.0,
      "Time_End": 1713.0,
      "Text": " And finally, trigger the segment 4 to trigger the core dump to exploit payload in the root bridge by the code pattern tree."
    },
    {
      "Time_Start": 1713.0,
      "Time_End": 1718.0,
      "Text": " Next, I will pass the bidding for the option to exploit."
    },
    {
      "Time_Start": 1725.0,
      "Time_End": 1742.0,
      "Text": " As we mentioned before, if the next pool does not have the space, KBase allocate page is used to allocate page directly from the kernel."
    },
    {
      "Time_Start": 1742.0,
      "Time_End": 1756.0,
      "Text": " Similarly, in the free case, when all pools are full, return the page back to the kernel, create an opportunity for reuse as another kernel object."
    },
    {
      "Time_Start": 1756.0,
      "Time_End": 1762.0,
      "Text": " We can then reuse the free page as another kernel object to continue the exploit."
    },
    {
      "Time_Start": 1762.0,
      "Time_End": 1768.0,
      "Text": " There is a type of way to achieve kernel address rewrite."
    },
    {
      "Time_Start": 1769.0,
      "Time_End": 1774.0,
      "Text": " The exploit scenario involves several steps."
    },
    {
      "Time_Start": 1774.0,
      "Time_End": 1781.0,
      "Text": " First, we will reserve page in the GPU for later allocation of the PGD."
    },
    {
      "Time_Start": 1781.0,
      "Time_End": 1792.0,
      "Text": " Then, we use impulsory to position a KBase memory physical allocation structure behind the LWS translation response buffer."
    },
    {
      "Time_Start": 1792.0,
      "Time_End": 1797.0,
      "Text": " Trigger an integer overflow to overwrite the GPU memory."
    },
    {
      "Time_Start": 1797.0,
      "Time_End": 1803.0,
      "Text": " And then trigger the memory coming and find out the UAF page."
    },
    {
      "Time_Start": 1803.0,
      "Time_End": 1811.0,
      "Text": " Allocate the reserved page and reuse the UAF page as PGD in the GPU."
    },
    {
      "Time_Start": 1811.0,
      "Time_End": 1819.0,
      "Text": " Use a latency handler to modify the page table entry to point to the physical address we want."
    },
    {
      "Time_Start": 1819.0,
      "Time_End": 1829.0,
      "Text": " We can disable X-initialize app, limit the competent trigger to get root, and launch a virtual shell for example."
    },
    {
      "Time_Start": 1829.0,
      "Time_End": 1841.0,
      "Text": " When we try to port our exploit on the PISO app, we encounter the issue to use a latency handler to modify the PGD point to the physical address."
    },
    {
      "Time_Start": 1842.0,
      "Time_End": 1850.0,
      "Text": " On the PISO-6 device, the KBase IO-control job submit IO-control can be used to write to the GPU memory."
    },
    {
      "Time_Start": 1850.0,
      "Time_End": 1859.0,
      "Text": " However, on the device featuring the CSM competent system feature start from the PISO-7 generation and above,"
    },
    {
      "Time_Start": 1859.0,
      "Time_End": 1868.0,
      "Text": " this specific IO-control may not be compiled or available due to the change of in-system architecture."
    },
    {
      "Time_Start": 1869.0,
      "Time_End": 1881.0,
      "Text": " In this scenario, where the KBase such IO-control is not available, we can resort to use OpenCL GPU memory rewrite operation."
    },
    {
      "Time_Start": 1881.0,
      "Time_End": 1890.0,
      "Text": " Here we can approach it. Use the DLSIM tool and let me point out the necessary functions from the OpenCL library."
    },
    {
      "Time_Start": 1890.0,
      "Time_End": 1896.0,
      "Text": " Initialize our GPU rewrite function. Use the gpurewrite.cl file."
    },
    {
      "Time_Start": 1896.0,
      "Time_End": 1902.0,
      "Text": " This contains the required OpenCL kernel and function for the memory access operation on the GPU."
    },
    {
      "Time_Start": 1902.0,
      "Time_End": 1912.0,
      "Text": " This approach alone performs the GPU memory rewrite operation without the KBase IO-control job submit."
    },
    {
      "Time_Start": 1912.0,
      "Time_End": 1920.0,
      "Text": " Thereby, maintain the physical and access the different device modules and software versions."
    },
    {
      "Time_Start": 1920.0,
      "Time_End": 1924.0,
      "Text": " So we can work our rewrite into the C support."
    },
    {
      "Time_Start": 1924.0,
      "Time_End": 1929.0,
      "Text": " Indeed, use the OpenCL introduces another problem."
    },
    {
      "Time_Start": 1929.0,
      "Time_End": 1938.0,
      "Text": " Due to its automatic create a new memory file descriptor and manage its own GPU address page table."
    },
    {
      "Time_Start": 1939.0,
      "Time_End": 1948.0,
      "Text": " Attached to write to the memory created by the OpenCL, use a different file descriptor will result in page 4 on the GPU side."
    },
    {
      "Time_Start": 1948.0,
      "Time_End": 1960.0,
      "Text": " For more, both screens in the OpenCL FD will break our CPU function, prevent the reuse of the UF page as the PGD."
    },
    {
      "Time_Start": 1961.0,
      "Time_End": 1967.0,
      "Text": " So we use a shell library known as convent tree to hook the OpenCL function."
    },
    {
      "Time_Start": 1967.0,
      "Time_End": 1974.0,
      "Text": " For set up the device and reserve the screen page can ensure the capability with."
    },
    {
      "Time_Start": 1977.0,
      "Time_End": 1985.0,
      "Text": " By interpolate and modify the name of this function, we can reserve the necessary page before GPU opens CL."
    },
    {
      "Time_Start": 1986.0,
      "Time_End": 1992.0,
      "Text": " The memory object cell can contain a region of memory and its different objects."
    },
    {
      "Time_Start": 1992.0,
      "Time_End": 1998.0,
      "Text": " Besides caused by the shrinker mechanism, we can use KFreeze to achieve page UF."
    },
    {
      "Time_Start": 1998.0,
      "Time_End": 2005.0,
      "Text": " Qualcomm GPU or PowerVR GPU should have the similar memory object as Mavic GPU."
    },
    {
      "Time_Start": 2005.0,
      "Time_End": 2012.0,
      "Text": " The exploit properly deploy on the shrinker mechanism to achieve properly escape from the page UF."
    },
    {
      "Time_Start": 2012.0,
      "Time_End": 2021.0,
      "Text": " Without directly engage MTE, the initial outbound as if it detect may trigger a KSL or warning in the deep messenger."
    },
    {
      "Time_Start": 2021.0,
      "Time_End": 2023.0,
      "Text": " Potentially hold the exploit flow."
    },
    {
      "Time_Start": 2023.0,
      "Time_End": 2029.0,
      "Text": " And the chance of detecting the outbound is low from our test, less than 50%."
    },
    {
      "Time_Start": 2029.0,
      "Time_End": 2035.0,
      "Text": " Offer a chance to execute the exploit flow and up the root access."
    },
    {
      "Time_Start": 2035.0,
      "Time_End": 2039.0,
      "Text": " We can run the exploit a few times to expound the root shell."
    },
    {
      "Time_Start": 2039.0,
      "Time_End": 2043.0,
      "Text": " And we can connect our root messenger in the deep messenger."
    },
    {
      "Time_Start": 2045.0,
      "Time_End": 2054.0,
      "Text": " Then we can show the device demo that we use to GPU technique exploit for the integer overload."
    },
    {
      "Time_Start": 2055.0,
      "Time_End": 2057.0,
      "Text": " Okay, so..."
    },
    {
      "Time_Start": 2061.0,
      "Time_End": 2067.0,
      "Text": " So here we can see that MTE is enabled and the AC Linux is enforced."
    },
    {
      "Time_Start": 2067.0,
      "Time_End": 2074.0,
      "Text": " And we trigger the exploit and it quickly pop a reverse shell back above."
    },
    {
      "Time_Start": 2076.0,
      "Time_End": 2082.0,
      "Text": " And we can see that we are the root bridge and AC Linux has been disabled."
    },
    {
      "Time_Start": 2085.0,
      "Time_End": 2091.0,
      "Text": " Okay, so this is our final part."
    },
    {
      "Time_Start": 2091.0,
      "Time_End": 2094.0,
      "Text": " We will do some conclusion based on the previous sharing."
    },
    {
      "Time_Start": 2094.0,
      "Time_End": 2098.0,
      "Text": " Mitigation is sometimes hard, it may be weak from another level."
    },
    {
      "Time_Start": 2098.0,
      "Time_End": 2102.0,
      "Text": " We should think other supports and defeat mitigations by our boosting features."
    },
    {
      "Time_Start": 2102.0,
      "Time_End": 2107.0,
      "Text": " And targets not only have vulnerabilities but also can be part of our exploit path."
    },
    {
      "Time_Start": 2107.0,
      "Time_End": 2111.0,
      "Text": " And with more and more software and hardware mitigations,"
    },
    {
      "Time_Start": 2111.0,
      "Time_End": 2115.0,
      "Text": " exploit 1.0 is harder but with good exploit package is still possible."
    },
    {
      "Time_Start": 2115.0,
      "Time_End": 2120.0,
      "Text": " And finally here are some references we use when we prepare the slide."
    },
    {
      "Time_Start": 2120.0,
      "Time_End": 2122.0,
      "Text": " And you can refer to it."
    },
    {
      "Time_Start": 2122.0,
      "Time_End": 2125.0,
      "Text": " And above is what we share today."
    },
    {
      "Time_Start": 2125.0,
      "Time_End": 2129.0,
      "Text": " It's supposed to be the Q&A session but I think our time is left."
    },
    {
      "Time_Start": 2129.0,
      "Time_End": 2130.0,
      "Text": " We are still around."
    },
    {
      "Time_Start": 2130.0,
      "Time_End": 2133.0,
      "Text": " If you have any question, you can come and ask us."
    },
    {
      "Time_Start": 2133.0,
      "Time_End": 2134.0,
      "Text": " Thank you."
    },
    {
      "Time_Start": 2137.0,
      "Time_End": 2138.0,
      "Text": " Thank you."
    }
  ]
}