{
  "webpage_url": "https://www.youtube.com/watch?v=PmqvBe1LSZc",
  "title": "DEF CON 32 - Defeating EDR Evading Malware with Memory Forensics - Case, Sellers, Richard, et al.",
  "description": "Endpoint detection and response (EDR) software has gained significant market share due to its ability to examine system state for signs of malware and attacker activity well beyond what traditional anti-virus software is capable of detecting. This deep inspection capability of EDRs has led to an arms race with malware developers who want to evade EDRs while still achieving desired goals, such as code injection, lateral movement, and credential theft. This monitoring and evasion occurs in the lowest levels of hardware and software, including call stack frames, exception handlers, system calls, and manipulation of native instructions. Given this reality, EDRs are limited in how much lower they can operate to maintain an advantage. The success of EDR bypasses has led to their use in many high-profile attacks and by prolific ransomware groups.\n\nIn this talk, we discuss our research effort that led to the development of new memory forensics techniques for the detection of the bypasses that malware uses to evade EDRs. This includes bypass techniques, such as direct and indirect system calls, module overwriting, malicious exceptions handlers, and abuse of debug registers. Our developed capabilities were created as new plugins to the Volatility memory analysis framework, version 3, and will be released after the talk.",
  "channel_url": "https://www.youtube.com/channel/UC6Om9kAkl32dWlDSNlDS9Iw",
  "duration": 2627,
  "channel": "DEFCONConference",
  "uploader": "DEFCONConference",
  "upload_date": "20241016"
}

0.62s - 10.90s | This text was transcribed using whisper model: large-v2

 Okay, thank you all for coming to my presentation.
10.90s - 13.84s |  For those who I haven't met before, my name is Andrew Case.
13.84s - 19.38s |  I am a core developer on the Volatility Memory Analysis Project and also the Director of
19.38s - 23.14s |  Research at Vellect City.
23.14s - 28.54s |  At Vellect City, we do a significant amount of incident response and malware analysis
28.54s - 33.46s |  and as part of our research workflow and being on the research team there, we make sure that
33.74s - 38.30s |  for all the malware techniques that we see during our attacks and that we see other vendors
38.30s - 42.96s |  reporting about, any type of malware technique, any attacker toolkit that's really being used
42.96s - 47.80s |  in the wild, we want to make sure that we have a complete understanding of it and also
47.80s - 52.34s |  that we can automatically detect it during our investigations.
52.34s - 57.94s |  To ensure that we meet that goal and meet that reality, we very often perform very targeted,
57.94s - 62.52s |  very specific deep dives on specific techniques that we see the malware using, that we see
62.52s - 67.28s |  attackers using, and then we make sure that we document all the different techniques,
67.28s - 70.84s |  all the different tools that use it, whether they're private tools from threat groups,
70.84s - 76.22s |  whether it's some open source tool that has implemented it, and then we make infected
76.22s - 77.22s |  machines with it.
77.22s - 81.16s |  So we make our infected virtual machines, we make sure all the techniques are active,
81.16s - 85.52s |  we do the deepest memory forensics research we know how to do, which we have most of the
85.52s - 89.60s |  volatility developers at Vellect City, so that's pretty deep, and then we do talks like
89.60s - 91.36s |  this where we publish it.
91.36s - 95.00s |  For one of the latest research projects that we did, that's what I'm going to be talking
95.00s - 101.56s |  to you about today, we looked at all the ways that EDRs were being evaded by real malware.
101.56s - 106.82s |  Because what we noticed in our investigations is that we're working in enterprises, they're
106.82s - 111.66s |  trying to do security correctly, they have EDRs, they have them configured, they're listed
111.66s - 116.80s |  as active on these machines, but over and over again, as we were doing memory forensics,
116.80s - 122.20s |  we were finding very potent malware in the same processes where the EDRs supposedly were.
122.20s - 126.16s |  So obviously we wanted to figure out why that disconnect was happening, and through our
126.16s - 131.64s |  memory forensics work, we wanted to be able to detect it automatically as well.
131.64s - 136.88s |  Because as you'll see as we go through the slides, normally when malware bypasses EDRs,
136.88s - 138.30s |  it's not every process.
138.30s - 142.92s |  It's just the process or the two processes where the malware is running out of directly
142.92s - 145.72s |  or where it's injected code into.
145.72s - 150.88s |  So if you detect the EDR evasion, then you also directly detect the malware.
150.88s - 154.36s |  And so this has allowed us to do very scalable work.
154.36s - 159.16s |  And at Vilexity, where we're dealing in many investigations with dozens, hundreds, thousands
159.16s - 164.56s |  of memory samples, we don't have time, and it would obviously not be very time efficient,
164.56s - 167.00s |  to manually look at anything to start.
167.00s - 171.40s |  So we want a set of techniques that will at least say, hey, out of these 100 memory samples,
171.40s - 173.76s |  these are the five you really need to focus on.
173.76s - 175.28s |  And that's where we target our research.
175.28s - 177.12s |  We don't want a lot of false positives.
177.12s - 179.24s |  We don't want algorithms that take forever to run.
179.24s - 182.84s |  We just want to find the malware so that we can deep dive it.
182.84s - 186.24s |  And then as you can probably guess by the title and the fact that all this research
186.24s - 191.90s |  was done with volatility, we're going to be looking for that malware in memory.
191.90s - 195.48s |  If you haven't seen memory forensics before, or maybe you've never looked at a memory sample
195.48s - 200.30s |  yourself, the reason why there's this whole industry now around memory forensics and why
200.30s - 206.34s |  it's so vital to incorporate it in your investigations is that when you look at the real attacks
206.34s - 210.62s |  in the wild, when you look at the malware that's going to be used in environments where
210.62s - 214.22s |  the attackers don't want to get caught, where the EDRs are, where there's actually security
214.22s - 217.58s |  teams, that malware is going to be memory only.
217.58s - 219.94s |  It's not going to touch the file system.
219.94s - 222.94s |  Anything that traverses the network is going to be encrypted.
222.94s - 226.98s |  So if you don't get a memory sample, then you just threw all the evidence away.
226.98s - 230.74s |  If you walk up to that compromised machine and you turn it off, as soon as that machine
230.74s - 233.94s |  shuts down, the evidence is gone forever.
233.94s - 239.30s |  And what I have highlighted here on the slide is just an interesting report from Microsoft.
239.30s - 245.82s |  There's hundreds of reports like this that companies have published.
245.82s - 249.50s |  But I like this one because in two sentences, it really summarizes why we spend so much
249.50s - 251.10s |  time doing memory.
251.10s - 252.10s |  This was Microsoft.
252.10s - 253.42s |  It was really interesting.
253.42s - 258.26s |  It was basically a spyware company out of Australia that was being used to target some
258.26s - 263.02s |  high-level people, and Microsoft burned the whole company to the ground in one report.
263.02s - 266.94s |  They burned every piece of malware that company had, all the capabilities.
266.94s - 271.14s |  And as I have highlighted in red here with the screenshot, over and over again, Microsoft
271.14s - 277.18s |  made the point to say that where the evasion is, where the real payloads are, are in memory.
277.18s - 281.58s |  And if you look at what these payloads are capable of, it's key logging, it's screenshots,
281.58s - 286.34s |  it's recording the microphone, recording the webcam, exfiltrating files, everything
286.34s - 291.58s |  that allowed this spyware to operate against politicians, journalists, all these people,
291.58s - 292.66s |  it was memory only.
292.66s - 296.34s |  So traditional disk forensics isn't going to get you anywhere, and you need to know
296.34s - 300.58s |  how to efficiently do memory forensics to even make sense of the data and detect the
300.58s - 303.82s |  malware in the first place.
303.82s - 308.98s |  So as part of our research project, when we first broke down how EDRs are monitoring system
308.98s - 312.50s |  activity, the first three have been around a while.
312.50s - 317.86s |  Kernel callbacks is where EDRs or antivirus inside the kernel, so from their driver, they
317.86s - 323.14s |  can register to say that that callback will be notified every time a process starts or
323.14s - 325.94s |  a thread starts or a DLL gets loaded.
325.94s - 333.30s |  EDRs will also monitor activity through two of the newer interfaces, so ETW and AMSI.
333.30s - 339.74s |  ETW is where kernel drivers can receive a wide range of system activity from processes,
339.74s - 344.50s |  also other parts of the kernel, and then AMSI, if you go to other DEF CON talks, Black Hat
344.50s - 350.26s |  talks, it gets mentioned a lot, because at this point, what AMSI does is it lets Defender,
350.26s - 355.82s |  so Windows Defender, as well as all the EVs, AVs and EDRs, they get to register to say
355.82s - 360.54s |  before a PowerShell script runs, before a macro runs, before all these scripting languages
360.54s - 366.06s |  where traditional reversing doesn't work and there's a lot of obfuscation, those antivirus
366.06s - 369.22s |  engines and the EDR engines get to scan the scripts.
369.22s - 372.98s |  If they say they are malicious, then the scripts get blocked.
372.98s - 378.06s |  And then what we'll really be focusing on with this talk is the last one, which is system
378.06s - 379.46s |  call monitoring.
379.46s - 384.00s |  And we'll have some pictures for that to make sure everyone is on the same page.
384.00s - 389.02s |  And so when we broke down the bypasses, even, not even just like your really sophisticated
389.02s - 394.06s |  threat groups, every ransomware family at this point, the half-decent ones, the first
394.06s - 398.22s |  thing they do is load a kernel driver through bring your own vulnerable driver, and they
398.22s - 401.98s |  disable all the EDR callbacks and the AV callbacks.
401.98s - 406.78s |  At that point, the ransomware can inject code, start new processes, and those systems are
406.78s - 408.10s |  blind.
408.10s - 413.80s |  For event tracing and AMSI, there are dozens and dozens of papers on how to disable these,
413.80s - 417.50s |  and it's essentially a modern part of what you see in real investigations.
417.50s - 422.46s |  But what we noticed, and as we'll see here on the next slide, is when we get to system
422.46s - 425.26s |  call monitoring, we had no way to detect this.
425.26s - 430.26s |  So before this research effort, with memory forensics, with volatility, you could very
430.26s - 435.42s |  quickly determine that callbacks had been unregistered, that ETW had been tampered with,
435.42s - 437.10s |  that AMSI had been tampered with.
437.10s - 439.86s |  Again, these are going to point you right to the malware.
439.86s - 444.94s |  But the system call monitoring that EDRs use, and it's one of the best ways they get visibility
444.94s - 447.74s |  on the system, there was no way to detect this.
447.74s - 451.90s |  And so in our investigations, we were having to do a lot of manual work to find it, to
451.90s - 456.04s |  unravel it, and that just doesn't work for the scale that we operate at.
456.04s - 460.58s |  We need automated ways.
460.58s - 466.46s |  And the reason that the system calls are so critical to EDRs is the idea with system calls
466.46s - 470.10s |  is this is your boundary from process memory to the kernel.
470.10s - 473.10s |  So this diagram here are the Windows internals book.
473.10s - 478.26s |  You have your processes running, your web browser, your office application, whatever
478.26s - 484.02s |  it is that the process is running in user land or user mode, it's all the same thing.
484.02s - 488.88s |  Besides manipulating their own memory, whenever they want to access a resource on the system,
488.88s - 492.86s |  so they want to read or write a file, they want to read or write a network packet, anything
492.86s - 497.30s |  beyond manipulating their own memory, they have to ask the operating system to do it.
497.30s - 501.26s |  Because obviously you don't want your random notepad process writing directly to the hard
501.26s - 507.02s |  drive or you don't want notepad writing directly to the ring buffer of your network driver.
507.02s - 514.74s |  So for processes that want to talk to network devices and request those operations, reading
514.74s - 519.54s |  a file, writing a file, interacting with the network, it has to go through a system call.
519.54s - 524.14s |  And that system call is going to change the execution context into the kernel, which is
524.14s - 526.30s |  obviously the most privileged part.
526.30s - 531.24s |  It has full access to the operating system itself, to other drivers, to other hardware.
531.24s - 536.24s |  What you're seeing on the right side of this slide is the arrow that breaks down between
536.24s - 539.90s |  process memory and the kernel where the system calls happen.
539.90s - 542.32s |  You're seeing a stack trace of that here.
542.32s - 545.90s |  When you look at a stack trace, you want to start at the bottom to make sense of it.
545.90s - 550.48s |  So in the beginning, what these lines or these rows here with the U, this is in user land
550.48s - 552.56s |  or again process memory.
552.56s - 555.30s |  You can see that the Edge browser is running.
555.30s - 558.68s |  It eventually gets to this call, ZW create file.
558.68s - 562.88s |  Your system calls will, in almost all cases, start with ZW.
562.88s - 566.92s |  And then you can see this is sysinternals monitoring the call stack.
566.92s - 571.12s |  It eventually, when this system call is made, it jumps into the kernel file.
571.12s - 573.34s |  And this K means we're in kernel memory.
573.34s - 578.92s |  So this last call, the ZW, whatever that particular system call is, that is the last boundary
578.92s - 580.84s |  before we jump in the kernel.
580.84s - 586.24s |  And the reason we're focusing on this background so much is this is where your EDRs live.
586.24s - 590.64s |  Because if you look at this slide, what we're seeing, I'll explain in more detail in a second,
590.64s - 593.72s |  but on the left is the normal system call handler.
593.72s - 596.40s |  So this is what you get with Windows by default.
596.40s - 600.76s |  In this case, the slide is showing ZW protect virtual memory.
600.76s - 603.12s |  So another system call on Windows.
603.12s - 606.60s |  On the left is the normal flow that's going to reach the kernel.
606.60s - 609.36s |  On the right is an EDR that has hooked it.
609.36s - 615.16s |  So EDRs that want to monitor what processes are doing on the machine by injecting code
615.24s - 620.36s |  into every process, hooking the system call functions of interest, it has complete control
620.36s - 623.96s |  over what that process is doing right before it makes the system call.
623.96s - 628.84s |  So if it wants to look for suspicious parameters, if it wants to log out what files are being read,
628.84s - 633.44s |  what parts of the registry are being interacted with, by hooking that lowest level function,
633.44s - 636.12s |  the EDR has full visibility.
636.12s - 641.40s |  And so as we'll see here in a second, what malware wants to do is make its system calls
641.40s - 644.84s |  without EDRs interfering or detecting it.
644.84s - 648.56s |  But some background real quick while we're on a nice slide with a picture.
648.56s - 654.24s |  What we're seeing here, again on the left, is the normal system call handler that jumped.
654.24s - 655.40s |  We're going to go back.
655.40s - 659.04s |  So what we see on the left is the normal system call handler.
659.04s - 661.28s |  And there's a few things to keep in mind.
661.28s - 666.56s |  First off, when you have the NT version of a function and then the ZW prefix version,
666.56s - 670.48s |  it's the same exact function, but one's in user land, one's in the kernel.
670.48s - 672.24s |  So we're seeing that here.
672.24s - 677.80s |  The second thing is from regular C code or C++ code, when you call a function,
677.80s - 680.52s |  the parameters are sent in certain registers.
680.52s - 683.00s |  We're going to focus on 64-bit machines.
683.00s - 687.64s |  And besides RCX and R10, they're exactly the same.
687.64s - 690.96s |  The weird thing is with Windows, when you make a system call,
690.96s - 694.84s |  your second parameter needs to be an R10 instead of RCX.
694.84s - 697.36s |  So this has to get updated in those paths.
697.36s - 701.48s |  And then EAX or RAX has to hold the system call number.
701.48s - 706.12s |  So for all the hundreds of system calls that Windows has for a particular version,
706.12s - 708.28s |  each system call has its own number.
708.28s - 711.44s |  And if you look at these handlers, they all look exactly like this,
711.44s - 717.12s |  except this number changes, because that is the index into the system call table at runtime.
717.12s - 721.24s |  And then we have a quick check to see what system call path is supported.
721.24s - 724.16s |  And then to make that transition to kernel mode,
724.16s - 726.52s |  we're either going to use the system call instruction,
726.52s - 729.80s |  or if we're on an older processor, older version of Windows,
729.80s - 732.00s |  we're going to make the int2e call.
732.00s - 736.48s |  So again, this is on the left is what we would expect on a regular machine
736.48s - 738.08s |  where you don't have EDRs.
738.08s - 741.08s |  And then if you look on the right here, instead of all this code,
741.08s - 743.20s |  make eventually calling system call,
743.20s - 747.76s |  we just have a jump out to an unknown region, which is going to be the EDR.
747.76s - 751.52s |  And then when malware calls something like protect virtual memory here
751.52s - 755.52s |  or create file on the previous slide, the EDR has full control of that.
755.52s - 759.16s |  It's going to kill the ransomware before it can launch any payloads.
759.16s - 761.60s |  It's going to kill all the code injection techniques.
761.60s - 765.32s |  And so if you have a decent EDR and it's not being tampered with,
765.32s - 768.84s |  it's going to stop all these regular malware techniques from functioning.
768.84s - 771.04s |  But like I said, we constantly do investigations
771.04s - 774.04s |  where there's very potent malware on the machine.
774.04s - 776.32s |  There's supposedly EDR on the machine.
776.32s - 787.54s |  But when we dig into the infected processes, the EDR has been nullified.
787.54s - 789.46s |  So what we're going to do for the rest of the talk
789.46s - 792.30s |  is look at all of the bypasses that we found.
792.30s - 793.82s |  Like I said, in our own investigations,
793.82s - 796.30s |  there's a bunch of open source tools that do it as well.
796.30s - 798.26s |  And then how we can detect them.
798.26s - 800.70s |  The first one goes by a couple different names,
800.70s - 804.38s |  module unhooking, system call unhooking, API unhooking.
804.38s - 809.22s |  The basic idea here is the malware is going to unhook the system call handlers.
809.22s - 812.50s |  And the end goal is when malware starts running
812.50s - 816.70s |  and they're in a process that EDRs have all the system calls in this hook form,
816.70s - 818.82s |  it wants to get it back to the original form
818.82s - 822.70s |  so that the EDR is blind to what's going on.
822.70s - 826.18s |  The way this works, and this PowerPoint keeps jumping a lot.
826.18s - 831.18s |  The way this works, this is a screenshot from a very recent report,
831.18s - 834.06s |  from a very recent report maybe two or three months ago
834.06s - 837.70s |  of malware that did this to then spread across a huge network.
837.70s - 843.62s |  And the basic idea is where system calls are implemented in memory is NTDLL.
843.62s - 847.30s |  So the first DLL that loads in every process is NTDLL.
847.30s - 851.22s |  That has all of those system call handlers, one per system call.
851.22s - 852.98s |  And that's what the EDRs hook.
852.98s - 856.26s |  They put the jump instruction, it goes directly to the EDR code.
856.26s - 858.78s |  And then like I said, the EDR can evaluate the parameters
858.78s - 860.82s |  before the system call is made.
860.82s - 862.10s |  So you can see it in the steps here.
862.10s - 863.82s |  This report was really nice.
863.82s - 868.58s |  What this malware did is it read the clean copy of NTDLL from disk.
868.58s - 871.46s |  So that copy on disk is what Microsoft published.
871.46s - 873.90s |  That does not have any EDR hooks present.
873.90s - 876.22s |  So it reads NTDLL from disk.
876.22s - 880.38s |  It finds where those system call handlers are in their clean state on disk.
880.42s - 882.94s |  And it just overwrites all the EDRs hooks.
882.94s - 885.62s |  And now the malware can call any system call at once
885.62s - 887.82s |  with whatever malicious parameters it wants,
887.82s - 890.06s |  any malicious end goal that it has.
890.06s - 892.98s |  And even though the EDR is technically loaded in that process,
892.98s - 895.18s |  its code is never going to be activated.
895.18s - 896.82s |  And so when we look at ransomware and we're like,
896.82s - 898.26s |  how can it inject code?
898.26s - 899.78s |  How is it encrypting all the files?
899.78s - 901.42s |  How is it elevating privileges?
901.42s - 904.10s |  It's because the EDR has no idea what's going on.
904.10s - 907.94s |  And this is one of the many ways that we'll talk about how it happens.
907.94s - 911.90s |  So again, you go from the state where every process on the machine
911.90s - 913.82s |  has their system calls hooked.
913.82s - 917.18s |  The malicious code, the malware is going to run in its own process
917.18s - 919.82s |  or it's going to inject code into a victim process.
919.82s - 922.86s |  And in that victim process or the malware's own process,
922.86s - 927.54s |  the system call handlers will be reverted back to where they were on disk.
927.54s - 930.46s |  But all the other processes will have the hooked form.
930.46s - 933.14s |  So what we realized is instead of trying to figure out
933.14s - 936.38s |  the 50 different variations for module unhooking,
936.38s - 942.18s |  we could just use data in memory to tell us where the malware is.
942.18s - 947.46s |  So what our new volatility plugin does is it enumerates every process.
947.46s - 951.22s |  It reads the bytes of all the system call handlers that the EDRs
951.22s - 953.38s |  or that the malware often targets.
953.38s - 955.54s |  And then we just compare the implementations.
955.54s - 957.66s |  And as you'll see here in a couple of slides,
957.66s - 961.06s |  what we can do is say you have 100 processes running.
961.06s - 963.50s |  99 of them have one implementation.
963.50s - 967.02s |  And this one process on its own has a different implementation.
967.02s - 970.02s |  The 99 are the ones where the EDR is still active.
970.02s - 974.66s |  And that one kind of outlier process is the one that the malware is unhooked.
974.66s - 976.78s |  And so we like, when we do this type of research,
976.78s - 980.54s |  we like to make experiments that can be repeated by anyone else.
980.54s - 982.86s |  Obviously, not everyone works at Valexity
982.86s - 985.98s |  and has access to our infected samples from the wild.
985.98s - 989.06s |  So we come up with experiments using open source tools
989.06s - 991.18s |  where you can recreate this on your own
991.18s - 993.30s |  and you can test it in your own environment.
993.30s - 996.26s |  So a very nice tool for testing EDR,
996.26s - 999.82s |  a very nice open source tool for testing EDR bypasses
999.82s - 1001.46s |  is called SilentStrike.
1001.46s - 1003.90s |  So this is an open source EDR,
1003.90s - 1007.02s |  and it was actually developed just to test these bypasses
1007.02s - 1009.02s |  and then see if you could detect them.
1009.02s - 1013.38s |  The way SilentStrike works is it hooks NT Protect virtual memory.
1013.38s - 1016.34s |  This is one of the main functions that malware needs
1016.34s - 1018.10s |  to perform code injection
1018.10s - 1020.86s |  and also to try to keep that code injection stealthy.
1020.86s - 1023.26s |  And so what this open source EDR does
1023.26s - 1024.86s |  is it hooks that function.
1024.86s - 1027.22s |  If it gets called where the region's going to become
1027.22s - 1029.02s |  readable, writable, and executable,
1029.02s - 1030.66s |  the EDR says you can't do that,
1030.66s - 1033.58s |  and that stops a lot of different code injection techniques.
1033.58s - 1036.06s |  So for our experiment, what we did
1036.06s - 1040.10s |  is we took a base Windows 10 install, so no EDR.
1040.10s - 1042.26s |  With SilentStrike, you can tell it
1042.26s - 1044.38s |  to create individual processes
1044.38s - 1047.46s |  that it will then treat as an EDR and protect.
1047.46s - 1050.34s |  So we started a notepad and we started a WordPad.
1050.34s - 1053.06s |  At this point, they have SilentStrike active in it,
1053.06s - 1055.02s |  which is your EDR.
1055.02s - 1057.02s |  We then took a memory sample.
1057.02s - 1060.94s |  After that, we ran R77, which is an open source rootkit
1060.94s - 1062.94s |  that does this module unhooking,
1062.94s - 1065.98s |  and we unhooked the notepad process.
1065.98s - 1067.94s |  And then we took a second memory sample.
1067.94s - 1071.34s |  So we have the state before and after the malware ran.
1072.34s - 1073.86s |  And with our new plugin,
1073.86s - 1077.30s |  so unhook system calls to volatility three,
1077.30s - 1079.26s |  what it's saying here is what we do
1079.26s - 1080.90s |  is we enumerate all the functions.
1080.90s - 1081.82s |  The slide is cut.
1081.82s - 1084.38s |  There's probably like 50 functions we actually check.
1084.38s - 1085.98s |  But the idea is we're saying,
1085.98s - 1088.06s |  for these processes down here,
1088.06s - 1089.86s |  there's no distinct implementations.
1089.86s - 1093.74s |  So every process inside of that memory sample
1093.74s - 1095.62s |  had the same version of the function.
1095.62s - 1098.46s |  And then the two that we started under SilentStrike,
1098.46s - 1101.94s |  their NT protect virtual memory, had the EDR's view.
1101.94s - 1104.82s |  This is before we ran R77.
1104.82s - 1108.70s |  We then ran the R77 rootkit on the machine.
1108.70s - 1111.50s |  We unhooked notepad, and you can see it removes
1112.18s - 1113.34s |  from distinct implementations.
1113.34s - 1115.70s |  It's been reverted back to the base form.
1115.70s - 1116.94s |  So then we took this plugin,
1116.94s - 1120.42s |  ran it across the many hundreds of memory samples
1120.42s - 1122.82s |  that we have to test our code on.
1122.82s - 1125.34s |  And the only place this plugin fired
1125.34s - 1128.74s |  was either traditional API hooking or EDR unhooks.
1128.74s - 1131.14s |  And so there's no false positives with this.
1131.14s - 1133.06s |  If the EDR's hooked every process,
1133.06s - 1134.74s |  it doesn't make sense that it would skip one
1134.74s - 1136.26s |  or that one should be reverted.
1136.26s - 1141.01s |  This directly tells you where the malware's running.
1141.01s - 1144.77s |  We then started looking into other ways to read NTDLL.
1144.77s - 1146.69s |  So you saw it in the screenshot before
1146.69s - 1148.29s |  from that malware report.
1148.29s - 1151.61s |  And I walked you through where for unhooking to work,
1151.61s - 1155.29s |  the malware needs access to a clean copy of NTDLL,
1155.29s - 1157.45s |  which normally you can just read from disk,
1157.45s - 1159.13s |  but there was several EDR vendors
1159.13s - 1160.57s |  that started detecting that.
1160.57s - 1162.49s |  Because why would some random process
1162.49s - 1166.25s |  need to read NTDLL as a file and parse the section?
1166.25s - 1167.61s |  The only reason to do that
1167.61s - 1170.33s |  is to unhook the EDR out of memory.
1170.33s - 1173.45s |  So this made it harder for that malware to operate.
1173.45s - 1177.13s |  It can't read NTDLL from disk or it's going to get caught.
1177.13s - 1180.57s |  So we saw some malware samples and some open source tools
1180.57s - 1184.33s |  that abused suspended processes to get the clean copy.
1184.33s - 1186.89s |  If you've ever investigated process hollowing,
1186.89s - 1188.37s |  whether you were writing code for it
1188.37s - 1190.21s |  or you were trying to detect it,
1190.21s - 1192.73s |  creating suspended processes is the first step
1192.73s - 1194.57s |  of every process hollowing technique.
1194.57s - 1197.05s |  So we'll see that we catch some of those as well
1197.05s - 1198.49s |  as kind of a side effect.
1198.53s - 1200.69s |  But the idea for EDR bypasses
1200.69s - 1204.53s |  is the malware will create a suspended process.
1204.53s - 1206.37s |  The idea with a suspended process
1206.37s - 1208.89s |  is that the only thing that's going to load
1208.89s - 1212.09s |  is the application executable and NTDLL.
1212.09s - 1215.29s |  It's kind of like a half created process at that point.
1215.29s - 1219.93s |  Once the EXE and NTDLL are mapped into the process,
1219.93s - 1222.13s |  then at that point, the parent process,
1222.13s - 1224.89s |  the one who created the process gets control back.
1224.89s - 1226.29s |  So then what the malware does
1226.29s - 1228.41s |  is it just reads from its child process,
1229.21s - 1230.85s |  the clean NTDLL out of memory.
1230.85s - 1233.21s |  The EDR doesn't see a suspended process
1233.21s - 1235.05s |  until it actually starts running.
1235.05s - 1237.93s |  So this puts a clean copy of NTDLL in memory.
1237.93s - 1240.09s |  The malware doesn't have to go read it from disk.
1240.09s - 1241.61s |  And so obviously we wanted to be able
1241.61s - 1243.13s |  to detect this as well.
1244.57s - 1246.53s |  So we did some reverse engineering
1246.53s - 1248.49s |  and read some preexisting reports
1248.49s - 1250.89s |  on what happens with suspended processes.
1250.89s - 1252.41s |  Like I said, we see it a lot
1252.41s - 1253.33s |  because you have to do this
1253.33s - 1255.69s |  if you want to create a hollowed process.
1255.69s - 1257.65s |  But what you have in kernel memory
1257.69s - 1260.77s |  is for every process, you have an E-process structure.
1260.77s - 1262.69s |  For every thread, you have an E-thread
1262.69s - 1264.29s |  or a K-thread structure.
1264.29s - 1267.37s |  When that process gets created in the suspended state,
1267.37s - 1269.85s |  every process starts with one thread.
1269.85s - 1272.41s |  And when you create the thread suspended,
1272.41s - 1274.41s |  its suspense count goes to one,
1274.41s - 1276.85s |  which tells the operating system not to run it.
1276.85s - 1279.29s |  Normally, if you just create a process in the normal way
1279.29s - 1281.25s |  or you double-click it on your desktop,
1281.25s - 1283.01s |  the suspend count's gonna be zero.
1283.01s - 1284.97s |  And as soon as that process can get scheduled,
1284.97s - 1286.77s |  its threads are going to run.
1286.77s - 1289.85s |  But what we saw in every piece of malware that we had
1289.85s - 1292.81s |  and every open-source tool we had access to that did this,
1292.81s - 1294.77s |  when they create the suspended process
1294.77s - 1297.13s |  just to read the clean NTDLL,
1297.13s - 1299.29s |  they're never going to run that child process.
1299.29s - 1301.21s |  They are just getting that into memory
1301.21s - 1304.41s |  to get access to the clean system call handlers.
1304.41s - 1306.09s |  So this was pretty easy.
1306.09s - 1307.21s |  We wrote a plugin.
1307.21s - 1308.89s |  Volatility could already enumerate
1308.89s - 1310.65s |  every thread of every process.
1310.65s - 1312.89s |  And then we just added an extra step to say,
1312.89s - 1316.09s |  does that thread have a suspend count greater than zero?
1316.09s - 1319.33s |  Running it across our large data set of memory samples,
1319.33s - 1322.33s |  the only false positive we had, which was pretty random,
1322.33s - 1325.41s |  is this work folder shell DLL inside of Edge
1325.41s - 1326.69s |  makes suspended threads.
1326.69s - 1327.69s |  We don't know why.
1327.69s - 1330.09s |  So we just added that to the list of ones
1330.09s - 1331.09s |  we don't print out.
1331.09s - 1334.01s |  And besides that, we didn't have a single false positive.
1334.01s - 1335.45s |  And then, like I said, at Vlexity,
1335.45s - 1338.09s |  we have hundreds and hundreds of memory samples
1338.09s - 1340.45s |  in different states that we test these things on.
1340.45s - 1342.21s |  And quite a few of the samples
1342.21s - 1344.57s |  that we know have process hollowing in them,
1344.57s - 1346.81s |  they were detected, too, because if you're
1346.81s - 1348.85s |  familiar with that technique, the idea
1348.85s - 1351.13s |  is you create a process in a suspended state,
1351.13s - 1354.53s |  you overwrite the code, and then you let that new process run.
1354.53s - 1357.57s |  And so not only is this plugin picking up all the EDR
1357.57s - 1361.77s |  bypasses, we generically caught a bunch
1361.77s - 1371.69s |  of different process hollowing techniques as well.
1371.69s - 1375.41s |  At Black Hat Europe, maybe two years ago now, three years ago,
1375.41s - 1377.21s |  there was a really cool white paper
1377.21s - 1380.29s |  and talk on a project called Dirty Vanity.
1380.29s - 1382.49s |  The idea was they tested against basically
1382.49s - 1385.69s |  every commercial EDR they could get their hands on.
1385.69s - 1388.45s |  And the idea is they wanted to be able to do code injection
1388.45s - 1391.85s |  into a victim process without the EDRs catching them.
1391.85s - 1394.17s |  And if you're familiar with this, to do code injection,
1394.17s - 1396.01s |  there's five or six APIs you have
1396.01s - 1397.87s |  to call to make that work.
1397.87s - 1400.61s |  And if you call all those in a row and you're injecting,
1400.61s - 1403.01s |  the end result is you're going to inject into your victim
1403.01s - 1407.45s |  process any half-decent EDR, any enterprise-level EDR
1407.45s - 1409.09s |  is going to catch that.
1409.09s - 1411.69s |  So what was really interesting about Dirty Vanity
1411.69s - 1414.97s |  is they instead created clone processes or a forked process
1414.97s - 1417.05s |  if you're more familiar with Linux.
1417.05s - 1419.73s |  So the idea with a clone or a forked process
1419.73s - 1422.19s |  is your process is running.
1422.19s - 1424.61s |  You create a clone of your own process.
1424.61s - 1426.61s |  So that child process you created
1426.61s - 1428.57s |  has your same exact state.
1428.57s - 1430.41s |  So then what Dirty Vanity did is they
1430.41s - 1433.33s |  called the first couple APIs from the parent.
1433.33s - 1435.19s |  And then they create the clone, which
1435.19s - 1437.29s |  has the same exact state as the parent.
1437.29s - 1440.13s |  And they called the final set of APIs from the child.
1440.13s - 1442.53s |  So the end result is they're still injecting code
1442.53s - 1444.17s |  into the victim process.
1444.17s - 1446.21s |  But none of the EDRs that they tested
1446.21s - 1449.61s |  were able to detect the calls going across the process
1449.61s - 1450.49s |  boundary.
1450.49s - 1452.87s |  So obviously, we wanted to be able to detect this
1452.87s - 1456.01s |  from a memory forensic standpoint.
1456.01s - 1457.83s |  So while we were looking into what
1457.83s - 1460.05s |  it means to clone a process in Windows,
1460.05s - 1463.61s |  the real internal state, we saw that what Windows does when
1463.61s - 1466.91s |  it's setting up that clone is it makes a suspended thread.
1467.03s - 1469.43s |  So that child that's being cloned into
1469.43s - 1471.39s |  has its first thread suspended.
1471.39s - 1475.03s |  And with Dirty Vanity, it never restarted the child process
1475.03s - 1477.63s |  or the initial thread of the child process.
1477.63s - 1480.43s |  So the plug-in that we had detected it right away.
1480.43s - 1481.91s |  And if you're interested in this,
1481.91s - 1483.55s |  I have it cited here at the bottom.
1483.55s - 1485.47s |  We found this thing called the Definitive Guide
1485.47s - 1486.87s |  to Process Cloning on Windows.
1486.87s - 1490.95s |  It's like 40 pages of APIs and data structures and background.
1490.95s - 1492.59s |  But it pretty much told us exactly
1492.59s - 1495.79s |  what we needed to know on top of what we saw with reversing.
1497.63s - 1501.55s |  We made a memory sample that was infected with Dirty Vanity.
1501.55s - 1504.39s |  And as you can see, we're running our suspended threads
1504.39s - 1505.31s |  plug-in.
1505.31s - 1508.87s |  It's telling us that inside of the fake EXE process, which
1508.87s - 1511.27s |  is what Dirty Vanity calls itself if you just
1511.27s - 1513.31s |  compile it straight from GitHub.
1513.31s - 1518.63s |  And then it's saying that this process ID, 6752, this thread,
1518.63s - 1522.53s |  it is suspended or suspend count is greater than 0.
1522.53s - 1525.15s |  And then if you look at PSTree in volatility,
1525.15s - 1528.07s |  so this is drawing out the parent-child relationship
1528.07s - 1532.79s |  of processes, you can see that the original fake EXE
1532.79s - 1535.55s |  has a child called fake EXE.
1535.55s - 1540.43s |  So this is that process that was created through cloning.
1540.43s - 1541.51s |  So this is the parent.
1541.51s - 1545.11s |  This is where Dirty Vanity will call the first couple APIs.
1545.11s - 1548.01s |  It then forks or clones off a child process
1548.01s - 1552.43s |  where it will call the remaining APIs, bypassing the EDR.
1552.43s - 1554.63s |  But what you can see volatility picking up on
1554.63s - 1557.91s |  is the child's always going to have its main thread suspended.
1557.91s - 1559.89s |  And so we pick up on that right away.
1559.89s - 1561.51s |  You would then run PSTree would probably
1561.51s - 1564.11s |  be the next thing if this was a real investigation.
1564.11s - 1566.03s |  You would figure out the parent that
1566.03s - 1568.27s |  created the suspended process.
1568.27s - 1571.51s |  And then you can see here what it does in demo mode.
1571.51s - 1573.75s |  So if you don't have an EDR you're targeting,
1573.75s - 1575.67s |  Dirty Vanity will run command shell
1575.67s - 1578.63s |  with some shellcode that makes a pop-up on the screen
1578.63s - 1580.23s |  or prints it to the terminal.
1580.23s - 1583.03s |  So you see that here as well, that child process.
1583.03s - 1585.03s |  But through the new plugin, you see exactly
1585.03s - 1586.79s |  which process is malicious.
1586.79s - 1594.47s |  You can then do your normal memory forensics workflow.
1594.47s - 1596.53s |  As you've been seeing in the slides,
1596.53s - 1598.37s |  the previous techniques that we looked
1598.37s - 1602.09s |  into for bypassing the system call handlers
1602.09s - 1604.15s |  relied on overwriting code.
1604.15s - 1605.53s |  And you might have been thinking,
1605.53s - 1608.73s |  especially if you've done debugging before or low level
1608.73s - 1610.89s |  programming before, the idea that you're
1610.89s - 1613.43s |  going to overwrite NTDLL, the entire thing
1613.43s - 1616.21s |  or certain functions at runtime, is a bit unsafe.
1616.29s - 1617.81s |  Because you can imagine if you're
1617.81s - 1620.85s |  overwriting 30 or 40 functions code in memory,
1620.85s - 1623.41s |  if any other thread is using that function
1623.41s - 1625.21s |  or a system call was just made and you're
1625.21s - 1627.49s |  waiting for user LAN to return again,
1627.49s - 1629.65s |  you just blew away the code that was technically
1629.65s - 1631.11s |  running on the CPU.
1631.11s - 1632.25s |  So malware does it.
1632.25s - 1634.49s |  It generally works, but it's a bit unsafe.
1634.49s - 1636.25s |  And then the other thing you could imagine
1636.25s - 1638.57s |  is EDR could just check for its hooks.
1638.57s - 1641.45s |  If it hooked 40 or 50 system call handlers
1641.45s - 1643.77s |  and then it checks in whatever frequency later
1643.77s - 1645.45s |  and its handlers are overwritten,
1645.45s - 1648.53s |  it knows that there is malware inside of that process.
1648.53s - 1651.81s |  So this led to what was some really interesting research
1651.81s - 1653.05s |  on the open source side.
1653.05s - 1656.41s |  And like I said, we saw it in private malware as well.
1656.41s - 1657.81s |  So there were alternative methods
1657.81s - 1660.61s |  developed where the code is not overwritten.
1660.61s - 1662.69s |  The malware, as you'll see, can still
1662.69s - 1664.33s |  make its malicious system calls.
1664.33s - 1668.01s |  It can still do any system calls at once with any parameters.
1668.01s - 1669.81s |  But we're not overwriting code.
1669.81s - 1673.85s |  So inside of NTDLL, in that EDR protected process,
1673.85s - 1677.21s |  the original implementation that the EDR gave is the same.
1677.21s - 1678.53s |  The hooks are present.
1678.53s - 1682.37s |  The EDR would get control if the real system call was used.
1682.37s - 1684.95s |  But malware is just going to avoid those code paths.
1684.95s - 1686.41s |  So we'll look at the different ways
1686.41s - 1689.97s |  they do that and the ways we can detect it.
1689.97s - 1692.69s |  The first one we looked at were direct system calls.
1692.69s - 1694.89s |  So the malware authors realized that,
1694.89s - 1699.09s |  why do I need to call the system call handler inside of NTDLL?
1699.09s - 1701.13s |  You saw that a system call handler is only
1701.13s - 1702.85s |  five or six instructions.
1702.85s - 1704.61s |  Why don't I just do that myself?
1704.61s - 1707.85s |  So rather than going through NTDLL, which the EDR is hooked,
1707.85s - 1710.13s |  I'm just going to set up the registers that are needed,
1710.13s - 1712.93s |  and I'm going to make the syscall instruction on my own.
1712.93s - 1714.97s |  And again, the EDRs that are trying
1714.97s - 1716.81s |  to catch you through system call hooks,
1716.81s - 1718.49s |  they are blind to you because you're not
1718.49s - 1720.49s |  going through their hooked code.
1720.49s - 1724.77s |  The problem with this, and there was a very interesting series
1724.77s - 1727.49s |  of posts by Elastic that I have cited at the end,
1727.49s - 1730.17s |  this is where they started doing call stack examination.
1730.17s - 1731.89s |  Elastic does this really well.
1731.89s - 1734.77s |  There's some open source implementations of it also.
1734.77s - 1738.05s |  But the idea is, if you were making a system call
1738.05s - 1741.05s |  instruction, or you're calling the system call instruction
1741.05s - 1744.13s |  outside of NTDLL, so you're in some random DLL
1744.13s - 1746.69s |  that you've injected, or you're in a shellcode region,
1746.69s - 1749.17s |  your EDR in kernel mode can see that.
1749.17s - 1750.97s |  And then it's going to say, why is a system
1750.97s - 1753.33s |  call being made from a random shellcode region that
1753.33s - 1756.41s |  wouldn't normally happen on a running machine?
1756.41s - 1758.85s |  And then the other downside to this, as we'll see,
1758.85s - 1761.37s |  is you have to know where the system call indexes are.
1761.37s - 1763.37s |  So like I said, there's hundreds of system calls
1763.37s - 1765.81s |  per release of Windows, and the indexes
1765.81s - 1767.09s |  change almost every time.
1767.09s - 1768.97s |  The indexes are not guaranteed.
1768.97s - 1771.29s |  If you're writing normal, legitimate code,
1771.29s - 1772.89s |  you shouldn't care about the indexes.
1772.89s - 1775.25s |  You just call the higher level API,
1775.25s - 1777.23s |  and the operating system does the work for you.
1777.23s - 1779.53s |  But in this case, where you want to make the system call
1779.53s - 1782.53s |  yourself, and you don't want to use the normal APIs
1782.53s - 1784.29s |  because the EDR has hooked them, you
1784.29s - 1788.93s |  have to be able to get that index value to put into EAX.
1788.93s - 1793.09s |  So if we look at the way that this has evolved over time,
1793.09s - 1796.21s |  the first tool that made this popular is called dumpERT.
1796.21s - 1797.21s |  It's an open source tool.
1797.21s - 1798.41s |  It's still on GitHub.
1798.41s - 1800.73s |  It has a very nice companion blog post.
1800.73s - 1803.97s |  And as you can see, for every system call
1803.97s - 1806.07s |  it wants to make available to the malware,
1806.07s - 1807.97s |  it has to put that little stub itself.
1807.97s - 1812.65s |  It has to update R10, update EAX with the very specific index
1812.65s - 1814.73s |  for the very specific system call.
1814.73s - 1817.17s |  Then it can call system call in return.
1817.17s - 1818.79s |  And at this point, you can make those,
1819.15s - 1820.43s |  but if you look at the code, this
1820.43s - 1823.27s |  is hard-coded to one version of Windows 7,
1823.27s - 1825.67s |  one release under Service Pack 1.
1825.67s - 1829.47s |  This is not something you could use in generic malware.
1829.47s - 1832.73s |  So instead, what we want to be able to have is where,
1832.73s - 1834.83s |  that is very loud, instead we want
1834.83s - 1838.07s |  to make it where system calls can be resolved dynamically.
1838.07s - 1841.35s |  So instead of your malware having what would literally
1841.35s - 1844.39s |  be hundreds of hard-coded system call tables
1844.39s - 1846.39s |  for different versions of Windows,
1846.39s - 1849.43s |  we want to find those indexes dynamically.
1849.43s - 1852.83s |  The first implementation of this is called Hell's Gate.
1852.83s - 1854.87s |  Almost every technique has gate in the name,
1854.87s - 1856.91s |  which makes it kind of annoying to remember.
1856.91s - 1858.75s |  So the first one is Hell's Gate.
1858.75s - 1862.19s |  In this case, what it did is it parsed NTDLL on disk,
1862.19s - 1863.71s |  kind of like we talked about before.
1863.71s - 1867.23s |  But instead of overwriting pre-existing code or the EDR's
1867.23s - 1870.23s |  code, it's just parsing NTDLL on disk,
1870.23s - 1872.95s |  and then it's dynamically resolving the numbers.
1872.95s - 1875.43s |  Because, for example, let's say in this case
1875.43s - 1878.15s |  it wants to call a ZW open process.
1878.15s - 1879.83s |  Instead of having to know beforehand
1879.83s - 1884.07s |  that on Windows 7 Service Pack 1, the index is 23 hex,
1884.07s - 1886.39s |  it can just load NTDLL.
1886.39s - 1889.59s |  It can call get proc address for ZW open process.
1889.59s - 1892.15s |  It can do some automated disassembly on the code,
1892.15s - 1894.89s |  and it can read out the index dynamically.
1894.89s - 1895.99s |  So this was Hell's Gate.
1895.99s - 1898.03s |  You can see the code here on the right.
1898.03s - 1900.51s |  Instead of being hard-coded to a certain number,
1900.51s - 1903.67s |  it has a little API wrapper that you use as a programmer.
1903.67s - 1905.07s |  You prep the system call.
1905.07s - 1907.19s |  That's going to fill in this global variable.
1907.19s - 1910.03s |  And then when it comes time to make the system call,
1910.03s - 1912.59s |  it will fill in the number correctly for you.
1912.59s - 1916.55s |  The problem with this, like I said, is most decent EDRs,
1916.55s - 1919.47s |  I'm not going to say certain vendors, but most decent EDRs,
1919.47s - 1922.87s |  if random code is reading NTDLL and parsing the P header
1922.87s - 1924.51s |  and all of that, the EDR is going
1924.51s - 1926.43s |  to flag on it because it's just not something
1926.43s - 1928.55s |  legitimate code would do.
1928.55s - 1930.95s |  So this led to even more gates.
1930.95s - 1934.15s |  There is Tataras Gate, which initially there
1934.19s - 1936.51s |  was some detections and some YARA rules that
1936.51s - 1940.75s |  were put out to detect this code pattern that's very hard-coded
1940.75s - 1943.05s |  and this code pattern that's very hard-coded.
1943.05s - 1946.03s |  All it did was make it a little more difficult to where
1946.03s - 1947.79s |  those naive patterns would break.
1947.79s - 1949.95s |  It put some no-op instructions.
1949.95s - 1952.67s |  It put some other instructions that didn't have a side effect.
1952.67s - 1955.43s |  But remember, you're in the system call handler path.
1955.43s - 1957.67s |  So you can't add a bunch of junk instructions,
1957.67s - 1960.23s |  or you will kill performance on the machine.
1960.23s - 1962.79s |  In a real process, you're going to have thousands and thousands
1962.83s - 1964.23s |  of system calls running.
1964.23s - 1966.87s |  You cannot have where you put in a bunch of junk code
1966.87s - 1968.47s |  just to throw off a YARA rule.
1968.47s - 1970.63s |  So even adding a few extra instructions
1970.63s - 1972.91s |  will have a real impact on the system.
1972.91s - 1975.71s |  So like I said, Tataras Gate is just trying to make it where,
1975.71s - 1978.83s |  if all you have is a kind of brittle, basic YARA rule,
1978.83s - 1981.03s |  you will not catch those code patterns.
1981.03s - 1984.83s |  There was then Halos Gate, which was an interesting twist
1984.83s - 1987.15s |  on reading NTDLL from disk.
1987.15s - 1990.23s |  So these malware authors wanted to get away
1990.23s - 1992.61s |  from reading NTDLL from disk.
1992.61s - 1995.21s |  So instead, what they do is they kind of rely on the fact
1995.21s - 1998.13s |  that the EDRs aren't going to hook every system call.
1998.13s - 2000.25s |  They're just going to, the malware is only
2000.25s - 2001.97s |  going to unhook this, sorry, the EDR
2001.97s - 2005.41s |  is only going to hook the system calls that it wants to monitor.
2005.41s - 2008.01s |  So what Halos Gate does is it dynamically
2008.01s - 2010.13s |  goes through all the other system calls
2010.13s - 2013.37s |  that the EDR is not hooking, and then it just does some math.
2013.37s - 2015.45s |  It says, OK, I know the system call before it
2015.45s - 2017.49s |  and the system call after it are this number,
2017.49s - 2020.57s |  so the one in the middle, it can dynamically figure it out.
2020.57s - 2024.01s |  Again, this avoids reading NTDLL from disk.
2024.01s - 2025.81s |  And then there is a really cool technique
2025.81s - 2027.97s |  called address sorting.
2027.97s - 2030.65s |  One of the authors of this open source project
2030.65s - 2032.61s |  realized that all the system calls
2032.61s - 2034.89s |  are put in order alphabetically.
2034.89s - 2037.45s |  So if you just read the addresses of where they all
2037.45s - 2039.25s |  are, it's kind of the same idea.
2039.25s - 2041.65s |  You alphabetically sort them.
2041.65s - 2043.97s |  If the one that you're trying to use is hooked,
2043.97s - 2046.33s |  you just look at the one before it and you add one,
2046.33s - 2048.53s |  and now you know the index that you need.
2048.53s - 2050.21s |  And then even dealing with all of that
2050.21s - 2051.85s |  previously was kind of difficult.
2051.85s - 2054.61s |  There's a lot of assembly, a lot of low-level C code.
2054.61s - 2056.09s |  So there's this really nice project
2056.09s - 2058.09s |  called Sys Whisperers 2, and the 2
2058.09s - 2060.81s |  is important because the first version was not very good,
2060.81s - 2063.49s |  but the second version is very powerful.
2063.49s - 2065.85s |  This integrates with Visual Studio.
2065.85s - 2067.61s |  You call directly through this, and it
2067.61s - 2070.21s |  does all the nasty work in the background for you
2070.21s - 2073.17s |  to dynamically resolve those system call indexes.
2073.17s - 2075.77s |  So if you want to write code that bypasses EDRs,
2075.77s - 2078.21s |  you want to be able to make whatever system call you want
2078.21s - 2080.25s |  without being detected, all you have to do
2080.25s - 2083.53s |  is import the Sys Whisperers 2 into your Visual Studio
2083.53s - 2085.53s |  project, write your malware freely,
2085.53s - 2089.33s |  and it does all the hard work in the background for you.
2089.33s - 2091.13s |  So with all these different techniques
2091.13s - 2093.73s |  that make EDRs blind to what's happening,
2093.73s - 2095.75s |  we wanted to be able to detect this.
2095.75s - 2098.21s |  So we kind of already knew this before going into it,
2098.21s - 2102.17s |  but we did a large sweep across all of our Windows memory
2102.17s - 2104.61s |  samples, and for every version of Windows
2104.61s - 2107.45s |  going back to XP through the latest Windows 11,
2107.45s - 2109.69s |  there's only three DLLs that legitimately
2109.69s - 2111.01s |  implement system calls.
2111.01s - 2113.41s |  There's the NTDLL that I talked about,
2113.41s - 2118.13s |  Wow64 for 32-bit processes, and then Win32 is for the GUI,
2118.13s - 2120.61s |  so what you're seeing here on the screen with Explorer
2120.61s - 2122.29s |  and PowerPoint.
2122.29s - 2125.21s |  So the idea is through memory forensics,
2125.21s - 2127.49s |  if we find the instructions needed
2127.49s - 2129.21s |  to make a system call instruction
2129.21s - 2131.37s |  and set the parameters, and it's not
2131.37s - 2133.75s |  in one of those three DLLs, this is malware
2133.75s - 2137.85s |  trying to bypass the system.
2137.85s - 2140.05s |  And then, like I mentioned, it's some very, very cool
2140.05s - 2141.13s |  low-level work.
2141.13s - 2144.13s |  I threw this screenshot in literally last second,
2144.13s - 2147.69s |  like right before I sent these slides to DEF CON,
2147.69s - 2150.29s |  because there was a talk by a security vendor
2150.29s - 2151.61s |  as I was making the slides, right
2151.61s - 2153.77s |  as I was about to upload it, and I took this screenshot
2153.77s - 2155.37s |  and threw it in last second, because it
2155.37s - 2157.85s |  was talking about malware that was just used recently
2157.85s - 2160.41s |  in the last one or two months in real attacks,
2160.41s - 2162.73s |  and the malware was called DodgeBox,
2162.73s - 2165.29s |  and it's talking about how in every phase of the malware,
2165.29s - 2167.25s |  every component the malware had,
2167.25s - 2171.17s |  it did call stack spoofing, so bypassing the EDRs
2171.17s - 2173.33s |  to make it appear where those system calls,
2173.33s - 2175.17s |  so it's doing direct system calls,
2175.17s - 2177.61s |  making it appear where it came from the trusted binary,
2177.61s - 2179.89s |  so the ones we saw in the last slide, instead
2179.89s - 2181.29s |  of the malware itself.
2181.29s - 2183.89s |  And so it's this constant back and forth between EDRs
2183.89s - 2185.61s |  and malware, trying to figure out
2185.61s - 2188.17s |  that system calls are being made from the wrong spot,
2188.17s - 2190.57s |  but quite honestly, the EDRs are in a tough spot,
2190.57s - 2193.13s |  and usually the malware wins.
2193.13s - 2195.33s |  We don't have these problems with memory forensics.
2195.33s - 2198.37s |  We don't have to detect a system call the second it's made.
2198.37s - 2201.13s |  We're trying to find proof of code that can do that
2201.13s - 2203.45s |  or does that through memory forensics,
2203.45s - 2206.81s |  and so what we did is we used Capstone,
2206.81s - 2209.61s |  which is a very flexible disassembly library,
2209.61s - 2212.85s |  has Python support so you can use it directly in volatility,
2212.85s - 2215.37s |  and what we do is look for blocks of code,
2215.37s - 2219.81s |  so code pattern blocks where EAX gets updated,
2219.81s - 2222.93s |  that's your system call index, where R10 gets updated,
2222.93s - 2225.05s |  where one of the system call instruction happens,
2225.05s - 2226.53s |  and where there's a return.
2226.53s - 2228.77s |  We did a bunch of work so that simple things
2228.77s - 2232.41s |  like to Taurus gate with this no ops wouldn't bypass our code.
2232.41s - 2233.81s |  We're not doing pattern matching.
2233.81s - 2236.97s |  We're doing actual automated static disassembly,
2236.97s - 2239.61s |  and when we tested this on every implementation
2239.61s - 2243.03s |  that we had of this technique, our new plug-in direct system
2243.03s - 2244.39s |  calls detected it.
2244.39s - 2246.81s |  In this case, just to make it fit on a slide nicer,
2246.81s - 2249.29s |  this is Hell's Descent from Hell's Gate,
2249.29s - 2251.81s |  so this is where it's calling the system call
2251.81s - 2253.85s |  instruction on its own, and then
2253.85s - 2256.09s |  the plug-in saying, hey, inside of this process
2256.09s - 2259.33s |  executable with this PID, and it shows you right in memory
2259.33s - 2261.21s |  where that system call handler is.
2261.21s - 2263.57s |  So it's as simple as running this plug-in
2263.57s - 2265.49s |  across your potentially infected samples,
2265.49s - 2269.93s |  and it tells you right where the malware is.
2269.93s - 2272.59s |  And then with the indirect system calls,
2272.59s - 2275.81s |  the idea is instead of having that code pattern where you're
2275.81s - 2279.63s |  making syscall or int2e directly from your malware code
2279.63s - 2281.25s |  or your shell code, which again, you
2281.25s - 2283.45s |  have to do a bunch of call stack spoofing and things,
2283.45s - 2285.21s |  or the EDRs will see you.
2285.21s - 2289.27s |  The idea is you find the address of the syscall instruction
2289.27s - 2293.57s |  in NTDLL, but instead of calling the function of that,
2293.57s - 2295.53s |  you find where the syscall instruction is,
2295.53s - 2296.69s |  and you jump to it.
2296.69s - 2298.41s |  So you set the registers yourself.
2298.41s - 2300.13s |  You do all the prereqs yourself.
2300.13s - 2301.89s |  You jump to the syscall instruction.
2301.89s - 2304.51s |  It looks like it's coming from NTDLL,
2304.51s - 2306.77s |  and then depending on which EDR you have,
2306.77s - 2309.21s |  that EDR is going to think it's the real system call,
2309.21s - 2312.21s |  and then you've bypassed it.
2312.21s - 2315.53s |  So we wanted to be able to detect that as well.
2315.53s - 2318.29s |  And something that also gets used with this technique
2318.29s - 2321.13s |  are the exception handlers and the debug registers,
2321.13s - 2323.57s |  which is the last thing we cover in this talk.
2323.57s - 2326.25s |  So the idea is debug registers have been abused forever
2326.25s - 2327.05s |  by malware.
2327.05s - 2328.89s |  There was a Frack article in 2008
2328.89s - 2332.57s |  that's considered the first public documentation of it.
2332.57s - 2335.89s |  And the idea is by abusing debug registers,
2335.89s - 2338.21s |  you can get your exception handler called
2338.21s - 2339.89s |  at any point in time.
2339.89s - 2341.57s |  And then from your exception handler,
2341.57s - 2344.01s |  you're going to make the system call instruction,
2344.01s - 2347.49s |  and EDRs do not follow this well at all.
2347.49s - 2349.13s |  They don't expect malware to be running
2349.13s - 2351.65s |  inside of exception handlers.
2351.65s - 2353.49s |  So a cool open source project for this,
2353.49s - 2355.81s |  if you want to see it yourself, is called MutationGate.
2355.81s - 2357.53s |  It is on GitHub.
2357.53s - 2359.05s |  And you can see what it's doing.
2359.05s - 2362.09s |  It's adding a vectored exception handler.
2362.09s - 2364.23s |  So it's saying it wants to handle exceptions
2364.23s - 2365.53s |  in its process.
2365.53s - 2367.69s |  This is the function that's going to be called.
2367.69s - 2370.17s |  And then on its own, it sets a breakpoint
2370.17s - 2373.33s |  at this innocuous system call, nt draw text,
2373.33s - 2376.21s |  that has nothing to do with code injection or malware.
2376.21s - 2379.57s |  So the idea is this malware, this code injection,
2379.57s - 2382.21s |  this EDR bypass technique, will get called
2382.21s - 2383.97s |  whenever a breakpoint is set.
2383.97s - 2385.97s |  And then it explicitly sets a breakpoint
2385.97s - 2388.77s |  on where the system call instruction is
2388.77s - 2391.77s |  inside of this innocuous function.
2391.77s - 2394.21s |  So then in the implementation of it, what it does
2394.21s - 2397.09s |  is every time the malware wants to make a malicious system
2397.09s - 2400.53s |  call, it just calls nt draw text, which, again, you can't
2400.53s - 2402.25s |  do anything malicious with that.
2402.25s - 2404.69s |  And then the malware, the MutationGate,
2404.69s - 2408.29s |  it updates RAX right before the system call instruction
2408.29s - 2409.93s |  to be the real system call.
2409.93s - 2412.57s |  So your EDR is going to think, hey, this malicious code's
2412.57s - 2413.61s |  calling draw text.
2413.61s - 2415.53s |  It's going to write something on the screen.
2415.53s - 2417.33s |  But in reality, it's all the prereqs
2417.33s - 2420.88s |  you need for code injection.
2420.88s - 2422.40s |  So we wanted to detect this.
2422.40s - 2425.12s |  We didn't even have to do any major reversing for this.
2425.12s - 2427.84s |  There was two very nice blog posts on the topic
2427.84s - 2429.52s |  that we have referenced here.
2429.52s - 2432.60s |  And the only downside to this is legitimate software
2432.60s - 2434.64s |  uses exception handlers.
2434.64s - 2437.92s |  You don't want your software having an unhandled exception
2437.92s - 2439.56s |  and then crashing the machine.
2439.56s - 2441.52s |  So by having an exception handler,
2441.52s - 2444.48s |  you make it where your code gets to handle the exception,
2444.48s - 2446.72s |  and then you can cleanly exit.
2446.72s - 2449.36s |  So what we did is we, instead of just listing them
2449.36s - 2452.12s |  all out like some plugins do, we applied
2452.12s - 2456.04s |  very similar static disassembly to the function handlers.
2456.08s - 2457.92s |  We looked at all the malicious techniques.
2457.92s - 2459.96s |  We saw which registers they interacted with,
2459.96s - 2462.36s |  which actions they performed.
2462.36s - 2465.12s |  And so instead of just listing out every vector exception
2465.12s - 2467.80s |  handler, we apply the static disassembly,
2467.80s - 2470.20s |  and then we only list out the malicious ones.
2470.20s - 2472.52s |  And as you can see here, with our new plugin,
2472.52s - 2475.60s |  we're catching mutation gate generically right away
2475.60s - 2478.68s |  because of how it interacts with it.
2478.68s - 2482.26s |  There was also a cool project by Marcus Hutchins,
2482.26s - 2485.56s |  where he wanted to bypass EDRs in the same way.
2486.32s - 2488.36s |  Instead of the vectored exception handler,
2488.36s - 2492.96s |  he used the higher level one, the unhandled exception filter.
2492.96s - 2495.48s |  In this case, this is going to be the address of where
2495.48s - 2497.96s |  he has his exception handler called,
2497.96s - 2500.00s |  and then he's calling set thread context
2500.00s - 2501.92s |  on what's an invalid address.
2501.92s - 2505.00s |  So this is going to trigger the exception handler.
2505.00s - 2506.88s |  So what we did here was very similar.
2506.88s - 2510.52s |  We enumerate all the handlers, and then we make it.
2510.52s - 2512.16s |  This keeps jumping a lot.
2512.16s - 2513.80s |  We enumerate all the handlers.
2513.84s - 2516.60s |  We apply our static disassembly, and then in this case,
2516.60s - 2519.28s |  we find his malicious process generically
2519.28s - 2522.24s |  because the exception handler is doing things that you
2522.24s - 2524.88s |  would need to bypass an EDR.
2524.88s - 2526.28s |  And then with the debug registers,
2526.28s - 2528.44s |  the last thing we really show here,
2528.44s - 2530.56s |  if you're familiar with AMSI bypasses,
2530.56s - 2533.20s |  one of the things you need to do is one of the functions
2533.20s - 2536.40s |  you're probably going to tamper with is the scan buffer one.
2536.40s - 2538.48s |  In this case, they set a breakpoint on it,
2538.48s - 2541.52s |  and they make it where that function doesn't get any time
2541.52s - 2542.88s |  that function returns.
2542.88s - 2544.64s |  It returns that the code is OK.
2544.64s - 2546.56s |  So you can send whatever malicious PowerShell
2546.56s - 2550.08s |  you want through, whatever malicious macros that you have.
2550.08s - 2553.04s |  And with this code present, all of your EDRs
2553.04s - 2555.20s |  are forced to say, hey, yeah, this is clean,
2555.20s - 2557.84s |  and then it gets to execute on the system.
2557.84s - 2560.48s |  And you can see that here with our new plugin.
2560.48s - 2562.36s |  So with the vector exception handler,
2562.36s - 2563.84s |  we're catching it right away.
2563.84s - 2566.56s |  The project that implements what you're seeing on these slides
2566.56s - 2568.56s |  is called Patchless AMSI.
2568.56s - 2571.68s |  So we're not only catching its vector exception handler,
2571.68s - 2574.44s |  we're also catching its abuse of the debug registers
2574.44s - 2576.56s |  so that it can be called whenever
2576.56s - 2580.42s |  the code is going to get scanned by the AMSI subsystem.
2580.42s - 2581.92s |  So the end result of our project is
2581.92s - 2584.16s |  we documented and went through every single way
2584.16s - 2586.76s |  that EDRs get bypassed in user land,
2586.76s - 2588.68s |  and then we wrote a bunch of volatility plugins
2588.68s - 2590.24s |  to automatically detect it.
2590.24s - 2592.24s |  Two quick things before I break.
2592.24s - 2594.56s |  We wrote a 19-page white paper about this.
2594.56s - 2597.56s |  It should be on the DEF CON website by now or tomorrow.
2597.56s - 2599.32s |  Feel free to email me if not.
2599.32s - 2600.32s |  Also, the slides.
2600.32s - 2602.40s |  Don't try to take pictures of the next couple of slides.
2602.40s - 2604.08s |  These are all the references that you
2604.08s - 2606.68s |  were seeing with the numbers at the top of the slides.
2606.68s - 2608.04s |  We have like 45 references.
2608.04s - 2609.72s |  It was a huge research effort.
2609.72s - 2611.56s |  The slides are on the DEF CON website as well,
2611.56s - 2613.24s |  or email me if you can't find them.
2613.24s - 2616.40s |  But if you really want to understand in great detail,
2616.40s - 2619.36s |  read the paper, and then read all the references as well.
2619.36s - 2624.53s |  And again, thank you for coming to the talk.