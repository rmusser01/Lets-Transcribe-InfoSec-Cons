{
  "webpage_url": "https://www.youtube.com/watch?v=oAriLYN-5HA",
  "title": "DEF CON 32 -  Exploiting Cloud Provider Vulnerabilities for Initial Access - Nick Frichette",
  "description": "\"In this talk we will explore vulnerabilities in Amazon Web Services (AWS) products which allowed us to gain access to cloud environments.\n\n\nTraditionally, adversaries have abused misconfigurations and leaked credentials to gain access to AWS workloads. Things like exposed long-lived access keys and exploiting the privileges of virtual machines have allowed adversaries to breach cloud resources. However, these mistakes are on the customer side of the shared responsibility model. In this session, we will cover vulnerabilities in AWS services that have been fixed and that previously allowed us to access cloud resources.\n\n\nWe will start with an exploration of how Identity and Access Management (IAM) roles establish trust with AWS services and cover the mechanisms that prevent an adversary from assuming roles in other AWS accounts. We\u2019ll then demonstrate a vulnerability that bypassed those protections. We\u2019ll cover a real world example of a confused deputy vulnerability we found in AWS AppSync that allowed us to hijack IAM roles in other accounts.\n\n\nNext, we'll highlight potential misconfigurations involving IAM roles leveraging sts:AssumeRoleWithWebIdentity. These misconfigurations cloud permit unauthorized global access to these roles without the need for authentication, affecting services like Amazon Cognito, GitHub Actions, and more.\n\n\nFinally, we\u2019ll cover a vulnerability we found in AWS Amplify that exposed customer IAM roles associated with the service to takeover, allowing anyone the ability to gain a foothold in that victim account. We\u2019ll also discuss how security practitioners can secure their environments, even against a zero-day like one we\u2019ll demonstrate.\n\n\nJoin us to learn how attackers search for and exploit vulnerabilities in AWS services to gain access to cloud environments.\"",
  "channel_url": "https://www.youtube.com/channel/UC6Om9kAkl32dWlDSNlDS9Iw",
  "duration": 2361,
  "channel": "DEFCONConference",
  "uploader": "DEFCONConference",
  "upload_date": "20241016"
}

0.40s - 5.90s | This text was transcribed using whisper model: large-v2

 Good afternoon DEF CON. Thank you so much for being here. Welcome to my talk on exploiting AWS
5.90s - 11.08s |  service vulnerabilities for initial access. My name's Nick Frechette. I'm a security
11.08s - 16.72s |  researcher over at Datadog where I specialize in AWS offensive security. So finding ways to
16.72s - 21.48s |  more effectively attack AWS environments and then hopefully how do we detect that behavior
21.48s - 26.22s |  or potentially prevent it entirely. As a result of that research sometimes I find
26.22s - 30.42s |  vulnerabilities in the underlying AWS services. Some of which we're going to be talking
30.42s - 35.72s |  about today. Uh in my free time I'm the creator and maintainer of Hacking the Cloud which
35.72s - 40.40s |  is an open source encyclopedia of offensive security techniques that you can use in cloud
40.40s - 44.34s |  hacking adventures. Uh if you'd like a Hacking the Cloud sticker come find me after. I have
44.34s - 51.18s |  quite a few to give away. Now breaking into AWS accounts is a topic that's near and dear
51.18s - 56.82s |  to my heart. And I'm sure it is for many of you as well. But I think if we're being honest
56.82s - 61.82s |  with ourselves the traditional methods for gaining access to AWS environments are boring.
64.32s - 69.52s |  If we were to poll the audience for real world AWS breaches, compromises and other security
69.52s - 75.96s |  incidents I guarantee 95 percent of scenarios would fall into one of three categories. They
75.98s - 81.82s |  were either caused by a leaked access key, an exposed S3 bucket or an exploited EC2
81.82s - 86.82s |  instance. These are the stereotypical ways that adversaries gain access to AWS accounts. And
89.30s - 94.90s |  to be clear these are very real risks that we do have to contend with but it's nothing you
94.90s - 100.98s |  haven't seen before and again these methods are boring. What we're going to be doing instead
100.98s - 105.64s |  is kicking it in the door to the cloud and exploiting vulnerabilities in AWS services to get
105.66s - 112.60s |  initial access. Particularly by abusing pre-existing trust. What I mean by that is a
112.60s - 118.98s |  common design pattern in AWS is to have IAM roles in your account that have a trust
118.98s - 123.98s |  relationship back to some AWS service. This enables that service to perform actions and uh do
127.12s - 131.68s |  functionality in your account. Today we're going to look at some vulnerabilities that would
131.70s - 136.80s |  allow us to hijack that trust relationship and gain access to victim accounts so that from
136.80s - 142.74s |  there we can escalate privileges, move laterally, access resources and more. In this session
142.74s - 147.92s |  we're going to talk a little bit about how trust is established between IAM roles and AWS
147.92s - 152.86s |  services. Then we're going to dive deep on two vulnerabilities as well as a more general
152.86s - 157.52s |  misconfiguration that would allow us to take advantage of this. And finally we're going to
157.54s - 163.04s |  discuss prevention options. In the absolute worst case scenario of an adversary having a
163.04s - 168.04s |  cross-tenant zero day in AWS, what options do we have to try and mitigate some of these
168.04s - 173.18s |  attacks? Now it's worth noting that the majority of the vulnerabilities we're going to be
173.18s - 178.48s |  talking about today have been remediated by AWS. So think of this more from the perspective
178.48s - 182.96s |  of what can we learn from these vulnerabilities that we can apply to better attack or defend
183.00s - 188.80s |  cloud environments. To get us started on the topic of abusing pre-existing trust, we should
188.80s - 193.82s |  probably talk about how that trust is established. In AWS, every IAM role is going to have a
196.82s - 201.82s |  role trust policy. And this policy determines who or what is permitted to assume a role.
204.96s - 211.56s |  Trust policies can trust a variety of identities. Users, roles, AWS organizations, uh identity
211.56s - 217.40s |  providers and many others. But where I think it's most interesting is when they trust an AWS
217.40s - 223.70s |  service itself. What you see here on the slide is the default trust policy that is associated
223.70s - 228.94s |  with roles for the Lambda service. If you were to create a Lambda function today, the role
228.94s - 233.66s |  that would be created for you would have this very same trust policy. And what it says is
233.66s - 239.32s |  that we're going to allow the Lambda service to assume role with web or sorry to assume
239.38s - 246.26s |  role. Now the way this works in practice is every time your Lambda function runs, the Lambda
246.26s - 252.46s |  service assumes that role in your account and does whatever it is that you want it to do. This
252.46s - 257.90s |  behavior introduces some really interesting questions. Since I already said that this is the
257.90s - 264.90s |  default policy, theoretically the majority of roles using Lambda would have it. And since the
264.90s - 270.56s |  trust policy just says that it trusts Lambda, could I do something a little bit sneaky? Could I
270.56s - 276.10s |  create a Lambda function in my account but point to or reference a role in a different AWS
276.10s - 282.14s |  account? Preferably one that I don't have legitimate access to. Uh could we cause that Lambda
282.14s - 287.78s |  service to assume that role in the victim account and carry out whatever operations would be
287.78s - 292.92s |  beneficial to us as adversaries? Well, the good news or bad news depending on your
292.94s - 298.14s |  perspective is there is something that stops this. And that's called pass role. Anytime you are
298.14s - 304.68s |  providing a role to an AWS service for it to assume it, you're interacting with pass role. One
304.68s - 311.16s |  of the core rules of which is that you can only pass a role within your same AWS account. If
311.16s - 315.76s |  you try to pass a role outside of it, you get the error message, access denied, cross account
315.76s - 321.80s |  pass role is not allowed. Now this is a very important security boundary in AWS because
321.82s - 327.22s |  without it, theoretically we could just arbitrarily assume role into pretty much any account and
327.22s - 331.66s |  access any of the resources associated with it. So this is going to be the goal for the first
331.66s - 336.56s |  part of our session today. Finding a vulnerability in the pass role implementation to allow us
336.56s - 343.00s |  to weaponize a service against roles that trust it and access resources in victim accounts.
343.00s - 348.50s |  So the first vulnerability is a confused deputy vuln in AWS AppSync. If you're not familiar
348.54s - 354.32s |  with AppSync, AppSync is a managed GraphQL service offered by AWS. And it allows you to
354.32s - 360.62s |  quickly and easily build GraphQL APIs. The way that it works is pretty similar to what I
360.62s - 365.76s |  described with Lambda. Where you first create an AppSync API in your account, configure it, set
365.76s - 370.60s |  your schema, uh and so on. And then as a part of setting your data source, a role will be
370.60s - 376.94s |  created for you that by default has a trust policy back to the AppSync service. Then when
376.94s - 382.42s |  your AppSync API is run, the AppSync service assumes that role and does whatever that API is
382.42s - 387.48s |  supposed to do. And again, if you try to pass a role outside of your account, cross account
387.48s - 393.22s |  pass role is not allowed. Now, I recognize this is DefCon and I'm sure many of you are already
393.22s - 397.90s |  trying to come up with ways that we can bypass this control. Things like unique encoding
397.90s - 403.54s |  schemes, maybe something like HTTP request smuggling or maybe even something more exotic.
403.54s - 408.42s |  These are all great ideas and I strongly encourage you to pursue them. But we actually found a
408.42s - 413.42s |  much simpler approach to get around this. Through the power of Spongebob memes. See, under
415.92s - 421.52s |  normal circumstances, the AWS API is typically case sensitive. And what I mean by that is, if
421.52s - 428.20s |  you pass a parameter to the AWS API, it expects it in a very particular casing format. If you
428.20s - 434.00s |  don't meet that expectation, you'll get an error. So to demonstrate this with a completely
434.00s - 440.18s |  unrelated API, here we're performing secrets manager create secret. And that API expects a
440.18s - 446.54s |  name parameter with a capital N. So long as you pass it in that format, 200 OK, everything
446.54s - 453.76s |  worked, you created a secret. However, if we were to deviate from that format in any way, in
453.78s - 459.26s |  this case we've put it to all uppercase, we try to pass that to the API, it complains. 400 bad
459.26s - 465.30s |  requests, member must not be null. The reason for this is, well, we didn't pass the parameter
465.30s - 470.64s |  it was looking for. It might be the right alphabetical characters, but it's not the specific
470.64s - 476.64s |  one and so it rightfully so throws an error. While this may sound like a fairly obvious thing
476.64s - 481.44s |  to point out, the reason it matters is that by comparison, the AppSync API was a bit of an
481.46s - 488.14s |  oddity. It was not case sensitive. We could pass arbitrary parameters of mixed casing and
488.14s - 493.28s |  the API would take it totally fine. Presumably somewhere on the back end it was normalizing
493.28s - 498.28s |  these values in some way. Now, the parameter you would use to pass a role ARN to the AppSync
501.18s - 507.28s |  service was called service role ARN. Capital R, capital A. If you try to pass a role outside
507.30s - 513.40s |  of your account, once again, cross account pass role is not allowed. But, if we change the
513.40s - 519.04s |  casing on that parameter in any way, even on just a single character, in this case we made it
519.04s - 524.72s |  all lowercase, and we try to pass a role outside of our account, for some unknown reason,
524.72s - 528.92s |  whatever filtering or allow listing or checking that was supposed to occur, either didn't
528.92s - 534.06s |  happen at all or completely failed. And so by changing the casing on a parameter, we were
534.08s - 540.84s |  able to now arbitrarily specify roles for the AppSync service to try and assume. And so we
540.84s - 547.72s |  were able to break a major security boundary in AWS with Spongebob memes. To put this in
547.72s - 553.82s |  another, in another context, what this allowed us to do was to target any role that
553.82s - 560.20s |  legitimately used the AppSync service in any AWS account. We could now provide that role to
560.20s - 566.24s |  the service and arbitrarily assume it and access whatever resources were associated with it.
566.24s - 571.68s |  This is an example of a cross service confused epi attack, where a lower privilege entity, in
571.68s - 576.88s |  this case us, was able to trick or coerce a higher privilege entity, in this case the
576.88s - 582.46s |  AppSync service, to do something on our behalf. In this scenario, that was assuming a role in
582.46s - 587.64s |  a victim account. It's really important to stress, the thing that makes this possible, the
587.64s - 593.68s |  thing that enables this attack, is that pre-existing trust relationship between those IEM
593.68s - 599.22s |  roles and the AppSync service. Because the roles trust AppSync and because we found a way to
599.22s - 604.12s |  weaponize that service against them, this is the path that allows us to assume those roles in
604.12s - 610.36s |  victim accounts. Now if you've ever done cross tenant attacks in AWS, you know that assuming a
610.36s - 615.94s |  role is only half the battle. From here, we have to actually do something useful. If we were
615.94s - 620.98s |  in a scenario where, say we had a vulnerability similar to this, but we were limited to
620.98s - 627.22s |  something like S3 list buckets as the only API call we could make, well yeah it's not great, um
627.22s - 631.52s |  I wouldn't be very happy of it if I was a defender, but at the end of the day there's very
631.52s - 636.26s |  little risk that could be demonstrated there. The good news for us is that in this scenario,
636.26s - 642.14s |  the AppSync service is more than happy to provide. In particular, AppSync allows you to run
642.14s - 647.14s |  arbitrary AWS API calls. So you now have the full spectrum of API calls that you can invoke at
650.54s - 656.82s |  your choosing. Now for a step by step practical example of how we'd exploit this, as an
656.82s - 662.32s |  attacker we'd create our own AppSync API. Configure it, set the schema, create our data
662.32s - 667.36s |  sources and so on. Then we would perform that pass role bypass to specify what role in the
667.36s - 672.86s |  victim account we want to assume. And then under normal circumstances, the AppSync service
672.86s - 677.46s |  would assume the role in our account. But because of this vulnerability, it now assumes the
677.46s - 683.40s |  role in the victim account and carries out whatever API operation we asked it to perform. The
683.40s - 688.04s |  neat thing about this, from a attacker's perspective, is if you've ever done pen testing or
688.04s - 692.42s |  red teaming in AWS, you know that one of the challenges you have is that you're trying to find
692.42s - 696.18s |  credentials with access to things that you care about. And if you can't find them
696.20s - 700.88s |  immediately, how can you move laterally, escalate privileges, find other credentials and
700.88s - 706.44s |  things like that? Becomes a bit of a hassle. By comparison, with confused deputy attacks, you
706.44s - 712.12s |  can just land as the identity of a production application. If there's a production AppSync
712.12s - 718.12s |  API, it has privileges to do whatever that service needs to do. Whether that is upload S3,
718.12s - 724.70s |  write to DynamoDB, read from RDS or anything else. Because we land as that role, we have
724.72s - 729.46s |  access to whatever privileges are associated with it and these tend to be fairly beneficial.
729.46s - 735.10s |  So no need for weird bloodhound-esque lateral movement paths, you just pass that role and
735.10s - 739.64s |  yow you're in. That's how we can do things like this in this screenshot where we dump the
739.64s - 745.64s |  contents of a DynamoDB table, cross tenant in AWS, by asking it to perform the DynamoDB
745.64s - 750.88s |  scan operation. If you're interested in this vulnerability and you'd like to learn more,
750.90s - 756.74s |  AWS did release a security bulletin for it and in addition we have a blog post with a ton of
756.74s - 761.48s |  additional information on conducting confused deputy attacks in AWS and some things to look
761.48s - 766.48s |  out for. Um the respective QR codes with the arrows will take you to each of those. Now
768.48s - 772.96s |  before we get to our next vulnerability, it's important that we learn a few things about a
772.96s - 779.06s |  assume role with web identity. Up until this point, we've been talking about plain assume
779.14s - 785.92s |  role, which is typically used for AWS to AWS role assumption. As an example, if you have an
785.92s - 790.98s |  AWS account and you would like me to assume a role in that account to do something, we'd
790.98s - 796.86s |  probably end up using assume role. Now while this is great, it does have sort of a limitation
796.86s - 803.66s |  and that it requires the entity doing the role assumption to originate from AWS. And
803.66s - 807.70s |  unfortunately there are a variety of use cases in which you might want to have an identity
807.74s - 813.44s |  from outside Amazon have the ability to assume role in your account. What do you do? Well
813.44s - 818.08s |  that's where assume role with web identity comes in. The core idea here is that you
818.08s - 823.72s |  essentially offload the responsibility of authorizing that role assumption onto an identity
823.72s - 828.80s |  provider of your choosing. This can be a private identity provider, one that you or your
828.80s - 833.70s |  company own and maintain, or it can be a public identity provider. Think things like
833.70s - 840.34s |  Facebook, Amazon, Google, GitHub and many others. The sort of core idea here is that your
840.34s - 845.02s |  external users, whether they be human or machine, interact with the identity provider to
845.02s - 850.36s |  generate a JWT. They pass that into the assume role with web identity call and this enables
850.36s - 855.70s |  them to assume a role in your account. Now before we go any further, I really want to stress
855.70s - 861.10s |  that assume role with web identity is a general design pattern. A variety of technologies
861.10s - 867.38s |  and services, both native to AWS and outside of it, will use this general design pattern. In
867.38s - 872.12s |  the next couple slides we're going to use GitHub Actions as an example, just to sort of
872.12s - 875.78s |  explain how this works and talk a little bit more about the underpinnings, but I really want
875.78s - 884.80s |  to stress, this is not limited to just GitHub Actions. To one common problem with CIC pipelines,
884.80s - 888.50s |  particularly if they're outside of your cloud provider, if you're using something like GitHub
888.50s - 894.14s |  Actions, well, how do you authenticate to an S3 bucket if you wanted to upload, say, some
894.14s - 898.48s |  sort of build artifact or logs or anything else? Well, we could use assume role with web
898.48s - 904.68s |  identity. To set this up, we initially create a trust relationship between our AWS account
904.68s - 909.26s |  and an identity provider. Since we're already using GitHub Actions, we might as well use
909.26s - 915.96s |  GitHub's provided identity provider. Once that trust is established, we then create an IEM
915.96s - 921.92s |  role. And like I said before, all roles have a role trust policy, and in that policy we
921.92s - 928.10s |  specify the identity provider as the entity that's allowed to assume the role. Then every
928.10s - 934.40s |  time our Git GitHub Action job runs, it will retrieve a JWT that has been signed by that
934.40s - 939.74s |  identity provider, that JWT is passed to an assume role with web identity call, and thus
939.74s - 943.98s |  that job at that pipeline is able to assume the role in our account and do whatever it
944.00s - 950.28s |  wants to do, whether that is upload something to S3 or call any other API calls. Now,
950.28s - 953.64s |  throughout that explanation, you might have noticed something a little bit scary and
953.64s - 958.28s |  thought, perhaps I misspoke or maybe I said something wrong. And I assure you, it's just as
958.28s - 964.66s |  scary as it sounds. What you see here is the most basic, bare bones, simple trust policy
964.66s - 970.30s |  you could possibly write when using assume role with web identity. And what it says is that
970.32s - 975.12s |  we're going to allow the GitHub identity provider the ability to assume role with web
975.12s - 979.80s |  identity. And that's a really scary thought, because if we think about it, GitHub's
979.80s - 985.96s |  identity provider is public. It's global. Anybody has access to it. There's nothing
985.96s - 989.88s |  stopping someone from creating their own GitHub account, creating their own GitHub
989.88s - 996.48s |  Action to generate a JWT signed by that very same provider and passing that into the
996.50s - 1001.90s |  assume role with web identity call, allowing them to access those roles in your account. If
1001.90s - 1007.34s |  you had this trust policy on a role, anybody with access to a GitHub account could have
1007.34s - 1013.24s |  just hijacked it and accessed anything associated with it. That's why anytime you use assume
1013.24s - 1019.48s |  role with web identity with a identity provider that is public or global, you need to also
1019.48s - 1025.92s |  have a condition which restricts specifically who is allowed to assume that role. Again,
1025.96s - 1030.50s |  assume role with web identity is a general design pattern. The specific condition you'll need
1030.50s - 1035.70s |  will differ depending on the service and what specific scenario you're in. Um, to continue
1035.70s - 1041.54s |  using GitHub Actions as an example, uh, you need to specify what GitHub repo or what GitHub
1041.54s - 1047.54s |  organization is allowed to assume that role. Uh, if you're a heavy AWS user, strongly
1047.54s - 1051.62s |  encourage you to audit your roles that use assume role with web identity for this
1051.72s - 1056.56s |  misconfiguration, because again, if you make this mistake, theoretically anybody could just
1056.56s - 1063.20s |  assume that role in your account, which is not optimal. Um, now the good news to all this is
1063.20s - 1067.50s |  this attack that I just described was very much in vogue last year. Number of security
1067.50s - 1071.48s |  researchers, including my own colleague Christoph, identified that this was a potential
1071.48s - 1076.08s |  issue and raised awareness about it. If you'd like to learn a little bit more about the GitHub
1076.08s - 1080.08s |  specific situation, uh, we have a blog post with a ton of details and that QR code will take
1080.08s - 1085.82s |  you there. Uh, now, to AWS's credit, they actually did something about this. In
1085.82s - 1092.12s |  particular, they made what was once an optional condition now mandatory. You can no longer
1092.12s - 1097.06s |  create a role trust policy for the GitHub identity provider that doesn't include a
1097.06s - 1103.44s |  condition. And so, that's good. Kudos to AWS, that's a great change. But, if we were to
1103.44s - 1107.90s |  nitpick it, remember, I said assume role with web identity is used all over the place in a
1107.92s - 1113.16s |  variety of contexts and they only fixed it specifically to GitHub actions. Any of the other
1113.16s - 1119.00s |  technologies or services that have this very same potential misconfiguration were slash are
1119.00s - 1124.34s |  still vulnerable. So again, definitely encourage you to audit your roles. There is one such
1124.34s - 1129.18s |  service that I'd like to dive a little bit more deeply on, uh, and that is Cognito. Uh,
1129.18s - 1135.52s |  Cognito is a sign in as a service offering from AWS. If you want to store user credentials
1135.54s - 1140.14s |  but you don't want to deal with the hassle of, uh, hashing, salting, password reset flows
1140.14s - 1144.68s |  and things like that, you can pay Amazon a fee and they'll take care of that for you. One of
1144.68s - 1150.02s |  the core features of Cognito is something called an identity pool. And an identity pool is a
1150.02s - 1155.26s |  resource you can create in your account that allows you to distribute short lived IEM
1155.26s - 1162.40s |  credentials to your users. So that they can assume roles in your account. As an example, say
1162.42s - 1167.42s |  you're building a web application and you want your users to be able to upload content to S3
1167.42s - 1172.22s |  or invoke an API gateway using IEM auth, the way you could achieve this is creating a
1172.22s - 1176.56s |  Cognito identity pool, allowing your users to interact with it, to generate tokens. They
1176.56s - 1180.40s |  would then, uh, through a library in the client, pass that to the assume role with web
1180.40s - 1186.70s |  identity call and assume the role in your account. The good news about Cognito is that they
1186.70s - 1191.40s |  seemingly foresaw the very same attack that occurred with GitHub actions. They do by
1191.40s - 1198.48s |  default include a condition to defend against it. Specifically, the condition will restrict
1198.48s - 1204.56s |  which identity pool is allowed to assume a role. And this is very important because if the
1204.56s - 1209.56s |  trust policy looked like this, anyone in the world would be able to assume that role. And
1209.56s - 1212.90s |  we're gonna talk about some reasons why that trust policy might look like this in just a
1212.90s - 1219.20s |  little bit. Uh, the way that we can take advantage of it is slightly different than what we
1219.24s - 1224.24s |  described with GitHub actions. This is mostly an implementation detail specific to Cognito
1224.24s - 1229.24s |  identity pools. Specifically, what we're gonna do is use a, uh, Cognito offload. Offloads
1230.98s - 1235.98s |  are essentially like the, uh, essentially the step by step operations, uh, that a user
1238.66s - 1243.42s |  would use to generate those credentials. There are two offloads currently supported. An
1243.42s - 1249.06s |  enhanced offload and a basic offload, sometimes referred to as classic. We're gonna
1249.06s - 1254.06s |  focus on classic because that allows us to actually specify the role we want to assume
1254.06s - 1259.24s |  because the final operation in this chain is assume a role with web identity. Um, the
1259.24s - 1263.20s |  specific step by steps are as an attacker, we're gonna create our own Cognito identity
1263.20s - 1268.64s |  pool. We're gonna, going to then perform get ID and get open ID tokens to generate that
1268.64s - 1273.68s |  JWT. And once we have that JWT, we pass it in an assume role with web identity call and
1273.68s - 1278.32s |  this allows us to assume the role in the victim account. So for our purposes, for the
1278.32s - 1283.82s |  remainder of this talk, we'll refer to this as the variant one vulnerable trust policy. A
1283.82s - 1288.72s |  trust policy tied back to, uh, the Cognito service but not including a condition to
1288.72s - 1294.00s |  restrict which identity pool is allowed to assume it. The reason we call this variant one
1294.00s - 1297.46s |  is cause there's a variant two as well. You might have noticed there's actually two
1297.46s - 1303.30s |  conditions on the default trust policy associated with roles using Cognito. And this
1303.32s - 1309.12s |  condition is the AMR condition or the authentication methods references. And this value can
1309.12s - 1313.24s |  be either authenticated or unauthenticated. You might wonder, could we assume a role if
1313.24s - 1317.94s |  this condition was set? And it turns out, yeah, absolutely, we totally could. If the value
1317.94s - 1322.28s |  was set to unauthenticated, then literally everything I just said works completely the same,
1322.28s - 1327.28s |  no changes required. If the value is authenticated, then we do have to jump through some
1327.28s - 1331.52s |  extra hoops. In particular, in our attacker controlled account, we have to create a
1331.54s - 1336.74s |  Cognito user pool, configure it alongside the identity pool, and then from there, basically
1336.74s - 1342.58s |  all the same steps apply with some minor changes. All this condition is doing is checking
1342.58s - 1347.36s |  that you are authenticated to an identity pool, not that you are authenticated to a
1347.36s - 1351.76s |  specific identity pool. And since we can just create our own identity pool, we can
1351.76s - 1357.04s |  configure it however we like, so we can add authentication if we need to. Now, earlier
1357.04s - 1361.10s |  you might have noticed that I called this a misconfiguration, and that's because it is.
1361.12s - 1366.06s |  The GitHub action stuff, this Cognito stuff, any of the other myriad of services which have
1366.06s - 1371.80s |  this very same issue, all of these are misconfigurations, not a vulnerability. Had you
1371.80s - 1376.54s |  suffered a breach, compromise, or other security incident as a result of it, well,
1376.54s - 1380.34s |  unfortunately that would be your responsibility as a part of the AWS shared responsibility
1380.34s - 1385.08s |  model. And so you're probably wondering, well Nick, I was promised a second vulnerability,
1385.08s - 1390.22s |  you're calling this a misconfiguration, what gives? Well, uh, this is where things get weird,
1390.24s - 1395.68s |  and we dive into our second vulnerability of the day, the AWS Amplify service exposing
1395.68s - 1401.02s |  IEM roles to take over. Uh, see, earlier this year, when we noticed this capability in
1401.02s - 1405.86s |  Cognito, one of the first questions we had was, okay, cool, I wonder how common this
1405.86s - 1411.00s |  misconfiguration is? And because it could be used for initial access, literally just a
1411.00s - 1415.24s |  Zoom rolling into victim accounts, we wanted to know if we could use publicly available
1415.26s - 1421.26s |  data to find vulnerable roles and notify their owners so they could be fixed. To do this, we
1421.26s - 1425.94s |  used a tool called Sourcegraph, one of the free features of which is essentially like a
1425.94s - 1432.08s |  Google search, but for public GitHub repos. Uh, we, we wrote a regular expression to find
1432.08s - 1437.78s |  IEM role ARNs, threw that into Sourcegraph, got back results, deduplicated them, removed
1437.78s - 1442.22s |  like clearly placeholder ARNs, like account IDs with all one digit or incrementing digits,
1442.24s - 1447.90s |  things like that. Uh, and that left us with a little over 8,000 results. We then tried to
1447.90s - 1452.88s |  assume each role twice, once authenticated and once unauthenticated, and we let our
1452.88s - 1458.52s |  automation run, and pretty much immediately it was clear, something was terribly wrong.
1458.52s - 1463.56s |  Remember, this was across all of public GitHub, across teams, organi- organizations,
1463.56s - 1469.10s |  individuals, and companies, so why was it then that the overwhelming majority of roles
1469.10s - 1475.02s |  that we found to be vulnerable all had this weirdly specific naming convention? What you
1475.02s - 1479.82s |  see here on the slide are real, real, real roles that we found in the wild that were
1479.82s - 1484.60s |  vulnerable, that we have slightly modified the names of so as to respect the anonymity of
1484.60s - 1489.80s |  their owners. Now, what made these roles so weird was that they all ended in either auth
1489.80s - 1494.96s |  role or unauth role. And additionally, they had what appeared to be either a time stamp
1494.96s - 1501.04s |  dating back to 2018 or 2019, or they had a six digit integer. Presumably, these were the
1501.04s - 1505.98s |  newer ones. To make things even more weird, as we were going through the results, we actually
1505.98s - 1511.88s |  found three roles that belonged to AWS themselves. And so at this point, it wasn't clear if
1511.88s - 1517.02s |  this was some sort of uh, tutorial gone wrong, where somebody was demoing how to set this
1517.02s - 1522.02s |  up with OIDC, not realizing that it was vulnerable and letting anybody just assume these
1522.02s - 1528.30s |  roles in anybody's account. Uh, using source graph, we were able to see the name of the file
1528.30s - 1533.34s |  where these roles were being found. And again, the overwhelming majority were found in
1533.34s - 1540.14s |  files called team provider info dot Jason. And through this, this led us ultimately to the
1540.14s - 1546.08s |  culprit. The thing that was causing all these roles to let anybody assume them. Turns out it
1546.08s - 1552.98s |  was AWS Amplify. Normally, when we're talking about a misconfiguration, we're talking
1552.98s - 1557.26s |  about a mistake, misunderstanding, developers moving a little bit too quickly and breaking
1557.26s - 1562.66s |  things or not realizing that something is as vulnerable as it actually was. This was a rare
1562.66s - 1568.60s |  circumstance in which an AWS service itself was exposing IEM roles such that anyone could
1568.60s - 1573.64s |  assume them. The vulnerability was not that you could misconfigure roles, it's that AWS
1573.64s - 1578.44s |  was doing it to you. And fortunately not just once, they actually did it twice. If you're not
1578.44s - 1583.44s |  familiar with Amplify, Amplify is a uh, web and mobile application framework that lets you
1583.44s - 1588.92s |  build these technologies. Uh, one of the core selling points to Amplify is essentially that
1588.92s - 1595.22s |  uh, by using Amplify, it will abstract away a lot of the underlying infrastructure. So, if
1595.22s - 1599.96s |  you build a web application and you want your users to be able to create accounts, sign up,
1599.98s - 1605.12s |  change the password and so on, your developers don't even need to know what Cognito is. They
1605.12s - 1611.20s |  can simply add authentication through Amplify and Amplify goes in, creates Cognito resources,
1611.20s - 1616.96s |  configures them, sets them up and so on. Key emphasis, Amplify configures those Cognito
1616.96s - 1622.60s |  resources. Now, there's two ways you can build an Amplify app or configure them. Uh, they're
1622.60s - 1627.48s |  not mutually exclusive, you can use either or. Uh, there is the studio which is the web
1627.50s - 1632.40s |  console portal equivalent and then there is the CLI which you can run from your local machine
1632.40s - 1637.84s |  or as a part of your CI city pipeline. Now, typically when we do cloud security research, one
1637.84s - 1642.24s |  of the challenges we often have is it's not really clear why this vulnerable, vulnerable
1642.24s - 1646.68s |  behavior is occurring. We might be able to see that something has security impacts but it's
1646.68s - 1650.76s |  not clear what exactly happened or why it's doing this. For example, with the first
1650.76s - 1654.96s |  vulnerability, for some remarkably strange reason, changing the casing on a JSON
1654.98s - 1660.18s |  parameter let us break a major security boundary in AWS. So, we run into these types of
1660.18s - 1664.62s |  scenarios fairly frequently. What's neat about this Amplify vulnerability and why it's
1664.62s - 1669.56s |  personally one of my favorites is that this is actually a rare instance where we are able to
1669.56s - 1675.56s |  know not only how did this become vulnerable but when. That's because the Amplify CLI
1675.56s - 1681.40s |  written by AWS is actually open source and by digging through the commit history we can
1681.44s - 1686.88s |  see how and when these vulnerabilities were introduced. And we didn't know it at the time
1686.88s - 1692.38s |  but later on in speaking to AWS employees we came to find out that the Amplify studio, the
1692.38s - 1698.46s |  web console equivalent actually uses parts of the CLI as libraries. And that's how I can
1698.46s - 1704.20s |  tell you with confidence that both the Amplify studio and CLI became vulnerable on or around
1704.20s - 1710.64s |  July 3rd 2018 to the variant 2 vulnerable trust policy. Allowing anyone in the world the
1710.64s - 1716.32s |  ability to assume these roles. What happened here is that any time you create an Amplify
1716.32s - 1721.76s |  project 2 roles are created for your account. An auth role and an unauth role like we saw
1721.76s - 1728.76s |  previously. Unfortunately as a part of this commit the default trust policy associated with
1728.76s - 1733.74s |  those roles was set to this which would allow anybody in the world to assume them. So, if
1733.74s - 1737.70s |  you thought you were building a private internal only application that required
1737.70s - 1741.18s |  authentication and you were gatekeeping who could create accounts so that you could
1741.18s - 1746.50s |  protect your stuff, well, um, sorry, no, no you weren't. Anybody could just assume those
1746.50s - 1751.58s |  roles and access whatever was associated with them. Like I said that was introduced on July
1751.58s - 1756.58s |  3rd 2018. A little over a year later on August 8th 2019 AWS sort of fixed this issue. Uh,
1760.22s - 1765.12s |  seemingly unintentionally. What they did was they set the default effect to a deny and
1765.12s - 1769.76s |  they removed the condition entirely. This is actually the exact same behaviour we see
1769.76s - 1775.30s |  today when uh creating a new Amplify project. It's really important to stress though that
1775.30s - 1780.56s |  what this change did in August of 2019 was make it so that no future roles would become
1780.56s - 1786.24s |  misconfigured. Any that had already been created were still vulnerable and that's how we
1786.24s - 1791.24s |  were able to assume them in 2024. Later on in July of 2020 variant 1 was introduced to the
1791.60s - 1796.60s |  Amplify CLI in studio. And this one was a bit more complicated than the previous one. What
1798.98s - 1804.08s |  happened here was that, like I said previously, you can add authentication to an Amplify
1804.08s - 1809.52s |  project. If at any time you chose to remove authentication for any reason, that would
1809.52s - 1814.56s |  introduce the variant 1 policy. Uh, in speaking to developers who were affected by this, it
1814.56s - 1820.06s |  seems the most common reason that this occurred was situations in which uh, uh, projects
1820.08s - 1825.26s |  started with the built-in Amplify controlled Cognito resources and then at a later time
1825.26s - 1830.46s |  moved to Cognito outside of Amplify or to just a different identity provider entirely.
1830.46s - 1835.50s |  Regardless of the reason why, what occurred was that a cloud formation template would run
1835.50s - 1840.00s |  that would start setting the default trust policy to what you see on the slide, which is
1840.00s - 1845.78s |  totally fine. This is the secure trust policy. However, under the line, uh under the
1845.80s - 1850.38s |  condition for the deletion of the authentication configuration, there was a line to delete
1850.38s - 1855.64s |  the condition off of the trust policy, which left you with this. The variant 1 vulnerable
1855.64s - 1861.72s |  policy. Whatever identity permissions were associated with this rule, when this exposure
1861.72s - 1867.26s |  occurred, it still had access to. So if your rule could do something like uh, read from an
1867.26s - 1872.70s |  S3 bucket, write to a demo deep table, it still had that access. Additionally, at the end of
1872.72s - 1878.02s |  the day, these are just plain IEM rules. And unfortunately, developers love to over
1878.02s - 1883.36s |  privilege their identities. When we were reacting to this vulnerability and, and notifying
1883.36s - 1887.80s |  customers so they could mitigate it, we found a number of customers who had highly privileged
1887.80s - 1893.58s |  roles, including some with S3 full access, Kinesis full access, and more. Unfortunately, as a
1893.58s - 1897.58s |  part of this vulnerability, now anyone could have just accessed them and then accessed
1897.60s - 1904.00s |  whatever resources were associated with those accounts. Uh, like I said, that was introduced
1904.00s - 1908.84s |  in July of 2020, and then between then and when we eventually disclosed in 24, more and more
1908.84s - 1914.02s |  roles were becoming misconfigured. One thing I'd really like to stress, uh, that makes this
1914.02s - 1920.42s |  cognito issue even more extreme, is that cognito role RNs are easily discoverable. If we
1920.42s - 1924.22s |  compare this to the first vulnerability we talked about today, a confused deputy volunteer in
1924.24s - 1930.04s |  some AWS service, an adversary still has to contend with the challenge of finding role RNs. To
1930.04s - 1935.08s |  be clear, an RN is not a secret, not in the same way a password or API key is, but it does
1935.08s - 1940.06s |  represent some level of challenge. They would have to brute force them, enumerate them, drive
1940.06s - 1944.36s |  them from IEC, pull them out of build logs, rip them out of GitHub like we did, or a myriad of
1944.36s - 1949.36s |  other ways. Suffice to say, it's something you could do across, say, a small number of
1949.40s - 1954.74s |  organizations, but not something that you could easily scale to the size of the internet. By
1954.74s - 1959.34s |  comparison, the whole point of cognito is that these roles are supposed to be available to your
1959.34s - 1964.58s |  users. They're basically public. And in addition, they're also deterministic in the sense that
1964.58s - 1969.28s |  if you know the unauth role, you now also know the auth role by default. And so what an
1969.28s - 1974.22s |  adversary could have done is simply taken advantage of the default domain associated with
1974.22s - 1980.20s |  Amplify apps to suddenly crawl tens of thousands of apps looking for vulnerable roles. And to
1980.20s - 1984.40s |  be clear, the majority should be fine, but undoubtedly some number of them were created
1984.40s - 1989.94s |  between July, er sorry, uh 2018 and 2019, or who have since changed their authentication
1989.94s - 1994.94s |  configuration since July of 2020. Like I said before, we did disclose this to AWS in January
1997.04s - 2002.38s |  of this year, and AWS released comprehensive fixes in February and April. Uh they did the
2002.38s - 2006.32s |  same thing they did with GitHub Actions, where you can no longer create these vulnerable trust
2006.32s - 2011.16s |  policies anymore, but in addition they sort of went above and beyond. Specific to this
2011.16s - 2016.86s |  Amplify issue, they actually made changes to STS so that you can no longer assume a role
2016.86s - 2022.90s |  cross-account in AWS. So even if you had a variant one or variant two role in your account,
2022.90s - 2027.64s |  somebody from a different account can no longer assume it. If you'd like to learn more about
2027.64s - 2032.72s |  this vulnerability, AWS did release a security bulletin for it, and we have a blog post here
2032.72s - 2036.72s |  with a ton of additional content and information on carrying out these types of attacks, how we
2036.72s - 2042.16s |  found this vulnerability, and more advice on dealing with assume role with web identity.
2042.16s - 2047.60s |  Really quickly though, I did want to mention, um throughout this talk we've been focused on
2047.60s - 2052.94s |  creating resources in an attacker account so that we could then victimize a victim account.
2052.94s - 2057.94s |  The reason for doing this is simplicity. If you own the resource, you can configure it, you can
2057.94s - 2062.48s |  set it up however you like, you know it'll always be available, you can troubleshoot it, but I
2062.48s - 2068.12s |  wanted to mention it's not strictly required, it's just easier. Specific to the Amplify
2068.12s - 2073.72s |  vulnerability, they fixed cross-account role assumption using identity pools. It's no longer
2073.72s - 2079.24s |  possible for me to use one of my identity pools to assume a role in your account. But they
2079.26s - 2083.14s |  didn't do anything about the same account scenario. And to be clear, I don't really think
2083.14s - 2088.40s |  there's much they could do. Uh the reason they were able to block cross-account assume role
2088.40s - 2093.42s |  using this is, well that's, it's a very weird thing to do. It's very likely zero if any real
2095.62s - 2100.12s |  organizations were doing this in the wild. And so they said hey, we can just block this off, we
2100.12s - 2105.10s |  can fix this attack vector and we'll mitigate a lot of the risk. But you can still absolutely
2105.12s - 2110.46s |  do this in the same account and this is something that you can still take advantage of today.
2110.46s - 2115.16s |  Um to be clear, this is more difficult, things are much nicer if you can just bring your own
2115.16s - 2119.44s |  identity pool, but it's definitely something to be aware of if you are penetration duster, red
2119.44s - 2124.94s |  teamer, or you simply use Amplify a lot. The way this would work is that if there is a variant
2124.94s - 2131.48s |  one or variant two role in that account, if there is also a identity pool that is configured
2131.50s - 2137.44s |  with basic authentication or the basic offload, not necessarily associated with Amplify, just
2137.44s - 2143.48s |  any Cognito identity pool with that enabled, you as an external adversary can still interact
2143.48s - 2148.58s |  with that identity pool, generate a JWT, pass it into Sumo with WebIdentity, and still assume
2148.58s - 2153.78s |  one of those variant one or variant two vulnerable roles. Um in the bottom left hand side
2153.78s - 2157.52s |  there's a QR code that'll take you to a Hacking the Cloud article that will walk you through
2157.54s - 2164.24s |  step by step how you can do this in both authenticated and unauthenticated environments.
2164.24s - 2168.34s |  With the time we have left, I wanted to talk a little bit about what we can do to prevent
2168.34s - 2174.34s |  cross-tenant attacks in AWS. To be clear, uh your time is probably much better spent doing
2174.34s - 2178.92s |  things like deleting old access keys, uh cleaning up old IAM users, following least
2178.92s - 2183.72s |  privilege and so on, but if you're already doing all those things, or you have the technology
2183.72s - 2187.70s |  and processes in place, it might be helpful to know that we do have some controls that can
2187.70s - 2193.50s |  potentially prevent some of these attacks. In particular, AWS offers us a number of
2193.50s - 2199.70s |  condition keys that allow us to restrict essentially where an adversary is coming from. Sort
2199.70s - 2205.04s |  of similar to what we saw with a Sumo with WebIdentity previously. These conditions allow us
2205.04s - 2210.42s |  to restrict either the ARN, the account, or the organization that is permitted to assume a
2210.42s - 2215.22s |  role. It's really important to stress, these are not included by default, uh if you were to
2215.22s - 2219.06s |  try to create an instance profile today, it wouldn't automatically add one of these, so you
2219.06s - 2223.36s |  would have to manually attach these conditions to each role you want to assume, or want to
2223.36s - 2228.16s |  protect, and more importantly, make sure that those services are compatible with these
2228.16s - 2234.04s |  condition keys. From some nominal testing, EC2, Lambda, AppSync, all work totally fine, but
2234.04s - 2238.44s |  again, really encourage you to test before you try pushing this into production. To
2238.46s - 2243.64s |  demonstrate how this would work in practice, uh using source account as an example and
2243.64s - 2248.88s |  tying us back to the first uh confused deputy attack we had in AWS, uh by exploiting this
2248.88s - 2253.52s |  vulnerability, an adversary would be able to assume a role which trusted the AppSync service.
2253.52s - 2259.32s |  But if we had set a condition key on that trust policy, limiting what AWS account is
2259.32s - 2264.56s |  permitted to assume that role, it would successfully block that adversary. The way we
2264.58s - 2268.42s |  know this is back in the day when this vulnerability was present, we were able to actually
2268.42s - 2273.52s |  test setting that condition key, and it did successfully block an external adversary. So
2273.52s - 2278.66s |  even in that worst case scenario of someone having a cross-tenant zero day in AWS, by
2278.66s - 2284.60s |  setting this condition key, we can block that access. The other reason I like this is from a
2284.60s - 2290.04s |  defense in depth perspective. If pass rule says, under absolutely no circumstance should
2290.06s - 2294.60s |  someone be able to assume a role cross-tenant, well great, we broke that with SpongeBob
2294.60s - 2299.36s |  memes. So the next time that happens, or if somebody finds a more inventive way around it,
2299.36s - 2304.80s |  let's have an additional layer of protection to block these types of attacks. You're also
2304.80s - 2310.64s |  unlikely to run into many issues, if it works, it's very unlikely to cause uh problems, it's
2310.64s - 2315.88s |  this is more of a static thing that stays the same over time. So in conclusion, we took a
2315.92s - 2320.86s |  look today at how confused epi attacks can weaponize cloud services against us. We took a
2320.86s - 2325.90s |  look at a very dangerous misconfiguration when using assume role with web identity. And
2325.90s - 2330.16s |  again, I strongly encourage you to audit your roles that use it, because if you make this
2330.16s - 2334.28s |  mistake, theoretically anybody can assume roles in your account. It's an easy mistake to
2334.28s - 2339.88s |  make. AWS actually made it twice. Um and then we also took a look today at how we can use
2339.88s - 2345.38s |  uh condition keys to block confused epi attacks in AWS. If you enjoyed this talk, you can
2345.38s - 2349.98s |  find more of our research at securitylabs.daydoghq.com. If you have any questions, feel free
2349.98s - 2354.32s |  to find me after or reach out to me on social media. Again, my name's Nick Frechette. Thank
2354.32s - 2355.00s |  you all so much.