{
  "webpage_url": "https://www.youtube.com/watch?v=5S_1uHLn4SI",
  "title": "DEF CON 32 - Finding & exploiting local attacks on 1Password Mac desktop app - J. Hoffman, C. Morgan",
  "description": "Password managers are routinely granted a massive level of trust from users, by nature of managing some of their most sensitive credentials. For any noteworthy password manager, the encryption standards for user data are well understood and highly scrutinized. What is less understood is the attack surface of the software itself. This presentation explores the local security of the 1Password MacOS desktop application and answers the question of \u201chow safe are my passwords if my computer is infected or otherwise compromised?\u201d.\n\nThis talk will cover the outcome of our research into 1Password, presenting several different attacks to dump local 1Password vaults. This includes describing multiple application vulnerabilities and security weaknesses we identified in the 1Password MacOS desktop application, as well as discussing the inherent limitations in its usage of IPC mechanisms and open source software. Additionally, we will discuss novel vulnerabilities found in Google Chrome that aided our exploitation of the 1Password browser extension.",
  "channel_url": "https://www.youtube.com/channel/UC6Om9kAkl32dWlDSNlDS9Iw",
  "duration": 2330,
  "channel": "DEFCONConference",
  "uploader": "DEFCONConference",
  "upload_date": "20241016"
}

3.25s - 8.25s | This text was transcribed using whisper model: large-v2

 Hello. Hi everyone. Uh, I'm Colby Morgan. I'm here with Jeffrey Hoffman. We're both
9.59s - 14.77s |  offensive security engineers at Robinhood. And earlier this year we did some research into
14.77s - 20.67s |  1Password for Mac. Uh, with the goal of identifying local attacks to dump vaults. And
20.67s - 23.91s |  today we're gonna be sharing with you the outcome of our research and some of the uh,
23.91s - 31.03s |  vulnerabilities we discovered. So, why look at 1Password for Mac? Um, well if you use
31.07s - 35.17s |  1Password, it's probably a place where you have some of your most sensitive credentials.
35.17s - 38.71s |  And we know that APTs, red teamers, one of the first things they're gonna do when they
38.71s - 44.21s |  land on an endpoint is look for credentials. Things like uh, cloud credentials, browser
44.21s - 48.25s |  cookies, um, passwords, API keys, things they might be able to use even if they were
48.25s - 54.39s |  evicted from the laptop uh, to retain um, some sort of access or even more access. Um, if
54.39s - 58.79s |  they were to be grepping around uh, looking for files that have the word password in the
58.79s - 64.29s |  file name, one thing they would find is this 1Password dot SQLite file. And this is a
64.29s - 69.69s |  SQLite database uh, it's encrypted but it contains your uh, 1Password vault contents. So
69.69s - 74.53s |  that file itself wouldn't get you much. Um, so we're gonna talk about some attacks later
74.53s - 79.97s |  that might be able to get you some of that content. Um, so to talk a little bit about the
79.97s - 84.55s |  local security model of 1Password on Mac. Um, when you log in with your password to
84.55s - 89.21s |  1Password, uh, it doesn't actually store your password. It's not even sending your password to
89.21s - 95.35s |  the server. Instead what's going on is um, your password along with a locally stored secret
95.35s - 99.93s |  key are combined cryptographically to generate a master unlock key uh, which is now
99.93s - 103.97s |  referred to as an account unlock key. You'll hear us throughout this talk refer to it as a
103.97s - 110.97s |  muck because that's how we saw it referenced in the code. Um, so we use SSO meaning uh, we
110.99s - 116.83s |  don't have a password for 1Password and how it works in this case is uh, you authenticate and
116.83s - 122.67s |  then you get a device key um, and you receive a credential bundle from 1Password's API and
122.67s - 127.17s |  the device key is stored in your Mac keychain and that is used to decrypt the credential
127.17s - 132.65s |  bundle that contains that muck that I referenced. So the muck is basically the keys to the
132.65s - 138.65s |  kingdom. It allows you to decrypt that SQLite database where your vault content is stored.
138.67s - 144.11s |  Malware on your machine uh, without a SIP bypass on Mac or a way to inject into processes
144.11s - 149.31s |  arbitrarily shouldn't be able to get your vault contents uh, decrypted um, without in the
149.31s - 154.85s |  SSO case unrestricted keychain access and in the non-SSO case um, access to your 1Password
154.85s - 160.59s |  password meaning something you know um, and your locally stored secret key. Once you have
160.59s - 165.33s |  the muck uh, the full decryption process um, isn't super straightforward but it's fully
165.35s - 171.05s |  explained in this blog post from David Shoots aka Darthnal uh, where he also had some code
171.05s - 176.90s |  that we referenced for the decryption and so this was really helpful in our research.
176.90s - 180.94s |  Yeah, so it's generally understood that if somebody has full control over your machine
180.94s - 185.04s |  they're gonna be able to access whatever data it protects in some way shape or form. That
185.04s - 189.08s |  being said, 1Password still cares about creating meaningful security boundaries wherever
189.08s - 194.82s |  possible and on Mac OS specifically with things like SIP and code signing uh, there is a
194.84s - 199.20s |  possibility to create these significant boundaries. Uh, these are just some CVEs that are Mac
199.20s - 203.74s |  specific uh, we took a look at these CVEs when we first started our work and they indicated
203.74s - 208.52s |  to us that we were thinking about the right things and looking in the right places. So when
208.52s - 212.18s |  we started out looking at 1Password we didn't really look at the app, we looked at the
212.18s - 217.92s |  framework that it was built on. Uh, we looked at the framework that it was built on uh, which
217.92s - 222.92s |  is Electron and so Electron is a chromium and node based framework. It has a pretty well
222.92s - 227.90s |  defined attack surface, the standard attack you'll see is somebody trying to get XSS and
227.90s - 232.64s |  convert that into RCE or something else but 1Password is an app, doesn't have a whole lot of
232.64s - 238.50s |  opportunities to inject user controlled content. Uh, the XSS to RCE route is usually
238.50s - 243.22s |  considered uh, a remote attack but because we're local attackers we have the ability to
243.22s - 247.72s |  consider local things and one of the local security controls in Electron is something
247.72s - 253.00s |  called fuses. Uh, these fuses control the behavior of 1Password in certain situations. I'm
253.00s - 256.96s |  not going to read all of these off to you but I'll tell you that 1Password correctly set all
256.96s - 261.80s |  of these. Uh, but some of the interesting ones that, that you might take a look at are things
261.80s - 267.64s |  like only load app from ASAR. Uh, if this had been enabled or rather disabled, uh, you might
267.64s - 272.78s |  be able to proxy the app and inject JavaScript that way. And the enable node CLI inspect
272.78s - 277.76s |  arguments fuse is also pretty interesting. It controls whether or not this Chromium flag
277.76s - 283.12s |  called the remote debugging port works. If that had been enabled in 1Password, we would
283.12s - 288.16s |  have, uh, started it with this flag, uh, connected a Chromium debugger to it and from there
288.16s - 292.34s |  you can see all the pages that the app has. You would have been able to inject, uh,
292.34s - 298.54s |  JavaScript or change the currently running JavaScript in any of those pages. So, once we
298.54s - 303.24s |  saw that all the electron, uh, attack surface was, was considered and wasn't going to be
303.24s - 308.24s |  viable, we started looking at how the app functioned and there were 3 main ways that we saw
308.24s - 314.98s |  to get passwords out of the desktop app and those were the SSH agent, the CLI, and the
314.98s - 320.12s |  browser extension. Now the SSH agent and the CLI were disabled by default, but the browser
320.12s - 325.64s |  extension is enabled by default. And so once we saw this, we installed the browser extension
325.64s - 329.44s |  and as long as the app is unlocked, if you click the browser extension, it's going to
329.44s - 332.60s |  seamlessly sync all of your passwords and they're going to show up without any kind of
332.60s - 336.34s |  re-authentication. And so as soon as we saw that behavior, we started trying to figure out
336.34s - 342.24s |  how we could abuse that. And so we briefly considered the idea of maybe if we had some
342.24s - 347.08s |  cool RCE and sandbox escape, we could control Chrome and try to do that remotely. Those are
347.08s - 351.56s |  prohibitively expensive and again, because we're local attackers, we have much less
351.58s - 355.88s |  expensive options. And uh, that fuse that I mentioned before that controlled the remote
355.88s - 361.32s |  debugging port, that's a Chromium flag. And so while Electron can turn that off, Chrome and
361.32s - 366.50s |  other Chromium based browsers can't. It's just how they work. So as soon as we realized
366.50s - 371.40s |  that, we found the JavaScript responsible for doing the syncing. It's that green URL that's
371.40s - 376.40s |  on screen now. And we opened it up, looked at the console and we saw some log messages
376.40s - 381.14s |  related to native core. This is a native messaging host and we'll re- we'll revisit that in a
381.16s - 387.76s |  little bit. Uh, but essentially what we did is we read the JavaScript from that page, uh,
387.76s - 392.80s |  beautified it, modified it to do that syncing behavior immediately and with the remote
392.80s - 397.74s |  debugging port, we just injected our new extension into that page and uh, everything was
397.74s - 404.04s |  synced and we were able to extract passwords and decrypt them. And so this is our mental
404.04s - 408.62s |  model of 1Password. We'll revisit this image a couple of times during the presentation. Uh,
408.66s - 413.30s |  but what's important to note here is that we didn't really have a vulnerability in 1Password
413.30s - 422.15s |  exactly. We're kind of just abusing how Chrome and extensions function. Yeah, so sticking
422.15s - 426.53s |  along the path of attacking the browser extension, um, one question we were asking
426.53s - 430.27s |  ourselves is would we be able to spoof the legitimate 1Password extension with our own
430.27s - 436.23s |  extension or make changes to the 1Password extension and still uh, still have it do that
436.27s - 442.27s |  automatic syncing process Jeff, uh, referred to before. Um, so if you're not familiar, uh, you
442.27s - 447.01s |  can start Chrome from the command line, uh, along with this dash dash load extension flag to
447.01s - 451.75s |  load extensions from disk, um, which are referred to as unpacked extensions. So what we
451.75s - 456.59s |  were wondering is if we could load a modified version of 1Password from disk, uh, and have it
456.59s - 460.79s |  do that syncing process, obviously the modified code we would add would be JavaScript that
460.79s - 464.27s |  makes it do what we want, such as like taking those passwords after they sync and sending
464.27s - 469.11s |  them to a remote server. Um, there were a couple of kind of challenges that, uh, made this
469.11s - 475.41s |  not straightforward. So, first, uh, the, when the extension talks to the Mac OS 1Password
475.41s - 479.05s |  app, uh, the 1Password app is going to verify that the connection is coming from the
479.05s - 484.49s |  legitimate extension's extension identifier. Um, and then further, we have a managed Chrome
484.49s - 489.09s |  policy that prevents, uh, loading unpacked extensions altogether, meaning we couldn't
489.09s - 494.79s |  launch Chrome with that CLI flag. Um, and also, all extensions are disallowed by default, with
494.79s - 500.77s |  only some being allow listed. So we started trying to tackle these challenges one by one. Uh,
500.77s - 506.03s |  first, uh, spoofing the extension identifier. Thankfully this was extremely straightforward
506.03s - 511.31s |  because Google tells us exactly how to do it on their browser extension, uh, security FAQ
511.31s - 517.59s |  page, where they basically explain that they don't consider this a bug. And, um, basically,
517.61s - 523.19s |  um, every browser extension has a manifest.json file with a bunch of key entries. Um, one of
523.19s - 528.93s |  those is called key, and, um, basically, if you take that key entry and put it in your own
528.93s - 533.69s |  extension's manifest.json file, the extension IDs will be the same because the extension
533.69s - 539.07s |  identifier is derived from that key entry. So we can just grab the legitimate extension's, um,
539.07s - 544.01s |  key identifier, put that on our own extension, and then it'll match. So now we're left with
544.03s - 548.53s |  the challenges from the managed Chrome policy. Uh, we basically started just trying to
548.53s - 554.11s |  figure out how it worked and how it is enforced, and we came across this policy directory in
554.11s - 559.37s |  Google Chrome's, um, application support directory. And we decided to just remove it and see
559.37s - 565.51s |  what happens. Um, so, if you delete that policy directory and you start Chrome, Chrome is
565.51s - 569.29s |  actually smart enough to realize it should be there and it'll recreate it and it'll start
569.29s - 574.47s |  reinforcing itself. However, um, as I mentioned before, we were prevented from starting
574.47s - 578.67s |  Chrome with the dash dash load extension flag, but what you can do is delete the policy
578.67s - 583.05s |  directory, start Chrome with the dash dash load extension flag, which will load your extension,
583.05s - 588.25s |  um, and it, that works because the policy directory doesn't exist at the time Chrome starts,
588.25s - 592.15s |  but then Chrome will recreate that directory and start reinforcing itself, um, but your
592.15s - 596.33s |  extension is already loaded, um, but Chrome will start going through and saying which
596.33s - 601.13s |  extension should be allowed, if it's not allowed, remove it. Um, but thankfully, it's only
601.13s - 605.91s |  doing a shallow check of comparing the extension identifier to the allow list, and we're
605.91s - 610.41s |  spoofing the legitimate extension's extension identifier, so it doesn't remove our modified
610.41s - 617.41s |  1Password. Um, so that overcomes all of the challenges we had, and here is us just, uh,
617.41s - 622.95s |  adding a POC.html file to the extension. We have the legitimate extension identifier, so
622.97s - 627.45s |  our passwords do sync when 1Password is unlocked, um, and it pulls in all our passwords as
627.45s - 631.95s |  expected, and obviously, we could have also added, um, edited the JavaScript or added
631.95s - 638.40s |  JavaScript to, uh, make it grab those credentials and send them elsewhere.
638.40s - 643.04s |  So earlier, I brought up the term native messaging host, and what that is is a binary that
643.04s - 647.70s |  acts as a middleman between, uh, Chrome or other browsers that support this protocol and
647.70s - 653.92s |  the desktop app, and, uh, how it normally works is Chrome will launch it, it will, uh, hold
653.92s - 658.08s |  pipes to the standard in and standard out of that process, and then send JSON messages back
658.08s - 664.28s |  and forth. And if you're familiar with IPC on macOS specifically, that's a big deviation
664.28s - 669.02s |  from the norm. Normally, things use XPC, and part of the reason they do that is because when
669.02s - 673.60s |  you use XPC, you have something called an audit token available to you, and you can use
673.60s - 677.54s |  that audit token to securely look up the code signing information of the process sending
677.54s - 682.34s |  the message. Because there's no audit token, and there's no way to attach it to this method
682.36s - 688.84s |  of IPC, uh, there's not really a great way for 1Password to go and verify the code signing
688.84s - 693.04s |  information of whatever is sending that JSON. And they seem to know about this and, and
693.04s - 698.48s |  still try to implement, uh, a parent PID check, and essentially what they did was they would
698.48s - 702.78s |  call getPPID, go look up the code signing information of the parent, and check it a bunch
702.78s - 708.82s |  of, uh, check it across the list of accepted and trusted browsers. But that's a generally
708.84s - 714.18s |  understood, you know, anti-pattern on XPC. The reason they tried it here is, again, there's
714.18s - 720.82s |  no audit token, so they can't really do much better. Uh, so, going forward, we're going to
720.82s - 724.42s |  talk about dumping, and instrumenting, and hooking, and our tool of choice for that was
724.42s - 728.26s |  Frida. We're going to release some Frida scripts for people to look at other native
728.26s - 735.30s |  messaging hosts. Um, what you can see on screen here is me hooking the read and write
735.32s - 739.76s |  methods for the native messaging host, and this is how we figured out what JSON to send
739.76s - 745.36s |  when we actually wrote our exploit. And so, like I said, it's a well understood problem
745.36s - 750.04s |  that if you're doing XPC, you should be using the audit token because if you try to look up
750.04s - 754.90s |  the code signing information by PID, what can happen is someone will send a message, exec
754.90s - 760.54s |  into the actual process that was supposed to send that message, and by the time the PID is
760.56s - 765.76s |  used, the co-signing information will be that of the trusted process and not the malicious
765.76s - 770.26s |  one that sent that initial message. And so we considered doing that, but we actually don't
770.26s - 775.04s |  have to, there's a, a bunch better way. What you can do is create this process tree of
775.04s - 780.04s |  three processes, where the parent holds the standard in and standard out write pipes, the
780.04s - 785.24s |  child execs into a trusted browser, and the grandchild is actually the browser support
785.28s - 792.02s |  process. And when it goes to do that, uh, get PPID check, we've satisfied that condition. So
792.02s - 796.16s |  this is what the exploit looks like in process, and once you've set up these pipes, you can
796.16s - 802.66s |  just send the JSON that we showed, uh, in the Frida slide, and the browser support process
802.66s - 809.00s |  will happily return back to you the muck. And so here's our mental model again. We've
809.00s - 812.88s |  totally cut Chrome and the need for the actual extension out of the equation, this time
812.88s - 817.16s |  we're attacking browser support. And we were satisfied with this, this is definitely a
817.16s - 821.96s |  valid way to get the muck and, and dump all your vaults, but we thought, well what if we
821.96s - 825.80s |  could also cut out browser support? So we started looking at the browser helper XPC
825.80s - 832.78s |  server. And I've talked a lot about XPC already, I'll spare you, but they do everything
832.78s - 836.52s |  correctly here that you would expect. They take the audit token, they get the co-signing
836.52s - 841.60s |  information in a secure way, and they check the team identifier and bundle ID.
841.60s - 846.54s |  Unfortunately, what they forgot to do was consider, uh, the hardened runtime, or the
846.54s - 850.58s |  co-signing flags of the client. And so, if you're not familiar with hardened runtime,
850.58s - 855.58s |  essentially what it is, is a co-signing flag that says to macOS to, uh, block all different
857.72s - 863.62s |  manners of injecting, uh, code dynamically, and that makes sense, right? If your security
863.62s - 869.16s |  model is going to be built around co-signing, you don't want ways to have untrusted code
869.16s - 874.10s |  running in a process without invalidating that signature. And so that was introduced in
874.10s - 878.76s |  September of 2018, and it would have been literally impossible for them to include that
878.76s - 883.78s |  control, and they were a company before 2018. And so we thought, maybe if we could find
883.78s - 892.14s |  some old clients, we could do this injection and satisfy their checks. Um, yeah, so like
894.20s - 898.24s |  Jeff mentioned, what they were doing is checking the code signature information of the XPC
898.24s - 901.84s |  client to see if it had a matching team identifier. They weren't checking for the
901.86s - 906.30s |  hardened runtime, so we knew what we needed to find. An old version of 1Password that
906.30s - 911.78s |  matched these conditions. Uh, we couldn't find any official source from 1Password that was
911.78s - 916.32s |  offering old versions of clients, so we tried to get a little bit creative, and what we did
916.32s - 920.82s |  is tried to enumerate subdomains of 1Password dot com by looking at certificate
920.82s - 926.62s |  transparency logs. And one of the subdomains we found was c dot 1Password dot com, and it
926.62s - 931.30s |  appeared to be some sort of web cache, we didn't really know what it was used for. Um, so we
931.32s - 937.00s |  used Google dorks to see what files Google had indexed, um, on the URL, and we found a bunch
937.00s - 941.46s |  of old versions of 1Password for all different operating systems. Um, one of the oldest ones
941.46s - 946.58s |  we could find for Mac was version 6.5.2, so we pulled that down, and it looked like a
946.58s - 950.74s |  perfect candidate because it had the correct team identifier, even though it was very old, um,
950.74s - 956.04s |  and it didn't have the hardened runtime. So we figured we likely could inject into it. If
956.06s - 961.60s |  you have a binary that is not signed with the hardened runtime, um, the easiest way to
961.60s - 967.20s |  inject into it is to write your own dynamic library, uh, that runs whatever code you want in
967.20s - 972.34s |  its constructor, and then you load that dynamic library, uh, as you launch the program using
972.34s - 977.34s |  the dial D insert libraries environment variable. This is very similar to LD preload on
977.34s - 982.22s |  Linux, uh, for loading shared objects. Um, basically you can, it'll be the first dynamic
982.24s - 987.04s |  library that the program loads, and it'll run your code pretty much immediately. So we knew
987.04s - 991.82s |  that the XPC server exposed one method called echo, which just echoed a string back to you.
991.82s - 995.66s |  So as a proof of concept, we just wrote our dynamic library to send the string hello world to
995.66s - 1000.76s |  the server. Um, as you can see here, uh, once our code runs, it does send that string, we get a
1000.76s - 1005.76s |  successful response, and this is great because it proves that, um, the XPC server validation
1005.76s - 1011.74s |  was passed by our client. So obviously we didn't want to just echo strings back to
1011.76s - 1016.16s |  ourselves, um, so we looked at what other methods were available, and the one that performed
1016.16s - 1020.54s |  actually interesting functionality was called send to main, uh, where basically a message
1020.54s - 1025.50s |  gets sent through browser helper and then to the main application, um, and gives you a
1025.50s - 1030.84s |  response. Um, so what we tried doing was just sending the same messages that the browser
1030.84s - 1035.58s |  extension was triggering, um, but unfortunately we were just getting no responses
1035.58s - 1040.52s |  whatsoever when we would do that. It would just totally hang. Um, so through some debugging,
1040.54s - 1044.44s |  we found that when our connection was created, there was a connection object and there was a
1044.44s - 1050.48s |  boolean flag on it of is browser equals false, and we figured this might be problematic. Um,
1050.48s - 1055.18s |  and it seemed to be getting set to false because our client's package ID, one password six in
1055.18s - 1060.36s |  this case, uh, didn't match what was expected being the browser support process. Um, so we
1060.36s - 1065.42s |  didn't give up there because we knew that the one password CLI tool, um, called OP, uh, we
1065.46s - 1070.54s |  knew that that also communicated with the same XPC server using XPC messages, so we wanted to
1070.54s - 1076.94s |  understand how that worked. To do so, we pulled down this XPC spy, uh, open source program for
1076.94s - 1082.38s |  inspecting XPC traffic that a process is sending, and we started using, uh, the OP tool, uh,
1082.38s - 1087.28s |  while looking at the XPC traffic, and we saw that it was sending, uh, similar XPC traffic, but,
1087.28s - 1091.72s |  um, it was including this client info JSON blob. Um, and I'll explain kind of the
1091.72s - 1096.40s |  significance of some of the values you see, uh, highlighted in red here in the coming slides,
1096.40s - 1101.46s |  but, um, the point is, we were able to send messages in the same way the one password CLI
1101.46s - 1106.80s |  was and mimic the functionality of the one password CLI. And this was nice, um, but there's
1106.80s - 1112.44s |  quite a few limitations that we weren't satisfied with. First, CLI integration is disabled by
1112.44s - 1117.48s |  default. So, uh, if you're sending these messages and the CLI integration is disabled, nothing's
1117.48s - 1123.12s |  gonna happen. Um, and, you know, most people probably haven't turned it on. So, we were
1123.12s - 1128.46s |  wondering, could we just find where the settings are stored and enable it ourselves? And we
1128.46s - 1133.60s |  found this settings dot JSON file. Um, we opened it, we saw a bunch of Boolean flags for various
1133.60s - 1138.36s |  settings, one of them being CLI integration. Um, but we also saw that every setting had a
1138.36s - 1142.34s |  corresponding auth tag, which looked like a big random string that we assumed was
1142.34s - 1146.34s |  protecting the integrity of the settings through some authenticated hash or something like
1146.34s - 1151.40s |  that. So, we assumed this wasn't gonna work, but we tried it anyway. Switched to CLI
1151.40s - 1155.34s |  integration from false to true and it just worked. So, it seemed like these auth tags were
1155.34s - 1160.58s |  here, probably secure, but they just weren't being enforced yet. So, we can enable CLI
1160.58s - 1166.62s |  integration, great. Uh, but there's still, uh, some serious limitations here. Um, the first
1166.62s - 1171.00s |  being that when you use the one password CLI, you have to approve the session. So, if you've
1171.00s - 1174.30s |  used it before, you're probably familiar with this image on the left, where it's gonna say
1174.36s - 1180.06s |  your terminal is requesting access to one password, do you wanna authorize it or not? Um, and
1180.06s - 1186.64s |  so what we saw was that your session basically gets created based on the XPC messages that
1186.64s - 1191.88s |  get sent when you run the, uh, OP tool. And the session identifier is basically based on
1191.88s - 1196.88s |  the PID of your shell, being the parent process that calls the tool, and the start time of
1196.88s - 1202.06s |  that parent process. And so, it'd be pretty easy for malware on the machine to basically
1202.08s - 1207.66s |  look for any shell that spawns the OP CLI, figure out the PID of that shell, and then grab the
1207.66s - 1211.26s |  start time of the process, and then you'd know a valid session identifier and you could
1211.26s - 1216.26s |  ride along with it, sending whatever messages you want with an approved session. However,
1216.26s - 1220.30s |  um, this, you know, obviously isn't optimal either because it requires that there's a
1220.30s - 1224.64s |  legitimate user sitting there, really using the one password CLI, having an active session
1224.66s - 1229.66s |  that you could spoof alongside. So we kept digging here, um, we, uh, saw that in the
1232.24s - 1236.90s |  client info JSON blob, there was a session type of CLI being sent when the CLI was being
1236.90s - 1242.18s |  used, and, uh, we were wondering if any other session types might be supported. We
1242.18s - 1247.08s |  disassembled the browser helper binary to take a look, and we saw that it seemed like the
1247.08s - 1251.98s |  string of browser could also be a valid session type. And this was interesting to us because
1252.00s - 1258.00s |  we hadn't seen this string being sent by, uh, the extension. But, uh, we tried it anyway to
1258.00s - 1261.58s |  see what would happen. We removed all of those other session identifiers that I was
1261.58s - 1266.78s |  mentioning before, and it just totally worked. If one password was unlocked, we were able to
1266.78s - 1272.02s |  send a session type browser, request the muck, and we were able to grab it. So that kind of
1272.02s - 1276.96s |  completed the chain of, um, injecting into an old client, sending XPC messages, and grabbing
1276.98s - 1281.98s |  the muck. Um, so you may have noticed that every issue we've discussed so far requires that
1284.08s - 1289.18s |  one password is unlocked. Um, this next and final issue we're gonna discuss does not require
1289.18s - 1293.46s |  that one password is unlocked. And it focuses on how biometric authentication is
1293.46s - 1298.26s |  implemented. If you, uh, use one password on a MacBook, you're probably familiar with this.
1298.26s - 1303.80s |  You launch one password, you provide your fingerprint, it unlocks. Um, so a very common way
1303.84s - 1308.28s |  that macOS apps are gonna implement fingerprint checks is by using this evaluate policy
1308.28s - 1313.52s |  method. And it's pretty simple. You call it, prompts user for their fingerprint. If they
1313.52s - 1318.18s |  provide it and it's valid, it returns true, otherwise it returns false. So what we did to make
1318.18s - 1322.92s |  sure this method was in use, we hooked it with Frida, uh, used the code on the right, uh,
1322.92s - 1328.10s |  screenshot here, and just basically made it always return true no matter what. And so after
1328.10s - 1332.54s |  doing that, we launch one password, prompt it for our fingerprint. We could either hit cancel
1332.54s - 1337.54s |  or provide someone else's fingerprint, and the vault unlocks. So, um, you might be
1339.72s - 1342.98s |  thinking, well, you know, if you're a red team or you land on someone's laptop, you can't just
1342.98s - 1347.16s |  disable SIP and hook methods with Frida. And that's true, but this taught us something
1347.16s - 1351.76s |  really interesting, which is that even with an invalid fingerprint, somehow one password is
1351.76s - 1355.70s |  grabbing the muck and it is decrypting the vaults and displaying your passwords. So we wanted
1355.70s - 1360.96s |  to understand how that worked. Um, and also it's not obvious that this was gonna work just
1360.96s - 1366.50s |  hooking, um, methods with Frida, cause it is possible to protect items at the keychain level
1366.50s - 1370.14s |  with flags that indicate a fingerprint is required. And you wouldn't be able to just hook
1370.14s - 1373.74s |  something with Frida and make that work, cause the keychain would protect you with your
1373.74s - 1379.30s |  fingerprint. So that was not what was going on here. So how does it work? We figured the
1379.30s - 1383.38s |  keychain was involved in some way, so we opened the keychain access application and started
1383.38s - 1388.28s |  looking around, and we saw that when using biometric authentication, there were, uh, these
1388.30s - 1392.44s |  items, or there was a item in the keychain called biometric unlock, and it would be named
1392.44s - 1396.38s |  differently depending on if you were using SSO or not. And we saw that it could only be
1396.38s - 1400.48s |  accessed by one password, so if it wasn't obvious from the name, we knew it was, uh, being
1400.48s - 1406.76s |  used by one password for biometric unlock. Now, along with, um, the item in the keychain,
1406.76s - 1410.60s |  there were these comments that were added, which tell us that it's, the item here is
1410.60s - 1415.36s |  encrypted by the secure enclave. And this tracked because when we looked at what was stored
1415.38s - 1420.56s |  in the item, it was just a bunch of random ciphertext that we couldn't do anything with. So,
1420.56s - 1424.12s |  we were wondering where the secure enclave key entry is, because we couldn't see it in the
1424.12s - 1428.80s |  keychain access application, we couldn't query it with the security CLI tool, which is the
1428.80s - 1432.94s |  built-in, uh, macOS CLI tool for interacting with the keychain. Uh, so we wanted to
1432.94s - 1438.14s |  understand where it was, what was going on and how it was being used. What we did for this
1438.14s - 1443.44s |  was hooked the sec item copy matching, uh, method with Frida, and logged the parameters
1443.46s - 1448.46s |  passed to it and the return values from it. This method is used to query the keychain. And so
1448.46s - 1452.54s |  we wanted to trigger the fingerprint unlock and see what was, uh, being accessed from the
1452.54s - 1457.70s |  keychain by one password when going through that flow. And amongst other things, one of the
1457.70s - 1464.38s |  things we saw accessed was a sec key ref or a secret key reference. And, um, that's what was
1464.38s - 1469.46s |  returned. And in the query was an A tag or an application tag, uh, with those hex bytes you
1469.48s - 1474.98s |  see in the top red box. And if you decode those, you get the string of com agile bits one
1474.98s - 1479.58s |  password memory enclave key. So this seemed likely what we were, uh, looking for based on
1479.58s - 1485.92s |  the name, but we wanted to be sure. So, uh, we wanted to see if it was being used to decrypt
1485.92s - 1491.06s |  anything or decrypt that biometric unlock entry. Um, now secure enclave keys, it's not the
1491.06s - 1495.36s |  case that you just access them and then do what you wish with the bytes. Instead, you ask the
1495.36s - 1500.14s |  secure enclave to encrypt something, decrypt something, or sign something. In this case, it, we
1500.14s - 1504.40s |  thought it would be decrypting something. So we did the same thing with hooking sec key create
1504.40s - 1509.42s |  decrypted data, which is how you would ask the secure enclave to decrypt something. And we log
1509.42s - 1514.28s |  the parameters and the return value. And we do see that that's during the biometric unlock, that
1514.28s - 1518.72s |  sec key ref is being used. It's decrypting the ciphertext that was stored in the biometric
1518.72s - 1524.16s |  unlock entry. And in return, we get 32 bytes. Uh, so we thought 32 bytes, that's great. That
1524.16s - 1529.94s |  sounds like an AES key. Maybe that's the muck. But it turned out it was not the muck. And we
1529.94s - 1533.84s |  didn't really know what to do. So we just took these 32 bytes and started trial and error
1533.84s - 1538.84s |  trying to decrypt things. And, um, finally, we found an item in the encrypted SQLite database
1541.32s - 1548.02s |  called enc unlock key. And we were able to successfully decrypt it with AES. And, uh, in
1548.02s - 1553.36s |  return, we got the muck. So, now we fully understood the chain here of the memory
1553.36s - 1557.76s |  enclave key in the secure enclave being used to decrypt the biometric unlock entry in the
1557.76s - 1562.06s |  keychain. From there, you have a key that can be used to decrypt this entry in the SQLite
1562.06s - 1569.08s |  database. Then you have the muck, which can decrypt the rest. Um, so now we fully understand
1569.08s - 1574.38s |  this process, but obviously we can't just access the keychain, um, on behalf of 1Password
1574.38s - 1578.88s |  unless we have a way to inject our own code into 1Password and query the keychain. Because
1578.88s - 1582.48s |  those items can only be queried by 1Password. So now we're gonna talk about how we
1582.50s - 1590.85s |  accomplished getting that code injection. Yeah, so we needed to, uh, have the 1Password
1590.85s - 1597.09s |  bundle ID and we needed to not invalidate the code signature. And, uh, there's a relatively
1597.09s - 1602.75s |  old technique on Electron where you can inject, uh, essentially the main.js file isn't
1602.75s - 1607.47s |  included in the signature check and so you can just overwrite it. And to protect against
1607.47s - 1612.93s |  that, they added this enable embedded ASAR integrity validation fuse. And this was enabled
1612.95s - 1617.45s |  in the modern version of 1Password. Uh, but we implied the same thinking that we did to the
1617.45s - 1621.23s |  hardened runtime and went through all of our scraped old versions. And we found one that
1621.23s - 1625.63s |  was created either before or around the time when this flag was introduced and it had it
1625.63s - 1630.31s |  disabled. Even if we couldn't find that though, there was this additional GitHub security
1630.31s - 1634.67s |  advisory that was a bypass to this fuse. And, uh, you know, if we couldn't find either of
1634.67s - 1640.79s |  those, we probably would have gone and hunted for some similar bug ourselves. So we can
1640.81s - 1645.95s |  overwrite the main.js file, but that isn't good enough to do what we need to do. Uh,
1645.95s - 1649.51s |  essentially there are no functions in Node.js that we can call directly that will let us
1649.51s - 1653.93s |  read the keychain and use the secure enclave. And so we need to call these native functions
1653.93s - 1658.59s |  from native code. And because of the hardened runtime, which is applied to this version of
1658.59s - 1662.87s |  1Password, we can't actually do the typical thing where you'd write your own library and
1662.87s - 1668.37s |  have the Node.js code hand off to it. And so we took a step back and saw that in the
1668.39s - 1673.79s |  entitlements, uh, there was this Apple security allow JIT entitlement, which essentially
1673.79s - 1677.83s |  means that somewhere in the process it would be okay to have a read write execute page of
1677.83s - 1683.57s |  memory. Once we saw that, we realized a browser exploit would probably work. And so we
1683.57s - 1688.27s |  found an applicable CVE that was exploited in the wild. We did the standard browser exploit
1688.27s - 1693.21s |  things and got our JavaScript heap and read write primitives and used that to run shellcode
1693.21s - 1697.79s |  by corrupting a WASM object. I'll show you a video of that in a second. But I also wanted
1697.81s - 1701.57s |  to call out that because we're not in a renderer process, we can kind of cheat a little bit
1701.57s - 1706.17s |  with ASLR by just running VM map outside of the process and then directly writing all
1706.17s - 1722.49s |  the addresses we need to a file and then reading that file into our exploit. Alright, so
1722.49s - 1728.17s |  hopefully you see that, it's on the monitor. Yeah, so in this video we're just adding a
1728.17s - 1732.91s |  demo password that we're gonna extract. Uh, we're adding it right now, then we'll show you
1732.91s - 1737.65s |  that SIP is enabled. And then what we're gonna do is run a makefile. And that makefile is
1737.65s - 1741.83s |  gonna compile a C program that prints out some function addresses in the core foundation
1741.83s - 1746.27s |  library. The reason this is important is because we need those functions, uh, but we didn't
1746.27s - 1750.63s |  want to do the work of adjusting the ASLR ourselves. And these functions are in the shared
1750.63s - 1755.37s |  cache, so we can just print them out and the addresses are the same between processes. That
1755.37s - 1761.51s |  print is gonna be used to generate our final ASLR adjusted, uh, shellcode in JavaScript.
1761.51s - 1767.15s |  And we're gonna start the old version of 1Password. The reason we do that is because on the
1767.15s - 1771.85s |  first run, a deep signature check is gonna be performed. Uh, but we can just start it, kill
1771.85s - 1777.93s |  it, and then run it again with our modified main.js. And because this fuse is disabled and
1777.93s - 1785.57s |  only a shallow check runs, we can run our browser exploit. Yeah, and so there it is. We'll
1785.57s - 1823.73s |  show you that the password matches. I think it's up. No, I'm not good. Oh man, this is the
1823.73s - 1833.28s |  hardest part of the talk. There we are. Okay, so this is the doc- oh man. Okay, so this is
1837.18s - 1840.88s |  the diagram of what we essentially did. Uh, and I think it's important to call out here that
1840.88s - 1846.02s |  although obviously 1Password could have used that enforcement flag, uh, but for everything else
1846.02s - 1850.22s |  in order to get that native code execution and actually exploit it, we essentially just
1850.22s - 1854.46s |  waited. And you know, we scraped the old versions, but the vulnerabilities were in Electron
1854.46s - 1858.26s |  and- and Chromium and it can be really hard to secure that when you're releasing new versions,
1858.26s - 1865.32s |  uh, every day. And so here's a vulnerability summary of what we reported. Uh, this is a
1865.34s - 1869.72s |  little bit, uh, there are a few more vulnerabilities here than what's going to be on the next
1869.72s - 1874.88s |  slide. The reason that is, is because the initial XPC entry vulnerability is really what
1874.88s - 1879.50s |  needed to be fixed, not the other stuff that we talked about with the session writing. And we
1879.50s - 1886.61s |  also reported the, uh, Chrome managed policy bypasses to them, or to Google rather. And so
1886.61s - 1890.81s |  here's an exploitability summary. Uh, I think it's important to call out that SIP doesn't
1890.81s - 1896.05s |  prevent this and root is not required. Low privilege malware can perform these attacks. Uh,
1896.07s - 1902.51s |  but, uh, the main issues that 1Password was able to fix are- are highlighted in green. And
1902.51s - 1908.05s |  so the XPC bypass was fixed, the biometric enforcement flag was fixed, and most
1908.05s - 1912.63s |  importantly, the settings modification is now being enforced. And you might say, well, why
1912.63s - 1917.83s |  is that important? It's important because the first two currently exploitable issues are not
1917.83s - 1921.79s |  exploitable if you just disable that setting. And so while it might degrade the user
1921.81s - 1927.51s |  experience a little bit, you are fully protected with the newest version of 8.10.38 which was
1927.51s - 1932.25s |  released in August. Now the- the browser extension injection and impersonation, like I
1932.25s - 1937.75s |  mentioned earlier, that's not really a- a bug per se, it's kind of just how browsers work. And
1937.75s - 1941.93s |  the browser support get PBID bypass is a little bit interesting because there's not really a
1941.93s - 1947.87s |  clear line of ownership to the issue. Uh, so 1Password can't really securely look up the code
1947.91s - 1954.35s |  signing information of their parent process. It is true that all browsers could maybe switch to
1954.35s - 1959.39s |  XPC to provide that audit token. Uh, it's one available method to perform inter-process
1959.39s - 1964.79s |  communication with, uh, or on Mac OS rather. But it's also true that Apple might be able to
1964.79s - 1970.63s |  provide some way to look up your parent processes code signing information securely. It's
1970.63s - 1978.49s |  just not super clear who, uh, who needs to go and fix this. And so, because you can't really
1978.49s - 1982.43s |  fix those things, we're going to talk about how to detect them. So, I pulled all of these
1982.43s - 1987.37s |  bundle IDs from the browser support process. These are all the chromium based browsers that
1987.37s - 1992.51s |  it will accept as a parent process. And these are the non-chromium based browsers that it will
1992.51s - 1998.25s |  accept as a parent process. And so, for the, uh, extension, injection, and impersonation,
1998.25s - 2002.11s |  those are relatively straightforward to fix. Essentially, what you have to do is go
2002.11s - 2006.55s |  enumerate the dangerous flags, which I've done for you. They're highlighted in orange. And
2006.55s - 2010.79s |  you just need to alert any time those flags are used. Uh, we also, out of an abundance of
2010.79s - 2014.23s |  caution, are just blocking the developer builds of certain browsers because they have a
2014.23s - 2019.93s |  slightly different threat model. And for the browser support issue, again, if you just disable
2019.93s - 2025.01s |  that setting, uh, you will be fine. Uh, I can tell you personally, I'm not going to disable
2025.01s - 2029.41s |  the setting. I like using the browser extension. And I think having malware on your computer
2029.41s - 2034.81s |  is already a pretty significant bar. Now, uh, if you don't want to disable the extension like
2034.81s - 2040.09s |  me, here's a, you can alert on it. Uh, basically, during normal use, when you click a browser
2040.09s - 2045.65s |  icon, what's going to happen is launch D actually spawns that process. And so, if you just set
2045.65s - 2050.67s |  an alert for any time a browser, uh, is spawned, and the parent is not launch D, it's likely
2052.79s - 2057.57s |  malicious, or it's going to be some kind of headless browsing. And you can usually limit
2057.57s - 2063.91s |  that to the people that need to do that at your company. Probably QA teams. And a malicious
2063.91s - 2068.65s |  actor might look at that alert and, and try to get around it, right? By getting launch D to
2068.65s - 2073.45s |  spawn their parent, uh, to spawn their exploit process and then execing in directly. And so
2073.45s - 2078.33s |  what you can look for there is the exec. Uh, the, the point of looking for the exec is that
2078.33s - 2082.27s |  there are a couple different ways to obscure or, or, you know, move around those read write
2082.27s - 2088.37s |  pipes. You don't have to use the process tree that we showed you here. But at every, um, for
2088.37s - 2093.57s |  every actual exploit, at some point, they're going to have to exec into a trusted browser. And
2093.57s - 2098.51s |  so, that's what you will, uh, would alert on and it looks like PID reuse in launch D child
2098.51s - 2104.21s |  processes. So here's our full disclosure timeline. We reported all the stuff that we found
2104.21s - 2110.19s |  initially in January of 2024. And then we followed up on March 8th and reported, reported
2110.19s - 2116.13s |  that the biometrics flag was missing. And we actually weren't convinced at the time that it
2116.13s - 2120.33s |  was going to be exploitable in practice. And so we put together a proof of concept and gave
2120.35s - 2124.47s |  it to them on March 22nd and that confirmed for both us and 1Password that this was going to
2124.47s - 2129.47s |  work. Here's a remediation timeline. Again, the, the browser support fix is unclear, but you
2131.63s - 2137.67s |  can toggle that setting. The XPC bypass was fixed in April. Uh, the settings file
2137.67s - 2141.77s |  modifications, this says it was scheduled to be fixed in August. That version is out now. We
2141.77s - 2148.19s |  just submitted the slides before. And the biometrics flag issue was fixed in 8.10.36 and
2148.19s - 2153.99s |  they followed up in 8.10.38 with just a reliability change. It was actually fixed in 3.6,
2153.99s - 2162.65s |  but I would just recommend upgrading to the, to the latest version. So here is where you can
2162.65s - 2167.65s |  find the code we've released at, uh, Morgan C3 slash 1Password exploits. Um, as of now we
2169.89s - 2174.69s |  released, uh, the Frida scripts we used while doing some of this research. Um, none of it is
2174.69s - 2179.47s |  really specific to 1Password at all. Um, it could definitely be extended and useful for
2179.49s - 2184.63s |  researching other applications. In terms of exploits, the only thing we've released is a proof
2184.63s - 2189.87s |  of concept for the XPC validation bypass issue. It's not going to decrypt your vaults, but
2189.87s - 2195.91s |  rather just demonstrate the issue. Uh, in the future, we, uh, will add more code here once ample
2195.91s - 2200.29s |  time has been given for people to be upgrading their 1Password to safe versions and for the
2200.29s - 2207.12s |  other issues to be fixed. Um, and yeah, we may have some time for a few questions if people
2207.20s - 2239.27s |  have them. Sorry, what was that? Yeah, we, we took a look at them. Um, I would just say any,
2239.27s - 2253.36s |  okay, sounds good. Yeah. Any other password managers? Yes. It was just us over the course of
2253.36s - 2258.32s |  about a month. And the, the guy to your left helped us a bit with the last coolest
2258.32s - 2272.92s |  vulnerability right there. I'm, I'm so sorry. Can you say that again? Oh, just, we wanted to
2272.94s - 2277.40s |  know how safe our passwords were. You know, really the detections, I would say are the most
2277.40s - 2282.58s |  important part for us. And I would say, practically, we expected this as, we expected this
2282.58s - 2287.08s |  as likely possible with, you know, most major password managers or similar attacks. We
2287.08s - 2290.78s |  wanted to do it on 1Password because we use 1Password and we wanted to use it on red team
2290.78s - 2307.20s |  operations. Um, and then of course get the issues fixed as well. So, uh, we, we took a brief
2307.20s - 2312.10s |  look at other password managers, but this was a significant amount of effort for us. And so you
2312.12s - 2317.78s |  can imagine that we wouldn't want to do the work, uh, especially on, you know, work time if,
2317.78s - 2328.10s |  uh, if it wasn't going to pay out on a red team. All right. Thank you.