{
  "webpage_url": "https://www.youtube.com/watch?v=cHsRxkfxvq8",
  "title": "DEF CON 32 - The Rise and Fall of Binary Exploitation - Stephen Sims",
  "description": "For the past 20+ years binary exploitation has been seen as the ultimate challenge and prize, when exploiting large applications and operating systems. During this period, the question of \"How much longer will we be able to do this?\" has been asked countless times, and with good reason. Memory safety and corruption issues with low-level languages have been an enormous challenge for OS and application developers. There are certainly efforts to move to \"safer\" languages such as Rust, but those languages need to mature a bit longer before they're able to stand up to the capabilities of a language like C++.\n\nThanks to exploit mitigations and memory protections, a large number of these vulnerabilities are not exploitable. There are the mature mitigations, such as Data Execution Prevention (DEP) and Address Space Layout Randomization (ASLR), and then newer ones such as Control-flow Enforcement Technology (CET) and Virtualization Based Security (VBS). A large number of these mitigations are not enabled by default on the Windows OS, due to the fact that many need to be tested to ensure they do not break production applications. In this presentation, we will take a technical dive into the state of binary exploitation and the effectiveness of the many available mitigations, by looking at the way they're enforced.",
  "channel_url": "https://www.youtube.com/channel/UC6Om9kAkl32dWlDSNlDS9Iw",
  "duration": 2860,
  "channel": "DEFCONConference",
  "uploader": "DEFCONConference",
  "upload_date": "20241016"
}

0.00s - 4.76s | This text was transcribed using whisper model: large-v2

 So, thank you so much for coming. Uh, I know it's early on a Saturday at DEF CON. I talked to
4.76s - 8.24s |  some people last night, they're like, when are you talking? It's at 11 AM. I don't get up
8.24s - 13.24s |  till 3, sorry. So, I appreciate the effort. Or maybe you're still up. So, I wanna move pretty
15.78s - 19.88s |  quickly here. I've got a handheld mic, I might walk around a bit. I don't have a lapel mic
19.88s - 24.58s |  because flippers and stuff like that. So, we'll see what we do. But, uh, I've got a lot of
24.58s - 28.36s |  slides and I wanna make sure I get through everything. So, I've got a quick agenda that I
28.38s - 33.42s |  will start with. Let me quickly introduce myself for those of you who may not be familiar with
33.42s - 39.52s |  who I am or my work. So, my name is Stephen Sims. I've been a vulnerability researcher for
39.52s - 44.54s |  going on 20 years now. I've, was lucky enough early on, uh, to have computers in the house and
47.44s - 52.24s |  be able to have access to video gaming and all the fun things early on and editing hex edit,
52.24s - 56.34s |  you know, using a hex editor and hacking, all the things you guys have already done. So,
56.36s - 63.10s |  let's move on beyond that. I've sold a lot of exploits over the past couple decades. I
63.10s - 68.64s |  corrected myself there. I thought it was over 30 browser exploits but I didn't wanna fib so I
68.64s - 73.88s |  went back and counted and it ends up being 29 of them. Um, those are mostly used after free
73.88s - 79.48s |  and tight confusion vulnerabilities. I've always been someone who sells exploits. I don't
79.48s - 85.76s |  typically disclose them publicly or through other programs. I will talk a little bit about
85.78s - 89.24s |  that because obviously there are ethics associated with exploit sales so I'll give you my
89.24s - 95.12s |  position when we get there. I found a couple kernel vulnerabilities on Windows 1 RCE which
95.12s - 98.82s |  you can get a lot of money for nowadays. Had I known a little bit more when I sold it, it
98.82s - 102.46s |  would have been better. But lots of other vulnerabilities in different applications and
102.46s - 105.60s |  hardware out there over the years. I've been lucky enough to have a lot of great relationships
105.60s - 111.00s |  and such. I moved to San Francisco early on in the 2000s and lived on Treasure Island where
111.00s - 114.78s |  we used to joke and call it Hacker Island because there was so many hackers there. People
114.82s - 119.52s |  from Burning Man, people from all kinds of different backgrounds but it was just a free for
119.52s - 124.36s |  all and it was pretty incredible. Lots of people from CDC lived out there and others and you
124.36s - 129.24s |  know you learn pretty early on to uh how to properly use a handle and not get yourself doxxed
129.24s - 134.24s |  out there. I'm also uh like I said a musician at the Sands Institute on the offensive
134.24s - 138.94s |  operations curriculum lead and I have a couple courses there on advanced exploit development. I
138.94s - 142.48s |  am one of the co-authors of Grey Hat Hacking if you've heard of that book series. We're
142.48s - 147.82s |  talking right now about doing a 7th edition so hopefully that comes to fruition. And then I
147.82s - 152.16s |  also run a weekly stream you might have heard of called Off By One Security where I do my
152.16s - 156.10s |  own stream solo and I also have a lot of guests on and I've been lucky enough to have some
156.10s - 161.06s |  really amazing people on and uh that just makes it all great. And I appreciate so many of
161.06s - 164.24s |  you have come up and say thank you for the stream cause that means a lot to me and that's
164.24s - 167.44s |  what I do it for is to give back to the community. And if any of you are ever interested in
167.44s - 172.98s |  being a guest I'd love to uh hear from you. Alright so quick agenda we're gonna start off
172.98s - 178.58s |  doing a quick history of mitigations. We're not gonna cover all of them there's dozens and
178.58s - 182.68s |  dozens of them so we can't get through them all but we'll touch briefly on them kinda show you
182.68s - 187.82s |  where we were where we are today. Microsoft MSRC was generous enough to get me some really
187.82s - 192.40s |  cool cutting edge data that uh has not been published yet so you'll get to see some
192.40s - 196.90s |  vulnerability information from Microsoft's perspective in relation to RCEs and local
196.90s - 201.76s |  priv and other types of bugs. Then we'll quickly go through payouts. I did a stream last
201.76s - 206.50s |  Friday on nothing but payouts and all the different types of buyers out there and uh I
206.50s - 211.74s |  got a lot of hate and a lot of love from that one which I expected because again it's it
211.74s - 217.64s |  involves your morals and it's very ethical you know considerations to have. The we'll
217.64s - 221.72s |  quickly look at the role of machine learning and AI in general in vulnerability research
221.72s - 226.28s |  because that's obviously a hot topic as of late and will continue to be. And then we're
226.30s - 230.74s |  gonna switch over into being technical cause I don't wanna do a talk without being technical
230.74s - 235.54s |  and we'll get into looking at one specific mitigation that is implemented in the Windows
235.54s - 241.32s |  kernel. And my main point of wanting to show you that is so that if you yourself wanna
241.32s - 245.48s |  understand how a new mitigation works that comes out. If you wanna figure out how to
245.48s - 250.52s |  bypass it how to work around it or other things or how effective it is if you're a defender
250.52s - 255.10s |  you need to go and debug it. It's really the only way you can learn other than taking other
255.12s - 259.72s |  people's published information. So every time a new mitigation comes out I love to jump in to
259.72s - 263.92s |  debuggers and disassemblers and go and understand it as best I can. And then we'll do some
263.92s - 270.00s |  takeaways. That is the agenda. So the golden years I'm not one you know it's it's not my right
270.00s - 273.74s |  to say what the golden years of hacking is but I have been doing it long enough and I
273.74s - 278.84s |  remember you know reading it was before my time but I left one smash in the stack for fun and
278.84s - 283.92s |  profit and other papers released around that time. Open wall, work that Brad Spengler was
283.94s - 289.90s |  doing so many other brilliant researchers and when you when when I personally think about
289.90s - 294.78s |  what the golden years is it's before all these mitigations became really effective. You'll see
294.78s - 299.48s |  on a diagram that I put together coming up in a moment that there are certain years where
299.48s - 304.42s |  stuff got real serious and it's only gotten harder and harder since then. So I would say the
304.42s - 309.66s |  golden years of memory corruption bugs is long over but still possible and those bugs are
309.66s - 315.88s |  very valuable now and you'll see that in a moment. But you see here Windows up at the top
315.88s - 321.34s |  and we can go way back to when trust from escape and wag that was what became Emmet or at
321.34s - 325.42s |  least some of the controls and mitigations there became the enhanced mitigation experience
325.42s - 330.32s |  toolkit which of course now today is exploit guard. But Windows it wasn't until XP service
330.32s - 334.76s |  pack 2 where mitigations were a thing. I remember when that dropped and admins were
334.76s - 339.00s |  freaking out because it was over a gigabyte update and there were a lot of new mitigations
339.04s - 342.44s |  published. You can see them listed there. I'm not going to go through every one of them but
342.44s - 347.68s |  notable ones like data execution prevention that's huge and in stack canaries. Linux down
347.68s - 352.32s |  below I was doing some uh research and thankfully Brad Spangler pointed me to some a great
352.32s - 357.32s |  talk from uh maybe a decade or so ago that really went through every single mitigation when it
359.76s - 364.70s |  came out the bug classes and gave credit where credit is due to all the brilliant researchers
364.70s - 368.70s |  and that's a really hard thing to do. There's a lot of confusion when you go out there
368.70s - 373.44s |  trying to find out who the original source was that published a technique for
373.44s - 379.74s |  exploitation or some documentation and I try my best to give that credit. So the information
379.74s - 386.18s |  there under Linux all the way back to 1997 I mean people were thinking about security way
386.18s - 391.92s |  back in 1997 especially on the Linux side of the house which as expected is always first in
391.92s - 397.46s |  that realm. But open wall was a big one for that one. Uh Mac OS you can see was a bit late to
397.46s - 402.66s |  the game. ASLR like randomization didn't come out until like 2011. That's way behind
402.66s - 409.70s |  Vista even. So all the operating systems now though are at a pretty good state. Some notable
409.70s - 413.94s |  mitigations this is not complete by any means. I put this together there's always
413.94s - 418.68s |  possibilities there's mistakes. A lot of times mitigations come out like before the
418.68s - 423.28s |  official OS release of that mitigation. You might hear well low fragmentation heap that
423.28s - 428.04s |  was around during XP service pack 2 or 3 but it didn't fully get implemented to replace the
428.04s - 432.72s |  front end heap allocator until Windows Vista. And then they got rid of the look aside list
432.72s - 436.86s |  except for in the kernel. So like a lot of this stuff can be fuzzy. So if the arrow is going
436.86s - 440.80s |  back that means back ported. A lot of times mitigations come out some of them get back
440.80s - 444.76s |  ported some of them don't get back ported. But you can see some other notable ones like
444.76s - 449.56s |  Windows 10 obviously came out uh control flow guard was a significant one. Microsoft was
449.56s - 453.46s |  pretty proud of that one and made some pretty bold claims about it. But none of these
453.46s - 459.62s |  mitigations by themselves are a one stop shop. They are complementary to one another. If
459.62s - 465.16s |  there's one weak link in the chain if one single mitigation is not working properly or if one
465.16s - 471.34s |  library is not compiled to participate in a mitigation it breaks the whole thing. So it can
471.34s - 476.28s |  be difficult to get all of them there. I usually put up like a Venn diagram that shows
476.30s - 481.28s |  overlapping circles where you've got different categories of mitigations like those enforced
481.28s - 486.32s |  by the operating system, those enforced by the compiler, those enforced by a tool kit like
486.32s - 490.92s |  exploit guard or malware bytes or whatever you might be using. And if you get to the merged
490.92s - 495.32s |  areas in the circles you're taking advantage of multiple categories and that's where things
495.32s - 500.10s |  become much more effective. Because depending on the type of exploit you're using or you're
500.10s - 505.46s |  writing a mitigation might not even matter. For example font protection. Like they
505.48s - 509.56s |  introduced font protection because I think it was Dooku or Stuxnet. It was a font based
509.56s - 514.76s |  vulnerability. It was a sign extension bug and it affected the Windows kernel and was a
514.76s - 521.86s |  brilliant exploit. That font mitigation just says you can't use any fonts unless it's in the
521.86s - 527.04s |  system 32 fonts folder. So no third party fonts to come along. But obviously that only
527.04s - 532.64s |  targets a very specific thing. So some of these mitigations don't matter when you're exploiting
532.66s - 538.30s |  things. So this is not something we're going to walk through. It's a pretty ugly slide but
538.30s - 542.54s |  it's something you can take a picture of. All it's showing is that with all of those
542.54s - 548.24s |  mitigations and that was not comprehensive by any means. It's a cat and mouse game where
548.24s - 555.04s |  you've got a mitigation that comes out due to a bug class or an exploit technique. For
555.04s - 561.22s |  example look at arbitrary code guard or export address table filtering. EAF specifically
561.24s - 568.34s |  targets shellcode and how it accesses the exports table inside libraries like kernel 32. So
568.34s - 572.88s |  they target very specific things and it's that cat and mouse game because when a new exploit
572.88s - 577.88s |  technique comes out or a new bug class a mitigation goes in to try to kill it. And then a
577.88s - 582.72s |  work around comes out and then they update the mitigation. A perfect example is back in
582.72s - 588.02s |  2014 and I was just hanging out with Corlan Coder like a week ago in Amsterdam at Hackfest
588.02s - 592.90s |  that we had out there. And he and I have something very in common with each other. Actually
592.90s - 597.84s |  I'll show you in a diagram coming up very soon. It might be the next one. It is the next one.
597.84s - 603.50s |  So this is the last version that Microsoft published outwardly that I've seen anyway from
603.50s - 609.82s |  Matt Miller and other folks at MSRC. And you notice it only goes up to like 2013 or so or
609.82s - 615.22s |  2015, 16. I can't even see it. But what I want you to look at here is and unfortunately I
615.22s - 619.82s |  don't have a laser pointer on this thing. But look at the grey area to the right side and see
619.82s - 626.06s |  how it's a very wide gap. And then all of a sudden after that it shrinks down. The reason that
626.06s - 632.60s |  happened is because Microsoft in 2014 introduced a couple mitigations that really killed
632.60s - 639.48s |  specific types of bug classes in the browser like type confusion, use after free. I brought up
639.48s - 644.82s |  Corlan Coder because he and I both were writing quite a few exploits per year against a
644.82s - 650.62s |  browser and then all of a sudden in June, July 2014 they stopped working. The exploits
650.62s - 656.00s |  stopped working because they put in deferred free, isolated heaps and then MemGC came
656.00s - 660.70s |  shortly after. And I remember even seeing people like Skylines who was releasing lots of
660.70s - 666.60s |  vulnerabilities or selling exploits or disclosing them saying one time in a tweet, hey does
666.60s - 671.50s |  anybody have a MemGC bypass? I'm literally sitting on a bunch of edge vulnerabilities that I
671.52s - 677.40s |  can't exploit. So that's the job of the OS developers who work with mitigations is to
677.40s - 683.84s |  identify and understand a specific exploit technique or bug class and try to kill it.
683.84s - 689.68s |  Deferred free is or MemGC I should say is so effective because it does validation of
689.68s - 694.92s |  references. Microsoft used C++ smart pointers to do dynamic tracking of objects and
694.92s - 699.72s |  reference tracking and the way in which they chose to track references allowed for a certain
699.74s - 705.18s |  type of exploit to be quite possible. So by adding the MemGC control in deferred free,
705.18s - 709.32s |  there's validation going on to make sure that there are other, there are no other references
709.32s - 713.82s |  to the object that's about to get freed before giving it back to garbage collector for reuse
713.82s - 719.50s |  to get recycled. And that's why it shrinks down so much. So Microsoft is very kind as I
719.50s - 724.34s |  said before in getting me this diagram and the next one. This one is remote code
724.36s - 730.66s |  execution CVEs by patch year. So you have to imagine that the majority of CVEs that come out
730.66s - 735.04s |  are privately disclosed. Meaning that there is no public exploit code. And that's why
735.04s - 740.54s |  there's a lot of exploit framework vendors out there like Rapid 7 with Metasploit and
740.54s - 746.48s |  Core Impact and Immunity Canvas and Saint. There's all these different frameworks and what
746.48s - 753.48s |  they want to be able to say is we have the most exploits for privately disclosed CVEs.
753.50s - 758.06s |  Because if you're a red team or some other offensive group and you want to be able to break
758.06s - 765.06s |  in obviously the targets, most companies are terrible about patching. So if we can get
765.06s - 770.60s |  some really smart people to do things like patch diffing, identify the delta in the code
770.60s - 775.34s |  and weaponize these end day vulnerabilities, then we're going to have a much more valuable
775.34s - 780.02s |  framework because we're able to allow you to exploit things that no one else can. I would
780.02s - 785.80s |  say close to like 90 percent of CVEs are privately disclosed. No public exploit code. So
785.80s - 791.44s |  that is absolutely a profitable business to go and write or weaponize end day
791.44s - 795.54s |  vulnerabilities. Because again organizations are terrible about patching. But you can see
795.54s - 799.24s |  we're not going to walk through all the data. I'm going to tweet this afterward and the slides
799.24s - 803.52s |  obviously will come out. But this is great stuff to use internally with your teams and your
803.52s - 808.52s |  threat intel folks and SOC and everyone else to say hey these are some things we should be
808.52s - 813.06s |  considering. Uh how effective are the mitigations? What bug classes are the most popular right
813.06s - 819.26s |  now? And this specifically is for RCE and you can see the number in the middle. The uh next
819.26s - 825.80s |  one here is overall CVEs by patch here. So this is not just memory safety or if you go back to
825.80s - 830.88s |  that initial slide that I had up, that was all memory corruption for the most part. All of it.
830.88s - 836.84s |  And I remember some patch Tuesdays there'd be like 50 patch, 50 patches coming out for
836.84s - 841.54s |  Internet Explorer and Edge alone. It was a serious problem and they had to solve it with
841.54s - 846.28s |  these mitigations and did a quite an effective job. But this shows you no memory corruption.
846.28s - 849.92s |  If you look at the left, that's the big green one in the middle. And if you look to the left
849.92s - 855.28s |  it's getting less and less and sometimes it gets bigger and smaller. But that is happening
855.28s - 860.06s |  because obviously secured code initiatives, introducing rust into the kernel to protect
860.06s - 864.36s |  critical components, the mitigations being very effective. That is what changes the
864.38s - 869.26s |  trajectory here. And you can see things like deserialization and other types of bugs start to
869.26s - 873.26s |  pop up and get more popular. Again, cat and mouse game and we're always trying to find new
873.26s - 878.44s |  ways of getting in. So how mitigations have affected payouts. I'll quickly go through this
878.44s - 882.40s |  one because again I want to make sure I have enough time. But and if you want more
882.40s - 886.48s |  information on this, if you go to the Off By One security channel on YouTube, look at last
886.48s - 892.02s |  week's stream. I spent like 2 hours almost talking specifically about this process. But
892.04s - 895.62s |  quickly going through, there are different categories of buyers. You can always go to the
895.62s - 901.42s |  vendor themselves, like Microsoft, Google, Apple and they will pay you. Some companies have
901.42s - 906.12s |  bounties, some don't. But they typically don't pay as much as third party buyers out there
906.12s - 910.40s |  depending where they sit on the realm of ethical boundaries. But they'll pay you and it's
910.40s - 915.14s |  gotten better. Then you go a little bit further. Okay, we can go to ZDI, the Zero Day
915.14s - 919.80s |  Initiative or go out to CanSec West and participate in Pwn2Own or you know Bug Crowd,
919.82s - 924.36s |  HackerOne, iDefense which I don't think are buying exploits anymore. But those are third
924.36s - 928.80s |  parties who do work with the vendor and they get it patched. The exploit code never goes
928.80s - 934.56s |  public. When you sell an exploit, it's no longer your exploit. Typically they don't pay you.
934.56s - 938.88s |  The money gets put into an escrow and you have to wait to get paid because they want to make
938.88s - 942.64s |  sure you're not trying to double dip and sell it to multiple buyers out there until you
942.64s - 946.48s |  build up a good trust. So we go out further and I'm not going to name any names because they
946.50s - 951.10s |  get mad. But there are all kinds of different third party buyers on behalf of different
951.10s - 956.78s |  intelligence agencies and governments around the world. Believe me, I've sat with them many
956.78s - 961.08s |  times and they are looking for bugs from you. Now you typically don't go knock on the front
961.08s - 965.82s |  door of the NSA, I don't advise that. But there are third parties out there and they will pay
965.82s - 971.22s |  more than the below ones that we just talked about. How much? We'll talk about some money
971.30s - 977.44s |  here in a moment. You go further than that, there are these third party companies that are
977.44s - 982.24s |  exploit acquisition companies. They refer to themselves as crowd fences, a relatively new
982.24s - 985.72s |  one. You heard of Zerodium? I don't think they're buying anymore. They used to be Voopin.
985.72s - 991.92s |  And there's Volnpoint. I don't know anything about Volnpoint but there's some hefty amounts
991.92s - 997.46s |  of money that you can make there. Millions. I think up to 9 million US dollars for an iOS
997.50s - 1003.78s |  bug. I mean full chain, obviously. It's got to be all the things. And then you've got kind of
1003.78s - 1009.54s |  the most unethical place you can go, which are random people. This is where you've got to be
1009.54s - 1012.52s |  really careful because you don't know who you're selling to and you don't know who they're
1012.52s - 1017.72s |  selling it to. You don't know who the buyer is. But this could be over Tor, Telegram, people.
1017.72s - 1022.96s |  If you start getting known for selling exploits or having the skills to find zero days and
1022.96s - 1028.30s |  weaponize them, especially in today's climate with how hard it is, they will find you. But
1028.30s - 1031.90s |  you've got to be really careful when you're selling this stuff to protect you and your family
1031.90s - 1036.44s |  and other things. I really again recommend watching that stream if you're interested in that
1036.44s - 1042.48s |  space because I go into some good detail about that. So examples of how much you get paid for
1042.48s - 1048.28s |  some of this stuff. Now this example is one from me personally. I've always sold things. I
1048.28s - 1052.66s |  don't sell to unethical buyers though. Personally that's my choice. Yes you get paid less but
1052.66s - 1057.66s |  that's you know, your choice. So someone like iDefense or uh ZDI back in 2014 before those
1060.30s - 1065.16s |  mitigations I told you about dropped, you could expect to get 10 to 30 thousand US dollars for
1065.16s - 1071.38s |  like a USAPTA free exploit. And back then you typically didn't need a big chain. Maybe one
1071.38s - 1076.48s |  exploit or two, like an information disclosure bug to bypass ASLR if you needed it. But if
1076.48s - 1082.18s |  anyone remembers and I'm sure some of you do, JRE6, the Java Runtime Environment 6, MSV CR
1082.70s - 1089.38s |  71.dll. That made me a lot of money because they didn't add dynamic rebasing to that module and
1089.38s - 1093.64s |  it also had all the gadgets you need to get around data execution prevention. So it's a
1093.64s - 1100.52s |  beautiful thing. So if you found one remote code execution uh USAPTA free against a browser
1100.52s - 1105.86s |  that's all you needed. There was no sandboxing on Internet Explorer Edge back then. And so you
1105.86s - 1111.74s |  could expect to get paid that amount but now it's a lot harder. On the more unethical side of
1111.76s - 1118.54s |  it, you can expect to get paid 10 to 20 times more. So you can see an example there from
1118.54s - 1123.48s |  CrowdFence. They say offering up to 400,000. That's straight from the website. Another
1123.48s - 1130.54s |  example is IOS. Zero click. Apple created something called Blastor to try to triage text
1130.54s - 1135.52s |  messages coming in to make sure code execution isn't occurring. Like it's gonna be a lot
1135.52s - 1141.42s |  harder to jailbreak or root that phone because of Blastor. So you gotta have like 4 to 6
1141.44s - 1146.50s |  zero days chained together at least. And it's not one person out there doing this anymore.
1146.50s - 1152.32s |  Back in 2014 you and yourself could find enough to get around all the things and get code
1152.32s - 1157.28s |  execution. But nowadays especially like in the kernel with HVCI and other cutting edge
1157.28s - 1161.72s |  mitigations you could say. It's hard. The execute primitive is gone. You get read write
1161.72s - 1165.16s |  opportunities but even that can be challenging with code signing and all kinds of other
1165.16s - 1170.70s |  things. But that is why the price tag goes up so much. So you can see 2014 I remember
1170.74s - 1175.68s |  Zerodium was offering up to 2 million, 2.5 million for IOS and Android full chain zero
1175.68s - 1182.36s |  clicks. Now you can get up to 9 million with VulnPoint and CrowdFence I think I saw. And
1182.36s - 1186.86s |  then this example here if you've ever seen Operation Zero it literally says on the Twitter
1186.86s - 1192.50s |  page on their home page the only Russian backed exploit acquisition program. And it
1192.50s - 1197.50s |  literally says we are non-NATO friendly. But 20 million US dollars you could retire. That's
1197.64s - 1203.54s |  amazing. But look who you're selling. You are literally doing treason at that point. I'll
1203.54s - 1207.92s |  stop saying literally. And they will use that to attack your country. So I don't know if you
1207.92s - 1213.22s |  want to be in that position but it's an option for you. So we'll jump now into machine
1213.22s - 1219.66s |  learning for vulnerability research. This one is one that I have a lot of interest in
1219.66s - 1224.66s |  because it saves you time. You already know but automation and machine learning or
1227.64s - 1233.04s |  the umbrella of AI in general are things that aren't going away. And we don't want to
1233.04s - 1237.62s |  fight it. We want to leverage it and use it to complement our skills. If you fight it you
1237.62s - 1242.62s |  will lose. When ChatGPT was made public I think it was November, December 2022 shortly
1246.86s - 1252.46s |  after that spring I believe Project Zero started an initiative of course to go and see
1252.46s - 1258.36s |  how AI in general, machine learning, can help with vulnerability research. Specifically
1258.36s - 1265.04s |  for memory corruption bugs. If you remember a long time ago DARPA back in like 2016 they
1265.04s - 1270.04s |  had a a challenge. And they paid I think 2 or 3 million US dollars to the winning team. And
1272.32s - 1278.56s |  the challenge was we want you to write basically machine wars. Automated hacking,
1278.56s - 1282.42s |  automated detection and defense. Where the machines are fighting each other. Almost
1282.42s - 1286.70s |  like a capture the flag. And back then there was a lot of universities looking into very
1286.70s - 1291.44s |  basic exploitation techniques like stack overflows. That's a pretty easy thing to
1291.44s - 1295.90s |  weaponize. Okay the buffer is overrun and you overwrite a return point like that's very
1295.90s - 1302.14s |  basic. So it's not so hard to write something that will do that for you automatically. But
1302.14s - 1307.98s |  when you're getting into harder bug classes, I gave a couple examples like type confusion.
1308.00s - 1313.24s |  Those are difficult to find. Static analysis, dynamic analysis, manual code inspection, it
1313.24s - 1318.68s |  doesn't matter. Those are tough to find. Because as a developer you can't possibly get your
1318.68s - 1324.76s |  code into the context for every possible situation where it might be run. Different
1324.76s - 1328.72s |  libraries, different patch levels, different things people do to their computers. A
1328.72s - 1333.60s |  developer can't anticipate what that code might run into in the future. So these
1333.62s - 1339.22s |  vulnerabilities manifest thanks to things like C++. A lot of people ask well why aren't we
1339.22s - 1344.70s |  already on Rust? Why isn't the Windows kernel rewritten entirely in Rust? I can't answer
1344.70s - 1349.70s |  that 100% but I can give my opinion which is wow. Theirs is louder than mine, it's amazing.
1352.64s - 1357.64s |  Alright I'll, okay. Cutting me off. So Rust, remember when HD more and the Metasploit team
1358.02s - 1363.02s |  they were on Perl early on. Metasploit came out in 2003. And at one point they said we need to
1368.16s - 1372.60s |  get off Perl because the language wasn't growing at the same pace that they needed it to. And
1372.60s - 1378.44s |  so they were going to choose between Python and what's the other one? Ruby right? And they
1378.44s - 1383.48s |  chose Ruby. And I remember talking to HD more at Defcon a long time ago and I believe it was
1383.48s - 1388.16s |  the Ruby developers were willing to work with that project because it became the largest
1388.16s - 1393.66s |  open source Ruby project to improve the language to meet the needs of the developers. So the
1393.66s - 1398.40s |  language developers working with the developers of the framework. I imagine it's a similar
1398.40s - 1405.10s |  thing where C++ has been around for a long time. It's very mature, it's very powerful. So a
1405.10s - 1409.72s |  couple things you get from that. You've got developers with decades of experience who can't
1409.72s - 1414.20s |  just overnight over to Rust. And you've got limitations in the language that might not allow
1414.20s - 1420.60s |  it to do the things that C++ can do. And yes, Rust is mimicking like low level behavior with
1420.60s - 1426.20s |  the speed and the power of being able to directly manipulate processor registers and memory but
1426.20s - 1432.28s |  unsafe languages tend to be extremely powerful. So it's, those memory corruption bugs they're
1432.28s - 1435.78s |  just, they're difficult to squash. And it's not going to be overnight where we replace
1435.78s - 1439.16s |  everything. But it is slowly happening. I believe the first thing you saw in the Windows
1439.16s - 1444.60s |  kernel was when 32k.sys driver, some implementation of that got put over to Rust. So
1444.60s - 1448.06s |  anyway, from a high level, because I can't really go into what Google's doing at nap time, I
1448.06s - 1451.78s |  read the paper, that's what they called it was project nap time. And I had been working on a
1451.78s - 1455.88s |  similar thing but as a single person so they've got a team of people. I've also talked to
1455.88s - 1460.82s |  multiple other teams out there who are doing the same thing. And that is how do we create
1460.82s - 1466.58s |  agents, different agents that serve different roles. They do different things. Because just
1466.58s - 1472.18s |  like humans, if you try to give AI in general, and again that's an umbrella encompassing
1472.18s - 1478.86s |  term, for everything underneath it. If you ask a single agent or LLM to do everything for you
1478.86s - 1483.46s |  it's, it's not going to do a great job. But if you break it down, just like humans, don't ask
1483.46s - 1488.70s |  one developer to go rewrite Microsoft Office suite. That's too much. Break it down into
1488.70s - 1493.54s |  different groups, different agents and roles, it's going to be a lot more possible. And the
1493.56s - 1498.10s |  gist of that, they did make some really impressive progress and they're going to continue
1498.10s - 1503.18s |  working on it of course. But said, as it quotes on the slide, there's still a long way to go.
1503.18s - 1507.88s |  We're not going to be replaced anytime soon because there's so much nuance that it can't
1507.88s - 1513.88s |  have, like humans can have the way we think. It'll get better of course. But going into that
1513.88s - 1518.40s |  a little bit more, this is an example of something called crew AI, if you've heard of that.
1518.40s - 1523.40s |  There's multiple frameworks out there for such, open source. And it has this concept of the
1523.42s - 1527.46s |  agents and these roles that things serve. So you can see on the right, we're saying we want you
1527.46s - 1532.80s |  to be a threat intelligence analyst. This is what your job is. And you feed it information, it
1532.80s - 1538.90s |  uses RAG and other cool technology to ingest all kinds of threat intel data and other. And
1538.90s - 1544.78s |  then it does a thing. And to put that in like a, a chain, you've got over on the left, like an
1544.78s - 1550.68s |  agent that is the threat intel agent. And it's ingesting things like PDF documents and just
1550.70s - 1556.04s |  threat intel data. Everything it can get its hands on. And then the result of that, the output,
1556.04s - 1560.98s |  like the list of MITRE ATT&CK TTPs as an example, because everyone knows that one, gets fed
1560.98s - 1565.88s |  into two other agents. One's the red team side and one's the blue team side. One's doing
1565.88s - 1572.52s |  detection engineering and generating Sigma or some kind of other rules out there. And the red
1572.52s - 1576.86s |  team side is using it for continuous automated red teaming and patent testing. So they're
1576.88s - 1581.18s |  consuming and ingesting the same data, using it for different purposes. A lot of companies are
1581.18s - 1585.48s |  getting into this now. A lot of managed socks out there are doing exactly that. Here's your
1585.48s - 1590.90s |  Yara rules, here's your Sigma rules, whatever from it. This is a pretty ugly slide but it's one
1590.90s - 1595.06s |  that I put together because this is what I'm working on personally and I have been for some
1595.06s - 1601.44s |  time now. I, I am not anywhere close to where I want to be and if Google's not getting the, the
1601.46s - 1605.46s |  best results in the world, like meaning it can replace humans with VR or the other way around,
1605.46s - 1610.26s |  um, then I'm certainly not going to be able to do it alone. But I have made some good progress
1610.26s - 1616.54s |  which is I feed into an LLM all the different CVEs, all the project zero or other public
1616.54s - 1621.54s |  research out there, all GitHub, at pastebin, anything I can feed it around exploits and patch
1624.04s - 1630.28s |  diffing, binary diffing and all that, all that data. So one thing I do a lot is end day
1630.28s - 1635.36s |  vulnerability weaponization. I download on patch Tuesday unless I don't have time. You get
1635.36s - 1638.82s |  used to looking at this stuff. You look at all the CVEs, you look at the knowledge base
1638.82s - 1643.94s |  articles, you try to figure out which ones are most likely exploitable. And you're probably
1643.94s - 1647.24s |  still wrong and you learn a lot so you got to keep telling yourself because it's very
1647.24s - 1651.24s |  frustrating when you spend two weeks looking at a patch vulnerability that you realize you
1651.24s - 1656.38s |  cannot weaponize because of mitigations or some other factors. Because even if a
1656.38s - 1661.98s |  mitigation can 100 percent stop a vulnerability from being exploitable, they're still
1661.98s - 1666.90s |  going to patch it. Because what if somebody turns a mitigation off? Or it's just, you know,
1666.90s - 1671.90s |  it's good, it's good habit to, to clean that stuff up. So when you do a patch diff and you look
1674.26s - 1680.08s |  at the delta of the code, use something like diaphora or bin diff and you take a look at the
1680.08s - 1686.34s |  changes at the function or the code level, you can give that information to the LLM and
1686.34s - 1691.52s |  teach it how and why it's a certain type of vulnerability. And then the output from that can
1691.52s - 1696.62s |  go into the next agent which is really doing the patch diffing for new vulnerabilities that
1696.62s - 1701.36s |  got patched. So it's taking the patch, it's extracting it or grabbing it from Winbindex,
1701.36s - 1707.30s |  doing the diffing and it's looking at the delta and it's knowledge of all the prior diffs that
1707.30s - 1712.36s |  it has learned about and all the information about exploits that are public or private. It's
1712.40s - 1718.70s |  using that to make a good guess as to what most likely is the vulnerability type. And then we
1718.70s - 1723.64s |  have a corpus generation agent which is trying to generate trigger files that you can then
1723.64s - 1728.24s |  feed to whatever it is and hopefully trigger the vulnerability. And then of course you would
1728.24s - 1733.74s |  have to go in and see if you can actually weaponize it. So it's automating the process of
1733.74s - 1740.36s |  binary diffing and trying to find where the bug is and trying to help you generate malformed
1740.36s - 1744.62s |  documents or whatever you need to send to the target to try and get it to crash. I've got
1744.62s - 1749.84s |  this working pretty good. It's not great but it's pretty, it's saving me a ton of time. I
1749.84s - 1756.54s |  would say probably like 10 to 20 times it's saving me on that research effort which is pretty
1756.54s - 1761.18s |  damn good for me anyway. So understanding how mitigations work, we're going to jump into a
1761.18s - 1767.26s |  more technical part now. I, there's so many mitigations so I just chose one random one and
1767.28s - 1771.96s |  also on my channel I do a lot of exploit mitigation reversing. If you're interested in
1771.96s - 1776.56s |  that stuff there's videos on that. But a lot of these mitigations especially the more
1776.56s - 1782.40s |  classic ones that came out with emits and the initial exploit guard. What they do is they
1782.40s - 1787.30s |  will hook something. So for example there are things called critical functions on Windows.
1787.30s - 1791.72s |  Critical function of one type will be any function that can change permissions in memory. Like
1791.74s - 1797.24s |  virtual alloc, virtual protect, heap create, write process memory. Those are critical APIs.
1797.24s - 1802.18s |  So we want to monitor those. So if we understand things about different bug classes out there
1802.18s - 1807.56s |  and different ways in which people exploit vulnerabilities then we can hook the flow of
1807.56s - 1812.72s |  execution and before we allow the function to be called that will in fact change permissions in
1812.72s - 1818.14s |  memory, we inspect it. And they can do that, you could do that by overwriting an entry in the
1818.16s - 1823.26s |  imports table so when it calls that function where it's linked it'll actually call your code
1823.26s - 1827.40s |  first or more likely they're going to hot patch or put a patch in the very beginning of the
1827.40s - 1832.98s |  function entry point and it will first jump to another location, execute some code, typically
1832.98s - 1838.68s |  points into something called payload restrictions dot DLL and it evaluates the environment to
1838.68s - 1841.78s |  make sure things look good. I'll give you one simple example. If you've heard of stack
1841.80s - 1848.24s |  pivoting before, Microsoft had the blue hat challenge and that was 2012, it was a long time
1848.24s - 1854.24s |  ago. But they paid over a million dollars US to the first place winner and then they had three
1854.24s - 1859.28s |  places, first, second, third and uh what they were looking for is help from the community to
1859.28s - 1864.48s |  stop return oriented programming. And one of the main things that we would do in use after free
1864.48s - 1869.76s |  exploits on browsers is we would pivot the stack pointer out to the heap because the stack
1869.78s - 1874.02s |  pointer is a register that only is supposed to point to the current thread stack to the top of
1874.02s - 1878.52s |  it. Let's not get into speculative execution and such but you know what I mean. And we like the
1878.52s - 1882.92s |  stack pointer because of three powerful instructions, push, pop, ret. That's the only
1882.92s - 1889.06s |  register that those instructions exist for. So that power, we want that in other places in
1889.06s - 1894.00s |  memory so what we would do is use an exchange gadget and it would exchange or pivot the stack
1894.00s - 1898.04s |  pointer with another register like the accumulator register. That would make it so the
1898.06s - 1902.52s |  stack pointer points out on the heap somewhere where maybe our ROP chain is, our exploit code
1902.52s - 1909.00s |  is. So great, it works. So anti-ROP which came out of right before Blue Hat was when Windows 8
1909.00s - 1913.60s |  all it did was it looked at something called the thread information block at the stack
1913.60s - 1918.14s |  boundaries, the stack high and stack low limits to make sure that the stack pointer points where
1918.14s - 1924.24s |  it's supposed to before allowing a critical API to be called. Very simple thing and it was very
1924.28s - 1928.28s |  easy to get around but it showed you Microsoft was taking return oriented programming
1928.28s - 1935.02s |  seriously. And then after that a whole suite of mitigations came out like 6, 7, 8 simulate the
1935.02s - 1941.26s |  execution flow, just many others. So again a lot of these hook and then they inspect and you
1941.26s - 1946.00s |  move on. Not all of them though. Some of them are enforced in user LAN, some of them are
1946.00s - 1952.74s |  enforced in the kernel and other factors. So let's look at one more more closely. So create
1952.74s - 1958.58s |  process, a little C++ program I put together. Lifted code of course too. And all it does is
1958.58s - 1965.32s |  it calls create process. There was a mitigation that Microsoft came out with called do not
1965.32s - 1970.62s |  allow child processes. And that was called the calculator killer because obviously a lot of
1970.62s - 1975.50s |  times people would use shell code to pop a calculator to prove that it worked. Well this
1975.50s - 1979.30s |  mitigation would kill that and prevent it from happening. So a lot of times if you're
1979.30s - 1984.60s |  exploiting like Microsoft Word or a browser or anything else you you want to create a new
1984.60s - 1990.60s |  process. This mitigation would stop you from being able to do it. So when I first saw the
1990.60s - 1996.44s |  mitigation I just assumed that it hooked create process in user LAN somewhere around NTDLL or
1996.44s - 2000.62s |  something it grabbed it and then payload restrictions would just inspect it and it would
2000.62s - 2004.62s |  just prevent you from being able to do it. But this one ended up being a kernel enforced
2004.64s - 2016.74s |  protection. So first off this is the code you compile it and great simple. When you run it so I'm
2016.74s - 2026.90s |  make sure this seems to be uh acting weird here. Alright there we go. So when you run it you can
2026.90s - 2031.22s |  see on command line right there a calculator pops up. We are exciting right? But that's that's
2031.22s - 2035.24s |  what it's job was. It's what it was supposed to do is just pass in an argument and it executes
2035.24s - 2040.60s |  and creates a process with that argument. Simple. Then I go into exploit guard that's a little
2040.62s - 2046.42s |  snippet on the top right and I turn that specific mitigation on. You can see there's audit mode
2046.42s - 2051.10s |  and then there's enabled mode and I I just enabled it. And then when we try to run it you can see
2051.10s - 2056.50s |  the command prompt in the middle it said create process failed. Okay the mitigation is working.
2056.50s - 2061.88s |  Down at the bottom you can see that as a defender you want to watch these things as so here's one
2061.88s - 2066.78s |  thing I'll take a step back. A lot of administrators are afraid to turn on these mitigations the
2066.80s - 2071.30s |  ones that aren't turned on by default by Microsoft. And Microsoft's kind of in a catch 22
2071.30s - 2075.08s |  situation because if they turn all the mitigations on that are available they might break your
2075.08s - 2079.18s |  applications. Because some of your developers have to adhere to the way in which these
2079.18s - 2083.42s |  mitigations work. But if they don't turn them on then you're mad at them because they didn't
2083.42s - 2087.92s |  protect you like so they're kind of in a bad spot. So they wait till things are mature enough. A
2087.92s - 2092.80s |  perfect example would be shadow stacks. If you've heard of shadow stack it's a relatively newer
2092.82s - 2098.32s |  mitigation though not in theory. Early 2000's someone mentioned the idea of that. It creates a
2098.32s - 2103.34s |  copy of return pointers and it requires at least an Intel Tiger Lake CPU. So obviously not
2106.80s - 2110.30s |  everybody's running one of the newest processors and they're not just going to turn that on by
2110.30s - 2115.24s |  default. So they have to wait. So a lot of these you do have to go on and turn them on. I
2115.24s - 2120.18s |  remember Microsoft released a paper a long time ago and said the adoption rate for the enhanced
2120.20s - 2126.60s |  mitigation experience tool kit, Emmet, was under 5%. So under 5% of organizations were
2126.60s - 2132.24s |  actually using Emmet in any way shape or form. Because the admins maybe don't understand how
2132.24s - 2135.84s |  the mitigations work at a very technical level and they don't want to do the screen test.
2135.84s - 2140.24s |  There's also performance hits associated with these mitigations. One nice thing you can do
2140.24s - 2144.62s |  though is turn on that audit mode. It's almost like an intrusion detection versus intrusion
2144.62s - 2150.46s |  prevention. Where it tells you about a potential problem but it doesn't actually block it. So
2150.46s - 2154.74s |  you've got the power to do that and then you can look in the event logs. There's a specific
2154.74s - 2159.50s |  event log area for user LAN mitigations and kernel LAN mitigations. And that's what you're
2159.50s - 2164.48s |  seeing at the bottom there. When I ran that program to execute the calculator that new log
2164.48s - 2169.32s |  popped up that said a mitigation was blocking it. That's right there what told me it was
2169.32s - 2175.96s |  kernel enforced. So looking at the NTOS kernel here. When I set a break point on create
2175.96s - 2181.50s |  process and let it continue it went straight into the kernel. So it told me right there
2181.50s - 2186.84s |  validated that this is not a kernel uh sorry user LAN enforced mitigation. So I went into
2186.84s - 2192.58s |  hex or I used hex rays obviously and I used win debug and went in and set some break points on
2192.58s - 2197.58s |  those functions right there. Like PSP get no child process restricted pro- policy or SC token
2200.46s - 2205.90s |  is no child process restriction enforced. These are by symbol name because thankfully
2205.90s - 2210.90s |  Microsoft gives us the symbols the PDB files. We can go and look for things that look like they
2210.90s - 2215.10s |  might be associated with the mitigation that we're curious about. So I set the break points
2215.10s - 2221.08s |  on there and then we run it. It immediately gets hit. But look where it gets hit. It gets hit
2221.08s - 2227.32s |  when I'm in the command prompt trying to start that C++ wrapper program. The create process
2227.32s - 2233.86s |  program. Because that's the program we turned exploit guard mitigation on. In the settings as
2233.86s - 2240.66s |  you saw in the last slide. So it makes sense. So we hit a break point on the setting API. The
2240.66s - 2245.54s |  one that sets the mitigation. Over on the right there if you're not familiar with the Virgilious
2245.54s - 2250.70s |  project. It's everybody I know's go to if you're looking at kernel structures. It is a
2250.70s - 2255.78s |  brilliant resource and every single Windows version, kernel version, every build, every
2255.78s - 2260.32s |  creators update whatever is tracked there. Because a lot of times when you're doing things
2260.32s - 2265.76s |  like token stealing in the kernel you need to make sure that your offsets are correct. There
2265.76s - 2270.42s |  might be a structure like E process or K process, K thread, E thread and you need to make sure
2270.42s - 2275.20s |  that what you think like AP links at a certain offset is still there depending on the kernel
2275.22s - 2278.76s |  version. So you can look at these structures, look at the members and you can update your
2278.76s - 2285.10s |  shellcode accordingly. But either way I saw an instruction and you can see in the code in the
2285.10s - 2290.10s |  top middle in the white area it says move into racks GS segment register offset 188 hex. So
2292.70s - 2297.04s |  the GS register while under the context of the kernel points to a structure called the kernel
2297.04s - 2302.04s |  processor control region. A very large kernel structure. And nested inside of that is
2302.06s - 2306.16s |  something called KPRCB. The kernel processor region control block which is a mega
2306.16s - 2312.50s |  structure. Well it's telling us at offset 8 within that nested structure is what we're
2312.50s - 2318.70s |  dereferencing. It ends up being the K thread pointer. K thread and E thread and K process and
2318.70s - 2322.64s |  E process are kernel things. If you've ever heard of the process environment block in user
2322.64s - 2327.18s |  land, the peb. E process is like the equivalent in the kernel. If you've ever heard of the
2327.22s - 2331.90s |  TIB, the thread information block. K thread, E thread, the executive and kernel thread.
2331.90s - 2336.60s |  Those are the relative entries in the kernel. Not one to one but it's pretty close. So either
2336.60s - 2342.84s |  way we're dereferencing and grabbing the K thread pointer for the current thread. So let me
2342.84s - 2348.08s |  go in further and we're checking out our progress here. You can see that I run this fancy
2348.08s - 2352.58s |  window bug command and we're basically saying what is our current process? And it tells us
2352.58s - 2358.30s |  that the current process is the uh which one? Command dot EXE. That's not the process I
2358.30s - 2362.70s |  want to be in. So we let it continue. We hit the breakpoint again and then we look at the
2362.70s - 2367.20s |  current process and now we're in the create process C++ program where we want to be. So now
2367.20s - 2371.30s |  we know where we want to be. We're at where we want to be. It's important to mention that
2371.30s - 2375.54s |  because when you set these types of breakpoints they will get hit often unless you set
2375.54s - 2379.68s |  process specific breakpoints as a kernel debugging session. So you want to make sure you
2379.68s - 2384.92s |  understand what context you're under for each you know process. And then we hit our
2384.92s - 2391.06s |  breakpoint on the SE token set no child process restricted function. So this means that
2391.06s - 2396.54s |  we're under the context of the create process C++ program and that mitigation function has
2396.54s - 2403.34s |  just been called. And it says set no child process restricted. So you go into hex rays and
2403.34s - 2407.38s |  you decompile it and you say hey let's take a look at this function and that's what you're
2407.38s - 2411.72s |  seeing on the right there. I know it's kind of small again slides will be released. Put some
2411.72s - 2416.16s |  circles around some variables because we don't know what those variables are. Thankfully we
2416.16s - 2420.66s |  get symbols from Microsoft. Thankfully hex rays and IDA pro are brilliant. It's a brilliant
2420.66s - 2424.96s |  disassembler and we get the function prototype data. As long as you know what the structure
2424.96s - 2430.00s |  is you can say hey I know this is a token structure because MSDN told me on the left on the
2430.00s - 2436.08s |  top there. And then once you do that you see that it's able to then go in and add all the
2436.08s - 2441.78s |  symbols. Define everything that you want to see. On the right there I did a stream a while
2441.78s - 2447.82s |  ago on documenting undocumented structures and it was all about looking at different bitmasks
2447.82s - 2452.46s |  in the kernel and e-process and the token structure to understand what the mitigation bits
2452.46s - 2457.76s |  are and to show you kind of how to do that. This is a reference from Google that shows us that
2457.76s - 2462.60s |  these different bitmask numbers you'll see lots of booleans like ands and ors and those are
2462.62s - 2467.76s |  either turning on or clearing bits in the bitmask so that the mitigation flags are set to the
2467.76s - 2472.04s |  state that they're supposed to be in. So I went through here and I added a bunch of comments
2472.04s - 2475.74s |  because obviously it's helpful especially if you're not used to debugging uh or
2475.74s - 2480.28s |  disassembling and decompiling kernel structures. But that defines everything that's
2480.28s - 2484.18s |  happening. Basically we're getting a token or acquiring a lock on the token. We're
2484.18s - 2488.62s |  initializing a variable which ends up being the token, the current token. And then we're
2488.64s - 2494.44s |  going in and we're checking bits that are set in the bitmask. And these bitmasks bits are
2494.44s - 2500.18s |  things like is it in audit only mode? Should it be turned on and enforced? Is the low box
2500.18s - 2504.46s |  token thing associated with it? What what setting should I do? And through the boolean
2504.46s - 2509.46s |  operations it turns on the appropriate bit which then sets the mitigation on. That is pretty
2511.70s - 2515.74s |  much how that mitigation works and that's why it's being blocked. Because the next thing
2515.76s - 2520.60s |  that would have happened had we kept going the get function would have gotten called and it
2520.60s - 2525.40s |  would have checked that bit to see if that program has the authority to spawn a new
2525.40s - 2529.84s |  process. So that's kind of what we learned by going through that and that's how easy it can
2529.84s - 2534.44s |  be to understand mitigations to see if you can get around them. So from that you're like well
2534.44s - 2540.48s |  then can I get around this somehow? Obviously the first thing you want to do is Google go to
2540.48s - 2545.32s |  chat GPT or your favorite AI LLM whatever and say hey can you tell me about any bypass
2545.34s - 2549.54s |  techniques that may be publicly available? But if there are no publicly available ones,
2549.54s - 2553.68s |  hey you've got a great opportunity to do some cool research and make it public if you can find
2553.68s - 2558.98s |  something. Some examples down there towards the bottom. There was a technique I forget who
2558.98s - 2563.28s |  discovered it but I put the link there where you can you can impersonate the anonymous token to
2563.28s - 2567.16s |  get around the mitigation and spawn a new process. I don't think that still works but it was an
2567.16s - 2574.26s |  option. You can use WMI like if you're in the context of Microsoft Office and you can use some
2574.30s - 2578.88s |  cool PowerShell or WMI to get around the mitigation that way. There's a process migration
2578.88s - 2583.18s |  potentially. You can use reflexive DLL loading where you load from memory something into
2583.18s - 2588.82s |  memory. That also gets you around other mitigations like CIT. Ones that are preventing you
2588.82s - 2593.82s |  from loading an unsigned DLL from your Windows box and again setting it accordingly,
2596.12s - 2600.12s |  enforcing the protection and getting around it with things like reflexive DLL. So there's a
2600.12s - 2604.10s |  bunch of ways we can potentially get around it and that's why it's so important that you put
2604.10s - 2609.04s |  a bunch of these together. That you're not just relying on any one mitigation. I remember
2609.04s - 2614.32s |  Microsoft made a pretty bold claim somebody there said CFG control flow guard should be a
2614.32s - 2620.28s |  strong enough mitigation that it can prevent the majority of exploitation techniques where
2620.28s - 2624.90s |  Emmet may not be needed as much. That ends up not being entirely true because CFG is
2624.90s - 2629.76s |  another one you could potentially get around. People have demonstrated that even with V8
2629.76s - 2634.76s |  on Chrome. So this right here I just wanted to point it out. There are two fields and rest
2637.80s - 2642.14s |  in peace to Jeff Chappelle brilliant individual passed away recently sadly but he
2642.14s - 2647.14s |  maintained this site and I hope it stays up forever because every time Microsoft would make a
2647.14s - 2652.04s |  structural change or add a new mitigation like if you can see the ones towards the bottom on
2652.04s - 2657.02s |  the right and mitigation flags too. You see things like control flow enforcement technology
2657.02s - 2661.92s |  and shadow stacks. Those are relatively new mitigations and these are bit masks that are set
2661.92s - 2667.76s |  as a member of the e-process structure and those are the things that are being checked. That's
2667.76s - 2671.92s |  why a lot of times you might heard people getting around SMAP like supervisor mode execution
2671.92s - 2677.10s |  prevention by setting a bit or flipping a bit inside a control register while under a certain
2677.10s - 2682.48s |  context. Getting around patch guard by doing it fast and doing a race condition. So the more
2682.50s - 2687.10s |  you understand from an offensive perspective about these mitigations the more you'll be able to
2687.10s - 2691.98s |  get around them potentially or know when to call it a day. For me it's all about saving time. If I
2691.98s - 2696.74s |  know a mitigation is likely on and I'm doing a patch dip or find a zero day and I think it's not
2696.74s - 2701.28s |  going to be fruitful for me to continue down that path. You gotta pay your dues though. You will
2701.28s - 2706.06s |  have those harsh you know frustrating days. I still have them all the time. From a defensive
2706.06s - 2711.40s |  perspective it really helps you to understand how these mitigations work so that if you don't
2711.42s - 2715.72s |  want to turn all of them on you know which ones are going to be more beneficial. Which ones
2715.72s - 2721.40s |  have less overhead. Which ones actually do stop an exploit technique and which ones are pretty
2721.40s - 2728.04s |  useless. So some takeaways I think I went through some already but it's it's a lot of nuance and I
2728.04s - 2734.54s |  think that that gives us power where AI won't take over our jobs anytime soon because the
2734.54s - 2739.14s |  circumstances in which you will be doing your research requires something that machine
2739.16s - 2743.82s |  learning just can't do right now. And there's synergy there as well when working with other
2743.82s - 2748.70s |  researchers. The golden years of binary exploitation can be behind us but um it's not
2748.70s - 2752.44s |  going away anytime soon. People ask me they probably ask you all the time for how much
2752.44s - 2757.40s |  longer am I going to be able to do this? As long as it's possible. People are going to keep
2757.40s - 2761.68s |  doing it. It's a lot harder now but I use an analogy like Tony Hawk the skateboarder. What he
2761.68s - 2766.38s |  was doing in the 1990s there's like a 8 year old kid able to do that today. We're just all
2766.38s - 2771.20s |  this information is out there to get you up to speed from all the research done in the past
2771.20s - 2776.90s |  fast so that you can then go and bring about novel exploitation techniques and new zero days.
2776.90s - 2781.70s |  And the ethical considerations are something that you have to understand and think about. Um
2781.70s - 2787.44s |  there's new acts and new legislation out there. Like palm oil and such that we have to worry
2787.44s - 2792.54s |  about. But as you probably know the more you push researchers and say you can't do
2792.58s - 2796.62s |  something the more likely they're going to go unethical route and sell it on the dark net and
2796.62s - 2803.08s |  make money that way. So mitigations are uh a real thing. They're hard but they're not going
2803.08s - 2806.66s |  away and you just have to deal with it. And they're how you have to think about it as if
2806.66s - 2812.96s |  there's always a way around it. And the prize will continue to grow. What was $10,000 is
2812.96s - 2818.90s |  $500,000 now. So it is worth your time putting months into research. So references and
2818.90s - 2823.10s |  thanks. I there's always more people than I can remember to thank but lots of researchers
2823.10s - 2826.34s |  out there in the past. Uh Jeremy Tinder just a shout out to him for getting me those
2826.34s - 2830.38s |  Microsoft documents or those updated charts which is cool. Brad Spangler helped me out
2830.38s - 2833.88s |  with going over some things so I'm not going to go through everyone. Harun Mir is the
2833.88s - 2838.92s |  individual I said that did a talk from 2010 that went through every single mitigation that
2838.92s - 2843.52s |  ever came out. It's a beautiful document. Definitely check that one out. And a lot of
2843.52s - 2848.16s |  other folks as well. Thanks to Def Con for selecting a talk. That is it. I think I'm right
2848.16s - 2851.46s |  on time here. I'm happy to you know chat out in the hall because I know I got to make
2851.46s - 2854.96s |  way if you have any questions. But thank you so much for coming to my talk. I really appreciate
2854.96s - 2855.00s |  it.