{
  "webpage_url": "https://www.youtube.com/watch?v=JERBqoTllaE",
  "title": "DEF CON 32 - Splitting the email atom  exploiting parsers to bypass access controls - Gareth Heyes",
  "description": "Websites often parse users' email addresses to identify their organisation. Unfortunately, parsing emails is far from straightforward thanks to a collection of ancient RFCs that everyone knows are crazy. You can probably see where this is going\u2026\n\nIn this session, I'll introduce techniques for crafting RFC-compliant email addresses that bypass virtually all defences leading to broken assumptions, parser discrepancies and emails being routed to wildly unexpected destinations. I'll show you how to exploit multiple applications and libraries to spoof email domains, access internal systems protected by 'Zero Trust', and bypass employee-only registration barriers.\n\nThen I'll introduce another class of attack - harmless-looking input transformed into malicious payloads by unwitting libraries, leading to yet more misrouted emails, and blind CSS injection on a well-known target.\n\nI'll leave you with a full methodology and toolkit to identify and exploit your own targets, plus a CTF to develop your new skillset.",
  "channel_url": "https://www.youtube.com/channel/UC6Om9kAkl32dWlDSNlDS9Iw",
  "duration": 2175,
  "channel": "DEFCONConference",
  "uploader": "DEFCONConference",
  "upload_date": "20241016"
}

0.00s - 5.76s | This text was transcribed using whisper model: large-v2

 Welcome to splitting the email atom, exploiting parsers to bypass access controls.
6.96s - 12.56s |  Email addresses might seem mundane but the RFCs governing them are downright bonkers.
13.44s - 19.92s |  I'll show you why predicting an email destination is highly complex and I'll take you on a journey
19.92s - 27.20s |  of ancient protocols, exotic encodings, access control bypasses and how I gained remote code
27.20s - 36.86s |  execution from an RFC compliant email address. First I'll explain why email address parser
36.86s - 42.22s |  discrepancies matter. Next I'll cover the shaky foundations that emails are built on.
43.66s - 49.18s |  The core of the talk will focus on parser discrepancies including Unicode overflows,
49.18s - 53.74s |  encoded word, AMP Unicode all with real world case studies.
54.94s - 59.34s |  Then I'll share my methodology and tools for automating exploitation.
59.90s - 65.26s |  Followed by advice on defense. I'll conclude with the key takeaways leaving five minutes
65.26s - 73.09s |  for questions. There's also a bonus material for Defcon 2. So this research all started when we
73.09s - 79.65s |  realized many websites use the domain part of the email address to infer the user's organization
79.65s - 86.29s |  and apply access control. For example Slack will automatically give you access to your company's
86.29s - 93.33s |  Slack channel based upon your work email address and Cloudflare Zero Trust can be configured to
93.33s - 100.93s |  use the email domain to protect your internal network. This makes email verification a critical
100.93s - 110.38s |  security boundary. What could possibly go wrong? Everyone knows that URL parser discrepancies are
110.38s - 119.26s |  critical as they can lead to SSRF path traversal and other security issues. Using an email domain
119.26s - 125.90s |  for access control makes email address parser discrepancies critical too. Predicting which
125.90s - 132.30s |  domain an email should be routed to should be simple but it's actually ludicrously difficult
132.30s - 140.90s |  even for valid RFC compliant addresses. So we've established why email address parser discrepancies
140.90s - 148.10s |  matter. Now let's explore why predicting the email destination is so challenging. Email addresses are
148.10s - 155.06s |  built on a shaky foundation of RFCs designed many years ago. Validation is often performed using
155.06s - 162.26s |  regular expressions copy and pasted from Stack Overflow all trying to follow the RFC. However
162.26s - 170.56s |  one mistake in the RegEx and everything can come crashing down. I'm not going to bore you
170.56s - 176.96s |  with RFCs but I will highlight the important ones for this talk. For instance the characters before
176.96s - 183.20s |  the at symbol in an email address are called the local part. The RFC allows what is called the
183.20s - 189.76s |  quoted local part. This enables you to use characters in the local part that are not
189.76s - 196.08s |  normally allowed by using quotes. In the example shown I use a quoted local part to use the at
196.08s - 204.08s |  symbol as part of the address. The same RFC allows you to use a quoted per which means one character
204.08s - 210.24s |  preceded by a backslash. This enables you to use a double quote and a backslash as part of the
210.24s - 217.20s |  address provided it is it is escaped. Characters enclosed in parentheses are treated as comments
217.20s - 223.76s |  and can be placed anywhere within the address except the quoted local part. They're all ignored
223.76s - 233.07s |  when the actual email is delivered. So here are two email addresses. You might be wondering which
233.07s - 240.83s |  one is valid as this is a typical question asked in an email presentation. However it's the wrong
240.83s - 249.33s |  question for this talk. The question you should be asking is which domain do they go to? You might
249.33s - 257.01s |  expect both emails to go to example.com but that's not what happens. They both go to psres.net
257.97s - 263.97s |  Remember how I said predicting the email destination is extremely difficult? This is just
263.97s - 270.53s |  the tip of the iceberg. The first example works on postfix and the second example works on sendmail.
271.25s - 280.83s |  If you are confused you should be. Next let's explain why this happens. A source route is a
280.83s - 286.91s |  sequence of servers which an email is sent before reaching its final destination. Servers in the
286.91s - 293.15s |  chain are separated by commas with the final destination marked with a colon before the
293.15s - 301.09s |  recipient's full address. Another form of source routing is called the percent hack. Despite its
301.09s - 306.69s |  name the actual character is determined by the mailer. In this process the email is initially
306.69s - 313.25s |  sent to example.com after which the percent symbol is converted into an at symbol and the email is
313.25s - 323.94s |  sent to foo at psres.net. This process can be repeated several times. Before email addresses
323.94s - 332.10s |  existed and even the internet people exchanged messages using UUCP. UUCP stands for Unix to Unix
332.10s - 338.50s |  copy protocol. It's an early protocol that separates the local user and multiple hosts
338.50s - 344.58s |  using an exclamation mark creating what is known as the bang path. Unlike the standard format
345.14s - 350.50s |  for internet email addresses today the bang path lists the host from left to right
350.50s - 358.83s |  with the destination user mailbox on the right as you can see in the example. So going back to
358.83s - 363.71s |  the original examples with all the special characters removed what the parentheses actually
363.71s - 369.55s |  do is remove that symbol and domain and without the domain part postfix treats that as a percent
369.95s - 376.03s |  route. Using a backslash and escape in the at symbol has the same effect on send mail which
376.03s - 382.11s |  treats the email as a UUCP address. Pretty damn crazy right and I've tested it and all those
382.11s - 389.41s |  special characters do go to the mailbox. I wish I could tell you that I uncovered this behavior by
389.41s - 394.13s |  analyzing thousands of lines of code and using a debugger and stepping through the code flow
394.13s - 401.41s |  in send mail and postfix but that's not actually how it went down. I noticed an unnamed target
401.41s - 406.61s |  was allowing all sorts of special characters so I just took all the characters pasted it into my
406.61s - 412.61s |  email and expected it to fail but actually what happened was I checked the syslog on the box that
412.61s - 419.81s |  I was testing and I noticed a difference. I was getting host unknown error in the delivery status
419.81s - 425.01s |  notification. This was significant because it would suggest a different host was being used.
426.53s - 430.69s |  If you look at the error you'll notice the exclamation mark is missing. I didn't actually
430.69s - 436.53s |  notice that at the time so I started to remove characters, resend the email and I still got the
436.53s - 443.01s |  same error message. I narrowed it down to the exclamation mark and thus discovered this UUCP
443.01s - 449.97s |  behavior. This was bonkers by sheer luck the characters I pasted into my email address
449.97s - 455.81s |  ended with a backslash. I think I did this subconsciously and then when the exclamation
455.81s - 461.73s |  mark was then sorry and then escape the out symbol and then the exclamation mark was treating
461.73s - 468.45s |  the address as a UUCP address. I then wrote a fuzzer to find the other behavior with source
468.45s - 474.45s |  routes with postfix. These findings gave me great confidence that there were a ton of bugs out there
474.45s - 484.10s |  so I began to look for more and this is a bonus slide for Defcon. In the RFC there are optional
484.10s - 491.70s |  SMTP parameters. I analyzed the postfix code with a poet swinger colleague and I discovered that
491.70s - 495.78s |  these parameters could be used to remove the domain part of the email address.
496.58s - 501.78s |  I found this parsing bug on a real target but the application in question didn't use the email
501.78s - 508.10s |  domain for access control. This attack works by escaping the backslash to break out of the
508.10s - 514.26s |  quoted local part confusing the email validation. Then you can use the greater than to end the
514.26s - 520.98s |  receipt to command and then you stick all the rest of the address within this SMTP optional
520.98s - 527.86s |  parameter and you will notice that yeah this works on a real target and is a valid
531.30s - 537.62s |  SMTP conversation so when it does the receipt to command it's a valid syntax for that.
540.37s - 545.97s |  As a further bonus here is some surprising email parsing behavior that I uncovered
545.97s - 551.41s |  works on postfix. I couldn't use these for access control bypasses but nevertheless
551.41s - 557.01s |  they are interesting and challenges your assumptions of how email addresses are parsed.
557.81s - 565.09s |  This first one uses a UUCP address and is sent regardless of the quotes. It's pretty damn crazy.
567.14s - 573.54s |  This second one uses source roots so if you use a square bracket syntax postfix will still treat
573.54s - 582.59s |  it as a source root and send to that email. So one of the main problems I had to solve with
582.59s - 588.83s |  this research was generating blocked characters. Since many web applications will block multiple
588.83s - 596.03s |  art symbols so this following section focuses on unicode overflows which enable the creation
596.03s - 601.47s |  of ASCII characters from higher unicode characters. It's pretty much normalization
601.47s - 610.37s |  but I'm calling it unicode overflows because it's a different technique. So the PHP char
610.37s - 616.93s |  function is a good example of how unicode overflows can occur. The function generates
616.93s - 622.45s |  a character from an integer code point. Here's an illustration of how the algorithm is used by this
622.45s - 629.25s |  function. It loops while the code point is less than zero continually adding 256 until it's non
629.25s - 636.93s |  negative because why not it's PHP after all. Then it uses the mod operation to ensure the byte value
636.93s - 644.61s |  is always within a range of 0 to 255. So if you introduce a unicode character is larger than 255
644.61s - 650.37s |  it'd be truncated into this range. Note that unicode overflows aren't just specific to PHP.
652.93s - 659.65s |  So generating a unicode overflow in JavaScript is quite simple using the from code point method.
660.29s - 667.49s |  First you pass the number that will cause the overflow such as 0x100 which is 256 in decimal.
668.13s - 672.69s |  Next you provide the second hex number to specify the actual character that you want
673.57s - 680.69s |  like 0x40 which is the art symbol. The from code point method will generate a unicode character
680.77s - 686.29s |  and when this character is transformed to fit within 255 a system that doesn't support higher
686.29s - 690.93s |  unicode characters will produce the ASCII character specified by the second number.
693.39s - 698.99s |  So I hunted for real world unicode overflows and I found a target that altered characters
698.99s - 705.31s |  within the mailer's SMTP conversation. This application blocked the backslash within the
705.31s - 711.71s |  quoted local part but I bypassed the validation using unicode overflows that enabled me to escape
711.71s - 718.43s |  characters and break out of the quoted local part. Despite this when using an encoded art symbol
719.07s - 725.15s |  the email wasn't sent suggesting there is a double validation going on once in the application and
725.15s - 731.87s |  once before sending. So although I didn't manage to exploit this particular target the key takeaway
731.87s - 737.71s |  is if you can you can use a unicode overflow to bypass validation and actually smuggle characters
737.79s - 747.25s |  within the SMTP conversation. So unicode overflows were great but I needed more methods to generate
747.25s - 753.17s |  block characters so I took a deep dive into the glorious RFC looking for gold and I found it.
754.29s - 760.29s |  This next section is about encoded word. I discovered this when trying to find ways of
760.29s - 769.17s |  encoding the art symbol without unicode overflows. Encoded word is specified in RFC 2047
769.17s - 778.85s |  and it allows the inclusion of unicode characters using encoded data and here is how encoded word
778.85s - 785.33s |  works. So first we've got the equals and question mark that indicate the start of encoded word.
786.93s - 792.53s |  The following character the following is the character encoding in this case utf-8.
800.99s - 806.91s |  Inside the so the question marks act as a separator between the charset and the encoded type
808.27s - 813.07s |  then it's the type of encoding and then you've got your encoded data as hex
813.07s - 819.79s |  so it's prefixed with equals so equal 41 is an uppercase a so that's where the data occurs
822.26s - 829.14s |  and the question mark equals indicate the end of the encoded word and the actual email that
829.14s - 836.02s |  gets sent is that so you all the meta characters are removed and that email is sent to there.
839.01s - 845.01s |  To probe for encoded word you should make two requests with the two charsets. The reason for
845.01s - 851.01s |  this is that many different email parsing libraries support different charsets. When
851.01s - 857.49s |  probing you should use lowercase characters in in case the site rejects or transforms to lowercase
857.49s - 864.93s |  so I was initially using x as a charset but to reduce the size of the the probe but however on
864.93s - 870.85s |  some systems they will reject unknown charsets and it would fail so it's better to use these
870.85s - 877.49s |  two probes and then follow up with a charset of x to see if it works. If successful in each case
878.45s - 884.29s |  you'll send an email to the ones displayed. In a real probe you would use a collaborator payload
884.29s - 891.17s |  or a similar tool. I've highlighted the encoded and decoded text in red so for example equals
891.17s - 901.81s |  61 is a lowercase a. So we've covered how encoded word works so let's dive into some real world case
901.81s - 910.13s |  studies. The following case studies all use the Ruby mail library which has over 508 million
910.13s - 918.29s |  downloads. At the time of testing the version was 2.8.1. This library is used by many popular
918.29s - 928.38s |  applications including github, zendesk, gitlab and bugcrowd. So for my first case study I'm going to
928.38s - 933.58s |  show you how I exploited gitlab enterprise. I love this vector because it's so elegant.
934.38s - 939.26s |  So first I used a charset of x because this was not important on the enterprise product.
941.26s - 948.14s |  Then I use an encoded at symbol so equals 40 is encoded at and then I used the underscore
948.14s - 954.70s |  character. So interestingly encoded word supports equals 20 as a space but also underscore. What
954.70s - 961.98s |  happens then is the email is split in half and the email is sent to that address. So gitlab thinks
961.98s - 971.50s |  the address is example.com but it actually goes to psres.net. So what was the impact on gitlab
971.50s - 977.50s |  enterprise? Well I could verify email addresses that I didn't control. This means I could gain
977.58s - 988.53s |  access to gitlab enterprise servers that use domain-based registration restrictions. To understand
988.53s - 994.85s |  the next set of slides let's have a quick recap on the how the email gets sent at the smtp level.
995.49s - 1000.53s |  So there's a conversation between the mailer and the smtp client and that and there's a handshake
1000.53s - 1005.25s |  that occurs but that's not important for this part of the talk. The important part is the receipt2
1005.25s - 1011.25s |  command. You'll notice it's enclosed with angle brackets. We're going to abuse this in the next
1011.25s - 1022.27s |  few slides to change the email destination. Gitlab is also an idp and I exploited the email
1022.83s - 1029.07s |  verification. So I used x for the slide because it wouldn't all fit on. No one needs to be able
1029.07s - 1036.35s |  to see it but you'd have to use this charset specified in red here. Then I used an encoded
1036.51s - 1042.75s |  symbol again but this time I used the greater than symbol. So this is an encoded greater than symbol
1043.47s - 1051.71s |  and then an encoded space and then gitlab thinks the domain is example.com but it actually goes
1051.71s - 1057.31s |  to psres.net. So you can spoof any domain you like and verify any domain you like on gitlab.
1060.06s - 1066.86s |  So yeah using this bug you could bypass domain-based access controls that websites
1067.18s - 1073.42s |  that support gitlab as an idp. This screenshot shows that I've got a Microsoft verified email
1073.42s - 1078.46s |  address and gitlab email address. It's a bit small but you can see it's verified.
1080.75s - 1088.27s |  So this one is more complex and this works on zendesk and uses the quoted local part with
1088.27s - 1099.36s |  encoded quotes. First we start the quoted local part then we use a q encoded double quote.
1099.36s - 1105.36s |  So equals 22 is a double quote followed by an encoded at symbol this time.
1107.60s - 1115.28s |  Next we have to use the greater than and a null character for zendesk. So this has the same effect
1115.28s - 1123.86s |  on space the null character prevents the rest of the address from being used. Due to the quirks of
1123.86s - 1130.58s |  the mailer and the validation that zendesk use I had to use an encoded less than character and
1130.66s - 1137.38s |  a double quote and my theory for this is that zendesk were doing email parsing multiple times
1137.38s - 1142.42s |  so adding all this would then decode and then start to remove parts of the email address
1143.54s - 1148.50s |  and then we finish the quoted local part and the actual email that gets sent is there.
1148.50s - 1157.94s |  Absolutely crazy um yeah pretty nuts. So the impact of this attack was attackers could verify
1157.94s - 1163.14s |  email domains from domain email addresses from domains they don't control which means they could
1163.14s - 1172.43s |  access zendesk email domain protected support centers. GitHub were also vulnerable to the
1172.43s - 1180.03s |  greater than a null attack so first I created an encoded at symbol then I used an encoded
1180.03s - 1187.95s |  greater than symbol to end the receipt to command and github required a null character so adding
1187.95s - 1193.23s |  this null character would then ignore the rest of the address and that would go to that email again.
1197.02s - 1203.02s |  So using this technique I was able to verify domains I didn't control on github and I had
1203.02s - 1213.97s |  verified emails from mozilla.com github.com and microsoft.com. By spoofing domains on github I
1213.97s - 1218.85s |  could verify domains I don't control this means I could bypass domain-based access controls
1218.85s - 1225.57s |  on websites that used github as an identity provider. For example I could penetrate internal
1225.57s - 1233.09s |  networks protected by cloudflow zero trust if it was configured to use github as an idp and email
1233.09s - 1240.53s |  domain validation. So the following screenshot shows zero trust trusting domains from github.com
1240.53s - 1246.53s |  since any domain can be spoofed and verified this vulnerability affected cloudflow zero trust
1246.53s - 1256.19s |  instance using email domain validation. So as I was testing multiple ruby libraries I could I
1256.19s - 1262.59s |  discovered that you could use base64 encoded email addresses that's why not right we all need this
1262.59s - 1271.39s |  don't we need base64 encoded addresses in this example you can it uses the b as the encoding
1271.39s - 1281.55s |  type so that indicates base64 and this is a base64 foobar so I'm using foobar as an example but any
1281.55s - 1289.63s |  character can be encoded and that results into an email of foobar at psres.net don't worry it gets
1289.63s - 1299.23s |  worse it gets more disgusting. So who remembers this a script tag encoded in utf-7 this xss vector
1299.23s - 1309.23s |  used to work on ie anybody remember it yeah surely no let's see surely email parsing libraries
1309.23s - 1317.23s |  won't allow me to use a utf-7 charset of course they do using the ruby library mail here is a
1317.23s - 1326.11s |  utf-7 encoded address so this is a an utf-7 foobar you'll notice the ampersand that's intentional
1326.11s - 1334.03s |  because that's the character that they support for utf-7 so the the charset will be decoded and
1334.03s - 1342.11s |  the email will be sent to foobar at psres.net I know what you're thinking or maybe it's just me
1342.11s - 1352.11s |  but yes you can use utf-7 and base64 in an email address in this example there's a base64
1352.11s - 1359.55s |  email address with a utf-7 charset first the email parser will decode base64
1360.67s - 1367.15s |  then the email parser will decode the utf-7 charset finally the decoded address will be
1367.15s - 1373.95s |  sent there absolutely crazy and I'll emphasize the point that any character can be encoded I'm
1373.95s - 1382.94s |  just using foobar to make it simple to follow then I thought what about utf-7 and queue encoding
1382.94s - 1389.90s |  so here I'm going to modify the a character and replace it with equals 41 this will then get
1389.90s - 1397.82s |  decoded and then the and then it will be decoded and form a utf-7 encoded foobar so it's going
1397.82s - 1403.42s |  through two layers of encoding at this point you might start having a few doubts about following
1403.42s - 1409.98s |  the rfc especially when I tell you that this works in the domain part 2 and when I tested the
1410.86s - 1420.86s |  ruby mail library I know what you're thinking it's sorry I've lost track I know what you're
1420.86s - 1426.46s |  thinking no website is going to support utf-7 right no website is going to support that
1427.18s - 1434.94s |  but actually there was a small source code web hosting site called github they supported utf-7
1435.42s - 1440.62s |  I'm so gutted that I didn't exploit them with utf-7 because they'd already fixed it by the
1440.62s - 1447.41s |  time I found this and then yeah it'll go to that email address so foobar psres done it
1450.37s - 1457.01s |  so then I went hunting for encoded word outside of ruby and I found that php mailer supports
1457.01s - 1463.17s |  encoded word within the name of the recipient I tried exploiting this in wordpress and other
1463.17s - 1468.61s |  applications but the requirements of needing angle brackets around the email made exploitation
1468.61s - 1474.29s |  difficult still I bet there are vulnerable systems that decode the actual name of the
1474.29s - 1485.17s |  recipient so you may find this in bug bounty sites so we've explored how you can manipulate
1485.17s - 1491.33s |  email parsing to sidestep access controls but shall we take it a bit further what if we could
1491.33s - 1497.97s |  use an email address and weaponize it to gain remote code execution in this section we'll cover
1497.97s - 1506.69s |  punicode attacks and how I exploited joomla punicode is a way to represent unicode characters
1506.69s - 1513.01s |  in the current dns system punicode always starts with xn and is followed by two hyphens
1513.57s - 1519.41s |  the algorithm converts the sequence of unicode characters into a representation that utilizes
1519.41s - 1525.01s |  only alphanumeric characters and hyphens for example the domain ruchun I hope I pronounced
1525.01s - 1531.41s |  that right is encoded with the following punicode sequence as you can see there due to the very
1531.41s - 1537.81s |  nature of how punicode works it makes it difficult to test because changing one character can affect
1537.81s - 1543.57s |  the entire output and the character position due to how the algorithm works so what we want to do
1543.57s - 1551.01s |  is generate some malicious characters that when it's decoded uh sorry what we want to do is
1551.01s - 1557.81s |  generate malicious characters when it's decoded but doing so is a big challenge in these examples
1557.81s - 1563.09s |  you can see the unicode character changes when one byte is modified this makes it difficult to
1563.09s - 1570.61s |  generate a malicious payload so after reading about punicode in uh on wikipedia I followed
1570.61s - 1578.45s |  a link to an online punicode converter and I began to experiment the converter used the idn php library
1578.45s - 1584.29s |  I first started to add zeros to the beginning of the punicode address to convert it into ascii
1584.29s - 1589.97s |  characters so I initially succeeded generating comma a comma which was so surprising I doubted
1589.97s - 1595.33s |  my eyes encouraged by this I started to experiment further and managed to produce an art symbol
1598.03s - 1602.59s |  so after searching github I found an interesting target using the library
1602.59s - 1609.63s |  joomla this was great because if I got xss then I would have rce doing a source code analysis
1609.63s - 1615.07s |  I noticed they were escaping the email before it was punicode decoded this means if I could
1615.07s - 1621.87s |  produce some malformed punicode that when decoded produces html I could get xss but it wouldn't be
1621.87s - 1629.63s |  that easy sounds simple just give the decoder some malformed punicode and generate some html
1629.63s - 1634.83s |  but remember how the algorithm works any change in the character can result in a completely
1634.83s - 1640.83s |  different output I thought about this for a while and I thought that this was a good job for a fuzzer
1641.87s - 1648.59s |  so I wrote a fuzzer to generate malformed punicode and the results were interesting I found many ways
1648.59s - 1653.07s |  to generate different characters so you can see what I was trying to do here I'm trying to generate
1653.07s - 1661.10s |  an svg type so I started generating millions of different character combinations I managed to
1661.10s - 1667.18s |  construct partial xss vectors but I encountered several issues I could only generate two ascii
1667.18s - 1673.10s |  characters by using more than one punicode subdomain this limitation arose from the specific
1673.10s - 1681.26s |  workings of the punicode of the punicode algorithm php and the quirks of this buggy php idn library
1681.26s - 1686.54s |  as you can see in the examples I was really close but these problems made exploiting joomla
1686.54s - 1693.90s |  very difficult I concluded that xss was not feasible so because although I was able to
1693.90s - 1699.66s |  generate a single quoted attribute it required an underscore character and joomla however
1699.66s - 1704.06s |  does not permit underscore does not permit underscore characters in the domain part of
1704.06s - 1710.62s |  the email address so you can see those mad punicode addresses are trying to inject some html
1711.58s - 1717.98s |  so what's that the end of the story not quite I thought about this for a while and I worked out
1717.98s - 1724.14s |  that you could use a single punicode subdomain and you could generate any opening tag eventually
1724.14s - 1729.74s |  after a lot of testing I concluded the only exploitable vector was an opening style tag
1730.30s - 1736.14s |  here I use malformed punicode to construct it it looks like a test string right but this is
1736.70s - 1743.10s |  this is actually how it works style 1 2 3 and 3 2 1 sorry and that would generate style tag
1745.33s - 1751.49s |  the rest of the pre-existing joomla html code would add the space and the closing angle bracket
1751.49s - 1757.81s |  for me so it injects this style tag and then the rest of the html adds those characters for me
1760.02s - 1765.30s |  so what I'd need is two accounts the first registered registers with a style tag with
1765.30s - 1772.26s |  malformed punicode as demonstrated the second account has the actual css payload inside the
1772.26s - 1779.38s |  name of the user that imports the malicious style sheet the first account starts with a
1779.38s - 1785.62s |  and the second account starts with x this is to ensure the style injection occurs first
1785.62s - 1792.74s |  and then the payload with the import occurs second notice I'm using curly braces this is
1792.74s - 1798.58s |  to trade to treat all the html that occurs before the import as an invalid css selector
1798.58s - 1808.24s |  and this still works because this is css right it'll just work so the first step is to register
1808.24s - 1814.88s |  two accounts for the attacker the first with the malicious punicode and the second with the evil
1814.88s - 1821.92s |  css so here we're using the malformed punicode in the email and the second account in the name
1825.66s - 1832.86s |  the attacker then uses import chaining and a custom node server a custom css exfiltrator
1832.86s - 1839.34s |  to quickly exfiltrate the c-surf token from the admin and when the admin visits the user's page
1839.34s - 1844.30s |  this css will get executed and the c-surf token is leaked to the attacker
1846.06s - 1854.93s |  the screenshot shows this process happening using the exfiltrated token the attacker then
1854.93s - 1862.05s |  uses the css exfiltrator and gives the admin a url the admin visits that site and the c-surf
1862.05s - 1868.05s |  attack is then performed on the admin using the exfiltrated token and then the admin template
1868.05s - 1877.60s |  is then modified and then you get rce now james said i should do a live demo i wasn't as keen
1877.60s - 1890.54s |  but let's give it a shot right so on the left is the victim so it's the admin on the left
1891.18s - 1895.82s |  on the right is the attacker we've also got the exfiltrator running
1896.78s - 1904.06s |  and this is where the token will be extracted so the attacker visits the page i've pre-filled
1904.06s - 1910.22s |  the data because you don't want to see me typing everything and the email address contains a
1910.22s - 1915.98s |  malformed punicode so i get an error and that error is just because i haven't configured
1915.98s - 1924.14s |  mail on the server and then you register a second account and this is with the actual payload in
1924.14s - 1935.60s |  that exfiltrates the token so the two accounts are registered now let's log in as the admin
1935.60s - 1951.79s |  and pray to the demo gods right thank you very much but we still need to send the message to
1951.79s - 1957.47s |  the admin right hey admin how's your day going yeah going good living the dream let's click on
1957.47s - 1966.32s |  this so i'm showing you a real attack he wouldn't show the payload in there but we've backdoored
1966.32s - 1976.99s |  joomla and then the attacker goes to pond and we've got rce we're casting etc password thank you
1976.99s - 1994.46s |  thank you so whilst conducting this research i found it useful to follow the following methodology
1994.46s - 2002.06s |  probe observe encode exploit first probe for encoded word observe that it will be decoded
2002.06s - 2007.34s |  to confirm that it's supported then encode the various characters and observe how they're
2007.34s - 2012.94s |  decoded and then follow with an exploit that abuses these characters so this methodology
2012.94s - 2018.22s |  this methodology is spelt out here so these are the steps you can take to exploit and this is the
2018.22s - 2026.26s |  some of the steps i use to exploit these targets hackverter is a free open source tool that i wrote
2026.26s - 2032.98s |  for burp suite i've crafted some hackverter tags to help you generate unicode overflows
2032.98s - 2040.02s |  and encoded word attacks easily within burp turbo intruder is another free burp extension
2040.02s - 2045.30s |  written by james kettle i've created a turbo intruder script to exploit the mailers so you
2045.30s - 2051.38s |  remember when github supported null for example this was found with turbo intruder i've also
2051.38s - 2058.26s |  created a punicode fuzzer to help with malformed punicode the fuzzer works by giving some inputs
2058.74s - 2064.02s |  some punicode address and then the placeholders are substituted with random numbers characters or
2064.02s - 2070.02s |  white space it was really effective in finding what characters could be generated we've also
2070.02s - 2079.18s |  updated burp intruder word list with a list of these attacks too for your convenience to defend
2079.18s - 2086.22s |  against email splitting attacks make sure you filter out or disable encoded word always verify
2086.30s - 2092.54s |  email addresses before using them even when received from an sso provider after validating
2092.54s - 2098.62s |  the email address do not use the domain as a sole means of authorization because it can lead to bad
2098.62s - 2106.67s |  stuff a few blog posts were really inspirational when conducting this research i recommend you
2106.67s - 2112.11s |  read each one because they are really useful and contain really useful information the import
2112.11s - 2117.23s |  training technique to use to exfiltrate the token is from pet villa and donut awesome researchers
2120.19s - 2126.91s |  so the three takeaways that i want to leave you with are valid email addresses that can trigger
2126.91s - 2134.43s |  major parser discrepancies even email addresses that end in at example.com might go elsewhere
2134.43s - 2140.11s |  and as a result is never safe to use email domains for access control enforcement
2140.59s - 2147.31s |  we've created a web security academy ctf so you can try and do an email splitting attack
2147.87s - 2152.67s |  i've also created a docker file with the vulnerable joomla uh installation for your
2153.47s - 2160.03s |  convenience you can get all the materials and download the um all the materials for
2160.03s - 2164.59s |  this presentation are on the github repository thank you very much defcon
2164.59s - 2174.83s |  thank you any questions