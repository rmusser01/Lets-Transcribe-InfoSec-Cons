{
  "webpage_url": "https://www.youtube.com/watch?v=8IzKwczq0jI",
  "title": "DEF CON 32 - Leveraging AI for Smarter Bug Bounties - Diego Jurado & Joel Niemand Sec Noguera",
  "description": "As security researchers, we constantly attempt to stay ahead of the curve, seeking innovative solutions to enhance our offensive security strategies. In recent years, the advent of artificial intelligence (AI) has introduced a new dimension to our efforts, particularly in the realm of bug bounties and pentesting. While significant attention has been given to understanding and mitigating attacks against AI systems, the potential of AI to assist in the offensive security field remains largely unclear.\n\nThis talk pretends to dig into the research and development process undertaken to create an AI agent designed to augment the bug bounty and pentesting workflow. Our AI agent is not merely a theoretical concept but a practical tool aimed at enhancing the efficiency and effectiveness of security researchers.\n\nWe have conducted extensive research to understand how AI can mimic and enhance human intuition and creativity in identifying vulnerabilities. While this may sound trivial, there is little evidence of this being tested before on generative AI agents. Our work breaks new ground by pushing the boundaries of what AI can achieve in offensive security.\n\nWill AI become an indispensable tool in our arsenal, capable of autonomously identifying and exploiting vulnerabilities? Join us as we explore the possibilities and implications of AI as an offensive assistant in this new era of offensive security.",
  "channel_url": "https://www.youtube.com/channel/UC6Om9kAkl32dWlDSNlDS9Iw",
  "duration": 2453,
  "channel": "DEFCONConference",
  "uploader": "DEFCONConference",
  "upload_date": "20241016"
}

0.00s - 5.08s | This text was transcribed using whisper model: large-v2

 So, welcome everyone to our talk, Leveraging AI for Smart Debug Bounties.
5.08s - 10.10s |  First of all, thank you to DEF CON and the Bug Bounty Village for giving us this space
10.10s - 17.44s |  to discuss how AIs can improve and change the security field and the bug bounty space.
17.44s - 22.60s |  We are going to be discussing how AIs can improve our daily job and help us work on
22.60s - 28.10s |  what we want and also let the AI take care of other stuff.
28.10s - 31.50s |  So his name is Diego Jurado, I'm Joel Noguera.
31.50s - 34.40s |  We are both security researchers at Expo.
34.40s - 40.98s |  For those that don't know us, we have been quite a while in the bug bounty scene.
40.98s - 47.78s |  And apart from that, we have been also working for several years in some well-known companies
47.78s - 53.64s |  in the security industry as security researchers and testers.
53.64s - 56.90s |  So let's start from the very beginning.
56.90s - 63.06s |  When we started this three months ago, we started looking that there may...
63.06s - 68.34s |  In the recent years, we have seen a lot of research being published about people hacking
68.34s - 69.34s |  AIs, right?
69.34s - 75.86s |  Like people doing research about publishing how to force the AI to do unexpected things,
75.86s - 77.78s |  to leak information, et cetera.
77.78s - 84.18s |  However, there is one particular brand that remains unclear regarding AIs and is how AIs
84.18s - 86.78s |  could be used in a more offensive way.
86.78s - 92.22s |  In other words, would be the AI hacking for us and taking care of some stuff that we could
92.22s - 93.94s |  do.
93.94s - 95.46s |  And so we have been just...
95.46s - 100.46s |  We started three months ago, and we don't know where the limit is for this technology,
100.46s - 105.74s |  but we wanted to show you one quick example of the things that an AI agent could do on
105.74s - 108.69s |  our field.
108.69s - 113.17s |  So first of all, we are going to be talking about different questions, interesting questions
113.17s - 119.17s |  that we have been encounter while doing this journey.
119.17s - 123.77s |  And this is one of the first one, and it's how can AIs mimic human bounty hunters?
123.77s - 129.05s |  But in order to understand what a bounty hunter, what human bounty hunter means, we need to
129.05s - 131.13s |  first understand what it is, right?
131.13s - 132.13s |  For us.
132.13s - 137.89s |  So humans have several skills and capabilities that we hardly seen on the tools that we use
137.89s - 139.65s |  in our daily job.
139.65s - 145.61s |  And some of them are intuition, creativity, and decision making based on the experience
145.61s - 147.37s |  that we have collected before.
147.37s - 152.05s |  For example, if we learn something doing bounties, this is something that we are going to apply
152.05s - 156.17s |  in the future to keep improving and getting better results.
156.17s - 159.93s |  So let's try to answer this question with the demo.
159.93s - 167.33s |  In this case, we are going to see our agent exploiting a JWT Python implementation for
167.33s - 170.25s |  this particular CVE.
170.25s - 175.45s |  During the video, you are going to see the AI interacting with the web application, performing
175.45s - 181.61s |  executing commands, processing the outputs, taking decisions, and creating goals and learning
181.61s - 184.77s |  space on what it sees and learns during the process.
184.77s - 188.81s |  All what it takes for this is just a small description or goal, and the target that we
188.81s - 194.28s |  want to test.
194.28s - 198.96s |  So I'm going to pause a little bit here, just to show you a little bit of the interface,
198.96s - 201.60s |  because it's the first time you are seeing this.
201.60s - 208.24s |  So on the first part, you're going to see what we give to the AI, just that we want
208.24s - 210.88s |  to exploit that CVE and the target.
210.88s - 215.48s |  Then you can see the things that the AI is processing, analyzing, and the decisions and
215.48s - 218.36s |  learning that it's taking.
218.36s - 223.52s |  Then you can see the commands and the output, and the goals that the AI is generating all
223.52s - 224.52s |  by itself.
224.52s - 227.20s |  We have no influence on that.
227.24s - 232.60s |  So first of all, we start with the basic recon, and recognize that there is a register endpoint.
232.60s - 238.32s |  So it decides to attempt to register a user, and in this case, it tries to use a content
238.32s - 242.36s |  type JSON, which is grown and expected for the website.
242.36s - 246.60s |  So it learns that based on the response, and decides to change that to use the correct
246.60s - 247.60s |  content type.
247.60s - 254.04s |  In this case, it registered a new user, and here on the bottom, you can see that the agent
254.04s - 259.32s |  is logging in and saving the cookies on a cookie jar to use it later during the whole
259.32s - 262.18s |  thing.
262.18s - 267.58s |  Once logged in, it detects on the response that it has a JWT token, so immediately binds
267.58s - 272.18s |  this to the goal that we have provided, and decides to go to the internet to look for
272.18s - 275.14s |  some public information and public exploits.
275.14s - 281.02s |  Try NIST and GitHub, and in GitHub, it finds one match that is a possible proof of concept,
281.02s - 288.94s |  so it decides to download the proof of concept, and you can see that it's going to cut the
288.94s - 289.94s |  readme file.
289.94s - 291.22s |  This is something that we always do, right?
291.22s - 296.50s |  We want to understand how this exploit works, and we need to learn how to use it.
296.50s - 301.38s |  So it's going to try to grab the token and run the exploit, but it makes a mistake.
301.38s - 302.90s |  It's running in an incorrect path.
302.90s - 304.30s |  Who hasn't been there, right?
304.30s - 306.98s |  Like running an incorrect path for an exploit.
306.98s - 311.82s |  So now that it learns, we define where it is, it runs again everything, and it finds
311.82s - 316.22s |  that there is one missing dependency, so it goes ahead and installs the dependency and
316.22s - 320.90s |  runs again the exploit, changing the claim username to admin.
320.90s - 324.10s |  This is a small detail that we are going to talk about later.
324.10s - 328.62s |  Then it starts trying the different payloads that it's getting from the exploit against
328.62s - 333.46s |  the whole application, changing from logging to registration to see where this exploit
333.46s - 334.46s |  works or not.
334.94s - 341.14s |  And at some point this works on the root page, so the AI realizes that it has been logged
341.14s - 350.06s |  as the admin user and successfully retrieved the flag from the challenge that we have proposed.
350.06s - 361.22s |  So during this video, we have seen some of the things that we mentioned before about
361.22s - 364.62s |  humans and tools that we use every day.
364.62s - 369.62s |  We have seen some creativity, learning from mistakes, like identifying the incorrect path
370.02s - 375.10s |  and taking a decision to decide where to execute the exploit.
375.10s - 380.50s |  But most important, we have seen the capability of the AI to adapt into different situations.
380.50s - 385.86s |  We have seen the AI registering a user, changing the content type to adapt to what the application
385.86s - 392.78s |  expects, using the credentials that just created, and then interacting with authenticating endpoints
392.78s - 395.86s |  based on all the things that have learned.
395.86s - 400.62s |  And something that really is interesting is, for example, things that we do, like cutting
400.62s - 405.30s |  the readme for an exploit, reading the Python code to understand how it works.
405.30s - 409.34s |  There are probably simple things for us, but when we talk about something that is going
409.34s - 414.34s |  on all by itself and it's reading the code and understanding the input, the output, and
414.34s - 420.26s |  also the claims that we need to modify from the JWT token, it's super interesting.
420.26s - 424.98s |  And most interesting probably is that if you are familiar with DCVE, there is no Nuclei
424.98s - 426.62s |  template for this.
426.62s - 430.38s |  And if you wonder why, it's probably because you first need a valid token, which would
430.38s - 435.26s |  mean you have to register, sign in, and retrieve that token.
435.26s - 439.98s |  Automatizing that for every existing application on the internet will be quite a challenge.
439.98s - 445.82s |  In this case, the AI takes care of all that and makes progress on that goal.
445.82s - 450.62s |  So in order to understand how we got here, we have to first understand where we were
450.62s - 453.74s |  three months ago when we started.
453.74s - 460.86s |  We started looking for different white papers that were trying to use agents in a more offensive
460.86s - 461.86s |  way.
461.86s - 464.38s |  We found a few of them, not many.
464.38s - 471.78s |  But when we started looking at the results, and they all have different approaches.
471.78s - 476.86s |  One super common was the human-in-the-loop, that is the human providing real-time feedback
476.86s - 479.34s |  to the AI in order to improve the results.
479.34s - 483.82s |  Other have full automated agents, like the one you are seeing, other have super specific
483.82s - 490.46s |  agents where they were in charge of different tasks, and some of them were trying to exploit
490.46s - 496.11s |  non-vulnerabilities or other type of CTF challenges.
496.11s - 500.15s |  When we started looking at the results, for example, for this paper, actually one of the
500.15s - 505.87s |  authors of this paper, Brendan Dolan-Gabit, is one of our colleagues at Expo.
505.87s - 510.75s |  On this paper, they were trying to use LM agents to solve CTF challenges.
510.75s - 515.79s |  If you see in the categories, they attempt to work with all of them, but probably if
515.79s - 520.63s |  we pay attention to the web one, which is probably most interesting for us as bounty
520.63s - 523.95s |  hunters, the results are not that promising, right?
523.95s - 526.75s |  It's 16% just for one model.
526.75s - 534.87s |  So we keep digging into the different papers, and we found another one that had more promising
534.87s - 535.87s |  results.
535.87s - 541.63s |  In this case, they were trying to use LM agents to exploit one-day vulnerabilities.
541.63s - 546.75s |  When we look there, we see an 87%, and that's quite exciting and promising, but when we
546.75s - 553.27s |  start reading the results and the details, we see that if you remove the CV description
553.27s - 558.47s |  that you provide to the model, that 87% drops dramatically to a 7%.
558.47s - 564.36s |  So again, the results weren't that promising in this case.
564.36s - 569.40s |  So as a conclusion from the state-of-the-art, the results weren't good at all for models
569.40s - 571.56s |  at three months ago.
571.56s - 574.02s |  All the cases weren't complex enough.
574.02s - 578.44s |  For example, they were based on particular cases, like the exploit being just one, two
578.44s - 583.60s |  lines, or just requiring two requests to successfully exploit it.
583.60s - 587.32s |  And something that they have in common is that they were all limited.
587.32s - 592.92s |  For example, this last paper only had 15 CVs on their paper, so when you try to scale this
593.00s - 598.44s |  to the real world, you don't know how this is going to be expanded.
598.44s - 605.45s |  So we wanted to change things and scale things up.
605.45s - 609.49s |  So now let's talk about the approach that we had at Expo.
609.49s - 612.57s |  As Joel was saying, we wanted to scale things up.
612.57s - 617.53s |  So the first thing that we did was starting collecting thousands of benchmarks from different
617.53s - 620.65s |  CTF competitions.
620.65s - 624.49s |  We also partnered with some companies that you may know, like Postfigure and Pentester
624.49s - 625.49s |  Labs.
625.49s - 631.01s |  So they provided to us all the exercises that they have online, and we added to our benchmarks.
631.01s - 636.85s |  Also we wanted to collect the most interesting and realistic challenges that we can find,
636.85s - 641.25s |  and of course with a great focus in web applications.
641.25s - 645.71s |  Also apart from that, we had to categorize all the challenges, depending on the level
645.71s - 648.97s |  of difficulty, from easy to hard.
648.97s - 654.13s |  And we also, something really important for us, we created a fully autonomous agent, which
654.13s - 657.03s |  is connected to an attack machine.
657.03s - 661.49s |  And this attack machine not only contains a lot of pentesting tools, but we also added
661.49s - 666.37s |  some tools that we use on our daily basis for bug bounty, as we have a lot of experience
666.37s - 669.01s |  using them.
669.01s - 675.29s |  And apart from that, one thing that is also very important, we wanted to analyze the performance
675.29s - 676.29s |  of our solvers.
676.33s - 681.65s |  So for that, we created an exclusive set of more than 100 novel benchmarks.
681.65s - 686.37s |  These benchmarks are used for validation, and as we are completely sure that the solution
686.37s - 695.85s |  is not part of any training data set, we can also evaluate how the AI is performing.
695.85s - 699.67s |  And here are the results that we got after three months of work.
699.67s - 706.23s |  As you can see, Expo was able to solve 75% of the challenges from Postfigure Labs, 72%
706.23s - 710.99s |  of the challenges from Pentester Labs, and all of that without any human interaction.
710.99s - 717.05s |  So all the exercises that we were able to solve were completely solved by the AI.
717.05s - 722.11s |  Also something really important, talking again about the novel benchmarks, we were able to
722.11s - 724.43s |  solve 85% of those.
724.43s - 728.79s |  We tried to create these challenges as more representative as possible, and now we are
728.79s - 733.98s |  going to see how these challenges were created.
733.98s - 739.46s |  So here you have a tree map with a distribution of some vulnerabilities that we added to our
739.46s - 740.46s |  benchmarks.
740.46s - 746.22s |  As you can see, we tried to be as more realistic as possible, trying to follow a distribution
746.22s - 750.18s |  similar to what we see in bug bounties.
750.18s - 755.38s |  So you can see here that we have cross-site scripting and IDORS, which probably are one
755.38s - 759.78s |  of the most common issues and vulnerabilities that we see when doing bug bounties, and especially
759.78s - 761.34s |  in life hacking events.
761.34s - 766.22s |  But we also have some vulnerabilities like server-side rigorous forgery, common injections,
766.22s - 768.70s |  privileged escalation, and also some CVEs.
768.70s - 773.58s |  So we tried to follow a very good distribution to cover all the areas and all the vulnerability
773.58s - 774.58s |  types.
774.58s - 779.50s |  Also, just in case someone is interested, we are going to share all the benchmarks that
779.50s - 780.50s |  we have.
780.50s - 784.86s |  So we are planning to publish them in a few weeks, just in case you want to test them
784.86s - 787.86s |  against your own agents.
787.86s - 792.38s |  So just keep an eye to all the social media and website, as we will be sharing those over
792.38s - 794.86s |  there.
794.86s - 801.42s |  And here we have some statistics about the success rate that we have, depending on the
801.42s - 802.42s |  category.
802.42s - 807.02s |  We tried to follow a similar category to what we have in OWASP, which is a reference for
807.02s - 810.94s |  all of us that we are doing web pentesting.
810.94s - 815.06s |  And as you can see here, for some kind of categories, the AI was performing better than
815.06s - 816.58s |  others.
816.58s - 821.82s |  So let's say, for example, for broken authentication, we can see that OAuth and XAML were performing
821.82s - 824.22s |  not that well than in other examples.
824.22s - 828.42s |  This is something that we will be talking later, but we are trying to increase this
828.42s - 829.42s |  success rate.
829.42s - 834.58s |  But for example, for broken authentication, we have very good success.
834.58s - 840.74s |  And again, we are failing in CCRF tokens, in CCRF issues.
840.74s - 845.06s |  And we have some examples of injection vulnerabilities, which, of course, you all may know.
845.06s - 847.62s |  Again, we are failing in DOM XSS.
847.62s - 851.98s |  This is basically because at the beginning, when we started doing our agent, we were missing
851.98s - 853.62s |  like an embedded browser.
853.62s - 858.82s |  So the agent was not able to exploit some issues that requires exploiting something
858.82s - 860.34s |  in the browser or in client-side.
860.34s - 863.82s |  So this is something that we have improved now, and I think we will be talking later
863.82s - 866.30s |  about this.
866.30s - 871.10s |  And then finally, some misconfiguration issues that, as you can see here in cache poisoning
871.10s - 873.82s |  and cores, is something that we still need to improve.
873.90s - 878.18s |  I was really impressed about the blind XSS, because it's not something really easy, and
878.18s - 881.38s |  we had a very good success rate.
881.38s - 886.18s |  And then talking about the success versus difficulty, we can see that we perform really
886.18s - 889.54s |  well for easy and medium vulnerabilities.
889.54s - 894.46s |  We have almost 90% from all the benchmarks that we are talking about now.
894.46s - 901.46s |  Just to clarify, these statistics belong to Porzweiger, PentesterLab, and our own validation
901.46s - 902.46s |  challenges.
902.46s - 906.42s |  We also have some other benchmarks that we use for training and that all, but here we
906.42s - 909.86s |  are only including those three that we were talking before.
909.86s - 915.02s |  And then for hard vulnerabilities, we can see that we have 40%.
915.02s - 918.94s |  So yeah, of course, we are going to try to improve that.
918.94s - 925.70s |  And now here you can see some examples about some vulnerability types that you can see
925.70s - 926.70s |  there.
926.70s - 928.90s |  And we have one question for all of you.
928.90s - 934.18s |  So for those examples that you can see here, I would like to ask you if you think that
934.18s - 937.42s |  there is any case that the AI was not able to solve.
937.42s - 943.62s |  So somebody has any idea, any number?
943.62s - 948.58s |  We give you some seconds so that you can read all of them.
948.58s - 949.58s |  Which one?
949.58s - 950.58s |  Seven?
950.58s - 951.58s |  Okay.
951.58s - 952.58s |  Yeah.
952.58s - 958.50s |  So this was a tricky question, because in the end, the AI was able to solve all of them.
959.50s - 963.94s |  You can see that in our website, we have already shared some of those examples.
963.94s - 967.62s |  For example, the Node.js one, the first one, the IDOR.
967.62s - 972.94s |  But now we don't have time to see all of them, but we want to show you three of them.
972.94s - 976.98s |  So we are going to start with the reflected XSS.
976.98s - 982.30s |  So for the people that like exploiting this issue, you will like this example.
982.30s - 986.22s |  In this example, the goal is to exploit an XSS.
986.22s - 989.66s |  We have some sort of several filtering in place.
989.66s - 993.22s |  So you will see the agent trying to train some default payloads.
993.22s - 996.74s |  Then you will see that it tries to use some kind of encodings.
996.74s - 1001.26s |  And finally, after realizing how is the way to exploit that, he managed to exploit it
1001.26s - 1004.42s |  using HTML entity encoding.
1004.42s - 1006.58s |  So let's go to the example.
1006.58s - 1009.86s |  Yeah, let me update this.
1009.86s - 1010.86s |  Okay.
1010.86s - 1014.58s |  So here you have an example of our agent working.
1014.58s - 1020.90s |  So this is basically how it looks when we try to provide a challenge with a description.
1020.90s - 1023.50s |  And we just say, okay, go ahead and hack it.
1023.50s - 1027.62s |  So let's go up to see to the very beginning what we have.
1027.62s - 1031.70s |  As Joel was mentioning before, we have the description of the challenge.
1031.70s - 1037.18s |  In this case, we are only providing the goal to execute an XSS with the string XSS in capital
1037.18s - 1038.30s |  letters.
1038.30s - 1041.86s |  And we have also information about the target that we want to exploit.
1041.90s - 1048.18s |  So if we go a bit down, you can see that first it starts accessing to the web application.
1048.18s - 1051.66s |  It finds an endpoint, which is XSS 20.
1051.66s - 1055.06s |  And then realizes that there is a potential vulnerable parameter.
1055.06s - 1059.02s |  So now it starts trying with a typical payload.
1059.02s - 1062.54s |  And it realizes that it fails because it's getting a 405 error.
1062.54s - 1066.46s |  This is because it's trying to perform a POST request.
1066.46s - 1070.98s |  If we go a bit up to the previous output, you can see that there is a form which has
1070.98s - 1071.98s |  no action.
1071.98s - 1077.62s |  So first it will try it with a POST request and then realizes that it's doing bad and
1077.62s - 1081.58s |  changes to GET and tries again with the same payload.
1081.58s - 1086.34s |  So if we go a bit down, we can see that the first thing that the AI does is identify that
1086.34s - 1088.58s |  there is one character which is being blocked.
1088.58s - 1093.74s |  So this is something really important, especially when we want to phase, for example, by passing
1093.74s - 1094.94s |  a WAF or something like that.
1094.94s - 1097.06s |  We want to know what characters are being filtered.
1097.06s - 1101.82s |  So this is something that the agent is realizing by itself, and it's really interesting.
1101.82s - 1104.54s |  Then here is something that is really important.
1104.54s - 1109.54s |  It fails while trying to craft a request within a space.
1109.54s - 1112.44s |  So it realizes that the current request is bad form.
1112.44s - 1117.10s |  So then changes, tries to encode the payload, and tries again, which is something that maybe
1117.10s - 1121.50s |  we can see when we are trying to do a bounty.
1121.50s - 1124.58s |  And then let's go a bit down.
1124.94s - 1129.46s |  Here you can see that after trying a couple of payloads, it realizes that it's not able
1129.46s - 1133.30s |  to find a good solution, so it tries to change from context.
1133.30s - 1137.78s |  At this point, tries to analyze again the application, but then it sees that there is
1137.78s - 1139.50s |  nothing interesting apart from that.
1139.50s - 1144.82s |  So again, gets the initial goal to exploit the XSS, and goes again to try and exploit
1144.82s - 1146.50s |  with different payloads.
1146.50s - 1154.46s |  Again, if we go a bit down, we can see that, again, changes from the initial goal and starts
1154.46s - 1158.90s |  trying to see if it can fuzz the application, trying to do some brute force, and trying
1158.90s - 1162.90s |  to see if it can find any additional endpoint that might be vulnerable.
1162.90s - 1169.18s |  Again, it says, okay, this is not the way to go, so start again with another payload.
1169.18s - 1175.02s |  And there's one point when it realizes that he's able to bypass the filters by using HTML
1175.02s - 1178.40s |  entity encoding with JavaScript string manipulation.
1178.40s - 1183.26s |  And then after a few attempts, it managed to get a payload that is working.
1183.26s - 1189.14s |  You can see all the encoded output, and if we go to the response, we can see the alert
1189.14s - 1194.06s |  and the flag of the challenge who has been retrieved.
1194.06s - 1196.22s |  So yeah, that was our first example.
1196.22s - 1198.78s |  Thank you.
1198.78s - 1208.02s |  If we go to the next one, here we have an image uploader vulnerability.
1208.02s - 1211.90s |  We know that we have some extensions that are being filtered by the application.
1211.90s - 1216.70s |  So one thing that is really interesting in this example is that Expo has to deal with
1216.74s - 1218.74s |  some CSRF token and session cookies.
1218.74s - 1223.54s |  You will see that it struggles with that because it's something that we have to do manually.
1223.54s - 1229.42s |  So after that, he managed to log in the application, then tries to upload a PHP web shell, plays
1229.42s - 1235.70s |  again with some extensions, until it finally exploited by uploading an htaccess file.
1235.70s - 1238.14s |  So let's go to the next example.
1238.14s - 1245.26s |  Let me update this one.
1245.30s - 1250.78s |  So here, in this case, you can see, again, the trace working.
1250.78s - 1255.50s |  We can see that in this description, which is a challenge from Porswiger, we have a very
1255.50s - 1256.70s |  detailed description.
1256.70s - 1261.82s |  So the first thing that says is that we have to exploit, again, an image upload function.
1261.82s - 1267.50s |  It says that in this case, the goal is to exploit and retrieve the content of the secret,
1267.50s - 1271.50s |  which is inside the server, and then also provide some credentials that you can use
1271.50s - 1272.66s |  for authenticate.
1272.66s - 1277.54s |  So the agent will take all this information, and from that point, we'll start working.
1277.54s - 1282.06s |  So if we go a bit down, you can see, again, that it starts to access the application.
1282.06s - 1287.50s |  It sees that there is some redirect, so it follows that, and then tries to use the credentials
1287.50s - 1290.94s |  to authenticate that were provided in the description.
1290.94s - 1294.46s |  At this point, it sees that it's missing a CSRF parameter.
1294.46s - 1298.82s |  So in these old comments, I'm going to scroll again.
1298.86s - 1303.98s |  It will start to understand how the CSRF token works, how it has to deal with that part,
1303.98s - 1305.82s |  which is new to him.
1305.82s - 1311.54s |  And finally, after playing around with session cookies and playing around with the CSRF token,
1311.54s - 1316.26s |  there is a point where it realizes that, okay, I'm going to do this in only one step.
1316.26s - 1321.10s |  So it creates this bash example with first access to the login page, retrieves the session
1321.10s - 1326.94s |  cookie and the CSRF token to have that updated, and then, for that point, uses that to log
1326.94s - 1329.78s |  in to the application with the provided credentials.
1329.78s - 1334.34s |  And finally, as you can see here, we access to the application, okay?
1334.34s - 1337.78s |  So we are now this user winner with this session.
1337.78s - 1341.30s |  Okay, so now the next point is trying to upload the web shell.
1341.30s - 1345.42s |  So it will try to go and create a PHP file.
1345.42s - 1346.42s |  It fails.
1346.42s - 1351.18s |  We are getting some errors here in the output, as you can see here, like PHP files are not
1351.18s - 1352.18s |  upload.
1352.18s - 1354.66s |  So that tries again with a double extension.
1354.66s - 1358.98s |  If we go and scroll a bit, we can see that eventually we'll try with another extension,
1358.98s - 1360.86s |  the phtml.
1360.86s - 1365.62s |  And then, finally, sorry, oh, yeah, sorry.
1365.62s - 1371.52s |  And after that, we see, which is really, really important and interesting, is that it tries
1371.52s - 1373.94s |  to upload an HT access.
1373.94s - 1379.66s |  In this case, what it's trying to do is it's trying to get any image file that can execute
1379.66s - 1381.82s |  PHP code.
1382.02s - 1386.22s |  I ask you here, how many times we were doing like a pen test, and maybe we forgot of doing
1386.22s - 1390.90s |  or trying these kind of things, like loading an HT access, to see if we can replace that
1390.90s - 1398.34s |  and we can execute PHP code in an image file, which at the beginning was filtered.
1398.34s - 1400.98s |  And yeah, after that, it just access to the application.
1400.98s - 1402.42s |  It tries a couple times.
1402.42s - 1407.34s |  Sorry for doing a scroll, but I don't want to waste too much time in this.
1407.34s - 1411.22s |  So eventually, let's go to the final one.
1411.22s - 1418.98s |  Yeah, here we can see that after uploading the PHP file, it can execute this command,
1418.98s - 1426.26s |  access to the secret key, and then submitting it to the submit solution, which is over here.
1426.26s - 1436.25s |  We can get the flag.
1436.25s - 1440.41s |  So something interesting about all these cases is that the AI is also being able to take
1440.45s - 1446.49s |  goals, like exfiltrating this file and submitting the secret to the endpoint to get the flag.
1446.49s - 1450.93s |  All these kind of details are things that we are not used to seeing in any tool, or
1450.93s - 1455.45s |  even if we want to test some particular functions of our web application, that's also super
1455.45s - 1458.85s |  interesting to see and is able to manage.
1458.85s - 1465.05s |  So now, the last example that we are going to see now, and then after that, we are going
1465.09s - 1471.37s |  to see some experiments that we have done, is this is a super interesting case because
1471.37s - 1474.45s |  we have provided no goal to the AI in this case.
1474.45s - 1480.57s |  We are going to see that we are going just to present a typical random text, as in any
1480.57s - 1487.25s |  CTF, that makes no sense and just confuses you, the target, and the AI will start exploring
1487.25s - 1491.29s |  the web application and trying to pursue that goal, right?
1491.29s - 1494.93s |  Because since it doesn't have a goal, it needs to find out what to do and how to hack the
1494.93s - 1498.73s |  website.
1498.73s - 1506.57s |  So let's go to the challenge, let's refresh this, and as you can see, the description
1506.57s - 1512.33s |  is saggy quack quack, try to quack me, that makes no sense, and any of us doing a CTF
1512.33s - 1518.53s |  will be confused, and we also get some information about the target.
1518.53s - 1524.01s |  Based on that, the agent understands that this is a CTF description and pursues to go
1524.01s - 1527.77s |  and start doing some recon on the web application.
1527.77s - 1534.05s |  So first of all, access to the root, then to a login website, and notice that there
1534.05s - 1539.01s |  is some JavaScript file, so decide to go and analyze the JavaScript all by itself.
1539.01s - 1544.13s |  We're going to see this behavior is repeated during the whole trace because every time
1544.13s - 1548.69s |  that it's detecting a new JavaScript, it's reading and understanding that file to improve
1548.69s - 1553.25s |  the knowledge about the application and keep digging deeper until it finds some particular
1553.25s - 1555.65s |  goal to exploit.
1555.65s - 1561.89s |  So once it learns about the login, it's going to test some test test user as we always do
1561.89s - 1564.61s |  when doing appendix to see how it behaves.
1564.61s - 1568.89s |  Of course it doesn't work, but the application understands that the login is working.
1568.89s - 1575.17s |  So after that, try some basic payloads for SQL injection, doesn't work either, we get
1575.17s - 1581.25s |  the same message, and now we craft just a quick Python script to do some default credentials
1581.25s - 1586.01s |  for the admin user, just trying some few well-known passwords to see if anything of
1586.01s - 1589.69s |  that is a low-hanging fruit that can get quickly.
1589.69s - 1594.29s |  None of them work, of course, so it decides to move on and try NoSQL injection against
1594.29s - 1603.05s |  the login, doesn't have lag anymore, so decides to just try some JSON parameter injection
1603.05s - 1607.85s |  to see if also can get some unexpected behavior on the application.
1607.89s - 1612.89s |  It didn't work either, so now it decides to go to the initial recon and say, okay, let's
1612.89s - 1619.69s |  see what other endpoints we have, and it realized that there was one endpoint called post create.
1619.69s - 1624.17s |  When it tried to access this endpoint, it realized it requires authentication, and in
1624.17s - 1628.69s |  this application, the main feature is that users can create posts, like in any social
1628.69s - 1635.25s |  media, so it decides to go and go to the endpoint for register an account, again, as we have
1635.25s - 1640.49s |  seen in other examples, it's going to access the endpoint, read the JavaScript file, understand
1640.49s - 1646.85s |  how the form works to register a user, and it's going to try to register a test user.
1646.85s - 1652.45s |  This works, and the user is registered, so now we move on to, again, use those credentials
1652.45s - 1659.09s |  and keep getting more access to the application and perform some authenticated tests.
1659.09s - 1662.97s |  If we scroll a little bit down, we're going to see now that it tries to access again to
1663.01s - 1668.37s |  this endpoint, providing the cookies, and this endpoint works, retrieves the JavaScript
1668.37s - 1675.41s |  file, gets more information about the application, and now decides just to do a simple post,
1675.41s - 1680.01s |  like we always do, like we're testing the website, we want to learn how the application
1680.01s - 1686.61s |  behaves, so this works, it creates a post, so now it knows, based on everything that
1686.61s - 1690.77s |  has been from the HTML and JavaScript files, that all the posts can be accessed on this
1690.77s - 1700.13s |  endpoint for the test user, so when it accesses, we can see here the post being printed, but
1700.13s - 1704.13s |  also, if we pay attention, we're going to see that there is a report to admin feature
1704.13s - 1709.85s |  that is a little bottom here, and this is super interesting, because now the AI is realizing
1709.85s - 1714.81s |  that there is a report to admin feature, and it has found a potential attack vector.
1714.81s - 1719.21s |  At this point, we didn't have any goal, but now the AI understands that there is an admin
1719.25s - 1723.57s |  user that could potentially be reviewing the reports, so it decides to go ahead and try
1723.57s - 1728.57s |  some exploits on payloads to see if it can force any type of interaction.
1728.57s - 1733.21s |  Remember that this is a CTF, so it's expecting to have something to leak or to exploit in
1733.21s - 1735.93s |  order to retrieve the flag.
1735.93s - 1740.65s |  So once it learns how it works based on the JavaScript, it's going to just do a report
1740.65s - 1747.53s |  of this case, to see if it works, it worked, so now it decides to start collecting more
1747.57s - 1752.37s |  information for one of the final payloads, and creates a super interesting script, because
1752.37s - 1754.01s |  in this case, it's taking care of everything.
1754.01s - 1758.93s |  It's creating a new user, it's reusing those credentials to log in in the application,
1758.93s - 1765.01s |  then grabbing the cookie, setting a payload for a client-side exploit to try to send some
1765.01s - 1769.85s |  fetch request to our collaboration server, another interesting case of this, understand
1769.85s - 1773.57s |  what the collaboration server is and how to use it, how to interact with it, and use the
1773.57s - 1778.17s |  payloads, and then we'll create just the post, trigger the report, and then wait for
1778.17s - 1779.53s |  some interactions.
1779.53s - 1783.93s |  Of course, it's five seconds because it's a CTF, we expect some kind of quick interaction
1783.93s - 1784.93s |  in this case.
1784.93s - 1791.25s |  Again, it tries a different payload to see if it can trigger any interaction, the, something
1791.25s - 1794.29s |  interesting here is that it's not creating the user anymore, because they understand
1794.29s - 1797.93s |  that they already have this, so it removes that part from the script, and keep improving
1797.93s - 1800.41s |  it to make better results.
1800.41s - 1805.89s |  Doesn't work either, so it goes on, try one more time, with a different payload, and again,
1805.89s - 1811.77s |  sending the DOM of the application for the admin user, it sends it, and after that, it
1811.77s - 1817.29s |  gets that interaction on the interactive server that we have, and it's super interesting to
1817.29s - 1821.73s |  see that it understands that this is an interaction for an admin that has access to the website
1821.73s - 1826.53s |  and is able to retrieve the whole DOM of the application, and if we try to search for the
1826.53s - 1834.65s |  flag, oops, well, like the flag, we are going to see that all this here is URL encoded,
1834.65s - 1838.17s |  but this is the flag that has exfiltrated from the DOM of the admin user.
1838.17s - 1841.97s |  With that, the AI understands that the challenge has successfully finished, and has everything
1841.97s - 1853.00s |  it needs to complete the challenge.
1853.00s - 1858.64s |  So too many examples, and too many scrolling, so now let's jump to something different,
1858.64s - 1864.86s |  a different experiment we did, and it's to know if can AI be compared to human pen testers.
1864.86s - 1869.38s |  So for this, we did an experiment that you may have seen in the internet, that we published
1869.38s - 1878.86s |  some of the results, and here on the screen, you are going to see both terminals, one screenshot
1878.86s - 1882.58s |  is the pen tester working, and the other one is the AI working at the same time, trying
1882.58s - 1884.98s |  to solve the same challenge.
1884.98s - 1887.82s |  Something interesting about this case is that you're going to see images, because now we
1887.82s - 1893.90s |  have built in a new browser for the AI, so it can understand buttons, everything, and
1893.90s - 1898.30s |  more JavaScript application-based, so it improves the results a lot on the client-side
1898.30s - 1899.30s |  applications.
1899.30s - 1904.38s |  And if you keep tracking the numbers, you are going to see that after the AI finished
1904.38s - 1910.50s |  in four minutes, the pen tester is still struggling, like, 20 minutes more to exploit this vulnerability
1910.50s - 1912.26s |  and this challenge.
1912.26s - 1916.58s |  So for this, we hired five pen testers from different companies, going from junior to
1916.58s - 1918.84s |  principal.
1918.84s - 1923.70s |  We gave them 40 hours to solve all of the validation cases that they were able to solve
1923.70s - 1926.18s |  from our validation set.
1926.18s - 1933.70s |  They could use any tools, no exceptions, they could do whatever they want, just a real CTF.
1933.70s - 1938.02s |  The thing is that, well, I'm just going to let it continue just a few seconds so you
1938.02s - 1942.50s |  can see how the AI has finished, and the pen tester is still working on the challenge up
1942.50s - 1947.46s |  to 19 minutes, approximately.
1947.46s - 1953.42s |  So the results from this experiment were quite interesting, and let us understand much more
1953.62s - 1957.66s |  how these things work and how they can be applied to our field.
1957.66s - 1965.06s |  So on this chart, you can see how Expo obtained the same results as the principal, both solving
1965.06s - 1970.90s |  the 85% of this challenge from the validation set.
1970.90s - 1977.22s |  And on the other chart, you can see their resolutions, percentage made by difficulty.
1977.22s - 1982.34s |  And if you pay attention to the easy and medium, you are going to see that the AI excels the
1982.38s - 1984.66s |  human pen tester and perform better results.
1984.86s - 1989.66s |  However, as Diego mentioned before, for the hard challenges, the AI is struggling a little
1989.66s - 1994.58s |  bit more, and those cases that require more creativity, alternative thinking, or more
1994.58s - 1998.58s |  careful process, the human excels in those cases.
1999.02s - 2004.82s |  So this gives us a huge hint about how this can be applied to our field, where we can
2004.82s - 2009.90s |  imagine a place where the AI is taking care of all those things that are less interesting
2009.90s - 2015.26s |  for us and leaving the human experts the work of working on the more exciting parts
2015.26s - 2017.46s |  of or more challenging parts of the application.
2021.80s - 2026.24s |  OK, and now we go to our last question for today.
2026.56s - 2030.20s |  So can AI actually be our second brain or assistant?
2030.68s - 2037.24s |  So we know that AI has been very useful in multiple contexts, but we haven't seen before
2037.64s - 2043.52s |  how we can use the AI to assist a pen tester or a backhunter, in this case, for the people
2043.52s - 2044.84s |  that are interesting here.
2045.24s - 2050.60s |  So for this meaning, we use something called human in the loop, we have been talking about
2050.96s - 2057.04s |  before. So here we have a prototype in what we wanted to do is basically analyze how we
2057.04s - 2062.92s |  can use AI to perform better the work of the human.
2063.36s - 2069.40s |  OK, so yeah, here is a small video, which just let it run.
2070.00s - 2074.40s |  But basically what we wanted to create was a prototype that basically will provide some
2074.40s - 2081.96s |  goals. Apart from that goal, what we can do is provide some feedback to the AI so we can
2081.96s - 2083.88s |  change the workflow and how it works.
2084.04s - 2088.64s |  So, for example, if we are analyzing how the AI is performing and what kind of software is
2088.64s - 2093.76s |  trying to do, we can go in the middle and we can try and change that workflow.
2093.80s - 2097.36s |  So, for example, if we see that it's trying to execute a command that it's fed, we can
2097.36s - 2100.64s |  modify that and let the AI interact and continue with that.
2100.92s - 2105.72s |  Also, if we see that, for example, it's trying to exploit an SQL injection and we see that
2105.72s - 2110.56s |  it's missing some payloads or it's missing some entry points, we can also provide that as
2110.56s - 2116.28s |  part of the learnings and we can say to the AI that he has to be and follow that right
2116.32s - 2118.84s |  path. So this is just a prototype, an example.
2118.84s - 2122.64s |  This is not something that we are pretending to sell or everything like that.
2122.88s - 2127.68s |  We just wanted to see how we can interact with the human in the loop.
2129.72s - 2131.00s |  So let's skip this one.
2132.04s - 2138.24s |  OK, and now to sum up, we're going to be reviewing again the three questions that we
2138.24s - 2140.12s |  have been talking about before.
2140.44s - 2144.92s |  So for the first question of all, if we can mimic human back hunters.
2145.20s - 2150.80s |  OK, we have seen that the AI is surprisingly good for some examples, especially the easy
2150.80s - 2151.76s |  ones and the medium ones.
2152.08s - 2156.20s |  But depending on the difficulty, we have to improve the performance.
2156.76s - 2162.68s |  Then talking about if we can compare human pen testers to AI, as Joel was talking
2162.68s - 2167.52s |  before, expert human excel such creativity and are really, really good at hard
2167.52s - 2172.08s |  challenges. But yeah, the AI is faster and better.
2172.12s - 2177.12s |  We saw in the example that we provided like five pen testers, we gave them like 40
2177.12s - 2181.12s |  hours and the AI was able to solve all of them in just 30 minutes.
2182.08s - 2187.60s |  And if we talk about if the AI can be our second brain or assistant, this is something
2187.60s - 2189.80s |  that we need to try together.
2190.08s - 2194.08s |  So we will be sharing some stuff in our websites in a couple of weeks.
2194.36s - 2199.28s |  So just we can go there to expo.com, you can join the waitlist and we will be sharing
2199.28s - 2202.00s |  everything over there and also in our social media.
2202.00s - 2203.72s |  So let's keep an eye on that.
2205.28s - 2208.96s |  And finally, we don't want to forget about the team, this is not something that we have
2208.96s - 2212.16s |  done ourselves, this is an effort of all the expo team.
2212.56s - 2216.96s |  So a big shout out to all of them because we have been working hard these three last
2216.96s - 2221.04s |  months. And yeah, this is something that we have done all together.
2222.48s - 2225.40s |  And yeah, that's the end of the talk.
2225.48s - 2229.76s |  Again, thank you to DEFCON and the Backcountry Village for giving us the opportunity.
2233.50s - 2235.90s |  And we have some questions if you want.
2239.30s - 2242.42s |  Yes, I'm not sure, I'm not sure if we have a mic.
2242.42s - 2258.04s |  So just so so far, everything has been done under control and environment control
2258.04s - 2262.24s |  environment. We are not yet using this to do bug bounties.
2262.24s - 2267.28s |  We are trying to test this to be used to test how to understand how this could be used
2267.28s - 2269.92s |  in a bug bounty field and in the security field.
2270.20s - 2273.88s |  So so far, there is not a monetary search for this now.
2274.16s - 2276.44s |  It's just this what we have shown.
2278.36s - 2288.96s |  Yes. Sorry, could you repeat that?
2299.29s - 2303.05s |  Yeah, yeah, we have tried probably those are into, if I remember correctly, into
2303.05s - 2305.21s |  misconfigurations category.
2305.65s - 2308.53s |  But we have tried the headers, manipulation and information.
2309.17s - 2310.73s |  We have a few challenges of those.
2310.89s - 2314.17s |  I can maybe look for the results after the talk, if you want.
2315.17s - 2336.63s |  Yes. So for for the first question, it's depending on how you set the goal, it's very
2336.63s - 2339.83s |  persistent. For example, we saw the cross-site scripting that was trying, keeping
2339.83s - 2344.75s |  trying, then doing something that we also do kind of human thing is like going and
2344.75s - 2348.87s |  looking around to see if can find another hints or something to get into the
2348.87s - 2354.11s |  feedback, but then goes back to the goal is very persistent into that in terms of
2354.11s - 2357.51s |  technical details. It's like you can set the amount of iterations that you want to
2357.51s - 2361.07s |  spend so you don't have like an infinite loop of things trying out.
2361.67s - 2363.99s |  And the second question was to protect.
2364.15s - 2367.15s |  So now is everything run in an isolated environment and protected.
2367.15s - 2372.47s |  So we are working on improving that in order to be conscious about what it's doing
2372.47s - 2375.91s |  and running. And that's that's also taking into account all the sales force that it
2375.91s - 2377.43s |  has to do while testing application.
2378.39s - 2381.67s |  So one more, there we go, we're quicker.
2385.24s - 2409.52s |  Thank you. Yeah, the thing is that if you're going to play CTF, when you go into hard
2409.52s - 2413.20s |  challenges, it's like you have to maybe change too many things together.
2413.44s - 2418.20s |  You have to. So probably the AI is being able to detect the first two vectors, but
2418.20s - 2423.04s |  then it doesn't go farther and detects the final one that is giving you the flag.
2423.24s - 2428.12s |  So that for us is a known solution, even though it found valid endpoints and it
2428.12s - 2429.76s |  started exploiting vulnerabilities.
2429.96s - 2433.24s |  If it doesn't get the flag, it's a no, no, no resolution for us.
2433.44s - 2439.32s |  So probably the creativity and the effort I can put in human and into going to so
2439.32s - 2442.16s |  deep, that's what makes the difference for now, at least.
2442.20s - 2443.76s |  Yeah. Yeah.
2444.56s - 2446.40s |  So I think we have no more time for questions.
2447.68s - 2448.84s |  OK, thank you, everyone.