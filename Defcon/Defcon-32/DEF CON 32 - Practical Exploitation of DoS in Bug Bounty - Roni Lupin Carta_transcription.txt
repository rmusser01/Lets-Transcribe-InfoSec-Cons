{
  "webpage_url": "https://www.youtube.com/watch?v=b7WlUofPJpU",
  "title": "DEF CON 32 - Practical Exploitation of DoS in Bug Bounty - Roni Lupin Carta",
  "description": "The talk \"Practical Exploitation of DoS in Bug Bounty\" explains methods for identifying and exploiting Denial of Service (DoS) vulnerabilities in bug bounty programs. Starting with an overview of DoS attacks and their impact, we will highlight how these attacks disrupt services by overwhelming resources or exploiting flaws. The talk covers various DoS attack types, including N+1 errors, in-depth GraphQL crashing, and Cache Poisoning, with real-world examples demonstrating their effects.\n\nWe will then detail practical techniques for discovering DoS vulnerabilities. This includes automated scanning tools, manual testing methods, and understanding the target system's architecture.\n\nN+1 errors occur when an application makes redundant database queries, significantly impacting performance. Attackers can exploit this by triggering numerous unnecessary queries, causing severe slowdowns or crashes. GraphQL, a query language for APIs, can be vulnerable to complex queries that consume excessive resources, leading to server crashes. We will show how to craft such queries and the resulting impact. Cache Poisoning involves manipulating cached data to serve malicious or incorrect content, which can disrupt services or degrade performance. We will explore techniques to poison caches and demonstrate the potential consequences.\n\nAdditionally, the talk emphasizes the importance of responsibly reporting discovered vulnerabilities to bug bounty programs. Best practices are shared for effectively communicating findings and ensuring timely mitigation. Of course, there are some fails during this path, and those are going to be covered too.\n\nThe session wraps up by stressing the need for continuous learning and staying updated on the latest trends in DoS attack vectors and mitigation strategies",
  "channel_url": "https://www.youtube.com/channel/UC6Om9kAkl32dWlDSNlDS9Iw",
  "duration": 1834,
  "channel": "DEFCONConference",
  "uploader": "DEFCONConference",
  "upload_date": "20241016"
}

0.00s - 3.80s | This text was transcribed using whisper model: large-v2

 So, I'm happy to introduce Ronnie Carta
3.80s - 5.56s |  and talk about practical exploitation
5.56s - 8.76s |  in denial of service and bug bounties.
8.76s - 14.13s |  Ronnie, thanks.
14.13s - 14.97s |  Hi everyone.
14.97s - 17.23s |  I'm really happy to be there today.
17.23s - 20.51s |  This is the first ever Bug Bounty Village
20.51s - 23.67s |  and it's a true honor to do the first talk ever.
23.67s - 25.39s |  Well, with some technical difficulties
25.39s - 27.93s |  of not having an HDMI cable, but no worries.
27.93s - 28.83s |  We are there now.
30.25s - 32.11s |  So, the talk is about practical exploitation
32.11s - 34.65s |  of denial of service in bug bounty program.
34.65s - 36.39s |  So, first of all, my name is Ronnie.
36.39s - 37.75s |  I go by the nickname Lupin.
37.75s - 39.59s |  I'm the co-founder of Lupin Homes.
39.59s - 42.51s |  We are a security research and development company
42.51s - 46.03s |  and I'm coming from the best city in the world, Grenoble.
46.03s - 48.91s |  It's in the French Alps, lot of skiing, beautiful place.
50.47s - 52.55s |  I love denial of service.
52.55s - 55.03s |  I love denial of service because you can actually
55.03s - 57.87s |  try to slow down or considerably take down
57.87s - 59.91s |  an entire product environment.
59.95s - 62.95s |  And so, the goal of denial of service in bug bounties
62.95s - 67.03s |  is to basically try to find the most business impact.
67.03s - 69.51s |  Imagine like a website not having traffic anymore.
69.51s - 72.11s |  That will be a huge bummer for the company.
73.31s - 77.83s |  And so, denial of service and like the difference
77.83s - 79.35s |  between denial of service and DDoS
79.35s - 82.79s |  is basically denial of service is from one single machine.
82.79s - 86.87s |  But DDoS, the additional D is for distributed, of course.
86.87s - 89.25s |  So, it means that we require a series of different machine
89.25s - 91.49s |  to be able to take down our target.
91.49s - 94.01s |  This is basically all about the resource
94.01s - 96.73s |  that you have on your machine against the resources
96.73s - 99.01s |  that you have on your target.
99.01s - 102.57s |  So, if the attacker has more resources on its machine,
102.57s - 106.37s |  then it can basically take down the target.
106.37s - 109.57s |  But in a DDoS, you might have amplification
109.57s - 112.09s |  or multiplicating factor in order to be able
112.09s - 113.97s |  to completely take down the machine.
113.97s - 116.37s |  So, that's what we're going to talk about today.
117.37s - 119.81s |  A little bit of definition debates here.
121.17s - 122.65s |  Basically, there is a whole debate
122.65s - 124.89s |  about denial of service being an availability
124.89s - 126.89s |  or integrity impact.
126.89s - 130.37s |  So, basically, the impact of like the DDoS
130.37s - 132.25s |  is not a vulnerability class,
132.25s - 134.47s |  but more like an impact, I will say.
134.47s - 137.33s |  And we can say that deleting a resource
137.33s - 139.01s |  is in a sense denied.
139.01s - 141.17s |  But the CVSS documentation says
141.17s - 143.69s |  that the deletion of a resource is integrity
143.69s - 145.37s |  and not availability at all.
145.37s - 147.73s |  So, that whole blob of documentation,
147.73s - 150.53s |  if you want to read it, is what the CVSS says.
150.53s - 153.33s |  So, basically, it says that availability
153.33s - 156.37s |  is the performance and operation of the service itself
156.37s - 159.77s |  and not the availability of the data.
159.77s - 161.85s |  For those who have been doing bug bounty hunting,
161.85s - 165.53s |  you know that you are debating a lot about CVSS
165.53s - 167.17s |  and you need to read all the documentation.
167.17s - 169.61s |  So, be mindful of that if you want
169.61s - 171.79s |  to argue with CVSS programs.
172.79s - 176.07s |  So, when DDoS is relevant,
176.07s - 179.11s |  basically, it is relevant for every feature
179.11s - 181.83s |  where there is a strong dependency.
181.83s - 183.47s |  This means that it's a feature
183.47s - 185.59s |  that a lot of users are going to use
185.59s - 188.83s |  or maybe there is a dependency on the machines
188.83s - 191.19s |  that you are targeting.
191.19s - 192.15s |  For instance, if you can take
192.15s - 194.79s |  that entire EKS cluster in production,
194.79s - 196.67s |  well, that might be super impactful.
198.03s - 200.15s |  But yeah, I know what you are going to say.
200.15s - 202.31s |  The denial-of-service is totally out of scope.
202.31s - 205.31s |  Actually, on HackerOne default templates for program,
205.31s - 208.49s |  it's marked as out of scope by default.
208.49s - 209.95s |  And there's a reason for that
209.95s - 213.55s |  because companies, in usual, do not like denial-of-service.
213.55s - 215.99s |  Not because of the low impact
215.99s - 217.83s |  or because it's not security availability,
217.83s - 221.47s |  but because, actually, if you let all your bug hunters
221.47s - 223.27s |  completely take down your website,
223.27s - 226.27s |  it might be a huge problem for them.
226.27s - 230.47s |  So, basically, it's not because denial-of-service
230.47s - 231.31s |  has low impact,
231.31s - 233.91s |  but because sometimes that's too much impact.
233.91s - 236.67s |  But we can test denial-of-service responsibly
236.67s - 239.73s |  and actually make a few bucks with it.
241.41s - 243.63s |  In order to test denial-of-service responsibly,
243.63s - 246.51s |  you need to find the gadget of the problem
246.51s - 247.79s |  to fully exploit it.
247.79s - 249.63s |  So, this means that, for instance,
249.63s - 252.79s |  if you have a request that takes more than 10 seconds,
252.79s - 254.19s |  this might be a cool gadget
254.19s - 257.23s |  in order to take down the entire product environment,
257.23s - 259.35s |  but you do not need to actually take it down
259.35s - 262.31s |  to just see that one request takes more than 10 seconds.
262.31s - 264.55s |  And also, if you are allowed,
264.55s - 266.55s |  you can still try to take down
266.55s - 267.91s |  the non-production environment,
267.91s - 270.99s |  so staging, integration, sandbox, et cetera.
270.99s - 274.79s |  But if there is something to know about this entire talk,
274.79s - 277.21s |  please, always ask the programs
277.21s - 279.79s |  before even searching for denial-of-services
279.79s - 281.47s |  because programs need to be aware
281.47s - 284.27s |  of what kind of tests you are going to do
284.27s - 285.71s |  in order for them to monitor.
285.71s - 288.35s |  And if everything is going to fire,
288.35s - 290.71s |  they need to identify that you are the one doing the test
290.71s - 291.75s |  and just call you and say,
291.75s - 294.09s |  hey, I think there is a problem here.
296.03s - 299.23s |  And denial-of-service is all about program's maturity.
300.35s - 304.75s |  Some companies do not care about denial-of-service's risk
304.75s - 306.15s |  because they, I don't know,
306.15s - 310.11s |  they don't have user traffic or stuff like that.
310.11s - 312.43s |  But actually, some programs will allow you
312.43s - 315.57s |  to completely take down their prod environment.
315.57s - 318.43s |  And I'm serious, they are completely allowing
318.43s - 320.35s |  to take down their dub-dub-dub environment,
320.35s - 321.73s |  so this is amazing.
322.63s - 324.81s |  Before starting going on all the different techniques,
324.81s - 328.23s |  I need to thanks Rezo, Zach, Ixo, Snorlax,
328.23s - 330.67s |  Bifed, BonsoirD, and DoomerHunter.
330.67s - 331.75s |  Those are amazing hunter.
331.75s - 334.31s |  We did all these research together
334.31s - 335.97s |  on the span of two years,
335.97s - 338.55s |  so I needed to quickly show that to them.
338.87s - 340.39s |  Amazing people to follow, too.
341.83s - 344.99s |  Okay, let's start with a quick vulnerability.
344.99s - 346.83s |  This one is really fun.
346.83s - 349.51s |  So one evening we were hacking with Snorlax
349.51s - 353.47s |  and there was this application that was sending service,
353.47s - 355.99s |  like it was service to send chat messages.
355.99s - 358.31s |  And so with Snorlax, when we are hunting together,
358.31s - 362.33s |  we have this game where the goal is to basically
362.33s - 364.47s |  try to XSS the other one.
364.47s - 367.19s |  So we were contacting one another, sending messages,
367.19s - 370.63s |  and we were like, the first that got XSS wins it.
370.63s - 372.35s |  But at some point, we were doing a test
372.35s - 374.91s |  and my page completely goes blank.
374.91s - 377.15s |  And I was like, ah, maybe I lost internet.
377.15s - 379.19s |  But I was still hearing Snorlax on Discord
379.19s - 381.39s |  and I was like, there's something weird, right?
381.39s - 386.11s |  Until he tells me, hey Lupin, is your page blank, too?
387.47s - 391.31s |  So those are the payloads that we sent at this moment.
391.31s - 394.49s |  So try to think about which one did manage
394.49s - 396.43s |  to make the page entirely blank.
397.31s - 400.53s |  Do you have it?
400.53s - 402.05s |  Yeah, this is the one.
402.05s - 405.61s |  And so to understand why this payload
405.61s - 407.57s |  made the page completely blank,
407.57s - 410.05s |  basically you need to understand that the service
410.05s - 413.01s |  was using a library called sanitize-html.
413.01s - 416.49s |  So basically it's some kind of dump purify
416.49s - 419.61s |  that will try to sanitize every XSS
419.61s - 421.57s |  that you are going to send.
421.57s - 424.69s |  And this library actually tried to sanitize
424.69s - 427.53s |  every href attribute in your frontend.
427.53s - 430.57s |  So for instance, if you have a JavaScript schema,
430.57s - 433.25s |  it will try to remove it from the href.
434.21s - 436.81s |  However, in this payload, where is the href?
436.81s - 438.45s |  There is a problem here.
438.45s - 441.09s |  And so the library actually called the function
441.09s - 444.73s |  noti-href and take an argument href
444.73s - 446.49s |  and do a dot replace on it.
446.49s - 448.49s |  However, when it's undefined,
448.49s - 451.01s |  completely crashed the entire frontend.
451.01s - 453.69s |  Okay, that was a pretty cool one.
453.69s - 456.61s |  And so for every kind of client side
456.77s - 457.89s |  of service malformed data,
457.89s - 460.21s |  I would say that the impact is not that huge.
460.21s - 464.37s |  It's all depending on the target.
464.37s - 466.53s |  Overall, with this specific technique
466.53s - 471.25s |  of malformed data html, we did $350 bounty,
471.25s - 472.57s |  but that's just the start.
473.81s - 476.29s |  If you want to actually search for more
477.49s - 480.17s |  malformed data in the frontend,
480.17s - 482.37s |  you can, there was a cool vulnerability
482.37s - 484.77s |  where we had like a POST request
484.77s - 487.33s |  and we could send any invalid JSON
487.33s - 489.01s |  that was validated by the backend,
489.01s - 491.81s |  but it was a completely malformed JSON.
491.81s - 494.25s |  And so when the frontend was using it,
494.25s - 496.89s |  it will also completely crash.
496.89s - 500.17s |  And so the malformed JSON was like really simple.
500.17s - 505.13s |  It was using two back quotes at the same time,
505.13s - 506.21s |  two escape back quotes.
506.21s - 509.09s |  And so it was somehow accepted by the backend,
509.09s - 512.29s |  but when you were doing a JSON.parse on the frontend,
512.29s - 514.69s |  it will completely crash.
515.53s - 518.45s |  And so this technique actually worked on TikTok
518.45s - 520.41s |  and we got paid with XO for that.
520.41s - 522.53s |  So that was a cool one,
522.53s - 525.49s |  but there were some cooler techniques now.
525.49s - 529.81s |  Okay, so that guy here is one of the biggest problem
529.81s - 534.37s |  for all developers, the N plus one problem.
534.37s - 539.21s |  Basically this technique, I actually knew about it
539.21s - 542.01s |  because my brother, who is a backend developer
542.01s - 544.69s |  told me about, like we were talking about
544.69s - 547.29s |  in our services and how I was trying to exploit them.
547.29s - 549.61s |  And he was like, do you know what's an N plus one problem?
549.61s - 550.45s |  And I was like, no.
550.45s - 553.09s |  And he told me that basically an N plus one problem
553.09s - 555.53s |  is was a database anti-pattern
555.53s - 559.97s |  when one query leads to N additional queries
559.97s - 562.97s |  causing inefficient data retrieval.
562.97s - 567.41s |  So basically an attacker can exploit N plus one queries
567.41s - 569.85s |  to trigger numerous call to the database
569.97s - 572.69s |  and potentially overwhelm the system.
572.69s - 575.13s |  And the impact of an N plus one query
575.13s - 577.25s |  often scales with the data size.
577.25s - 578.81s |  So the more data that you add,
578.81s - 582.21s |  the more DOS capability you can have on your target.
583.47s - 585.81s |  So how to detect an N plus one query?
585.81s - 589.51s |  Basically you find an endpoint that creates data in the API.
589.51s - 592.43s |  You find a request that gets all the data at the same time.
592.43s - 594.05s |  So usually a get request.
594.05s - 596.69s |  And if there is pagination, try to increase the limit.
596.69s - 598.21s |  For instance, you have some get request
598.21s - 599.81s |  which is page equal 10.
599.81s - 602.85s |  Try to put 10,000 and see what's going to happen.
603.77s - 606.97s |  And if the more data you add in the backend,
606.97s - 609.59s |  the more time delay there is in the response,
609.59s - 611.29s |  then you have an N plus one error.
612.69s - 614.77s |  I also created a BURP extension
614.77s - 618.05s |  that I'm going to release right after this talk.
618.05s - 619.53s |  That's called Tridos.
619.53s - 623.53s |  And basically it's going to search in your proxy passively
623.53s - 626.57s |  all the requests that takes more than X seconds
626.57s - 629.93s |  where X is a threshold that you set yourself.
629.93s - 632.23s |  I personally put it to three seconds.
632.23s - 636.35s |  And this is a good way to actually identify queries
636.35s - 639.07s |  that might take a lot of time on the backend
639.07s - 642.89s |  and that you can actually use for your exploitation.
642.89s - 647.89s |  So let's take an example of an N plus one problem.
648.55s - 650.61s |  There was an app that could accept
650.61s - 653.65s |  to create as many objects as we wanted.
653.65s - 655.25s |  The JSON blob was something like that
655.25s - 657.17s |  where you had a list of users.
657.17s - 662.05s |  And then on each user, on each array of the list,
662.05s - 664.61s |  you can create a new user.
664.61s - 667.01s |  And then there was another sub object
667.01s - 669.41s |  with another array with new objects.
669.41s - 671.71s |  So that's basically an N plus one problem
671.71s - 673.45s |  when one request can create
673.45s - 676.09s |  as many sub objects as you want.
677.21s - 679.09s |  And so how did we exploit that?
679.09s - 682.65s |  Well, we sent the request to create all those objects
682.69s - 686.97s |  and we created approximately 10,000 objects in the backend.
686.97s - 691.39s |  And then our get request to retrieve all the objects
691.39s - 694.01s |  took 10 seconds per request.
694.01s - 696.85s |  So that's a really, really good sign
696.85s - 698.83s |  that you have an N plus one problem.
698.83s - 700.17s |  We took those requests,
700.17s - 703.29s |  we put it into an intruder on burp
703.29s - 706.77s |  and we set it with no payloads, 10 concurrent requests.
706.77s - 710.31s |  And we basically set it to run indefinitely.
710.31s - 716.36s |  And the result, complete crash.
716.36s - 718.84s |  Overall, this technique, not on a single vulnerability,
718.84s - 723.26s |  but overall, we did $46,000 in bounty.
723.26s - 724.60s |  There was an LHE this week,
724.60s - 727.84s |  so we can add 10,000 more to this slide.
727.84s - 732.40s |  I think that 30K of this was Nolak's alone
733.38s - 736.12s |  because he's so good as just taking one technique
736.12s - 737.24s |  and spread it.
737.24s - 740.16s |  I think he did 15K per vulnerability,
740.16s - 742.48s |  so in two vulnerability, 30K.
742.48s - 743.64s |  That guy is insane.
745.32s - 749.64s |  Okay, let's talk about network-based denial of services.
749.64s - 752.16s |  Have you ever been in that situation
752.16s - 753.80s |  where you have a blind SSRF
753.80s - 756.20s |  and you don't know what to do with it?
756.20s - 758.66s |  And that you are desperate for a technique
758.66s - 762.16s |  that will help you transform this sometimes informative
762.16s - 764.44s |  vulnerability into a higher crit?
764.44s - 766.62s |  Well, we have a technique for you.
767.62s - 770.90s |  Basically, do you guys know something called
770.90s - 772.62s |  like slow low-risk attack?
772.62s - 774.58s |  Well, basically, we are going to try
774.58s - 776.62s |  to do something really similar
776.62s - 780.06s |  where we are going to try to make the bucket hang
780.06s - 782.66s |  on the network level as much as possible.
782.66s - 784.90s |  We can do it with several ways.
784.90s - 788.06s |  You can make your server hang
788.06s - 790.54s |  and just time out after 10 seconds,
790.54s - 793.60s |  or you can create a request loop.
793.60s - 796.02s |  So, what do I mean by request loop?
796.42s - 798.46s |  Well, you have your server that has a path
798.46s - 801.46s |  that will reject 301 on path two,
801.46s - 804.22s |  and then the path two will reject again on path one.
804.22s - 807.70s |  So, we create like an infinite loop of redirects.
807.70s - 811.46s |  And the goal is to make the server time out
811.46s - 812.88s |  as much as possible.
812.88s - 815.96s |  So, we have that kind of schema happening.
817.94s - 819.86s |  And the goal of that technique is actually
819.86s - 822.94s |  to fill all the available sockets of the server
822.94s - 827.02s |  so it couldn't actually treat the next request
829.06s - 831.74s |  until we have this bottleneck happening
831.74s - 834.16s |  and there is no available sockets anymore.
837.36s - 839.32s |  For this technique, I think it was
839.32s - 841.24s |  on two separate vulnerabilities.
841.24s - 843.32s |  We made 15K.
843.32s - 845.00s |  So, it's actually a great technique
845.00s - 848.20s |  to transform blind SSRF into a critical.
848.20s - 850.92s |  Again, every time that we take down product environments,
850.92s - 853.16s |  we always ask for the programs.
853.16s - 854.96s |  Really be mindful of that.
855.52s - 858.42s |  That's a pretty cool one if you're ever stuck.
860.08s - 863.48s |  Okay, let's go to sign-in denial of services.
864.96s - 867.82s |  This one was really cool because we had a target
867.82s - 870.36s |  with an employee webpage.
870.36s - 872.56s |  And basically, when we see an employee webpage,
872.56s - 875.50s |  we try password stuffing or brute forcing
875.50s - 878.88s |  with simple combination, injection, et cetera, et cetera.
878.88s - 882.36s |  But why this target was particularly interesting for us
882.36s - 886.64s |  is because it was a target with more than 1,000 employees.
886.64s - 890.36s |  There was no rate limiting on the login, no 2FA at all,
890.36s - 893.40s |  and they were using first name dot last name for the user.
893.40s - 895.80s |  So, we could pull everything on LinkedIn
895.80s - 899.12s |  and we had a great world list to work with.
899.12s - 900.90s |  So, what do we do?
900.90s - 903.20s |  We managed to automate the attack,
903.20s - 906.88s |  no rate limiting at all, and then no login found.
906.88s - 908.60s |  Wait, no login found?
909.48s - 911.64s |  But we still got a crit.
911.64s - 915.84s |  Okay, guess what protection they implemented
915.84s - 917.46s |  for brute forcing attack.
917.46s - 919.72s |  Is it A, delay the next attempt?
919.72s - 921.44s |  B, capture?
921.44s - 923.40s |  C, ban the IP address?
923.40s - 930.69s |  Or D, ban the employee account?
930.69s - 933.01s |  There is actual documentation on the internet
933.01s - 936.03s |  that says that this is the right thing to do.
936.03s - 937.59s |  So, yeah.
937.59s - 938.43s |  What happened?
938.43s - 939.89s |  600 account locked.
940.77s - 943.85s |  They had LTAP integration with the AD.
943.85s - 946.83s |  So, Active Directory completely down,
946.83s - 949.29s |  no access to the VPN anymore,
949.29s - 952.69s |  completely take down of the internet environment.
952.69s - 953.71s |  So funny.
954.97s - 957.21s |  I would say that the impact of this technique
957.21s - 961.25s |  is actually like a three out of five,
961.25s - 964.97s |  but it's because the presence in the wild is also reduced.
964.97s - 966.41s |  I don't think that a lot of companies
966.41s - 969.87s |  are doing that anymore, but pretty cool bug.
970.87s - 974.75s |  Okay, let's go to another type of DOS,
974.75s - 976.41s |  disk consumption DOS.
976.41s - 977.75s |  So, this story is quite cool.
977.75s - 980.79s |  It started because I read this AssetNode research.
980.79s - 982.71s |  If you guys don't know AssetNode,
982.71s - 985.63s |  you should read every blog post of them.
985.63s - 986.69s |  It's amazing.
986.69s - 989.11s |  And there was this blog post from 2019
989.11s - 992.79s |  called Discovering a Zero Day and Getting Code Execution
992.79s - 994.63s |  on Modular AWS Network.
994.63s - 997.05s |  So, how did AssetNode achieve that?
997.05s - 1000.21s |  Basically, there was an instance called WebHTest
1000.21s - 1002.45s |  and it was completely open source.
1002.45s - 1005.05s |  So, they read the code and there was this piece of code
1005.05s - 1007.45s |  where you could extract a zip file
1007.45s - 1008.89s |  that was given by the user
1008.89s - 1012.09s |  and then with some kind of quick race condition,
1012.09s - 1015.09s |  you could actually call a PHP file.
1015.09s - 1017.57s |  And so, for this race condition to work,
1017.57s - 1019.89s |  you needed to set up an intruder
1019.89s - 1022.93s |  and just run as many requests as possible.
1024.17s - 1025.97s |  What happened when I tried it?
1027.17s - 1029.57s |  The backend didn't have enough eNodes
1029.57s - 1030.93s |  to take the charge of requests.
1030.93s - 1033.41s |  So, every time it was creating a zip file
1033.41s - 1037.17s |  and trying to extract it, it was allocating eNodes
1037.17s - 1041.67s |  and so, the disk was full in like maybe two, three seconds.
1041.67s - 1044.31s |  So, yeah, I took down the instance
1044.31s - 1047.33s |  and I thought that this instance wasn't used by anyone
1047.33s - 1050.61s |  until someone told me, hey, all the pipelines are down.
1050.61s - 1052.69s |  And so, every time they were running a pipeline,
1052.69s - 1054.51s |  they were going to that instance.
1055.53s - 1056.37s |  That's cool.
1057.37s - 1059.25s |  So, total crash of the server.
1059.25s - 1060.33s |  No access to the disk.
1060.33s - 1062.65s |  They needed to clean everything, wipe out,
1062.65s - 1064.21s |  restart the server.
1064.21s - 1065.61s |  That was a cool one.
1065.61s - 1068.77s |  I would say that, again, the impact is reduced
1068.77s - 1070.33s |  because of the presence in the world.
1070.33s - 1072.09s |  So, it's a three out of five.
1073.93s - 1075.33s |  Cache poisoning.
1075.33s - 1076.33s |  That's a good one.
1077.19s - 1080.45s |  So, one day, for this anecdote,
1080.45s - 1083.21s |  at Lupienzo Homes, we were developing a new feature
1083.21s - 1085.57s |  for our tool, Depi, in research mode.
1085.57s - 1088.77s |  Research mode, for us, is when we want to test an idea
1088.77s - 1092.01s |  and spread it to see if it should be incorporated
1092.01s - 1095.01s |  into our tool for our customers.
1095.01s - 1098.61s |  And so, the idea was, what if registries,
1098.61s - 1101.49s |  when you install a dependency and have two factories,
1101.49s - 1103.13s |  used by the clients were vulnerable
1103.13s - 1105.45s |  to cache poisoning in our service?
1105.45s - 1107.41s |  It's a good thing to try.
1107.41s - 1109.33s |  So, we developed a proof concept
1109.33s - 1112.45s |  and on the first run, we managed to get a hit
1112.45s - 1114.45s |  on registry.npmjs.org.
1114.53s - 1118.29s |  And I was like, no, that didn't happen.
1118.29s - 1119.33s |  Like, no way.
1120.93s - 1122.65s |  So, we thought it was a false positive
1122.65s - 1125.61s |  and lo and behold, it worked.
1126.91s - 1129.61s |  So, what is CPDOS?
1129.61s - 1134.61s |  CPDOS, it was a web attack technique described by Portugal.
1135.01s - 1137.69s |  Portugal actually made it really, really famous.
1137.69s - 1139.85s |  Again, if you didn't read in your life
1139.85s - 1142.81s |  a James Kettle research, you should do it.
1142.81s - 1144.05s |  This guy is amazing.
1144.57s - 1145.93s |  Always breaking the internet.
1145.93s - 1148.69s |  And basically, it involved exploiting vulnerabilities
1148.69s - 1149.97s |  in the web caching system
1149.97s - 1154.21s |  in order to deliver malicious content to the users.
1154.21s - 1157.97s |  So, the methodology is to first understand
1157.97s - 1161.49s |  how the cache keys of our target is working
1161.49s - 1165.57s |  and then understand how the output of the request
1165.57s - 1168.09s |  is linked to your HTTP input.
1168.09s - 1171.29s |  So, for instance, is the cache key inside the path,
1171.29s - 1175.17s |  the headers, or maybe some data in the POST requests?
1175.17s - 1176.81s |  Once you identify the cache key,
1176.81s - 1179.33s |  try to understand how you can manipulate it
1179.33s - 1181.65s |  in order to cache unwanted content.
1181.65s - 1184.93s |  So, it could be a malicious content like an XSS payload
1184.93s - 1189.01s |  or it could just take down the page for all the users.
1190.09s - 1194.49s |  So, the case of registry.npmjs.org was pretty cool.
1194.49s - 1196.93s |  Basically, my assumption is that the cache key
1196.93s - 1199.57s |  was actually the full path.
1199.65s - 1203.97s |  And when we added our malicious header,
1203.97s - 1207.09s |  it will create a 404 error.
1207.09s - 1210.29s |  But however, the cache key is still remaining the same,
1210.29s - 1213.81s |  and so it will just override the cache key with a 404.
1215.13s - 1219.01s |  So, at this point, we called deny packages.
1219.01s - 1223.45s |  That's a screenshot of my script running in the back
1223.45s - 1225.65s |  and I'm trying to do an npm install,
1225.65s - 1226.65s |  and then that's it.
1226.65s - 1229.49s |  We got a 404 in production environment.
1230.17s - 1231.33s |  That was kind of cool.
1231.33s - 1234.13s |  Don't worry, I did it on a package that I created myself.
1234.13s - 1236.61s |  I didn't take down anything, hopefully.
1237.77s - 1241.13s |  And so, the impact was a complete denial
1241.13s - 1243.93s |  of any npm package in the world.
1243.93s - 1247.25s |  Imagine Express has 30 million plus downloads per week.
1248.45s - 1251.21s |  Actually, there was a lot of mitigation in place
1251.21s - 1254.17s |  on GitHub and npm side,
1254.17s - 1258.09s |  but it was quite cool vulnerability.
1258.09s - 1263.09s |  And so, first, they awarded a $500 informative,
1264.05s - 1267.29s |  but then they actually did an awesome work
1267.29s - 1269.17s |  to reconsider the severity,
1269.17s - 1274.17s |  and they added a $10,000 bounty for this npm crash.
1274.89s - 1278.57s |  So, I was so happy, especially for something
1278.57s - 1280.65s |  that we didn't do on purpose again.
1282.41s - 1285.41s |  Okay, let's go to another cool attack vector
1285.41s - 1286.89s |  for denial of services.
1286.89s - 1289.29s |  Everything related to GraphQL.
1289.29s - 1291.81s |  So, why are we talking about GraphQL today?
1291.81s - 1295.85s |  Because it has a huge adoption in the last few years,
1295.85s - 1298.13s |  and there is so many denial of services
1298.13s - 1300.37s |  in the default configuration.
1300.37s - 1305.34s |  But when I say so many, I say so many.
1305.34s - 1309.26s |  First case of denial of services on GraphQL
1309.26s - 1311.26s |  is a circular definition.
1311.26s - 1313.46s |  Basically, circular definition occurs
1313.46s - 1318.46s |  when an object references itself directly or indirectly.
1319.70s - 1322.46s |  For instance, here we have a type user
1322.46s - 1324.14s |  that has a best friend user.
1324.14s - 1328.64s |  But imagine if your best friend is also best friend with you.
1328.64s - 1330.62s |  You are basically referencing yourself.
1330.62s - 1332.62s |  So, we have a circular definition here.
1333.60s - 1336.30s |  But no need to check for the introspection
1336.30s - 1339.06s |  and actually understand the structure of your target.
1339.06s - 1340.94s |  GraphQL is vulnerable by default
1340.94s - 1342.92s |  in the introspection schema.
1343.36s - 1344.68s |  So, you can just do an introspection
1344.68s - 1346.24s |  and actually DOS your target
1346.24s - 1348.80s |  without understanding their data structure.
1348.80s - 1352.31s |  That's insane.
1352.31s - 1354.91s |  And so, there's another kind of technique
1354.91s - 1357.31s |  called GraphQL batching that is pretty cool.
1357.31s - 1361.35s |  Basically, the goal is to compile a lot of different requests
1361.35s - 1363.55s |  in the same HTTP requests.
1363.55s - 1368.47s |  And again, this could be used to actually DOS your target.
1368.47s - 1371.67s |  We're going to talk about this a little bit later.
1371.67s - 1373.67s |  Something really similar to GraphQL batching,
1373.67s - 1375.27s |  there is aliases where, basically,
1375.27s - 1380.07s |  you can use different aliases for the same requests
1380.07s - 1382.19s |  but also use different arguments.
1382.19s - 1385.63s |  So, that also could be a huge attack vector
1385.63s - 1387.47s |  for the network service.
1387.47s - 1390.83s |  So, quick tip for batching and aliases
1390.83s - 1393.55s |  is to actually try to find gadget.
1393.55s - 1396.91s |  What I call gadget, if it's the right definition,
1396.91s - 1399.57s |  but what I call gadget for this specific vulnerability
1399.57s - 1403.81s |  is to find a query in the structure of your target
1403.81s - 1406.05s |  that takes already 200 milliseconds
1406.05s - 1408.13s |  up to 500 milliseconds.
1408.13s - 1412.17s |  Sometimes more when you don't optimize anything, I guess.
1413.49s - 1417.73s |  And use this specific query in every batching request
1417.73s - 1420.17s |  that you do or in every aliases.
1420.17s - 1423.05s |  And this will allow you to send a lot of requests
1423.05s - 1426.65s |  to maybe the disk operation that it does, the memory,
1427.05s - 1429.85s |  it really depends on how the backend implemented it.
1430.81s - 1433.59s |  But this could take you a batching
1433.59s - 1435.49s |  that takes five seconds per request
1435.49s - 1437.79s |  up to five minutes per request.
1437.79s - 1442.73s |  So, this is a good way to multiply and amplify your DOS.
1444.53s - 1448.17s |  And there is this one, the GraphQL directives.
1448.17s - 1450.13s |  So, what's a directive?
1450.13s - 1454.35s |  It's a way for GraphQL to decorate a part of the schema
1454.35s - 1457.63s |  and actually to do an operation on top of it
1457.63s - 1459.41s |  or additional configuration.
1460.39s - 1461.75s |  And there is a technique called
1461.75s - 1464.59s |  GraphQL directive overloading,
1464.59s - 1467.27s |  where basically you can just make that payload,
1467.27s - 1470.95s |  repeat the at a as many times as you like,
1470.95s - 1475.71s |  and it will totally crush the server somehow.
1475.71s - 1479.63s |  But we had a cool story on the Google console
1480.83s - 1482.39s |  with evolving that.
1482.39s - 1486.63s |  So, let's imagine that a directive could be used
1486.63s - 1488.67s |  for, again, our type user,
1488.67s - 1490.87s |  and you can query every user
1490.87s - 1494.43s |  with a auth role admin or auth role user.
1494.43s - 1498.95s |  So, that's the way that normally we could use a directive.
1499.83s - 1502.27s |  But then Google was using the directive
1502.27s - 1505.31s |  in a very, very strange way.
1505.31s - 1509.39s |  Basically, you add the query list operation, for instance,
1509.39s - 1512.47s |  and then you see that we have directive
1512.47s - 1515.55s |  at signature with bytes inside.
1515.55s - 1517.83s |  And what they were doing,
1517.83s - 1521.63s |  they were actually signing the body of the request
1521.63s - 1524.59s |  from within the GraphQL requests.
1525.51s - 1528.71s |  And every time that we wanted to modify any variables
1528.71s - 1532.31s |  or anything in the schema, we will get an error.
1532.31s - 1535.39s |  So, when we are trying to attack a backend,
1535.39s - 1538.51s |  we really want to modify the request in our proxy.
1538.95s - 1540.35s |  That was a huge bummer
1540.35s - 1543.67s |  because it means that everything was totally signed.
1543.67s - 1547.83s |  So, we tried to see if we could sign out our requests,
1547.83s - 1551.03s |  but the problem is that they were outcoding everything
1551.03s - 1552.03s |  in the JavaScript.
1552.03s - 1554.15s |  So, generating everything on the build
1554.15s - 1556.07s |  and putting this in the JavaScript.
1556.07s - 1557.87s |  And so, they actually told us
1557.87s - 1562.31s |  that they were using a secret that was a passphrase,
1562.31s - 1565.27s |  and it was also outcoded inside the code base,
1565.27s - 1568.23s |  so they awarded $1,000 for that.
1568.95s - 1572.11s |  That was a fun one, but nothing related to DOS.
1572.11s - 1573.83s |  But there is something interesting.
1573.83s - 1576.95s |  How they can sign the body
1576.95s - 1579.79s |  and put the signature inside the body.
1579.79s - 1583.07s |  This means that there is something in the GraphQL
1583.07s - 1585.83s |  that is not being checked correctly, right?
1585.83s - 1588.15s |  That is not inside the signature.
1588.15s - 1591.39s |  And normally, it's just the signature itself.
1591.39s - 1593.15s |  So, this means that we can add
1593.15s - 1595.87s |  as many signatures as possible.
1595.87s - 1597.39s |  And every time that we had a signature,
1597.39s - 1599.23s |  they were running the check
1599.23s - 1601.67s |  of the entire body all over again.
1602.59s - 1607.23s |  So, we wrote a script where we will add 10 directive,
1607.23s - 1609.59s |  500, 1,000, up to a million,
1609.59s - 1613.27s |  and check the requests every time.
1613.27s - 1614.35s |  What happened?
1614.35s - 1618.95s |  The first 10 directive, 0.9 seconds to answer.
1618.95s - 1621.51s |  500 directive, one second.
1621.51s - 1624.31s |  We had 5,000 directive, 2.7.
1624.31s - 1626.75s |  10,000, 2.6, don't know what happened here.
1627.83s - 1632.83s |  50,000, 6.5, and then up to 1,109,000 seconds.
1633.19s - 1638.19s |  So, we had one minute 40 per request, which is huge.
1639.67s - 1641.91s |  This vulnerability was found with Rezo,
1641.91s - 1645.43s |  and Google actually gave us a 6K bounty for that.
1645.43s - 1650.43s |  And I think that compared to the presence in the wild,
1651.27s - 1654.55s |  the impact is really high for that kind of stuff.
1654.55s - 1659.39s |  And overall, for all the GraphQL DOS that we did in the,
1659.39s - 1660.35s |  oh, I'm sorry.
1660.35s - 1661.91s |  Also, pro-tips, pro-tip.
1661.91s - 1663.31s |  Yeah, this one is important.
1664.39s - 1667.03s |  GraphQL exposes WebSockets,
1667.03s - 1669.83s |  depending on the configuration and on the backend.
1669.83s - 1674.83s |  But this WebSocket server usually do not have any WAF
1675.11s - 1678.19s |  or any check, and people often forget that it exists.
1678.19s - 1679.95s |  So, if you have rate limiting in place
1679.95s - 1683.23s |  and that you want to exploit any GraphQL DOS,
1683.23s - 1684.95s |  you can just go to the WebSocket,
1684.95s - 1686.79s |  and there is no security anymore.
1686.79s - 1691.43s |  And if you like, actually, GraphQL hunting,
1691.43s - 1694.39s |  if you go to the WebSocket,
1694.39s - 1696.07s |  you can also have introspection
1696.07s - 1698.43s |  and other GraphQL configurations.
1698.43s - 1701.75s |  So, it might actually give you a lot more attack surface.
1701.75s - 1703.91s |  So, that's another GraphQL pro-tip.
1703.91s - 1706.87s |  And overall, with all the GraphQL denial of services,
1706.87s - 1710.39s |  we made a 70K bounty.
1710.39s - 1712.43s |  So, every time you see GraphQL,
1712.47s - 1717.46s |  just say to yourself, we can take it down.
1717.46s - 1719.90s |  Okay, I had to rush a little bit this presentation
1719.90s - 1722.90s |  because we were having this HTML problem.
1722.90s - 1725.06s |  So, let's go straight to the conclusion.
1725.06s - 1726.46s |  Let's talk about the timeline
1726.46s - 1730.14s |  of this entire denial of service research.
1730.14s - 1733.58s |  The first denial of service that we found with Snorlax
1733.58s - 1738.58s |  was in 2022, and the last one that we found was last week.
1738.94s - 1743.22s |  But the main focus of the entire research
1743.66s - 1745.90s |  was during eight months last year.
1745.90s - 1747.90s |  So, most of the bounties were made
1747.90s - 1749.34s |  in a span of eight months.
1750.90s - 1753.18s |  And so, how much bounty overall
1753.18s - 1757.30s |  we made with this entire research?
1757.30s - 1762.30s |  We made almost $150,000 in bounty,
1762.98s - 1765.10s |  which is a lot, I would say,
1765.10s - 1767.54s |  for a technique that is out of scope.
1769.10s - 1771.18s |  Something that is actually quite interesting
1771.22s - 1775.02s |  is that I think that this could be a main vulnerability
1775.02s - 1776.22s |  for a lot of bug hunters,
1776.22s - 1778.14s |  but I would say it's better to use it
1778.14s - 1781.10s |  like as a side golden goose.
1781.10s - 1784.70s |  So, for instance, if you like to find a lot of vulnerabilities
1784.70s - 1787.38s |  and then at one point you have no ideas anymore,
1787.38s - 1789.58s |  just look for a DOS, you'll find one,
1789.58s - 1791.98s |  send it, make a quick bug out of it.
1791.98s - 1794.14s |  I think it's a good way to do it.
1795.18s - 1798.14s |  Before finishing this presentation,
1798.14s - 1801.30s |  I needed to do a huge shout out to Idnama.
1801.30s - 1803.58s |  She's our graphical designer.
1803.58s - 1804.82s |  When I asked her,
1804.82s - 1807.62s |  hey, can you do this entire presentation for DEF CON?
1807.62s - 1810.54s |  She was like, what do you want me to do again?
1810.54s - 1813.46s |  2,000 memes, a lot of reference, a lot of things.
1813.46s - 1815.22s |  I think she did an amazing job.
1815.22s - 1817.42s |  So, huge shout out to her.
1818.50s - 1821.38s |  Thanks a lot, everyone, for attending this presentation.
1821.38s - 1822.86s |  I hope you liked it.
1822.86s - 1825.70s |  And if you have any question later,
1825.70s - 1827.66s |  I will be happy to answer them.