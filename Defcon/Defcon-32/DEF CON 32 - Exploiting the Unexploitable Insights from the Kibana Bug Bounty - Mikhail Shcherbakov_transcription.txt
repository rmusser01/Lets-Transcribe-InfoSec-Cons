{
  "webpage_url": "https://www.youtube.com/watch?v=H-bhmSwnRdY",
  "title": "DEF CON 32 - Exploiting the Unexploitable Insights from the Kibana Bug Bounty -  Mikhail Shcherbakov",
  "description": "We explore case studies of exploiting vulnerabilities in modern JavaScript and TypeScript applications, drawing on experiences from participating in the Kibana Bug Bounty Program. It's not uncommon to encounter a vulnerability that appears unexploitable at first glance, or to be told by a triage team that the behavior is \"by design.\" So, what options does a security researcher have in such situations? And what primitives can be utilized to construct an exploitation chain with significant impact?\n\nOur study involves breaking out of properly isolated containers in scenarios where there is RCE-by-design. We will examine several Prototype Pollutions that crash an application in less than one second after exploitation and explore how these vulnerabilities can ultimately lead to critical RCEs. Furthermore, we introduce new primitives and gadgets that enable the achievement of RCE from Prototype Pollutions previously deemed unexploitable beyond DoS attacks.\n\nBy highlighting these methods, the talk aims to equip attendees with advanced techniques for exploiting complex vulnerability chains in JavaScript applications, as well as recommendations for proper defense and mitigations against them.",
  "channel_url": "https://www.youtube.com/channel/UC6Om9kAkl32dWlDSNlDS9Iw",
  "duration": 2750,
  "channel": "DEFCONConference",
  "uploader": "DEFCONConference",
  "upload_date": "20241016"
}

0.00s - 7.00s | This text was transcribed using whisper model: large-v2

 My name is Mikhail Shcherbakov, and today I want to tell you a few stories about Kibana bug bounty.
8.00s - 14.00s |  This first part of the talk is about vulnerabilities that I found in Kibana,
14.00s - 23.00s |  and I combined only remote code execution vulnerabilities in this talk, just because of time limits.
23.00s - 27.00s |  A few words about me.
27.00s - 33.00s |  Now I am finishing my PhD studies at KTH University Stockholm,
33.00s - 41.00s |  and working on the thesis Code Reuse Attacks in Managed Programming Languages and Runtimes.
41.00s - 52.00s |  My main research interests are static code analysis, dynamic program analysis, and language-based security in general.
52.00s - 62.00s |  I participated in bug bounty programs of Microsoft, GitHub, some open source projects, and Elastic.
62.00s - 71.00s |  Today we will talk about Elastic bug bounty program, namely Kibana bug bounty program.
71.00s - 73.00s |  Who is Kibana?
73.00s - 84.00s |  Kibana is a part of popular ILCA stack that includes Elasticsearch, Logstash, and Kibana.
84.00s - 92.00s |  It is used for data visualization and real-time analysis.
93.00s - 104.00s |  Kibana is an open source project, all code is available, and it is possible to analyze statically or just make a manual review.
104.00s - 112.00s |  It is definitely a large project, probably one of the largest, it is written in TypeScript,
112.00s - 124.00s |  and they have an interesting bug bounty program with 3,000-7,000 rewards for critical vulnerabilities.
124.00s - 136.00s |  All of that makes Kibana a great target for bug hunters, and I contributed a lot last year in this program.
137.00s - 146.00s |  Before starting to tell about vulnerabilities in Kibana, I would like to say my thanks to Elastic Security team.
146.00s - 156.00s |  In my practice, in my experience, it is one of the best bug bounty programs that is managed by Elastic Security team.
156.00s - 169.00s |  Thank you guys for your work, and the main reason that I contribute a lot in this bug bounty is just a good experience of this work.
169.00s - 175.00s |  So, story number one, how it all began.
176.00s - 190.00s |  One year ago, in the last August, after DEFCON, I found that Elastic Bug Bounty started compiling for a new feature
190.00s - 200.00s |  that's called synthetic monitoring in the Kibana product that can be used for some dashboard.
200.00s - 210.00s |  The idea of the feature that you can set up some monitors for websites and see how the website is available
210.00s - 217.00s |  or some content was changed and make some reports based on such monitoring.
217.00s - 224.00s |  Okay, let's see how this feature looks like in practice.
224.00s - 231.00s |  In this main page of the Kibana, you can find synthetics, the feature that we discussed.
231.00s - 236.00s |  You can create new monitor to monitor some website.
236.00s - 244.00s |  You need to set the name of the monitor, location, when your agent will be run to make a request to the site.
244.00s - 249.00s |  And look, you can define some script.
249.00s - 253.00s |  So, it looks interesting.
253.00s - 258.00s |  We have some script editor and we can pass all the script here.
258.00s - 263.00s |  Let's check the documentation, how such scripts look like.
263.00s - 273.00s |  It's one of the examples, a simple script that's just open the example.org and check some element,
273.00s - 280.00s |  the text and the element and check that it equals to example domain.
280.00s - 285.00s |  Okay, but it looks like a JavaScript, right?
285.00s - 294.00s |  So, if you just replace the body of this method and write, for example, to run a reverse shell,
294.00s - 297.00s |  probably we can execute it.
297.00s - 302.00s |  But exactly this code doesn't work because of requiring.
302.00s - 309.00s |  If you did some JavaScript CTF, you probably already know about this problem.
309.00s - 315.00s |  You don't have a require in the scope, but you can bypass it for Node.js, for example.
315.00s - 331.00s |  You can use load, underscore load method in the process main module to load any module, including child process.
331.00s - 334.00s |  And you can run a reverse shell.
334.00s - 336.00s |  Let's see on the demo.
336.00s - 345.00s |  We paste this code, click on the run and see you have already connection from the reverse shell, from the agent.
345.00s - 353.00s |  We see the file system and the user on this agent, on the harebit engine.
353.00s - 359.00s |  You can see the harebit name of the user that we get.
360.00s - 363.00s |  That monitor any websites.
363.00s - 366.00s |  Okay, this is a remote code execution.
366.00s - 371.00s |  I think it's the simplest remote code execution that I reported.
371.00s - 375.00s |  And in the last August, I made a report.
375.00s - 384.00s |  The program, the company already finishing and it was the last days.
384.00s - 388.00s |  And also the rules for the post-exploitation was not clear.
388.00s - 392.00s |  And I decided, okay, I found it, I will report it and let's see.
392.00s - 397.00s |  We discount this report with Elastic security team in September.
397.00s - 401.00s |  And in October, they came back with the feedback.
401.00s - 407.00s |  Synthetics by design is arbitrary code execution as a service,
407.00s - 413.00s |  in which Elastic deploys a number of security features to prevent exploitation.
413.00s - 421.00s |  For successful exploit, someone would have to do something beyond getting a shell.
421.00s - 425.00s |  Okay, so it makes sense.
425.00s - 433.00s |  If you make such feature, probably you already isolated this code on the container.
433.00s - 437.00s |  And what they actually did.
438.00s - 446.00s |  Okay, we discussed it and I decided to continue exploitation of this container
446.00s - 450.00s |  and see what I can get in the end.
450.00s - 452.00s |  Where we are?
452.00s - 455.00s |  This is an isolated container.
455.00s - 462.00s |  After some investigation, I see that it's run in the Kubernetes cluster on Google Cloud Platform.
462.00s - 471.00s |  Probably it was managed Kubernetes cluster, but the details are not important here.
471.00s - 477.00s |  The first idea was to try to affect another client on the same container.
477.00s - 482.00s |  But the container was running per task.
482.00s - 486.00s |  So we don't have any persistent state.
486.00s - 493.00s |  After execution of the code that we injected, the container just restarted.
493.00s - 496.00s |  And no any client there.
496.00s - 499.00s |  Okay, try to escape the container.
499.00s - 504.00s |  It was secure configuration of up-to-date Kubernetes version.
504.00s - 507.00s |  So it looks like not possible.
507.00s - 511.00s |  Access to Google Cloud Platform metadata API?
511.00s - 512.00s |  No again.
512.00s - 517.00s |  So I think it's one of the first thing that they checked.
517.00s - 521.00s |  It looks like unexploitable case.
521.00s - 530.00s |  So we found remote code execution, but we cannot bypass the container isolation.
530.00s - 543.64s |  I continue investigated some things around and found the same Docker container for private Kubernetes cluster.
543.64s - 547.64s |  That means we can run it in the own Kubernetes cluster.
547.64s - 555.64s |  It makes threat model a little bit weak because we don't have exactly the same settings.
555.64s - 567.64s |  We can say if we can escape from container or affect some another services or features in the default configuration on the Kubernetes.
567.64s - 573.64s |  It looks like possible exploitation flaw.
573.64s - 582.64s |  And I also found that this container already have natural capabilities.
582.64s - 588.64s |  It means that we can send any raw package to the network.
588.64s - 590.64s |  Any package.
590.64s - 593.64s |  It means we can emulate any protocol.
593.64s - 598.64s |  For example, we can say send ARP packages.
598.64s - 605.64s |  I think you already understand my idea and get what I want to do.
605.64s - 614.64s |  Yeah, let's try to do ARP spoofing attack in 2024.
615.64s - 625.64s |  So our protocol allows to send some request to match IP address to the MAC address of any computer.
625.64s - 634.64s |  And for example, in the network, when Bob tried to connect to Mary and communicate by IP transport,
634.64s - 646.64s |  we can say to Bob that Mary is an attacker computer and say to Mary that Bob is an attacker computer and intercept the traffic between these two machines.
646.64s - 653.64s |  It's a simple, old, very old, old school attack.
653.64s - 657.64s |  But what about Kubernetes?
658.64s - 665.64s |  I already wanted to start to run Wireshark and investigate the traffic, what actually happens.
665.64s - 672.64s |  And found a nice blog post from Nir Chacko.
672.64s - 677.64s |  Attacking Kubernetes clusters throws your network plumbing.
677.64s - 694.64s |  So, he described the same idea of ARP spoofing to replace DNS server that available in the Kubernetes to the own DNS server.
694.64s - 710.64s |  And in this case, you can hijack any DNS request and send the request to the own web server instead of any available web server.
710.64s - 716.64s |  And the crucial component of this attack, this is this bridge.
716.64s - 720.64s |  Let's call it BR0 on this figure.
720.64s - 740.64s |  So, this bridge supports ARP protocol and has own ARP table that has any IP addresses and MAC addresses of the ports that run on the same node.
740.64s - 743.64s |  So, it looks like very restricted attack.
743.64s - 747.64s |  We can affect only ports on the same node.
747.64s - 758.64s |  But default network interface in Kubernetes allows us to exploit ARP spoofing.
758.64s - 760.64s |  Let's see on the demo.
760.64s - 768.64s |  So, the one of the idea to start this attack was to use some cloud environment.
768.64s - 774.64s |  I check Microsoft Azure and they allow us to use default Kubernetes.
774.64s - 776.64s |  So, you can see the console.
776.64s - 785.64s |  I already started attacker at victim ports and you can see that it's run on the same node in Kubernetes cluster.
785.64s - 792.64s |  It allows us to perform attack from the attacker to affect the victim.
792.64s - 800.64s |  First of all, we install proof of concept script and some additional dependencies on the attacker.
800.64s - 803.64s |  At the same time, we open the victim machine.
803.64s - 808.64s |  We will install KURL there to emulate some web requests.
808.64s - 811.64s |  Yeah, it's the console of the victim machine.
811.64s - 822.24s |  And after installation of the KURL, the idea that we try to get the data from the google.com.
822.24s - 831.24s |  After that, we start the attack and try to use own web server instead of the google.com.
831.24s - 837.24s |  So, now you see the usual, the valid response from the google.com.
837.24s - 839.24s |  And this is the attacker port.
839.24s - 849.24s |  We run DNS spoofing proof of concept that I found in that blog post.
849.24s - 854.24s |  I also improved it to use it on Azure.
854.24s - 857.24s |  By default, it did not support it.
857.24s - 860.24s |  And we start the attack here.
860.24s - 864.24s |  And now we do the same request.
864.24s - 871.24s |  And you can see that our web server responds instead of the google.com.
871.24s - 878.24s |  So, it's a classic DNS spoofing that we demonstrated in this demo.
878.24s - 883.24s |  And I updated the report to demonstrate this attack.
883.24s - 886.24s |  Elastic changed the report.
887.24s - 899.24s |  And a few days, one week ago, they rewarded with almost 4000 bounties for this attack.
899.24s - 905.24s |  Not bad for unexploitable case and very exotic attack.
906.24s - 916.24s |  And it was very interesting experience to try to use ARP spoofing in the real bug bounty case.
916.24s - 924.24s |  So, I missed a lot of the details of network configuration of the Kubernetes.
924.24s - 928.24s |  If you're interested in that, read the blog post.
928.24s - 930.24s |  I'm sure you'll enjoy it.
930.24s - 937.24s |  It's one of the best blog posts about Kubernetes networking that I was read.
937.24s - 941.24s |  The links, all links will be in the end of the presentation.
941.24s - 945.24s |  Let's see on another attacks.
945.24s - 956.24s |  The main topic in my PhD studies for last two years was server-side prototype pollution vulnerabilities.
956.24s - 958.24s |  We published three papers about that.
958.24s - 964.24s |  When we found, we implemented some tool chain to find prototype pollution vulnerabilities.
964.24s - 975.24s |  We found prototype pollution gadgets that allows us to exploit prototype pollution and achieve remote code execution attack.
975.24s - 982.24s |  In Node.js itself, in Deno, in NPM packages.
982.24s - 985.24s |  If you're interested in this, read the papers.
985.24s - 994.24s |  And I also give us some short introduction of our research and prototype pollution attack the last year on DEF CON.
994.24s - 1002.24s |  And many technical details of the gadgets that we found in Node.js itself in another talk on the Black Hat Asia.
1002.24s - 1013.24s |  And today I will tell you short introduction what the prototype pollution is, just to be on the same page.
1013.24s - 1020.35s |  So let's assume that we have a Node.js application.
1020.35s - 1024.35s |  We run some web server, you see index.js.
1024.35s - 1030.35s |  It's very simple web server that can handle two requests, update and backup.
1030.35s - 1033.35s |  For update request, we provide some arguments.
1033.35s - 1038.35s |  For backup request, we just trigger the backup of database.
1038.35s - 1040.35s |  Okay, it's all set up.
1040.35s - 1044.60s |  So we have attacker in this threat model.
1044.60s - 1048.60s |  It's any user that can send any request to the web server.
1048.60s - 1058.60s |  And if the attacker send such request with these parameters, and we have a handler for update request.
1058.60s - 1064.60s |  The handler in the first line create empty object.
1065.60s - 1075.60s |  And run time in the same time, create empty object with the built-in property proto that points to the object prototype.
1075.60s - 1081.60s |  That contains a lot of function like toString, valueOf that we can reuse.
1081.60s - 1090.60s |  So it's like inheritance implementation for JavaScript and TypeScript.
1091.60s - 1103.60s |  In the second line, you can see that we read the property from the object that specified in the argument org.
1103.60s - 1105.60s |  This is the proto.
1105.60s - 1109.60s |  It means we get a reference to this object.
1109.60s - 1123.60s |  In the last line of the code, we assign a value from details to another property of the prototype, the property shell.
1123.60s - 1132.60s |  So we read the proto, we assign value calc in the shell, and we get it in the prototype.
1132.60s - 1136.60s |  This code pattern is called prototype pollution.
1136.60s - 1143.60s |  Because we pollute, we add some property or replace some property in the object prototypes itself.
1143.60s - 1147.60s |  Let's assume that we have such code for backup handler.
1147.60s - 1154.60s |  This function try to run the backup script, this one.
1154.60s - 1163.60s |  And use the shell from the options and default shell if the shell is undefined.
1164.60s - 1169.60s |  In our case, shell is undefined and it will be used default shell.
1169.60s - 1172.60s |  Okay, it's very common pattern in the JavaScript.
1172.60s - 1179.60s |  But what actually happens if we trigger this handler after prototype pollution?
1179.60s - 1185.60s |  We create options that points to the same object prototype.
1185.60s - 1197.60s |  We read the shell and the runtime lookups for the shell property in the prototype chain and reads the polluted shell property.
1197.60s - 1210.60s |  And the exec command run a calculator because we get a calc in the shell, in the cmd variable at the end.
1210.60s - 1221.60s |  Okay, this is prototype pollution and remote code execution that we can achieve by prototype pollution in the end.
1221.60s - 1227.60s |  And this code pattern is called a gadget, prototype pollution gadget.
1227.60s - 1237.60s |  Let's start the story too about prototype pollution and remote code execution based on that.
1238.60s - 1241.60s |  So, I tried to use SilentSpring.
1241.60s - 1254.60s |  It's our first research on the prototype pollution, the toolchain that we implemented based on the CodeQL to detect prototype pollution vulnerabilities in Kibana.
1254.60s - 1264.60s |  So the first attempt CodeQL terminated by timeout because of too large database that I tried to analyze.
1265.60s - 1274.60s |  I implemented a script that rerun CodeQL for subfolders if the analysis is timed out.
1274.60s - 1281.60s |  And this script reported 77 cases in the application itself.
1281.60s - 1285.60s |  I will add the script in the same repository if you're interested.
1285.60s - 1286.60s |  You can find it there.
1286.60s - 1288.60s |  Try to play with that.
1289.60s - 1298.60s |  So, we get 44 server-side cases including some false positive testing code.
1298.60s - 1307.60s |  And today I will show you a couple cases from these that was exploited.
1309.60s - 1317.60s |  So, the first case, this is prototype pollution pattern that was detected in the config parser.
1317.60s - 1327.60s |  The config parser take some YAML document, main config of the Kibana when you restart Kibana.
1327.60s - 1342.60s |  And after the parsing it also tried to expand dot-separated names in this YAML config to such nested object.
1343.60s - 1350.60s |  So, a.b becomes a object that contains nested object with property b.
1350.60s - 1354.60s |  So, very simple idea.
1354.60s - 1359.60s |  But the code that does it is vulnerable to prototype pollution.
1359.60s - 1364.60s |  First of all, it take a key like ab in our case, split it by the dot.
1364.60s - 1371.60s |  So, we get array a and b and call walk function.
1371.60s - 1386.60s |  In the walk function we get the first key a and read the value of the a and call walk recursively.
1386.60s - 1388.60s |  So, okay.
1388.60s - 1399.60s |  And for the next case, if we have a last case, vary the b, case becomes empty array now.
1399.60s - 1404.60s |  And we assign the value to the b.
1404.60s - 1410.60s |  So, it's absolutely the same pattern that I've shown you before in the prototype pollution.
1410.60s - 1417.60s |  And such payload leads to prototype pollution vulnerabilities in this case.
1417.60s - 1426.60s |  So, we can add any property and we control the value of the polluted property.
1426.60s - 1428.60s |  Good.
1428.60s - 1441.60s |  I found it and also Elastic Cloud Enterprise, it's an on-premise version of the ILCA stack,
1441.60s - 1444.60s |  provides web UI to edit Kibana YAML.
1444.60s - 1448.60s |  It means we can edit it with admin privileges.
1448.60s - 1457.60s |  So, we need some high-level privileges, but we can do this attack through the web.
1457.60s - 1468.68s |  Attacker can store any payload in Kibana and restart Kibana to load all configs.
1468.68s - 1475.68s |  The problem here that Kibana crashes immediately after prototype pollution, of course,
1475.68s - 1482.68s |  because other code does not expect some properties, some additional properties in the object prototypes.
1482.68s - 1494.68s |  It happens before we get started web server.
1494.68s - 1503.98s |  We cannot send any other request to trigger any gadget.
1503.98s - 1512.98s |  It means we can only control the prototype pollution point.
1512.98s - 1519.98s |  And it's some difficulty with that because nothing dangerous happened between restarting Kibana
1519.98s - 1525.98s |  and prototype pollution triggering and the crash of the application.
1525.98s - 1535.98s |  It just tried to load some modules, tried to load configs, prepare some caches.
1535.98s - 1542.98s |  Nothing dangerous like starting new process or evaluate some function.
1542.98s - 1546.98s |  And the attack looks like unexploitable.
1546.98s - 1553.98s |  So, you can achieve denial of the service, but if you are administrator and you restart Kibana,
1553.98s - 1555.98s |  it's nothing actually.
1555.98s - 1558.98s |  What we can do in this case?
1558.98s - 1563.98s |  Let's see what Kibana did before the crash.
1563.98s - 1566.98s |  It tried to load some modules.
1566.98s - 1575.98s |  It would be nice if we have a gadget in the require call that loads modules.
1575.98s - 1581.98s |  Because the require, it will read the code that it loads from the module.
1581.98s - 1589.98s |  And if we can replace the module to the own code, we can get remote code execution before the crash.
1589.98s - 1591.98s |  That's a nice idea.
1591.98s - 1602.98s |  And we already found the gadget in the require when we worked on the first paper, Silent Spring, that I mentioned today.
1603.98s - 1611.98s |  Actually, we can run any malicious JS file through the prototype pollution.
1611.98s - 1616.98s |  Let's see on the require gadget how it works.
1616.98s - 1622.98s |  So, let's assume that we have the same prototype pollution from the first example.
1622.98s - 1629.98s |  And we can trigger and pollute some property main in the object prototype.
1630.98s - 1638.98s |  We can pollute one more property environment and trigger or handle backup.
1638.98s - 1643.98s |  Handle backup has only one line, a require to the some module.
1643.98s - 1651.98s |  And when require tries to load the module bytes, it has such code.
1652.98s - 1654.98s |  It do a load config.
1654.98s - 1671.42s |  And for load config, this function returns the parsed JSON, like this one, with all properties from the config.
1671.42s - 1679.42s |  But some package JSON, the configuration file, does not have main.
1679.42s - 1684.42s |  In this case, the default behavior should be get index JS.
1684.42s - 1690.42s |  But we have main read expression here.
1690.42s - 1697.42s |  And it tries to read the main that we polluted before from the object prototype.
1697.42s - 1705.42s |  It means we can read any JS file that exists in the system.
1706.42s - 1712.42s |  And it's some limitation for the require gadget, but we combine it with another attack.
1712.42s - 1723.42s |  If we can find some JS file that, for example, start new process, do child process exec, we can combine it with another function.
1723.42s - 1731.42s |  And npm JS, actually, when we load it, starts new process.
1731.42s - 1735.42s |  It does such code.
1735.42s - 1737.42s |  It executes spawn function.
1737.42s - 1744.42s |  These two arguments, not executable process and some arguments.
1744.42s - 1752.42s |  And the implementation on the spawn function, we have another gadget.
1752.42s - 1759.42s |  Let's try to read property shell and nth from the options.
1759.42s - 1765.42s |  And options was empty, undefined.
1765.42s - 1768.42s |  It means it becomes an empty object.
1768.42s - 1774.42s |  And when we read nth here, we read it from the empty object.
1774.42s - 1779.42s |  And we actually read the value from the prototype.
1780.42s - 1781.42s |  Okay.
1781.42s - 1783.42s |  That's the idea of the require gadget.
1783.42s - 1789.42s |  The problem is that this gadget has been fixed by Node.js team.
1789.42s - 1793.42s |  And I already knew this when I found it.
1793.42s - 1798.42s |  And in parallel, I worked on some other tool, some dynamic analysis.
1798.42s - 1799.42s |  It's called gHunters.
1799.42s - 1803.42s |  I described it in the last paper that we published.
1803.42s - 1808.42s |  And that will be presented in using security in a few days, next week.
1809.42s - 1819.42s |  And working on that tool, I investigated require gadget and the fix.
1819.42s - 1822.42s |  And the require gadget looks like this.
1822.42s - 1825.42s |  So, the code that we already saw.
1825.42s - 1827.42s |  We have a load config.
1827.42s - 1832.42s |  So, we have such code that read package JSON.
1832.42s - 1835.42s |  Try to parse it by JSON parse.
1835.42s - 1841.42s |  And JSON parse is an object that has an object prototype in the chain.
1841.42s - 1845.42s |  And it tried to read the main property.
1845.42s - 1854.42s |  And at that moment, it can read the polluted property if we already polluted main in the object prototype.
1854.42s - 1856.42s |  So, this gadget.
1856.42s - 1858.42s |  And Node.js team fixed it.
1858.42s - 1861.42s |  So, the fix looks like this.
1861.42s - 1870.42s |  They wrote some filter on properties that actually read this list of properties exactly from the object itself.
1870.42s - 1873.42s |  Does not check it in the prototype chain.
1873.42s - 1880.42s |  So, it means we cannot affect reading on the main property anymore after that fix.
1880.42s - 1889.42s |  But at some moment, gHunters start detect the require gadget again.
1889.42s - 1892.42s |  In the new version of the Node.js.
1892.42s - 1896.42s |  And I double checked all experiments.
1896.42s - 1900.42s |  And I see that require detected again and again for some cases.
1900.42s - 1905.42s |  And I start to see on this fix more closely.
1905.42s - 1909.42s |  And it has another gadget.
1909.42s - 1911.42s |  I will zoom in.
1911.42s - 1913.42s |  You can see.
1913.42s - 1916.42s |  Exactly in these slides.
1917.42s - 1920.42s |  We have this if statement.
1920.42s - 1924.42s |  If JSON is undefined, the function returns false.
1924.42s - 1929.42s |  The function loadConfig returns false.
1929.42s - 1932.42s |  ParseJSON becomes a false.
1932.42s - 1935.42s |  And we try to read the main from the false.
1935.42s - 1940.42s |  JSRuntime in this case tried to box primitive type, boolean type.
1940.42s - 1944.42s |  And add object prototype in the prototype chain.
1944.42s - 1947.42s |  And we again can read the main.
1947.42s - 1951.42s |  But from the false, actually.
1951.42s - 1954.42s |  So, it's new gadget.
1954.42s - 1957.42s |  And when I figure out it.
1957.42s - 1969.42s |  So, I add the payload for the require in the original Kibana YAML file.
1969.42s - 1973.42s |  And it allows us to exploit this prototype pollution.
1973.42s - 1978.42s |  And achieve remote code execution.
1978.42s - 1983.42s |  So, this vulnerability did not get a high score.
1983.42s - 1986.42s |  Because it required high privileged user.
1986.42s - 1990.42s |  But still it's almost 4,000 bounces.
1990.42s - 1994.74s |  Let's see on the next story.
1994.74s - 1998.74s |  About prototype pollution and remote code execution.
1998.74s - 2003.74s |  Another case that was reported by our script.
2003.74s - 2007.74s |  SilentSpring Node.js queries.
2007.74s - 2012.74s |  Was a prototype pollution in some handler.
2012.74s - 2014.74s |  Web handler.
2014.74s - 2016.74s |  So, it's very simple prototype pollution.
2016.74s - 2019.74s |  You can see we create empty object.
2019.74s - 2024.74s |  It means this object has the prototype points to the object prototype.
2024.74s - 2028.74s |  And we have this line of the code.
2028.74s - 2033.74s |  If namespace is __prot__.
2033.74s - 2037.74s |  And the key is the key controlled by the attacker.
2037.74s - 2039.74s |  That's all.
2039.74s - 2042.74s |  And the value also can be controlled by the attacker.
2042.74s - 2046.74s |  It means we can add any key with controlled value to the object prototype.
2046.74s - 2048.74s |  Very simple.
2048.74s - 2051.74s |  You don't even need a script to find it.
2052.74s - 2056.43s |  Okay.
2056.43s - 2060.43s |  So, when I started working on this script.
2060.43s - 2062.43s |  The question, we need to find a gadget.
2062.43s - 2064.43s |  We worked on the Dusty.
2064.43s - 2068.43s |  It's another project that detected 49 gadgets.
2068.43s - 2073.43s |  Leading to remote code execution in NPM packages.
2073.43s - 2078.43s |  We took 1,000 popular NPM packages.
2078.43s - 2083.43s |  And run dynamic analysis that try to instrument the package.
2083.43s - 2087.43s |  And investigate what the flows can lead to.
2087.43s - 2091.43s |  Read the properties from the prototype.
2091.43s - 2094.43s |  And can lead to remote code execution in NPM.
2094.43s - 2102.43s |  And one of the package that has gadget was NodeMailer.
2102.43s - 2107.43s |  And Kibana uses this gadget to send emails.
2107.43s - 2114.43s |  So, the idea, we have some send mailer transport that's optional.
2114.43s - 2118.43s |  But you also can pollute some option to enable it.
2118.43s - 2127.43s |  And it has some options that's by default empty.
2128.43s - 2135.43s |  And if we have path in the options.
2135.43s - 2139.43s |  The path of the run program that should be send mailer.
2139.43s - 2143.43s |  And args will be read from the options object.
2143.43s - 2145.43s |  And prototype in our case.
2145.43s - 2147.43s |  And send to the spawn function.
2147.43s - 2149.43s |  Okay.
2149.43s - 2151.43s |  So, it means we can inject any command.
2151.43s - 2158.43s |  And execute, start any process on the victim machine.
2158.43s - 2165.86s |  But the problem that delete handler creates the application.
2165.86s - 2169.86s |  In less than one second after the prototype pollution.
2169.86s - 2172.86s |  So, it's also becomes immediately.
2172.86s - 2176.86s |  Because some code in the end of the handler, of the same handler.
2176.86s - 2179.86s |  Does not expect the property, some additional property.
2179.86s - 2182.86s |  And throw exception that's not handled correctly.
2182.86s - 2184.86s |  And we get denial of the service.
2184.86s - 2189.86s |  That's not much interesting for such vulnerability.
2189.86s - 2192.86s |  So, it looks like unexploitable.
2192.86s - 2194.86s |  Denial of the service.
2194.86s - 2199.86s |  I could not say that it's interesting impact that we want to show.
2199.86s - 2204.86s |  But if we try to emulate some race condition.
2204.86s - 2209.86s |  By sending a lot of gadget triggered request in parallel.
2209.86s - 2213.86s |  And one prototype pollution triggered request between them.
2213.86s - 2220.86s |  We can try to get the situation that gadget triggered request.
2220.86s - 2227.86s |  Will be in the small time exactly after the prototype pollution request.
2227.86s - 2231.86s |  Let me explain it based on the script.
2231.86s - 2233.86s |  On the exploit script.
2234.86s - 2240.86s |  So, we can implement such race condition exploit on the bash.
2240.86s - 2242.86s |  Or any other language.
2242.86s - 2244.86s |  So, the idea.
2244.86s - 2249.86s |  We send 20 requests that trigger a gadget first.
2249.86s - 2254.86s |  And after that we send the request that trigger a prototype pollution.
2254.86s - 2260.86s |  And after that we send 50 requests that trigger a gadget again.
2260.86s - 2270.86s |  And this ampersand means that all of these commands will be executed in parallel.
2270.86s - 2273.86s |  So, we send a lot request.
2273.86s - 2277.86s |  Let's see how it works in the demo.
2277.86s - 2281.86s |  So, I run it from my laptop.
2281.86s - 2284.86s |  Through the Wi-Fi.
2285.86s - 2294.86s |  And first of all I start some payload that created email connector.
2294.86s - 2302.86s |  That we need to know to send the request to trigger node mailer package.
2302.86s - 2311.86s |  So, we change in this or exploit SH script this connector.
2312.86s - 2315.86s |  And run the exploit script.
2315.86s - 2321.86s |  And I started this webpage to see which request we will get.
2321.86s - 2323.86s |  So, I did not run a reverse shell.
2323.86s - 2329.86s |  I just sent a request to this webpage.
2329.86s - 2335.86s |  You can see that five requests will be successfully received.
2335.86s - 2346.86s |  It means that five cases will be for so short time that were executed before the crash.
2346.86s - 2350.86s |  So, this attack was run from the Wi-Fi.
2350.86s - 2358.86s |  You can get more interesting, I guess, if you run it on the same server in the same network like in cloud or some places.
2359.86s - 2360.86s |  Okay.
2360.86s - 2367.86s |  This attack give me biggest bounty that I got from the Elastic.
2367.86s - 2371.86s |  And not only this prototype pollution that I reported was exploited.
2371.86s - 2374.86s |  This case was closed a few days ago.
2374.86s - 2377.86s |  I did not have time to edit in the presentation.
2377.86s - 2380.86s |  And also we don't have much time.
2380.86s - 2384.86s |  And another case that was reported also.
2384.86s - 2388.86s |  This is a chain that leads to account takeover.
2388.86s - 2392.86s |  Maybe I will do it in the next presentation.
2392.86s - 2393.86s |  Let's see.
2395.86s - 2405.86s |  As a bonus part, I want to explain some advanced technique for the prototype pollution.
2405.86s - 2409.86s |  When we pollute the objects in the prototype, not the prototype itself.
2412.86s - 2423.86s |  When I understood this trick, it allows me to report few new vulnerabilities that I actually thought unexploitable before.
2423.86s - 2425.86s |  Let's see on the example.
2425.86s - 2431.86s |  We have a prototype pollution from our original example.
2431.86s - 2433.86s |  Very simple code that we already know.
2433.86s - 2434.86s |  We have a gadget.
2434.86s - 2443.86s |  The gadget read options and check the property runner.
2443.86s - 2447.86s |  So the options empty object by default.
2447.86s - 2457.86s |  And if the runner is defined, we read paths and arcs and spawn a new process for that.
2457.86s - 2462.86s |  So it means we need to pollute a runner in the object prototype.
2462.86s - 2463.86s |  So like this.
2463.86s - 2471.86s |  So we add a runner with this object as a value.
2471.86s - 2472.86s |  Okay.
2472.86s - 2479.86s |  And after that we trigger handleback, of course, to trigger a gadget.
2479.86s - 2488.86s |  What if this prototype pollution does not allow us to control the value?
2488.86s - 2494.86s |  For example, it's some object with predefined identifier or another properties.
2494.86s - 2496.86s |  We cannot control it.
2496.86s - 2499.86s |  Or it's empty array.
2499.86s - 2502.86s |  Array does not have any properties.
2502.86s - 2503.86s |  Right?
2503.86s - 2507.86s |  So it looks like unexploitable.
2507.86s - 2509.86s |  At least for such gadget.
2509.86s - 2512.86s |  Maximum we can get denial of the service.
2512.86s - 2517.86s |  But what if we have such code?
2517.86s - 2518.86s |  It's fixed.
2518.86s - 2520.86s |  I call it fixed prototype pollution.
2520.86s - 2529.86s |  We check that org does not equal a proto and execute this code only for that.
2529.86s - 2532.86s |  It cannot lead to prototype pollution.
2532.86s - 2539.86s |  But we can combine these two code snippets.
2539.86s - 2546.86s |  So it's absolutely safe code separately from this one.
2546.86s - 2549.86s |  But what we can do together with these components?
2549.86s - 2552.86s |  First of all, we need to pollute the prototype.
2552.86s - 2560.86s |  We add a runner with a value of empty array in the prototype to trigger handle update.
2560.86s - 2562.86s |  Good.
2562.86s - 2574.42s |  After that, we trigger this save function with org that has a runner value.
2574.42s - 2580.42s |  It means we will try to read the runner from the prototype at this step.
2580.42s - 2583.42s |  And we pollute the runner after that.
2583.42s - 2589.42s |  We can't feel any additional properties in the runner.
2589.42s - 2591.42s |  By this call and the second call.
2591.42s - 2595.42s |  And after that, we trigger backup handler.
2595.42s - 2601.42s |  It gives us the remote code execution again by this chain of the calls.
2602.42s - 2606.42s |  The web request that triggers such functions.
2606.42s - 2611.42s |  If you think that it's unlikely that we find some fixed prototype pollution case
2611.42s - 2616.42s |  and unfixed prototype pollution case in the same application,
2616.42s - 2619.42s |  I can say to you that, for example,
2619.42s - 2628.42s |  merge functions are very typical in the fixed prototype pollutions.
2628.42s - 2638.42s |  A merge function of the very popular package lodash allows us to pollute a runner with such payload.
2638.42s - 2643.42s |  And you can find lodash merge calls in many applications.
2643.42s - 2647.42s |  And that's important that these two parts can be unrelated.
2647.42s - 2655.42s |  It could be absolutely different features in the application.
2656.42s - 2660.42s |  Use it for fun and bounces.
2660.42s - 2667.42s |  In conclusion, in this talk, I wanted to show the cases that look unexploitable.
2667.42s - 2670.42s |  And say, don't give up.
2670.42s - 2676.42s |  Try to achieve remote code execution even when it looks impossible.
2676.42s - 2681.42s |  If you're interested in prototype pollution research, check out our papers.
2681.42s - 2685.42s |  SilentSpring, G-Hunter and Dusty that I mentioned in the talk.
2685.42s - 2692.42s |  Check out the collection of server-side prototype pollution gadgets that we shared.
2692.42s - 2701.42s |  This is a gadget in Node.js itself and Deno and NPM packages that I also use in my bug bounty cases.
2701.42s - 2709.42s |  If you're interested in networking attacks and this story about ARP spoofing,
2709.42s - 2712.42s |  I highly recommend to read this blog post.
2712.42s - 2717.42s |  ARP spoofing in Kubernetes is not so easy as it looks like.
2717.42s - 2726.42s |  It also has some difficulties with IP table rules that was bypassed by this talk.
2726.42s - 2729.42s |  Check out this blog post.
2729.42s - 2731.42s |  I think you'll enjoy it.
2731.42s - 2737.42s |  And follow me on Twitter if you're interested in some details of code reuse attacks.
2737.42s - 2742.42s |  I want to share some findings that I am now including in my thesis.
2742.42s - 2746.42s |  And thank you for your attention.
2746.42s - 2748.42s |  Enjoy DEF CON.
2748.42s - 2749.42s |  Bye-bye.