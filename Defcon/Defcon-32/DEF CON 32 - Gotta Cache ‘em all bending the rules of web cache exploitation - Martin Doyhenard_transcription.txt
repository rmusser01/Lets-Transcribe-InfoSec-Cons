{
  "webpage_url": "https://www.youtube.com/watch?v=70yyOMFylUA",
  "title": "DEF CON 32 - Gotta Cache \u2018em all  bending the rules of web cache exploitation - Martin Doyhenard",
  "description": "In recent years, web cache attacks have become a popular way to steal sensitive data, deface websites, and deliver exploits. We've also seen parser inconsistencies causing critical vulnerabilities like HTTP Request Smuggling. This raises the question: what happens if we attack web caches' URL-parsers?\n\nIn this session, I'll introduce two powerful new techniques that exploit RFC ambiguities to bypass the limitations of web cache deception and poisoning attacks.\n\nFirst, I'll introduce Static Path Deception, a novel technique to completely compromise the confidentiality of an application. I\u2019ll illustrate this with a case study showing how such a breach can be replicated in environments like Nginx behind Cloudflare.\n\nNext, I'll present Cache Key Confusion, and show how to exploit URL parsing inconsistencies in major platforms, including Microsoft Azure Cloud. I\u2019ll then show how to achieve arbitrary cache poisoning and full denial of service.\n\nFinally, I'll reveal how to supercharge these vulnerabilities with a live demo that blends Cache Key Confusion with a \u201cnon-exploitable\u201d open redirect to execute arbitrary JS code for complete site takeover.\n\nAttendees will depart armed with a set of innovative techniques, along with a definitive methodology to find and exploit these and other URL or HTTP discrepancies.",
  "channel_url": "https://www.youtube.com/channel/UC6Om9kAkl32dWlDSNlDS9Iw",
  "duration": 2638,
  "channel": "DEFCONConference",
  "uploader": "DEFCONConference",
  "upload_date": "20241016"
}

0.00s - 5.00s | This text was transcribed using whisper model: large-v2

 Uh welcome to track 2 talk number 2 on Saturday. Uh this morning we uh have Martin and he's
7.40s - 11.88s |  gonna talk about breaking the rules of webcache exploitation. So are you ready Martin?
11.88s - 21.66s |  I'm ready. Let's hear it for Martin. Thank you. Hello everyone. Welcome to Gara Cache Mall
21.66s - 28.14s |  bending the rules of webcache exploitation. Uh it's already not working. So this is the
29.14s - 34.14s |  agenda for today. First I'm going to briefly explain how a webcache works and then I'm
36.78s - 42.68s |  going to show how we can abuse um discrepancies between the URL parsers of HTTP servers and
42.68s - 48.28s |  cache proxies in order to steal secret information from victims using arbitrary webcache
48.28s - 54.32s |  deception. Next I'm going to show how use the same techniques or similar techniques to
54.32s - 60.68s |  obtain arbitrary webcache poisoning by modifying the keys of a store resource. Then I'm
60.68s - 66.16s |  going to combine both techniques in order to store whatever I want in the webcache with any
66.16s - 71.86s |  key so this will allow us to create a full defacement of a website. And finally I'm going to
71.86s - 76.00s |  present some protections that can be used to defend against those attacks and it takes hours
76.00s - 83.14s |  of the session. So before I start eh I want to clarify that most of the or all the examples
83.16s - 88.54s |  are going to be based on CDNs like CloudFront, CloudFront, Akamai but the idea is that you
88.54s - 94.20s |  can use all of these techniques with any HTTP with any webcache eh proxy or with any webcache
94.20s - 100.98s |  that you want even those that are included in the HTTP server. So whenever someone sends a
100.98s - 105.26s |  request to a website using a webcache basically the first thing that is going to happen is
105.26s - 109.56s |  that the cache proxy is going to handle the request and is going to try to generate the
109.58s - 114.28s |  response without having to communicate with the original server. And this is going to be
114.28s - 120.06s |  done by calculating a key and then this key is basically an identifier of the request that
120.06s - 125.26s |  states which is the resource that is being requested and it's not really important other
125.26s - 129.64s |  other things like the the headers like cookies or user agent because when we have two
129.64s - 134.94s |  requests that are looking for the same resource and that resource is static then we just need
134.96s - 140.10s |  to provide the resource and we don't care about processing anything else. So we will see
140.10s - 145.10s |  that the keys are just URLs and host names and in this talk we will just focus on the URL. So
147.74s - 153.44s |  when the cache proxy calculated this key and is looking for a re- a response that can be
153.44s - 159.08s |  served eh to this to this request it will he will look at the cache table and if there's
159.08s - 163.96s |  nothing there it will send the request to the original server. Now the original server is
163.98s - 169.84s |  going to parse the URL obtaining the path and then it's going to use an endpoint to resolve
169.84s - 174.66s |  the request. Sometimes it's just a static endpoint like a file and sometimes it's a dynamic
174.66s - 181.66s |  one that is generated by a program back then. So when this response is sent back to the cache
181.66s - 187.44s |  proxy the well the cache proxy is going to generate to evaluate some rules to see if this
187.44s - 193.44s |  response should be stored in the cache. So if it's static or not. These rules are usually
193.46s - 199.76s |  evaluated on the response using the cache control header but also in the request the cache
199.76s - 204.50s |  proxy is going to extract the path and it's going to evaluate it with some of the other rules.
204.50s - 210.70s |  For example the static extension one which is by default in most CDNs that looks for static
210.70s - 216.24s |  extensions. So basically this is the list that Cloudflare has. Uh it will look for the path
216.24s - 221.88s |  and the extension of that path and if it ends with any of these eh extension any of these
221.92s - 226.06s |  strings then it's going to decide that this is a static respo- resource and it's going to
226.06s - 232.20s |  store it in the in the web cache. So in this example we see that styles.css ends with a
232.20s - 236.94s |  static extension and therefore it's going to be cached using the key that was calculated in
236.94s - 243.70s |  the first step. Now whenever another client or even the same client sends a request to the
243.70s - 248.24s |  same resource the cache proxy is going to handle that, it's going to get the key of that
248.24s - 253.84s |  request and then it's going to retrieve the res- the store resource because it doesn't need to
253.84s - 259.26s |  interact with the origin server. And that's basically how a web cache works. Now we can
259.26s - 264.66s |  exploit this in many ways. The first one is usually is the first one I'm going to describe
264.66s - 269.66s |  actually is the one that was discovered by Omer Gil in 2017 which is a web cache deception
271.86s - 277.54s |  and basically this attack is based on the idea that some backend servers use this special
277.54s - 282.38s |  mapping where they are going to put some parameters in the path, this is called path
282.38s - 286.42s |  parameters, and they are going to just look for the beginning of the path and they will try to
286.42s - 293.08s |  match it with uh with any regex that is eh relate- related with the handler. So in this case
293.08s - 298.52s |  if we send a request to slash my account slash param1, param2 then the only the first part
298.52s - 305.04s |  is going to be used to map the endpoint and then this in this case is going to the origin
305.04s - 308.40s |  server is going to generate a response which contains a lot of information from the victim
308.40s - 315.28s |  because it is my account and it contains for instance the mail or the credit card details so
315.28s - 322.17s |  basically this is what we want to steal. And to do so the first thing is to send uh a link to
322.17s - 327.71s |  the victim, this requires user interaction and the link will start with the endpoint that we
327.71s - 332.65s |  want to to steal the response so in this case it's my account and then it will use as a
332.67s - 338.95s |  parameter a dot js. And the reason this is because first when it's handled by the origin
338.95s - 344.19s |  server this is going to be mapped to my account using the cookies of the victim and so the
344.19s - 349.39s |  response with the sensitive information is going to be sent back to the to the proxy and now
349.39s - 354.99s |  with the cache proxy it evaluates the the path, this in this case it doesn't know anything
354.99s - 359.13s |  about this mapping so it will think that the last part is just a parameter it's not a
359.15s - 363.63s |  parameter sorry it's a path it's part of a path and therefore it will think that it has a static
363.63s - 368.89s |  extension in this case dot js and so it will store this response containing all the secret
368.89s - 373.87s |  information. Now the attacker can send the same request and as the cookies are not important
373.87s - 379.07s |  as the only important thing is just getting the same path well the cache proxy is going to
379.07s - 383.85s |  match it with the key that already calculated in the first place and it will retrieve the
383.85s - 388.35s |  victim's response containing all the secret information. Now the problem with this
388.37s - 393.21s |  technique is that we need a special mapping for that basically we need this special my
393.21s - 397.75s |  account thing and then we also require that the parameters that we are sending in this case
397.75s - 403.31s |  a dot js doesn't have any effect on the backend because if not maybe the the response is not
403.31s - 409.74s |  going to contain that information that we want. So I started looking at different ways to
409.74s - 414.24s |  obtain arbitrary web cache deception which is basically obtaining the same thing but for any
414.26s - 420.72s |  kind of uh end point that we want. And to do this I started looking at how the the path is
420.72s - 426.76s |  obtained at each state. So basically the path is obtained from a URL by using these
426.76s - 431.90s |  delimiters which are basically characters that can then can be used to know where each part of
431.90s - 438.10s |  the URL or each part of the elements of the URL start and begin uh and end. There are a lot of
438.10s - 443.72s |  them defined by the RFC so we can see that the URL has things like the scheme, the
443.72s - 449.26s |  credentials, the host, the path query and fragment. So to split the each of them in a URL we
449.26s - 455.20s |  need these these delimiters. The problem is that the RFC says that any any of these
455.20s - 460.34s |  delimiters may or may not be or any of these characters may or may not be used as delimiters.
460.34s - 464.88s |  And so each implementation can choose new delimiters and this could create some
464.88s - 471.82s |  discrepancies. So let's say we find a server that is using a cache proxy and that is using
471.82s - 478.00s |  the dollar sign as a delimiter. Then if we send a request to my account dollar sign 8 dot JS
478.00s - 483.20s |  this is just going to be interpreted as my account because of the delimiter. However as I
483.20s - 488.20s |  said in the front end there's no delimiter being being said with eh the dollar sign and
488.20s - 492.18s |  therefore this is going to be interpreted the entire URL is going to be interpreted as the
492.18s - 497.92s |  path and the last part which is 8 dot JS is going to be used as the extension. In this case
497.92s - 502.52s |  actually it's dot JS the extension and so this is going to be stored in the cache just
502.52s - 507.70s |  because of that delimiter. And in this case we can use it with any kind of path we want
507.70s - 512.66s |  because we are not attacking a mapping we are attacking the entire way of obtaining the path
512.66s - 518.94s |  from the URL. Now which kind of delimiters we can find in the well well there are a lot of
518.94s - 525.12s |  them. Some I listed were in the frameworks is eh the first one is semi the semicolon in
525.12s - 531.72s |  spring so basically to define a matrix variable that is similar to a path eh parameter we can
531.72s - 537.46s |  use a semicolon. And the thing is that if we send something like my account semicolon 8 dot
537.46s - 543.84s |  JS anyone using Java probably Java in the well so they are going to consider this as my
543.84s - 548.48s |  account. This includes Google or big companies that are using Java because this is how
548.50s - 555.52s |  Spring works. And so we can use this for the attack. Now in Rails there's another really
555.52s - 561.96s |  interesting case which is they use the dot as a delimiter and that's because ehm the user is
561.96s - 567.46s |  able to send an extension with a valid endpoint and this will eh the effect that this will
567.46s - 573.26s |  have is that Rails will look for a specific view for that eh request. So let's say we define
573.32s - 578.76s |  an endpoint which is my account and then when we send a request to my account Rails will just
578.76s - 585.26s |  go and look for the HTML view. Now if we send something like my account dot CSS, Rails will
585.26s - 591.24s |  not just return a not a not found but it will look for the view of the the CSS view of my
591.24s - 597.78s |  account. Usually there's no CSS view for my account so we'll just receive a 406 error. But
597.78s - 602.62s |  the thing is that if the extension that we include is not recognized by Rails so let's say we
602.64s - 607.88s |  send something like my account dot AAA then Rails is just going to send us the default view
607.88s - 614.32s |  which is HTML. Remember all these eh all these extensions that are defined by Cloudflare.
614.32s - 620.32s |  Well in green you can see the ones that are recognized by Rails. So if we send my account
620.32s - 626.94s |  dot PNG or dot GPA or CSS then all of them are going to be recognized by Rails and it's going
626.94s - 631.98s |  to try to look for that response. And if there's no view for that extension then it's just
632.00s - 636.68s |  going to return us an error. But in red we see all the other extensions that are not
636.68s - 642.44s |  recognized by Rails. So if we send something like my account dot ICO then we are going to
642.44s - 649.74s |  get the default view but Cloudflare is going to think that this is a catchable resource. Now
649.74s - 653.88s |  there are other delimiters that can be used in HTTP servers instead of frameworks such as
653.88s - 659.28s |  the encoded null byte which is the case of open light speed. So basically this works like a
659.30s - 664.10s |  question mark if we send something like my account null encoded byte A dot JS then this is
664.10s - 670.00s |  just going to be used as my account. The problem for this is that we cannot send it through
670.00s - 675.44s |  many CDNs like Azure, Imperva, Cloudfront, Cloudflare, Google Cloud. That's because they
675.44s - 680.62s |  don't accept null encoded bytes. But fortunately Akamai and FastCDC yes so we can use them
680.62s - 687.36s |  for eh this explanation. And finally in Nginx we have a delimiter whenever whenever we
687.40s - 693.54s |  find a rewrite rule and the delimiter is the new line encoded and so basically it works just
693.54s - 698.58s |  as in open light with a null encoded byte and in this case we can send it through any CDN we
698.58s - 705.12s |  want. So if we send a request using any of these delimiters with the correct with the
705.12s - 710.42s |  corresponding eh backend then all of them are going to be interpreted as my account. The
710.42s - 715.26s |  response is going to be sent back but in this case the web caches are going to just store that
715.26s - 722.72s |  because of the static extension. But the problem with this attack is that many CDNs are
722.72s - 727.08s |  are already aware of this and they are implementing some detection some protection for for
727.08s - 731.86s |  this kind of attacks. In the case of Cloudflare for instance is web cache deception armor
731.86s - 737.50s |  which what it does is it looks for the extension of the request and the content type of the
737.50s - 742.30s |  response. And if they don't match for for instance for instance in this example we are using
742.30s - 748.68s |  dot CSS as the extension and the content type is text HTML so if they don't match basically
748.68s - 755.22s |  this is an attack and Cloudflare won't store this in the cache. So we can attack other rules
755.22s - 761.46s |  like the static directories one. That's a rule that we can create as a user that states that
761.46s - 766.16s |  anything starting with a specific path is going to be stored in the cache and that's really
766.16s - 771.20s |  common in many applications because we we usually store static files in the same directory
771.24s - 776.88s |  like share, public, assets, resources, anything that you can think. Uh and so we can use
776.88s - 782.24s |  this to attack this kind of eh this kind of web caches that are used in the rules. To create
782.24s - 788.18s |  an attack in this case we will need some payload that is interpreted in the front end with
788.18s - 793.60s |  the static directory at the beginning so basically in if the static directory is called static
793.60s - 799.36s |  then we want the path to start with static slash and anything we want. And then in the back
799.36s - 804.70s |  end we still want my account because we in this case want to steal my account we could steal
804.70s - 810.90s |  anything else we want. So if we have a delimiter in the back end we can try to do this but we
810.90s - 817.18s |  will need something else. And as I said to extract the path from a URL we just need the
817.18s - 822.82s |  delimiter and then that path is used in the keys rules and mapping. Well not really. There's
822.82s - 828.86s |  one extra step which is normalization. We need to normalize the path and most CDNs and
828.86s - 834.14s |  back end servers do normalize the path. This includes decoding the the characters. We can
834.14s - 840.80s |  send them with URL encoded eh notation that is percentage eh and the excite small value of a
840.80s - 846.54s |  character. And then in some cases the eh other other characters like segment delimiters like
846.54s - 852.88s |  the slash or the dot are also going to be decoded so this is going to be really useful. And
852.88s - 858.98s |  then the normalization also includes dot segments eh resolution which is just resolving
858.98s - 863.22s |  path traversals and whenever we find a dot segment then we just remove the previous
863.22s - 868.22s |  segment. And some parsers like the IIS one eh will also convert back slashes to slashes. So
872.20s - 876.94s |  now that we know this we can actually create a new payload that is going to use normalization.
876.94s - 881.48s |  Again we are using a delimiter so everything before the delimiter is going to be interpreted
881.48s - 888.12s |  in the back end server. But now we are also sending an encoded eh path traversal. And that is
888.12s - 894.46s |  because the front end is not using the delimiter so it's going to resolve this into this. And
894.46s - 900.72s |  this includes a path traversal which is going to convert it to static WCD. So now in the front
900.72s - 905.24s |  end we see that there are static characters there so this is going to be stored in the web
905.24s - 910.44s |  cache. And in this way we are able to bypass the web cache deception armor because there's no
910.46s - 918.36s |  extension so nothing to compare. Now let's see how how we can how we can apply this in a
918.36s - 923.36s |  real environment. And so first we need a a front end that is normalizing the path. Sorry. Eh
926.76s - 932.46s |  this is the case for CloudFront, Imperva and Azure. And so if we combine them with any back
932.46s - 937.64s |  end that is using a specific delimiter like for instance Tomcat then we can send the same
938.26s - 944.70s |  payload which is secret the semicolon with that represented delimiter. And this will cause
944.70s - 949.84s |  that in the back end we see secret. And in the front end again the semicolon is not a
949.84s - 954.88s |  delimiter for either CloudFront I Azure or Imperva. And therefore this is going to be
954.88s - 962.12s |  resolved to static slash X. And this way we will be able to steal any response we want in an
962.14s - 967.42s |  environment that is using basic basic and default configured eh Tomcat and any of the CDNs
967.42s - 972.42s |  that I showed. This can be used also with other back ends like eh Rails and Puma or even some
975.06s - 980.22s |  in the same case that we observed in the in the first example when we had a special mapping
980.22s - 985.80s |  in the back end. In this case there is no delimiter the the delimiter is just the the path
985.82s - 993.73s |  that we are attacking. Now we could also try another attack that is using the opposite
993.73s - 997.51s |  normalization so basically in the front end we don't have normalization that's the case of
997.51s - 1003.15s |  CloudFront eh Google Cloud Platform and Fastly. And in the back end we have normalization
1003.15s - 1008.15s |  in Nginx, IIS and open light speed. So if we use this we can create the attack by starting
1011.15s - 1016.89s |  with the static directory. In this case it's slash static. And this is because the path is
1016.91s - 1022.31s |  not normalized and so CloudFront for instance will think that this is the entire URL is the
1022.31s - 1029.21s |  path. But in the back end this is going to be normalized and therefore anyone using Nginx or
1029.21s - 1034.99s |  IIS or open light speed is going to see that the response is going to be for secret and this
1034.99s - 1041.43s |  will be storing the cache because of the static path. This worked on OpenAI and many other
1041.43s - 1046.45s |  bounties that I wasn't able to be eh I'm not able to talk about. And also this can be used
1050.45s - 1056.95s |  with IIS basically IIS is the only one that is decoding uh normalizing the backslash so if we
1056.95s - 1063.09s |  send something like using the in the slide this is going to be converted to static eh and
1063.09s - 1067.73s |  basically a dot segment with a backslash and it's going to be converted to account in IIS but
1067.73s - 1073.67s |  not in any other eh CDN because IIS decided that this is a cool idea. And so yeah they are
1073.67s - 1080.52s |  the only ones that I can be attacking with any other CDN. Now if we don't find one of these
1080.52s - 1086.84s |  rules well there's there's another rule that we can use which is the static files. Eh in many
1086.84s - 1093.90s |  in many CDNs we will see that there's a static file rule by default to store robots dot txt but
1093.90s - 1100.10s |  we can also find others for favicon or for index dot html or for any the any file that is
1100.10s - 1105.74s |  usually accessed by people and is static. And in this case we can use the same attack only
1105.74s - 1110.72s |  that we are not going to target a static directory we are just going to target something that
1110.72s - 1117.72s |  is being stored by the front end. So we can do something like secret then the delimiter
1117.74s - 1123.26s |  then coded eh dot segment and finally robot dot txt and this should work in many in many
1123.26s - 1128.92s |  applications. And also we can try to find other files. I found that there are many in in in the
1128.92s - 1136.20s |  wild so you should be able to find many others if you look for. So web cache deception is
1136.20s - 1140.94s |  pretty cool but the thing is you need user interaction and we don't really want user
1140.94s - 1147.38s |  interaction. So web cache poisoning is there for rescue us and the idea in web cache
1147.44s - 1153.28s |  poisoning is that we are going to try to store a malicious response in in a with a key that is
1153.28s - 1158.78s |  going to be accessed by other people. So let's say we want to eh hijack someone that is
1158.78s - 1163.72s |  using eh this this website this website and is accessing to the home page. Well if we are
1163.72s - 1167.96s |  able to find a payload that is stored in the home page then everyone navigating through the
1167.96s - 1172.76s |  web page is going to be affected. And usually you will look for something that is not
1172.78s - 1178.52s |  stored like that is not used in the key so in this case if the cookie value is reflected in the
1178.52s - 1184.62s |  in the body of the response then we are able to store this and anyone using the home page is
1184.62s - 1190.54s |  going to be affected and is going to re is going to retrieve the malicious response. The
1190.54s - 1195.64s |  problem with this attack is that in many cases we will find eh an example of a cache
1195.64s - 1200.38s |  poisoning but is with a is using a key or is using a resource that is not going to be
1200.40s - 1204.90s |  accessed by anyone. Like for instance if we are able to poison something that starts with
1204.90s - 1211.04s |  files then our username and then our unique ID no one is going to be accessing that eh that
1211.04s - 1216.04s |  path by themself so we will need user interaction. And that's not really cool. So to avoid
1218.88s - 1224.16s |  having to interact with any victim I designed an attack that is going to be able it's going
1224.18s - 1229.18s |  to allow us to change the key of the eh poison resource. Now in this case we will need key
1231.44s - 1237.12s |  normalization and this is by default in impaired but Azure is just normalizing the key eh and
1237.12s - 1243.16s |  it's partially by default also in Akamai and it's configured in all the other CDNs and what's
1243.16s - 1247.60s |  really interesting about this is that if you remember CloudFront for instance was
1247.60s - 1251.86s |  normalizing the rules but is not normalizing the key. So that means that they have different
1251.86s - 1257.14s |  parsers for each of these processes which is even in the same eh in the same HTTP parser
1257.14s - 1263.42s |  probably. So this this tell us that we can even find other desynchronization attacks or
1263.42s - 1268.42s |  other discrepancies even in the same eh in the same web cache. So as I said what we need is
1271.76s - 1277.06s |  a a front end that is normalizing the key and what we can do to detect this is to send a
1277.10s - 1281.94s |  request to a static resource like style.css and whenever we see evidence that this is of
1281.94s - 1288.30s |  being obtained from the web cache so for instance we have an X cache hit value eh hitter or we
1288.30s - 1293.98s |  can just compare the time of the response and whenever we find this then we need to modify the
1293.98s - 1300.48s |  path so that when normalized we still have style.css and if we send this request and the
1300.48s - 1304.66s |  response is still from the cache then it means that the key was normalized and so we
1304.66s - 1311.70s |  detected key normalization. And how we can exploit eh web cache poisoning with this? Well
1311.70s - 1316.88s |  basically we will try to modify as I said the key by sending first the exploit that we want
1316.88s - 1322.78s |  so this is the the the response that we will we will use to poison eh usually contains a
1322.78s - 1328.48s |  malicious payload then a delimiter so again we will need a delimiter in the back end but as I
1328.48s - 1334.22s |  said this is really common and we can find them almost anywhere and then we will need
1334.26s - 1339.86s |  some normalization in the front end so Imperva, Azure uh and sometimes Akamai and all the
1339.86s - 1345.10s |  others that are configured eh and this is going to be resolved with Poison so basically the
1345.10s - 1349.80s |  web cache is going to store the exploit response in the Poison endpoint which is something
1349.80s - 1360.13s |  we control so it's arbitrary we can just wire up a path we want usually the home page. So in
1360.13s - 1364.41s |  the in the first example I didn't talk w- about one of the delimiters because we weren't
1364.41s - 1369.55s |  able to send it with web cache deception and that's because the user needs to send it
1369.55s - 1374.95s |  through his browser and anything but uh and if the browser sees a hash then it's not going to
1374.95s - 1381.63s |  send the fragment but in web cache poisoning we can use the fragment. So I I started
1381.63s - 1386.19s |  looking at different at the behavior of different CDNs and HTTP servers and even
1386.19s - 1393.01s |  frameworks in regarding the the hash and I found that there were a lot of differences. The
1393.01s - 1397.41s |  most interesting one was again Imperva because they were no likes in the key. Eh Cloud
1397.41s - 1402.09s |  Front well sorry Cloud Front can be configured to to do the same thing so it's interesting to
1402.09s - 1407.09s |  see they are too. And basically if we have a hash and eh and key normalization then we can
1409.59s - 1414.37s |  use Imperva for for this exploit that I'm going to show. And in the back end we can use
1414.37s - 1419.63s |  pretty much any HTTP server like NGINX, Unicorn, Puma then we can use also frameworks like
1419.63s - 1425.73s |  Rails, Flash, Laravel they are not going to see the hash as a delimiter. Sorry they are
1425.73s - 1431.27s |  going to see the hash as a delimiter. Eh so basically we can send an attack that uses the
1431.27s - 1435.45s |  hash. First we are going to send what we want to be interpreted in the back end because it's
1435.45s - 1441.85s |  going to be using the hash and so if we send something like this then the XSS is going to be
1441.85s - 1446.09s |  interpreted as the path in the back end. It's going to retrieve retrieve the response the
1446.09s - 1451.29s |  malicious response and now this is going to be normalized the key so we will be able to
1451.29s - 1456.29s |  poison the home page with any any web cache poisoning eh payload that we have. This was
1458.63s - 1464.77s |  found in Vista, Mastercard and T-Mobile and again many others that I'm still unable to
1464.77s - 1469.77s |  talk about. And of course we can use the same attack for with eh Azure and Imperva and also
1470.17s - 1475.17s |  with Tomcat, with Rails, with NGINX, with a new line encoded and also again with any back end
1481.37s - 1486.71s |  that is using a special mapping. So it should be pretty easy and I already saw many people
1486.71s - 1491.75s |  exploiting this eh since I give this talk in black hat so it seems like there are a lot of
1491.75s - 1498.05s |  targets. Now we can do similar a similar thing with Azure only in this case Azure is
1498.07s - 1505.07s |  considering the front the hash as a delimiter and this is not the case for OpenLaySpeed,
1505.07s - 1511.69s |  Express and Django. So what we are going to do is we're going to send a payload that in this
1511.69s - 1517.39s |  case starts with what we want to poison so the keys the beginning and that's because the
1517.39s - 1522.59s |  front end is using the hash as a delimiter then the rest is going to be normalized and we
1522.61s - 1527.61s |  have the exploit. And again we can poison any path we want that is using Azure and OpenLight
1529.77s - 1534.65s |  or other frameworks there are other examples but as I in this research I wasn't able to look
1534.65s - 1539.65s |  for all all servers but yeah. And this was found again in OpenAI so yeah they they acted
1543.19s - 1547.29s |  really fast and they fixed the issue which I'm not sure really sure how they fixed because
1547.29s - 1555.77s |  it's still there. Eh and so what if we don't have a payload so let's say we don't have
1555.77s - 1561.37s |  anything that we can use to poison a malicious response we only we are only able to change
1561.37s - 1567.55s |  the keys well we still can do something we can start poisoning all the paths with a static
1567.55s - 1573.75s |  file. So let's say we use styles.css this will poison every single path and so when a user
1573.79s - 1579.23s |  sends a request to home my account or any other path he will just get CSS and therefore a
1579.23s - 1586.66s |  denial of service. Which many companies think that this is not a vulnerability. So sorry so
1588.60s - 1594.06s |  we already saw how we can poison anything we want and how we can change the keys so it's just
1594.06s - 1600.68s |  combining those ideas to create a very useful payload. And the first thing we need to do to
1600.68s - 1605.54s |  store everything anything we want in anywhere is to identify a malicious response that we
1605.54s - 1610.98s |  want to use. And this malicious response the the what's interesting about this attack is
1610.98s - 1616.04s |  that we are going to combine both so the response doesn't need to be eh cacheable. So we
1616.04s - 1620.22s |  can use anything we want in this case we are going to use an open redirect which is not
1620.22s - 1624.52s |  stored which is not cacheable and therefore it's it's not a vulnerability you can't report
1624.52s - 1630.20s |  this to anyone because it's really not a vulnerability. Then we need to choose what we are
1630.20s - 1635.80s |  going to poison and what I usually recommend is to poison some script that is being
1635.80s - 1640.44s |  included in uh in any web page usually the home page so in this case we have a home page
1640.44s - 1645.94s |  that is eh loading a main dot JS script. So we are going to poison that with a open
1645.94s - 1651.82s |  redirect. Why? Well because first as I said we are going to use this technique in this in this
1651.82s - 1657.16s |  example this demo I'm going to show it using Azure and Tomcat I finished coding this this
1657.16s - 1663.16s |  morning so it could work it could not work but eh the thing is if we send something that
1663.16s - 1667.80s |  starts with in this case logout which is the open redirect then the semicolon which is the
1667.80s - 1672.44s |  delimiter this is going to be interpreted as logout using the x forwarded host header which
1672.44s - 1677.44s |  is going to sh- to to show to send the the victim to the evil dot com. And then this is
1679.90s - 1684.92s |  going to be normalized so we are going to poison main dot JS and this is because it has a
1684.94s - 1690.12s |  static extension so even if the operator wasn't storable by default well we have the static
1690.12s - 1695.82s |  extension so we are able to poison main dot JS using this attack. Now when a user loads the
1695.82s - 1702.42s |  home page he will again load the main dot JS script and when this request is eh is received
1702.42s - 1708.80s |  by the by Azure he will just send the open redirect which will redirect the victim to the
1708.82s - 1715.56s |  evil dot com server will load the malicious JavaScript and we will be able to poison any any
1715.56s - 1721.54s |  victim with a malicious script that we completely control. And if we have the content security
1721.54s - 1726.84s |  policy enabled to provide to avoid this kind of attacks then we can use something like CSX
1726.84s - 1731.84s |  exfiltration to obtain anything we want you can ask Gareth about that he knows a lot. And so
1732.56s - 1742.49s |  yeah this is the demo. Eh so yeah so this is the web page. This is using Azure right now and
1749.17s - 1754.17s |  maybe this is yeah this is loading perfect. Internet. Eh so when we send a request to the
1756.51s - 1761.51s |  home page which is caches cache all Azure blah blah. Don't hack it right now please. Eh yeah
1762.23s - 1767.23s |  so we see that the main dot JS is being imported so that's what we want to attack. This is
1772.95s - 1780.32s |  main dot JS. Main dot JS is being obtained from the cache right now so it's going to last
1783.86s - 1787.80s |  twenty seconds. I said twenty seconds probably is going to in a real application is going to
1787.80s - 1792.90s |  be a day or maybe some days so you will need to wait for that to stop doing you can just use
1792.92s - 1799.72s |  uh an intruder session. Now this is the open redirect that we are going to use. This is the
1799.72s - 1808.84s |  evil dot com. And as you can see this is being this is an open redirect that is not being
1808.84s - 1813.84s |  cacheable. Config no cache means no cacheable. This is the evil dot com server that is going
1816.56s - 1823.56s |  to load our arbitrary JavaScript. And this is the exploit. Now I'm going to try to code it
1823.56s - 1829.14s |  by myself. So again the exploit is going to work like this. First we put the thing that we
1829.14s - 1834.14s |  want to to log so this is going to be used in the backend. Log out. Log out is the open
1836.18s - 1841.18s |  redirect. Then the semicolon to um to use as a delimiter. Now because the way that Java
1844.38s - 1850.26s |  use semicolons is eh is a semicolons only work for a segment so we cannot put a slash after
1850.26s - 1854.56s |  the semicolon because it's not going to be it's not going to work. So we need to send the
1854.56s - 1861.64s |  slashes and everything encoded in this case. So this is a slash encoded. This is a dot
1861.64s - 1871.08s |  encoded. Yeah the dot en- the dot segment encoded. And then we will put what we want to
1871.08s - 1879.60s |  poison which is main dot js. And it seems we are lucky enough. Yeah. So first as you if you
1880.60s - 1885.60s |  observe the first time we got a miss so nothing there. Now we got a hit so it seems it worked.
1890.24s - 1896.22s |  So if we load if we try to get the main dot js now instead of getting the js that we had we
1896.22s - 1901.22s |  have an open redirect. So now if we load let's try let's try it again. The problem is the
1907.25s - 1913.95s |  time because yeah so I need to wait the twenty seconds for this to stop being cached.
1919.03s - 1931.76s |  Unfortunately. See cached. So as you see I'm getting the main dot js that's because it's
1931.76s - 1937.66s |  being resolved the key and I'm getting the restore resource right now. But right now it
1937.66s - 1942.66s |  worked. So okay. So now if I go I do this. This is going to do everything that we saw. And
1949.64s - 1965.36s |  it's great. I'm running out of battery. Okay so I have time for this secret demo. Okay so we
1980.34s - 1984.98s |  already saw how we can use different discrepancies between URL parsers to exploit web
1984.98s - 1989.98s |  caches. But there are other kind of discrepancies where you can use and there are many other
1989.98s - 1995.02s |  discrepancies that I didn't research on but probably you can look for them. One of them is
1995.04s - 2000.04s |  the HTTP 0.9 smuggling. And basically I trust that most of you already know what HTTP is. The
2002.94s - 2008.82s |  basic protocol that we use everyday to communicate in the internet. But and probably you
2008.82s - 2013.82s |  already know the really new HTTP 3, the still new HTTP 2, the classic HTTP 1.1 and even
2017.00s - 2022.00s |  HTTP 1.0. But maybe you don't know that there's HTTP 0.9. 0.9 is basically a legacy
2022.44s - 2027.44s |  protocol that shouldn't be used by anyone unless you are NGINX, Apache, IIS or any other
2031.06s - 2037.42s |  HTTP server in the world. And the uh the thing with HTTP 0.9 is that we don't have any
2037.42s - 2042.56s |  headers. So no header for requests, no header for responses. And the con- the connections
2042.56s - 2049.00s |  are not persisted. Their add responses of course shouldn't be cacheable. So this is a
2049.00s - 2055.24s |  basically uh a basic 1.1 request, a HTTP 1.1 request. We send a request to home, we get a
2055.24s - 2060.26s |  response, nothing strange. Now if we remove the HTTP version and we just send get uh the
2062.82s - 2069.82s |  and the URL, the entire URL, then we will receive uh 0.9 response if we are targeting NGINX
2069.82s - 2075.40s |  as I said, Apache, IIS, Tomcat, any HTTP server basically. You will just get the response
2075.40s - 2081.98s |  which is the body. If you send something like this, then still HTTP 0.9. If you send
2081.98s - 2086.98s |  something like this, 0.9. And if you send this, 0.9. So why is this interesting at all? Well
2090.08s - 2095.42s |  browsers are a little bit smarter than others and they knew that it doesn't make sense to
2095.42s - 2101.86s |  keep talking this uh this old protocol so you cannot send a 0.9 request through browsers. So
2101.86s - 2107.40s |  most of the attacks are discarded just because of that. But let's see what happen if the
2107.40s - 2111.94s |  front end and the back end are not doing the same thing or they don't talk the same
2111.94s - 2116.94s |  protocol. So if we send a request like a HTTP 0.9 request and we send it through uh CDN,
2120.88s - 2125.88s |  most CDNs will take this request and they will upgrade it to HTTP 1.1. So then the back
2126.24s - 2131.24s |  end will just generate a 1.1 response. The body will be extracted and sorry, the response
2135.78s - 2142.40s |  will be actually downgraded and we will just be left with the body. And this works basically
2142.40s - 2149.30s |  even if no one should be using 0.9, this works because if the upgrade and downgrading is
2149.30s - 2155.40s |  done correctly then this works. And also connections are not persistent so a lot of
2155.42s - 2161.84s |  attacks are also discarded because of that. But the interesting thing is that some CDNs such
2161.84s - 2168.14s |  as Imperva, they don't verify the HTTP version before forwarding a request. So if we send a
2168.14s - 2173.14s |  request, a 0.9 request, Imperva will say well I will just forward it, I don't care. And the
2175.38s - 2180.06s |  problem is Imperva is not just going to forward it, it's going to think that this is a 1.1
2180.12s - 2185.12s |  request because Imperva doesn't know about 0.9. And the back end will send a body because it's
2188.02s - 2194.70s |  0.9 and so no headers and now Imperva is going to try to use this as a response and probably
2194.70s - 2199.50s |  it's going to fail. And so you are not going to see a lot of valid responses because of the
2199.50s - 2204.18s |  parsing. Because when Imperva tries to parse a body of a response that doesn't contain
2204.20s - 2210.78s |  valid HTTP headers then this is going to be interpreted as an error. But what if the body does
2210.78s - 2215.78s |  have these valid HTTP response headers? So let's say we have uh upload download uh file
2218.72s - 2225.02s |  feature or let's say we can control the body of a plain text or let's say we are even able to
2225.02s - 2230.86s |  modify the response using byte range or something like that. Then if by any means we are able
2230.88s - 2235.66s |  to control the response, then the body of the response no matter what the content type, no
2235.66s - 2245.25s |  matter anything, then we will be able to use this attack. Again this demo, I hope it works.
2245.25s - 2253.42s |  Okay, yeah. So in this super page, web page I created an upload file feature, okay. And in
2258.50s - 2263.52s |  this upload file feature we can upload any file we want, in this case an evil file that if you
2264.38s - 2269.38s |  want to see it, well it's really really small, but basically it's a response containing a
2272.48s - 2278.38s |  script and containing a cache control header, probably you can't see it, but yeah it
2278.38s - 2284.06s |  contains a cache control header saying that it should be stored for ten seconds I think.
2284.06s - 2289.06s |  Let's put one hundred seconds. And so when I upload this, I will also be able to retrieve it.
2289.08s - 2296.42s |  So, it seems like it was uploaded. So let's go back to burp. Okay, so this is the file that I
2305.68s - 2310.02s |  uploaded. Okay, let's say we have this upload download feature which is pretty common in
2310.02s - 2318.21s |  many applications. And this works, yeah. As you can see, I uploaded this file which in the
2318.21s - 2324.75s |  body will have a valid HTTP response. Containing headers, containing everything we want.
2324.77s - 2329.77s |  Now, if I send an, let's say I send a, an HTTP 0.9 request, which is basically this request
2333.73s - 2342.78s |  that doesn't contain any header here. As you can see, Imperva sends, says that it's an error
2342.78s - 2347.28s |  because it was trying to load the home page as a 0.9, it was trying to parse the response
2347.28s - 2352.28s |  body of the home page as 0.9, failed. Okay. Now, what if we send the same but for this
2352.36s - 2357.36s |  response? And as you can see, Imperva thinks that this is a valid response. It's actually
2366.64s - 2371.62s |  using the cache control header and it's contain, it's putting everything, it's also including
2371.62s - 2376.62s |  his own header so it seems like it's working. So, yeah, we can poison this file. Great. So
2379.22s - 2382.96s |  someone that is accessing this file is going to receive this response and is going to be
2383.00s - 2388.10s |  attacked. Now, not really cool. So we can use something that I just explained which is
2388.10s - 2393.74s |  modifying the old cache key. Again, we can use the request to the thing that we want to
2393.74s - 2399.22s |  store. Then the hash, in this case we are using Imperva. Imperva doesn't think that the hash
2399.22s - 2404.22s |  is a, is a delimiter. Ah, this, sorry, this time we are using Imperva and Nginx. And the,
2406.72s - 2412.56s |  then we have a path traversal. I added a few, eh, slashes because it's the way to avoid
2412.56s - 2417.56s |  being detected as an attack by, eh, many CDNs. And so, I have this path traversal that
2420.30s - 2425.30s |  removes the files, removes the abl file.txt and so basically is the path is going to be
2425.30s - 2431.64s |  converted to the home page which is index. And so we are going to poison the index. So if
2431.64s - 2438.08s |  we send this, I will have a little bit of luck. Yeah, it seems it's working because the
2438.08s - 2448.78s |  second time was obtained from the cache. So now, if I go back to the home page, it's not
2448.78s - 2453.78s |  working. Ah, sorry, I was using this. Ah, not good. This was, eh, this was the Azure one. This
2456.32s - 2463.21s |  is the Imperva one, fortunately. So if we go to Imperva, arbitrary cache. Okay, so how we
2480.24s - 2486.18s |  can defend against these kinds of attacks? Well, first we need to use the, eh, cache
2486.20s - 2491.68s |  control heater for web cache deception. So whenever we have a response that we don't want
2491.68s - 2495.92s |  to, anyone to store it, then just use private and no store for the web, for the cache
2495.92s - 2501.18s |  control heater. But also, eh, I wasn't able to show it in the example but there are many
2501.18s - 2506.26s |  CDNs that will override this cache control heater if there's a rule for the path. So
2506.26s - 2511.84s |  sometimes the rules for the request have priority and therefore it's important to check if
2511.86s - 2516.50s |  this is happening. If this is happening, try to modify this. And if it's not possible, then
2516.50s - 2523.40s |  try to consider using another CDN. And then, eh, for cache poisoning, well, we can try to
2523.40s - 2528.28s |  abort, to disable the key normalization. In some cases it's possible, in some cases not. So
2528.28s - 2533.12s |  in those cases, I suggest using the tool that I will provide that will let you know if
2533.12s - 2537.86s |  there's any discrepancy between normalization and, eh, delimiters and anything. So this
2537.88s - 2542.62s |  will allow you to know if you need to change either your HTTP server or your front end
2542.62s - 2549.62s |  server. These are all the references, eh, for the research. I, I use all this information.
2549.62s - 2556.20s |  All the other attacks that inspired me. And also in the slide you have the, eh, the links
2556.20s - 2561.00s |  for the cache poisoning and cache deception academy topics. We just released the academy
2561.00s - 2567.34s |  topic for deception. And also the extension for cache killer which is the, the extension I
2567.36s - 2573.96s |  created for, to detect this. It's still in progress. Eh, it should work but I will, I will
2573.96s - 2579.06s |  keep working on, on this, on this tool for the next probably month or two. And the
2579.06s - 2584.70s |  takeaways. Basically I showed that we can use any kind of discrepancy we, we find in the, in
2584.70s - 2589.78s |  the wild to exploit, eh, different servers using web cache. So web cache poisoning and
2589.78s - 2594.48s |  deception, eh, can be used in many, many cases wherever we find these kind of
2594.48s - 2601.02s |  discrepancies. Then we can use the exploitation things in many bounties because I found
2601.02s - 2605.76s |  that these kind of delimiters are being used in many systems. So I invite you to look for
2605.76s - 2610.56s |  them in different bounties and collect them and send me a message to just add you in the list
2610.56s - 2616.90s |  of people that are using this. And finally, eh, I found, I showed you a way of changing
2616.90s - 2621.28s |  these vulnerabilities but you probably can think of many other ways to combine it with
2621.28s - 2625.62s |  different vulnerabilities. Probably to upgrade vulnerabilities that are not really
2625.62s - 2631.06s |  useful and probably to be, to get better payments in bug bounties so I hope this helps
2631.06s - 2634.56s |  everyone. Uh, that's it. Thank you.