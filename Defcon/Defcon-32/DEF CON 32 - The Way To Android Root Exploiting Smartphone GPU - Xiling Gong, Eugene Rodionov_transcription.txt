{
  "webpage_url": "https://www.youtube.com/watch?v=BN07rjaNqXk",
  "title": "DEF CON 32 - The Way To Android Root: Exploiting Smartphone GPU - Xiling Gong, Eugene Rodionov",
  "description": "GPU security is a vital area of mobile security highlighted both by public security research as well as by in-the-wild attacks. Due to the high complexity of the GPU software/firmware along with a widely available attack surface, issues in GPU provide strong exploitation primitives for local privilege escalation attacks by the code running in unprivileged context.\n\nIn this talk, we will focus our research on the Qualcomm Adreno GPU, which is a very popular GPU implementation in mobile devices. We will do a deep dive into Adreno GPU kernel module implementation focusing on the most recent GPU versions, reveal its complex and new attack surfaces, and discuss vulnerabilities we discovered in this component.\n\nIn total we identified 9+ exploitable vulnerabilities in Adreno GPU driver leading to kernel code execution and affecting Qualcomm-based devices using the latest GPU models. We will demonstrate the exploitation of one of the race condition issues on a fully-patched widely used Android device to obtain root privileges from zero-permission application with 100% success rate.\n\nAndroid kernel mitigations such as CFI and W^X create significant hurdles for exploiting vulnerabilities in kernel to achieve code execution. Also race condition usually means unstable, low success rate. We'll explain how we overcome these challenges with a novel, generic exploit method that leverages GPU features to achieve arbitrary physical memory read/write. This technique bypasses key mitigations (CFI, W^X) and has broader implications for kernel heap buffer overflows. We will cover the technical details of the exploitation, and especially the novel generic exploit method.\n\nWe will also discuss the action items that the vendors could take to minimize the impact of this exploit method, as well as general methods to improve the overall security status of the GPU.",
  "channel_url": "https://www.youtube.com/channel/UC6Om9kAkl32dWlDSNlDS9Iw",
  "duration": 2778,
  "channel": "DEFCONConference",
  "uploader": "DEFCONConference",
  "upload_date": "20241016"
}

0.59s - 3.07s | This text was transcribed using whisper model: large-v2

 OK.
3.07s - 5.67s |  OK, sorry for that.
5.67s - 7.35s |  Good afternoon, everyone.
7.35s - 8.75s |  My name is Xuexin.
8.75s - 10.63s |  I'm the manager of Android Red team.
14.11s - 18.27s |  Today, I'm really honored to present you
18.27s - 20.19s |  the way to Android root exploiting
20.19s - 26.25s |  your GPU on smartphone with these two gentlemen.
26.25s - 29.41s |  This is Shilin Gong, our security researcher.
29.41s - 33.25s |  And he actually did most of the technical work.
33.25s - 35.53s |  So big credit to him.
35.53s - 39.25s |  And also next to Shilin is our tech lead, Eugene Rodionov.
39.25s - 42.37s |  Eugene did a lot of work to help us create the slides
42.37s - 44.77s |  and make sure our demo runs smoothly.
44.77s - 48.06s |  Big shout out to him.
48.06s - 51.66s |  So our story dated back to the earliest year
51.66s - 58.62s |  when Shilin decided to take a look at Qualcomm GPU drivers.
58.62s - 60.78s |  But before we go into details, here's
60.78s - 62.82s |  a brief introduction of our team.
62.82s - 66.14s |  So we are the Android Red team.
66.14s - 69.94s |  Our goal is to increase the Android and Pixel security.
69.94s - 75.34s |  And we do this by simulating adversaries attacking
75.34s - 77.34s |  Android key features.
77.34s - 81.78s |  And our work can be broken down into a couple of different ways.
81.78s - 85.50s |  Most obviously, we do offensive security research review
85.50s - 89.50s |  to verify our breaking security assumptions, which
89.50s - 91.82s |  means finding bugs.
91.82s - 94.78s |  And we scale our work by developing
94.78s - 100.38s |  tools such as continuous fuzzing or static analysis.
100.38s - 105.02s |  And once we find issues, we develop proof of concept
105.02s - 107.94s |  just to show the real world impact,
107.94s - 110.58s |  as some issues are not so straightforward
110.58s - 113.30s |  to see their impact.
113.30s - 116.38s |  Lastly, while we are developing the exploits,
116.38s - 118.50s |  we're also assessing the efficacy
118.50s - 120.82s |  of the security mitigations that our feature
120.82s - 124.58s |  team implemented.
124.58s - 128.30s |  The more pain we experience during our work,
128.30s - 131.66s |  the more security our end user will gain.
131.66s - 134.98s |  So we are literally making our work harder
134.98s - 139.91s |  to help end users.
139.91s - 141.71s |  So here's today's agenda.
141.71s - 146.03s |  We'll first talk about the GPU and security background.
146.03s - 149.07s |  And then we'll go through the Qualcomm Adrena GPU
149.07s - 151.71s |  introduction, talking about its architecture
151.71s - 153.91s |  and where the issue patterns are.
153.91s - 157.19s |  And then we'll dive into very technical details
157.19s - 160.91s |  for the CVE-2024-23380 and how we
160.91s - 164.43s |  exploit to gain root privilege.
164.43s - 167.55s |  Lastly, we'll conclude our talk with the methodology
167.55s - 172.42s |  discussions.
172.42s - 177.94s |  So before we jump into engagement,
177.94s - 180.50s |  usually we need to ask ourselves questions.
180.50s - 182.70s |  Why do we look into this one?
182.70s - 186.26s |  The reason is that, compared to the Android ecosystem,
186.26s - 188.62s |  our team is very small.
188.62s - 193.86s |  So we want to spend our time into the most impactful areas.
193.86s - 196.06s |  So why GPU drivers?
196.06s - 199.06s |  Here, we think these are the answers to that question.
199.06s - 202.30s |  The biggest one is there is no permission
202.30s - 207.86s |  required for applications to look into GPU driver.
207.86s - 210.16s |  On the right side, you can see a diagram.
210.16s - 212.76s |  And the unprivileged applications,
212.76s - 216.04s |  whatever user space library they call OpenGL, Vulkan,
216.04s - 220.68s |  anything else, those libraries talk into the device node
220.68s - 223.96s |  directly in the application's process.
223.96s - 226.44s |  So that means this device driver has to be
226.44s - 228.44s |  exposed to the application.
228.44s - 230.80s |  So no permission required.
230.80s - 233.36s |  This is the biggest problem.
233.36s - 237.68s |  And this is why researchers love GPU drivers.
237.68s - 242.88s |  Next one, GPU driver performance is the key.
242.88s - 246.52s |  And because of that, they need to have some powerful functions
246.52s - 248.60s |  to do this.
248.60s - 250.96s |  The most important one is that they usually
250.96s - 254.00s |  have access to the system physical RAMs
254.00s - 257.28s |  and so that they can map in memories from user space
257.28s - 261.72s |  to kernel space and to the hardware without copying them.
261.72s - 263.92s |  This is a very powerful primitive,
263.92s - 266.64s |  and attackers want them.
266.64s - 270.00s |  We'll explain more later why it's powerful.
270.00s - 274.20s |  And lastly, again, because of the performance requirement,
274.20s - 279.08s |  this involves high complexity code in the GPU driver.
279.08s - 282.60s |  And because of that, it's really, really hard
282.60s - 284.36s |  to develop bug-free code.
284.36s - 286.96s |  I'm not sure if anybody here write bug-free code.
286.96s - 288.80s |  Raise your hand if you did.
288.80s - 291.92s |  Wow, very brave.
291.92s - 295.42s |  Anyway, and it's even harder to fix an issue.
295.42s - 298.66s |  And it's very common that you fix an issue,
298.66s - 300.86s |  but it's not 100% fixed.
300.86s - 303.02s |  There's still something left over.
303.02s - 306.06s |  And oh, even worse, you fixed one issue,
306.06s - 311.43s |  and you introduced another new issue, or two issues.
311.43s - 314.21s |  So this high complexity is another reason
314.21s - 317.79s |  one look into this area.
317.79s - 322.19s |  But why Qualcomm GPU?
322.19s - 328.01s |  Hello?
328.01s - 345.41s |  There's an audio problem.
345.41s - 345.97s |  Hello?
345.97s - 348.49s |  Hello?
348.49s - 349.29s |  I can use this one.
349.29s - 349.79s |  All right.
349.79s - 350.29s |  All right.
355.10s - 359.86s |  OK, we have issues, so we fix them.
359.86s - 362.14s |  So why Qualcomm?
362.14s - 365.30s |  Qualcomm is one of the most important smartphone SoC
365.30s - 369.90s |  vendors, and many devices use the Qualcomm SoCs.
369.90s - 374.70s |  And on those SoCs, Adreno GPU is the one used the most.
374.70s - 379.62s |  And last one is, this applies to all GPUs,
379.62s - 384.78s |  that GPU is a very actively developing area because
384.98s - 386.94s |  all the requirements, all the games
386.94s - 391.66s |  keep having high resolutions, faster speed, faster FPS.
391.66s - 393.98s |  So there's lots of development happening
393.98s - 398.46s |  that involves revolutions in the architecture, hardware,
398.46s - 399.62s |  software.
399.62s - 402.94s |  And coincidentally, we noticed that there
402.94s - 407.02s |  is a new architecture recently in the Qualcomm GPU.
407.02s - 411.10s |  New architecture, new software means new bugs.
411.10s - 414.26s |  So we want to take a look and see what's the difference,
414.26s - 419.44s |  and is there any issues there.
419.44s - 424.84s |  And another study we did before we look into our source code,
424.84s - 427.36s |  I mean, not our source, Qualcomm source code,
427.36s - 431.24s |  is to check the security bulletins
431.24s - 434.08s |  and understand any historical issues.
434.08s - 435.84s |  And here's a chart that we manually
435.84s - 439.92s |  created from the Qualcomm security bulletin.
439.92s - 442.84s |  The size of the bars might look a little bit scary,
442.84s - 445.64s |  but you can see the numbers actually are single digits.
446.08s - 450.36s |  There's not a lot of issues, but my point here
450.36s - 454.12s |  is that you can see this is more like constant issues
454.12s - 456.88s |  happening every quarter.
456.88s - 460.16s |  So this chart gives us a little bit of confidence
460.16s - 465.76s |  that if we look into the code, we might as well find issues.
465.76s - 467.64s |  Oh, by the way, I forgot to mention,
467.64s - 470.68s |  all our work is based on the open source Qualcomm drivers.
470.68s - 472.24s |  So everything is public.
472.24s - 476.33s |  There's no private information involved.
476.33s - 479.41s |  Among all those issues, there are quite some high profile
479.41s - 484.17s |  issues disclosed and talked by previous security researchers.
484.17s - 489.13s |  These talks are great, and we learn a lot from the talks.
489.13s - 491.57s |  Really big credit to them for helping
491.57s - 497.37s |  us to jump into an area we never looked at before.
497.37s - 500.81s |  And now we look back into the just recent three months.
500.81s - 504.17s |  Here are all the issues reported to Qualcomm,
504.17s - 508.09s |  disclosed by Qualcomm security bulletin.
508.09s - 512.09s |  Our security researcher, Xilin, did a little bit analysis
512.09s - 515.73s |  and focused on the last two columns.
515.73s - 519.17s |  You can see the tech area, mostly many of the issues
519.17s - 522.05s |  are focusing on IOMMUs.
522.05s - 524.05s |  That matches to our previous assumption
524.05s - 527.29s |  that, OK, physical memory is the key.
527.29s - 532.53s |  And also, very subjective, but based on Xilin's experience,
532.53s - 536.05s |  most of the issues are easy to exploit.
536.05s - 540.37s |  And once exploited, they are pretty stable.
540.37s - 542.69s |  Attackers want the stabilities.
542.69s - 546.90s |  They want their code to be good.
546.90s - 549.06s |  So over the course of our engagement,
549.06s - 553.06s |  Xilin has identified more than nine issues.
553.06s - 556.42s |  We report all the issues to Qualcomm immediately.
556.42s - 560.70s |  And today, we're going to talk about CVE-2024-23380.
560.70s - 563.22s |  This is one of the issues we reported.
563.22s - 566.38s |  This issue has been patched and published
566.38s - 569.14s |  in the security bulletin of July 2024.
569.14s - 572.18s |  And Qualcomm communicated to all the device vendors
572.18s - 575.42s |  in April before the disclosure.
575.42s - 578.62s |  So go to their security bulletins.
578.62s - 580.86s |  You can see what's affecting devices.
580.86s - 583.58s |  But don't worry if your device is affected.
583.58s - 585.22s |  And check your security patch level.
585.22s - 588.94s |  If it's July or later, it's fixed.
588.94s - 592.06s |  And from here, I'll hand over to Xilin
592.06s - 594.46s |  to talk about technical details and how we
594.46s - 599.42s |  exploit to gain root privilege.
599.42s - 602.20s |  XILIN LIU.
602.20s - 604.44s |  Yeah, thank you, Xilin.
604.44s - 613.44s |  So I'll quickly introduce the basic knowledge of Andrino GPU.
613.44s - 616.44s |  So here is the basic architecture.
616.44s - 620.84s |  You can see in the middle is the KGSL driver,
620.84s - 624.68s |  which is a glue between the user space and the hardware.
624.68s - 627.88s |  So from the perspective of the user space,
627.88s - 631.40s |  we will have a set of interfaces.
631.40s - 633.80s |  The first one is a context, which
633.80s - 638.28s |  is used to identify user space application
638.28s - 643.08s |  and also to manage the GPU driver or hardware resources.
643.08s - 644.88s |  And also, the user space maybe want
644.88s - 648.04s |  to share memory with the GPU hardware.
648.04s - 650.48s |  So we will have memory interfaces.
650.48s - 652.40s |  There are three types of memory.
652.40s - 656.32s |  The basic memory, the user space memory, the DMA memory.
656.32s - 659.44s |  And previously, we also have the sparse memory.
659.44s - 664.48s |  But now, this sparse memory already not used anymore.
664.48s - 668.12s |  And the user space also want to send the customer GPU
668.12s - 669.92s |  commands to the GPU hardware.
669.92s - 673.52s |  So we will have some commands interfaces.
673.52s - 676.40s |  And also, the user space want to get
676.40s - 678.44s |  synced with the GPU hardware.
678.44s - 681.76s |  So we will have synchronization interfaces.
681.76s - 685.84s |  To accomplish these tasks in the GPU driver,
685.84s - 688.20s |  we will have a command queue, which
688.20s - 691.32s |  receives commands from the user space.
691.32s - 693.88s |  And then the software dispatcher will
693.88s - 696.52s |  get the command from the queue and add
696.52s - 702.20s |  the necessary informations and maybe modify the GPU command
702.20s - 704.92s |  and then send them to the ring buffer.
704.92s - 708.00s |  There is a simple firmware in the GPU hardware,
708.00s - 711.48s |  which will receive commands from the ring buffer
711.48s - 713.52s |  and send the command to the hardware.
713.52s - 718.68s |  So GPU customer commands will be run in the GPU hardware.
718.68s - 722.16s |  Also, we will have something like the global buffer,
722.16s - 726.16s |  the registers to control the GPU hardware.
726.16s - 728.08s |  For memory management, we will have
728.08s - 732.28s |  a memory pool and MMU for the user space memory
732.28s - 738.16s |  and IOMMU for control the GPU memory.
738.16s - 741.04s |  So this is the new architecture starting
741.08s - 745.72s |  from generation seven in the later generation.
745.72s - 750.48s |  You can see we have lots of new stuff in red color.
750.48s - 753.76s |  The most important change is the software dispatcher
753.76s - 756.44s |  is replaced by the hardware scheduler, which
756.44s - 761.44s |  means the GPU command comes from the user space.
761.44s - 763.64s |  We are not to be sent to the ring buffer directly
763.64s - 765.12s |  by the driver.
765.12s - 768.48s |  The driver will not touch the ring buffer anymore.
768.48s - 772.76s |  Instead, the driver will send this command directly
772.76s - 774.96s |  to a HiFi command queue.
774.96s - 778.24s |  So there is a simple firmware.
778.24s - 783.52s |  And this firmware will take over and finish the job previously
783.52s - 785.28s |  finished by the driver.
785.28s - 789.12s |  So a lot of software dispatcher jobs
789.12s - 791.32s |  will be moved to the firmware.
791.32s - 793.80s |  So we don't have the source code of the firmware.
793.80s - 798.04s |  So I can just guess that this job previously
798.04s - 800.28s |  finished by the software dispatcher
800.28s - 801.88s |  will move to the firmware.
801.88s - 807.00s |  But how it works and whether there are any vulnerabilities,
807.00s - 809.04s |  I have no idea now.
809.04s - 813.20s |  And also to coordinate with these new features,
813.20s - 817.28s |  some other new features like the hardware fence is added.
817.28s - 819.96s |  Previously, we only have the software fence.
819.96s - 822.64s |  Now we also have hardware fence.
822.64s - 826.96s |  There, we introduce a lot of new code, new features,
826.96s - 830.96s |  and also a new hardware fence queue and new hardware fence
830.96s - 831.84s |  event here.
834.48s - 838.20s |  For the memory, we will have a new virtual buffer object.
838.20s - 840.76s |  You can see here, this is a new VBO.
840.76s - 843.68s |  And the previously ARM, IOMMU, you
843.68s - 846.92s |  will replace it by the Qualcomm-owned IOMMU.
846.92s - 850.56s |  So these new features will, of course,
850.56s - 852.76s |  enhance the GPU capability.
852.76s - 860.19s |  But also, we introduce lots of new attack surface.
860.19s - 864.31s |  If you want to look into some new vulnerability,
864.31s - 867.83s |  you can start from the new features.
867.83s - 870.79s |  Here, I'll also introduce the memory management.
870.79s - 874.23s |  You can see here is the basic memory management
874.23s - 876.19s |  called a basic memory object.
876.19s - 878.07s |  So it's used in most of the cases
878.07s - 881.91s |  you want to share some memory to the GPU from the user space.
882.75s - 885.03s |  You request a basic memory object.
885.03s - 885.99s |  It's a basic.
885.99s - 888.27s |  So it's used in most of the cases.
888.27s - 889.91s |  You call this our control.
889.91s - 892.87s |  And then you set a parameter to tell the driver
892.87s - 895.19s |  how much physical pages you want.
895.19s - 897.75s |  Then the driver will allocate this number
897.75s - 899.59s |  of physical pages for you.
899.59s - 902.15s |  And then the second step, the driver
902.15s - 906.71s |  will allocate address range in the GPU virtual address space.
906.71s - 911.07s |  So you can see here, we have this virtual GPU address.
911.07s - 915.95s |  And then the GPU driver will set this physical to virtual
915.95s - 917.23s |  mapping for you.
917.23s - 920.51s |  So at this time, the GPU hardware
920.51s - 924.15s |  will be able to access to the physical page using this GPU
924.15s - 926.03s |  virtual address.
926.03s - 928.39s |  And in most of the cases, the user space
928.39s - 931.67s |  will also want to access to the physical page.
931.67s - 935.39s |  So the user space will do memory map
935.39s - 937.51s |  on this basic memory object.
937.51s - 939.51s |  And then the driver will help you
939.51s - 944.19s |  to set up the physical page to virtual mapping,
944.19s - 945.67s |  so through the MMU.
945.67s - 948.75s |  So at this time, the physical page
948.75s - 952.75s |  can be accessed from both the GPU hardware and the user
952.75s - 953.79s |  space.
953.79s - 955.87s |  So that's the basic memory object.
955.87s - 958.63s |  The driver will manage all the objects in the kernel
958.63s - 962.91s |  and also manage the back-end physical memory.
962.91s - 965.87s |  And here is the second type of memory object.
965.87s - 967.95s |  It's called the user space memory.
967.95s - 971.55s |  So suppose you already have a user space memory.
971.55s - 973.19s |  You have a back-end physical memory.
973.19s - 976.23s |  You can use this user space memory object
976.23s - 981.83s |  to import memory from the user space into the GPU hardware.
981.83s - 984.51s |  And here is the third type of memory.
984.51s - 986.95s |  It's called a virtual buffer object.
986.95s - 992.55s |  From the name virtual, you maybe guess that it's virtual.
992.55s - 995.27s |  So for this type of memory, it doesn't
995.27s - 999.23s |  have its own back-end physical memory.
999.23s - 1002.43s |  So you call this out control with this flag.
1002.43s - 1007.07s |  Then the driver will simply allocate a GPU virtual address
1007.07s - 1008.07s |  for you.
1008.07s - 1011.51s |  And then it will map this virtual address
1011.51s - 1013.35s |  to a dummy zero page.
1013.35s - 1015.27s |  So it's a dummy zero page.
1015.27s - 1018.03s |  It's just a placeholder.
1018.03s - 1021.59s |  Of course, you can access it to the virtual memory
1021.59s - 1022.71s |  in the GPU hardware.
1022.71s - 1023.91s |  But it's no effect.
1023.91s - 1026.83s |  Whatever you read or write will have no effect.
1026.83s - 1028.83s |  It's just a zero page.
1028.83s - 1030.15s |  It will have no effect.
1030.15s - 1033.51s |  So how to use this virtual buffer object?
1033.51s - 1039.63s |  You can actually map a basic memory object into this VBO.
1039.63s - 1044.67s |  So suppose you already have two basic memory object, A and B.
1044.67s - 1048.47s |  Both of them have their own back-end physical memory.
1048.47s - 1052.69s |  You can bind these two basic memory object into this VBO.
1052.69s - 1055.45s |  So you call this bindRangeOutControl.
1055.45s - 1057.73s |  Then the driver will do the work.
1057.73s - 1061.05s |  The first step, the driver will remove any existing
1061.05s - 1063.05s |  mapping from the VBO.
1063.05s - 1066.33s |  Here, we already mapped the zero page to the VBO.
1066.33s - 1068.45s |  So this mapping will be removed.
1068.45s - 1072.05s |  If you have previously mapped any other basic memory
1072.05s - 1077.73s |  object to this VBO, so this map will also be removed.
1077.73s - 1081.49s |  So the first step, we will remove any existing mapping
1081.49s - 1082.97s |  from the VBO.
1082.97s - 1085.33s |  And then we will get a connection
1085.33s - 1089.93s |  between this basic memory object and the VBO.
1089.93s - 1093.37s |  So the driver will know that there is a connection.
1093.37s - 1096.57s |  Somebody is using this basic memory object.
1096.57s - 1099.33s |  So this object cannot be freed.
1099.33s - 1100.93s |  And also, the driver will help you
1100.93s - 1104.69s |  to find out the physical memory page of this basic memory
1104.69s - 1105.73s |  object.
1105.73s - 1110.45s |  And then the driver will help you to set up this connection.
1111.37s - 1114.05s |  Here is the physical memory to virtual mapping.
1114.05s - 1118.57s |  We'll map this physical page into the VBO's region
1118.57s - 1121.49s |  at a specified offset.
1121.49s - 1126.17s |  And also, the driver will continue these two steps,
1126.17s - 1129.97s |  find all the basic memory object you want,
1129.97s - 1132.97s |  and get all the connections between the basic memory
1132.97s - 1134.65s |  object and the VBO.
1134.65s - 1139.13s |  And then map all the physical pages to this VBO.
1139.17s - 1144.81s |  So that's the basic memory object binding to the VBO.
1144.81s - 1151.89s |  It's very powerful and flexible, but also very vulnerable.
1151.89s - 1157.13s |  You can see here we have this CVE-2024-23380,
1157.13s - 1162.73s |  which happens when you bind a basic memory object into a VBO.
1162.73s - 1165.01s |  So we will take a look at the code.
1165.01s - 1167.13s |  You can see when we do the binding,
1167.13s - 1171.41s |  we will get a connection between this basic memory
1171.41s - 1172.57s |  object and the VBO.
1172.57s - 1175.61s |  So the connection is finished by this function,
1175.61s - 1177.45s |  intervalTreeInsert.
1177.45s - 1182.33s |  So insert this basic memory object into the VBO.
1182.33s - 1188.49s |  Then we will get a physical page and virtual address mapping.
1188.49s - 1192.85s |  We will set up this mapping using this function,
1192.85s - 1195.93s |  mmuMapChild.
1196.93s - 1200.93s |  Of course, we will have to protect our global status.
1200.93s - 1205.93s |  So we will use this mutex lock to protect the interval tree.
1205.93s - 1209.97s |  So this interval tree is a global status.
1209.97s - 1212.05s |  This will be protected by the lock.
1212.05s - 1214.73s |  And when we finish, we will do unlock.
1214.73s - 1219.41s |  And here, the vulnerabilities, this physical to virtual mapping
1219.41s - 1222.25s |  is also a global resource, so it should also
1222.25s - 1224.33s |  be protected by the lock.
1224.37s - 1227.13s |  But you can see here, this physical to virtual mapping
1227.13s - 1229.09s |  is outside of the lock.
1229.09s - 1233.61s |  So it's possible, from the driver's perspective,
1233.61s - 1236.49s |  we already have this basic memory object
1236.49s - 1238.93s |  connected to the VBO.
1238.93s - 1241.41s |  When we do the physical to virtual mapping,
1241.41s - 1245.01s |  this connection might be removed by somebody else.
1245.01s - 1247.97s |  So that's the vulnerability.
1247.97s - 1249.61s |  Let's take a look at the fix.
1249.61s - 1253.41s |  You can see the fix simply moves this physical
1253.41s - 1255.93s |  to virtual mapping inside of the lock.
1255.93s - 1258.13s |  It's very simple fix.
1258.13s - 1260.77s |  It just protects this mapping.
1260.77s - 1263.53s |  So that's the vulnerability.
1263.53s - 1266.69s |  Let's take a look at how to trigger this vulnerability.
1266.69s - 1271.77s |  We will need two threads, one to the mapping, to the binding,
1271.77s - 1274.33s |  binding a basic memory object to the VBO.
1274.33s - 1278.09s |  And at the same time, somebody else do the unbinding.
1278.09s - 1279.53s |  So look at the code.
1279.53s - 1281.69s |  You can see, when do the binding,
1281.69s - 1283.77s |  we are getting into this add range.
1283.77s - 1286.45s |  This is the function we just read.
1286.45s - 1287.97s |  You can see, we have the lock.
1287.97s - 1293.33s |  We will insert the basic memory object into the VBO.
1293.33s - 1295.97s |  Then we unlock and do the physical mapping.
1295.97s - 1299.53s |  And another thread, you do the unbinding.
1299.53s - 1302.85s |  You can see, it's just the reverse of the binding.
1302.85s - 1309.01s |  You will have a lock, and then you remove the binding,
1309.01s - 1311.61s |  and then you do the unlock.
1311.61s - 1314.45s |  So here is how we trigger the vulnerability.
1314.45s - 1318.41s |  We have two threads, thread A, running, and lock,
1318.41s - 1323.73s |  and then undo the tree insert and do the unlock.
1323.73s - 1327.21s |  And at the same time, we can run thread B,
1327.21s - 1331.21s |  because it's unlocked, so the thread B can run in.
1331.21s - 1334.61s |  Then we get the lock removed and unlock.
1334.61s - 1337.17s |  And finally, we do the mapping.
1337.17s - 1342.17s |  So here is the detailed vulnerability.
1342.17s - 1345.49s |  We run thread A. We acquire the mutex.
1345.49s - 1346.37s |  Then we connect.
1346.37s - 1349.17s |  You can see this connection is set up.
1349.17s - 1352.57s |  So we connect the basic memory object to the VBO
1352.57s - 1354.57s |  and release the lock.
1354.57s - 1357.45s |  Then we get to thread B. Thread B also
1357.45s - 1359.33s |  acquires the same mutex.
1359.33s - 1362.33s |  And you can see this connection between the basic memory
1362.33s - 1364.97s |  object and the VBO is removed.
1364.97s - 1370.65s |  So this is thread B, unbinding, and release the mutex.
1370.65s - 1374.41s |  Then we get back to thread A. The thread A
1374.41s - 1380.13s |  will map the victim's physical page to this virtual address.
1380.13s - 1383.97s |  So because from the driver's perspective,
1383.97s - 1390.53s |  the basic memory object already have no connection with VBO,
1390.53s - 1392.21s |  so it can be freed.
1392.21s - 1396.09s |  So we can delete the basic memory object in the driver.
1396.09s - 1400.05s |  So all the resource related with this basic memory object
1400.05s - 1403.45s |  could be freed, as well as the back-end physical memory.
1403.45s - 1406.41s |  You can see this page has been freed.
1406.41s - 1409.17s |  But the connection here, the connection
1409.17s - 1411.61s |  between the physical memory and the virtual address
1411.61s - 1413.09s |  is still mapped.
1413.09s - 1414.49s |  So it's still there.
1414.49s - 1415.85s |  That's the vulnerability.
1415.85s - 1419.17s |  So we have run this code sequence
1419.17s - 1423.53s |  and triggered the vulnerability.
1423.53s - 1428.37s |  It's a physical page used after free.
1428.37s - 1431.97s |  So we can read and write to free the physical page.
1431.97s - 1433.57s |  You can see we can read and write
1433.57s - 1439.37s |  to this free the physical page from the GPU's virtual address.
1439.37s - 1442.29s |  And also, it's a worst condition issue.
1442.29s - 1446.33s |  We require the two threads to do binding and unbinding
1446.33s - 1448.85s |  at the same time.
1448.85s - 1453.49s |  And here, let's summarize the exploit primitive.
1453.49s - 1456.41s |  We have a physical page used after free.
1456.41s - 1459.57s |  We return this physical virtual mapping.
1459.57s - 1463.09s |  So we can access free the physical page.
1463.09s - 1466.85s |  And this vulnerability is pretty stable.
1466.85s - 1472.85s |  Usually, when we trigger used after free issue or rate
1472.85s - 1476.17s |  condition issue, we have to trigger it multiple times.
1476.21s - 1479.33s |  So it's very dangerous you trigger this issue
1479.33s - 1483.21s |  because it will cause the system status, wrong status,
1483.21s - 1484.77s |  maybe crash the kernel.
1484.77s - 1486.77s |  But this issue is pretty stable.
1486.77s - 1488.65s |  You can trigger it multiple times
1488.65s - 1493.73s |  without worrying about it fails or causing any crash.
1493.73s - 1497.97s |  And also, we have a method to get the feedback
1497.97s - 1500.17s |  whether this issue is triggered or not.
1500.17s - 1503.45s |  If it's not triggered, we will get this feedback.
1503.45s - 1506.09s |  And if it's triggered, then we know
1507.01s - 1510.61s |  so that we can know exactly how many pages we have controlled.
1510.61s - 1513.61s |  This will make our exploit more stable.
1513.61s - 1516.93s |  And this issue is pretty easy to trick.
1516.93s - 1519.57s |  Without any special tricks, you don't
1519.57s - 1521.85s |  have to adjust the thread priority
1521.85s - 1524.37s |  or add more entries to the list.
1524.37s - 1527.25s |  You can easily trigger this issue.
1527.25s - 1532.65s |  So this is a pretty nice exploit primitive.
1532.65s - 1538.73s |  So far, we have tricked the vulnerability.
1538.73s - 1543.25s |  We have controlled a lot of physical memory pages.
1543.25s - 1547.57s |  The questions became the following question.
1547.57s - 1550.05s |  Suppose we already controlled a large amount
1550.05s - 1551.93s |  of physical memory page.
1551.93s - 1553.41s |  What are we going to do?
1553.41s - 1555.69s |  There are lots of answers and solutions
1555.69s - 1558.17s |  for an experienced kernel hacker.
1558.17s - 1561.53s |  For example, we can supply lots of this structure
1561.53s - 1564.09s |  created into the kernel heap and then
1564.09s - 1566.61s |  modify the UID and the GID.
1566.61s - 1570.09s |  We can also supply lots of structure file
1570.09s - 1573.01s |  and then modify the file permission.
1573.01s - 1577.89s |  And also, we can use this kernel space memory mirroring attack.
1577.89s - 1581.33s |  So we can modify and control the GPU page table
1581.33s - 1584.37s |  and then do the mirroring.
1584.37s - 1587.45s |  Here, we will introduce our new method.
1587.45s - 1594.41s |  So we are spraying structure KGS memory description.
1594.41s - 1596.57s |  So you can see on the right, we are
1596.57s - 1601.41s |  spraying this structure, KGS memory entry.
1601.41s - 1604.61s |  It contains the target structure we want to spray.
1604.61s - 1607.21s |  It contains the memory description structure.
1607.21s - 1610.05s |  Also, it contains metadata.
1610.05s - 1612.05s |  And for this memory description, we
1612.05s - 1615.65s |  can see they have a physical address and a size.
1615.65s - 1618.41s |  So why we are using this method?
1618.41s - 1621.01s |  The first reason is easy to spray.
1621.01s - 1625.25s |  You can simply call this GPU allocator control.
1625.25s - 1626.89s |  Then you can spray a large amount
1626.89s - 1629.45s |  of this structure in the kernel.
1629.45s - 1633.09s |  And also, because we have this metadata,
1633.09s - 1635.49s |  this is fully controlled by the user space.
1635.49s - 1638.61s |  So the user space can set a unique metadata
1638.61s - 1642.61s |  so that it can be defined easily in the memory.
1642.61s - 1646.05s |  And it's easy to use and very useful.
1646.05s - 1648.53s |  You can spray this structure and then
1648.53s - 1650.69s |  modify the physical address.
1650.69s - 1653.61s |  And then do memory map in the user space.
1653.61s - 1655.57s |  When you do memory map, you will be
1655.57s - 1659.53s |  able to map the physical address to user space.
1659.53s - 1662.85s |  And also, if you check the result of the memory map,
1662.85s - 1666.01s |  then you know whether your exploit is working or not.
1666.01s - 1671.25s |  So you can easily know how the exploit works.
1671.25s - 1673.53s |  And there's one extra bonus.
1673.53s - 1675.33s |  It's possible you use this method
1675.33s - 1678.09s |  to bypass the KSR directly.
1678.09s - 1680.09s |  Even if you don't have a KSR, you
1680.09s - 1683.21s |  can use this method to bypass the KSR.
1683.21s - 1686.09s |  We will discuss this later.
1686.09s - 1691.33s |  Now, suppose we already have a physical page controlled.
1691.33s - 1693.53s |  Like this, we control this physical page.
1693.53s - 1697.69s |  And in this page, we have our package structure,
1697.69s - 1700.41s |  memory entry, which contains the metadata
1700.41s - 1702.81s |  so that we can find this metadata.
1702.81s - 1708.65s |  And then we find this memory description structure.
1708.65s - 1712.73s |  In this structure, it will have a physical address
1712.73s - 1715.29s |  and a size and ops.
1715.29s - 1717.57s |  We will modify these three fields.
1717.57s - 1719.17s |  We will modify the physical address
1719.17s - 1722.97s |  to the physical address of the kernel
1722.97s - 1725.51s |  and the size to the kernel size.
1725.51s - 1729.25s |  And also, we will modify the ops from the KSR ops
1729.25s - 1733.45s |  to this continuous ops.
1733.45s - 1735.73s |  Why we will modify this ops?
1735.73s - 1736.93s |  Look at the new ops.
1736.93s - 1739.13s |  You can see it have a VM folder.
1739.13s - 1756.84s |  This is used when we do a new continuous ops, which
1756.84s - 1759.60s |  contains a new VM folder.
1759.64s - 1764.84s |  So when the user space do memory mapping on this memory object,
1764.84s - 1769.32s |  it will get a user space virtual address,
1769.32s - 1773.08s |  which the user space can access to the virtual address.
1773.08s - 1775.92s |  But at the first time, when the user space access
1775.92s - 1779.24s |  to the address, because the physical to virtual mapping
1779.24s - 1783.68s |  is not set up yet, so it will get into a VM folder.
1783.68s - 1786.16s |  So the driver will get into the VM folder
1786.16s - 1788.48s |  to set up the physical to virtual mapping
1788.48s - 1789.76s |  and look at the code.
1789.76s - 1792.12s |  You can see this mapping is quite simple.
1792.12s - 1795.72s |  It just gets the physical address we just modified.
1795.72s - 1798.68s |  So it will use the physical address we want
1798.68s - 1802.80s |  and then map this physical address to the user space.
1802.80s - 1806.24s |  So if we modify this physical address
1806.24s - 1809.32s |  to the kernel physical address, then the kernel memory
1809.32s - 1811.72s |  will be mapped to the user space.
1811.72s - 1815.24s |  So we can do arbitrary read write to the kernel memory.
1815.24s - 1820.24s |  So that's why we use this structure memory description
1820.24s - 1824.20s |  and how the exploit works.
1824.20s - 1826.44s |  Let's summarize the exploitation.
1826.44s - 1829.32s |  So we trigger the vulnerability, and then we
1829.32s - 1831.68s |  get a controlled physical page.
1831.68s - 1835.44s |  We repeat this step 200 times.
1835.44s - 1839.40s |  Then we get 200 physical pages controlled.
1839.40s - 1841.72s |  Then we can get to the next step.
1841.72s - 1846.00s |  We can force the system memory into a low memory status.
1846.00s - 1849.36s |  So all the used kernel memory, all the caches
1849.36s - 1854.40s |  will be returned to the system, including the physical pages
1854.40s - 1855.44s |  that we controlled.
1855.44s - 1861.12s |  So the 200 pages will also be returned to the kernel.
1861.12s - 1862.84s |  Then we get to the next step.
1862.84s - 1865.36s |  We do kernel heap spray using the structure
1865.36s - 1867.44s |  we just described.
1867.44s - 1872.00s |  So if we are lucky, some of the entries
1872.00s - 1874.60s |  will be located in the controller page.
1874.60s - 1883.24s |  So we can find these structures in the controller page
1883.24s - 1885.56s |  using the metadata we just assert.
1885.56s - 1890.08s |  So we can scan the controller memory and find the structure.
1890.08s - 1891.80s |  And then we get this structure.
1891.80s - 1895.02s |  You can see on the right, we get the memory description
1895.02s - 1898.22s |  structure, which contains the physical address side
1898.22s - 1900.30s |  and the ops we want to modify.
1900.30s - 1905.54s |  And here, one thing you can see, the ops is a pointer.
1905.54s - 1909.82s |  It's a point to something in the kernel memory.
1909.82s - 1913.06s |  So if we read this ops out, then we
1913.06s - 1916.10s |  can get the KSL information.
1916.10s - 1920.78s |  So in our exploiter, we bypass the KSL at this step.
1920.78s - 1924.06s |  So we can bypass the KSL here, and then
1924.06s - 1925.70s |  get to the next step.
1925.70s - 1929.10s |  We can modify the physical address, modify the size,
1929.10s - 1930.90s |  modify the ops.
1930.90s - 1933.14s |  We will modify the kernel physical address
1933.14s - 1935.50s |  to the kernel physical address, and the size
1935.50s - 1936.78s |  to the kernel size.
1936.78s - 1939.54s |  Then finally, we can map the whole kernel memory
1939.54s - 1941.10s |  to the user space.
1941.10s - 1943.66s |  Then we can do arbitrary read-write to the kernel
1943.66s - 1945.74s |  memory in the user space.
1945.74s - 1948.86s |  So that's the exploiter.
1948.86s - 1954.38s |  We can actually expand this method to a more generic case.
1954.38s - 1960.18s |  Suppose you have kernel heap buffer overflow,
1960.18s - 1962.02s |  or you have a risk condition issue,
1962.02s - 1967.58s |  you can also use this method to make your exploiter easier.
1967.58s - 1971.62s |  The first step, you can spray a large amount of this memory
1971.62s - 1974.58s |  descript into the kernel heap.
1974.58s - 1977.14s |  And then you trigger your vulnerability.
1977.14s - 1980.62s |  Suppose you have a kernel heap overflow issue.
1980.62s - 1985.42s |  You can overflow it from here into this ops.
1985.42s - 1990.22s |  Then you can control the physical address and ops.
1990.22s - 1992.30s |  And then you can try to do memory
1992.30s - 1995.58s |  map on this memory object.
1995.58s - 1997.58s |  If you are lucky, you succeed.
1997.58s - 2001.38s |  Then you can map the whole kernel physical memory
2001.38s - 2002.70s |  to the user space.
2002.70s - 2005.66s |  But if you are not lucky, you can try it again and again
2005.74s - 2007.50s |  until you succeed.
2007.50s - 2012.46s |  So that's how we expand this method to a more generic case.
2012.46s - 2016.26s |  And maybe you remember we have a bonus,
2016.26s - 2019.70s |  which we can bypass the case using this method.
2019.70s - 2022.82s |  So look at the structure carefully.
2022.82s - 2027.22s |  You may find that there are lots of kernel points,
2027.22s - 2031.54s |  like the page table is a pointer and the host PTR.
2031.54s - 2033.30s |  And also we have the SGT.
2033.30s - 2035.90s |  You might think, oh, we will need
2035.90s - 2038.50s |  to get a case information first.
2038.50s - 2043.58s |  We have to point this point to a digital address.
2043.58s - 2047.30s |  But in fact, you don't have to worry about this field.
2047.30s - 2048.94s |  Because in most of the case, if you
2048.94s - 2052.70s |  don't call some special control by yourself,
2052.70s - 2056.10s |  these fields are not used in most of the case.
2056.10s - 2061.22s |  So you can just overwrite these fields with a capital value
2061.22s - 2062.70s |  or whatever you want.
2062.70s - 2065.90s |  You can just overwrite the page table, the host PTR,
2065.90s - 2067.78s |  and the GPU address.
2067.78s - 2071.06s |  All this stuff are not used.
2071.06s - 2073.90s |  The only thing you care about is the physical address,
2073.90s - 2076.30s |  the size, and the ops.
2076.30s - 2079.10s |  You might all think, oh, here we have the ops.
2079.10s - 2080.82s |  It's also a pointer.
2080.82s - 2083.98s |  So you have to know the original value,
2083.98s - 2086.74s |  or you have to know the ASR information.
2086.74s - 2091.90s |  But actually, no, you don't have to know the KSR information.
2091.90s - 2094.22s |  You look at the original value carefully.
2094.22s - 2097.10s |  You can see this is the original value,
2097.10s - 2101.34s |  and this is the target value we want to modify.
2101.34s - 2105.30s |  You can see that the high bytes are actually the same.
2105.30s - 2106.62s |  Why are they the same?
2106.62s - 2111.02s |  Because the KSR is based on the page.
2111.02s - 2112.10s |  It's page-based.
2112.10s - 2115.86s |  So if the two function points are in the same page,
2115.86s - 2120.50s |  so they have the same high bytes that are in the same page.
2120.50s - 2122.98s |  So all these bytes are the same.
2122.98s - 2124.86s |  So you can actually ignore these bytes
2124.86s - 2128.70s |  and overwrite from the beginning to the lowest byte,
2128.70s - 2130.14s |  overwrite it to here.
2130.14s - 2133.02s |  Then you don't have to care about the KSR.
2133.02s - 2135.78s |  So that's how we bypass the KSR.
2135.78s - 2139.62s |  And once in here, you can see the lowest byte already
2139.62s - 2141.78s |  known from the kernel firmware.
2141.78s - 2145.54s |  So you don't have to acquire additional information.
2145.54s - 2149.66s |  You can bypass the KSR and get the expert working.
2149.66s - 2152.86s |  You just overwrite to the lowest byte
2152.86s - 2155.74s |  and ignore the high bytes.
2155.74s - 2158.18s |  Yeah, that's how we bypass the KSR.
2158.18s - 2161.10s |  And in some case, maybe you are not so lucky.
2161.10s - 2164.38s |  You get the following situation.
2164.38s - 2166.58s |  You can see it's not in the same page,
2166.58s - 2169.34s |  but in the source code, they're near each other.
2169.34s - 2172.98s |  So in most of our case, the original value
2172.98s - 2175.18s |  is near the target value.
2175.18s - 2178.18s |  So it's just like a 4-bit difference.
2178.18s - 2181.54s |  So for 4-bit, it's just a 16 possibility.
2181.54s - 2183.94s |  You can try 16 times.
2183.94s - 2187.26s |  So you can undo the brute force for 16 times.
2187.26s - 2189.30s |  Then you can bypass the KSR.
2189.30s - 2194.66s |  So that's how we bypass the KSR, and that's the exploit.
2194.66s - 2197.30s |  We'll get to the demo.
2197.30s - 2198.66s |  The demo is online.
2198.66s - 2201.86s |  You can view the demo online.
2201.86s - 2203.62s |  Also, we'll play it here.
2203.62s - 2208.54s |  You can see here, when we record this demo,
2208.54s - 2212.66s |  we are recording it on a pretty famous smartphone
2212.66s - 2216.86s |  using the latest Qualcomm SoC, using
2216.86s - 2222.46s |  Snapdragon generation 8 with the latest security patching.
2222.46s - 2225.22s |  That will start with the shell user.
2225.22s - 2228.26s |  Of course, you can also use untracked application user.
2228.26s - 2229.86s |  It's no difference.
2229.86s - 2232.50s |  So we are trying to get a root shell.
2232.50s - 2237.38s |  Of course, we don't have a root privilege now, so this fails.
2237.38s - 2239.30s |  We will start our exploit.
2239.30s - 2242.02s |  And the first step is to trigger the vulnerability
2242.02s - 2246.54s |  and control a large amount of physical pages.
2246.54s - 2249.14s |  So we trigger the vulnerability again and again.
2249.14s - 2253.38s |  And here, we think we have enough pages.
2253.38s - 2255.58s |  So now you can see we have controlled
2255.58s - 2257.30s |  enough physical pages.
2257.30s - 2259.22s |  Then we go to the next step.
2259.22s - 2261.78s |  We trigger a system no memory.
2261.78s - 2265.22s |  We allocate a lot of memory from the user space.
2265.22s - 2270.38s |  So all the cached memory, all the system memory,
2270.38s - 2273.82s |  unused system memory will be returned to the kernel.
2273.82s - 2276.06s |  So we can do heap spray.
2276.06s - 2280.02s |  We create a lot of these VBO entries.
2280.02s - 2281.82s |  And then we are lucky.
2281.82s - 2287.14s |  Some of the VBO entries will be located in the controller page.
2287.14s - 2289.58s |  So we scan the controller page.
2289.58s - 2294.02s |  And then we can find this controlled object.
2294.02s - 2298.18s |  You can see we found one controlled memory description
2298.18s - 2299.06s |  object.
2299.06s - 2301.94s |  So this object has a physical address, size,
2301.94s - 2303.62s |  and the ops we want.
2303.62s - 2308.86s |  So we can patch this structure, the ops.
2308.86s - 2310.62s |  We will modify the physical address.
2310.62s - 2314.70s |  You can see this A801 is actually
2314.70s - 2316.54s |  the kernel physical address.
2316.54s - 2318.46s |  And the size is the kernel size.
2318.46s - 2321.78s |  So we have patched the structure.
2321.78s - 2325.14s |  And now we can do memory map, map this structure
2325.14s - 2327.34s |  to the user space.
2327.34s - 2330.78s |  So we can map the whole kernel memory to the user space
2330.78s - 2333.38s |  and patch the kernel memory.
2333.38s - 2335.86s |  Here we have patched the kernel version.
2335.86s - 2339.50s |  And also we patched some of the code in the kernel.
2339.50s - 2340.98s |  So we can get a root.
2340.98s - 2344.34s |  So you can see now we are the root user.
2344.34s - 2346.86s |  So that's the demo.
2346.86s - 2350.17s |  Yeah.
2350.17s - 2351.01s |  Thank you.
2351.01s - 2355.13s |  I will transfer to Eugene for the next content.
2355.13s - 2356.73s |  Thank you very much, Shilin.
2356.73s - 2358.69s |  And with that, I will be speaking
2358.69s - 2361.77s |  about the last section of this presentation, how
2361.77s - 2364.81s |  we found this vulnerability, which methodology is
2364.81s - 2367.61s |  applicable when you are doing bug hunting for GPU kernel
2367.61s - 2372.81s |  modules, and what we can do to improve security of the GPU
2372.81s - 2375.65s |  in the mobile space.
2375.65s - 2378.01s |  Well, first of all, we identified this vulnerability
2378.01s - 2380.85s |  via manual code review when we were doing patch analysis.
2380.85s - 2383.05s |  And by patch analysis, essentially,
2383.05s - 2385.77s |  we use a collective term where we
2385.77s - 2388.13s |  look at the security fixes, which
2388.13s - 2390.81s |  are published in the Android Qualcomm Security Bulletin.
2390.81s - 2393.25s |  We also look at the security research published
2393.25s - 2395.09s |  by other security researchers.
2395.09s - 2397.13s |  And this is very important for such complex cases
2397.13s - 2400.69s |  and big targets such as GPU, because the state is very big.
2400.69s - 2403.17s |  And as Shilin explained earlier in this presentation,
2403.17s - 2404.49s |  there is a lot of moving parts.
2404.49s - 2407.33s |  So in order to have a holistic understanding,
2407.49s - 2413.69s |  it's important to read others' blog reports
2413.69s - 2418.41s |  to better understand the domain in this area.
2418.41s - 2420.17s |  Originally, we wanted to put on the slide
2420.17s - 2423.09s |  a very cool chain of vulnerabilities, which
2423.09s - 2425.65s |  we did variant analysis for.
2425.65s - 2428.13s |  So for example, Qualcomm internally
2428.13s - 2429.81s |  identified one of the issues.
2429.81s - 2432.13s |  They published a fix in their security bulletin.
2432.13s - 2436.21s |  Then a security researcher looked at this fix.
2436.21s - 2439.57s |  They found another related issue in this area.
2439.57s - 2442.37s |  They wrote a blog post and published it.
2442.37s - 2445.77s |  While looking at these two fixes by Qualcomm and the security
2445.77s - 2448.73s |  researcher, we managed to identify another problem
2448.73s - 2451.69s |  in the related area.
2451.69s - 2453.85s |  But later, we decided to remove this information,
2453.85s - 2457.97s |  because the issue might still be under remediation
2457.97s - 2460.97s |  and not to tip off the folks working
2460.97s - 2462.61s |  on the other side of the fence.
2462.61s - 2464.53s |  We decided to put this quote here,
2464.53s - 2466.81s |  which I think reflects the idea which we
2466.81s - 2470.54s |  would like to convey in the slide.
2470.54s - 2472.50s |  While speaking about methodologies,
2472.50s - 2474.50s |  we cannot skip fuzzing, because fuzzing
2474.50s - 2477.06s |  is one of the central methodologies we use.
2477.06s - 2479.54s |  This is one of the most efficient and productive ways
2479.54s - 2483.42s |  of finding bugs in the modern complicated software
2483.42s - 2484.50s |  and the firmware.
2484.50s - 2488.58s |  And there is a lot of benefits, I think,
2488.58s - 2489.74s |  quite obvious for fuzzing.
2489.74s - 2491.66s |  So on this slide, particularly, we
2491.74s - 2494.94s |  will focus on challenges applicable to fuzzing GPU
2494.94s - 2501.90s |  targets and think about how can we overcome those
2501.90s - 2504.30s |  or how can we solve them.
2504.30s - 2509.50s |  So first of all, to enable efficient fuzzing of the GPU
2509.50s - 2513.94s |  drivers, there is a lot of dependence on the hardware.
2513.94s - 2516.10s |  As we have seen, this particular vulnerability
2516.10s - 2518.62s |  is in the misconfiguration of the IOMMU.
2518.62s - 2521.66s |  So in order to theoretically find this vulnerability,
2521.66s - 2523.62s |  we would need to do on-device fuzzing.
2523.62s - 2525.66s |  And although this is possible, this
2525.66s - 2528.14s |  makes fuzzing a little bit less scalable,
2528.14s - 2529.86s |  because we would actually need to run it
2529.86s - 2531.74s |  on the hardware versus, let's say,
2531.74s - 2533.82s |  pure software fuzzing, which can scale
2533.82s - 2536.18s |  with the number of the fuzzing cores.
2536.18s - 2538.46s |  This is not a limitation, but this
2538.46s - 2541.78s |  is one of the interesting observations,
2541.78s - 2544.86s |  because I know that there are some other GPU vendors which
2544.86s - 2546.74s |  enable building their kernel mode
2546.74s - 2549.58s |  components in the architecture-independent way.
2549.58s - 2551.66s |  So basically, there is a separation
2551.66s - 2553.34s |  between software and hardware logic,
2553.34s - 2558.98s |  so it's possible to build driver and run it
2558.98s - 2562.22s |  without the hardware to be able to test and fuzz
2562.22s - 2565.50s |  the generic functionality implemented in the software.
2565.50s - 2567.90s |  And another approach is using the emulation-based fuzzing
2567.90s - 2569.78s |  to have an emulator for that.
2569.78s - 2572.78s |  But I guess this is a little bit more complicated approach,
2572.78s - 2574.98s |  because this requires manual work in order
2574.98s - 2576.98s |  to understand how the hardware actually works,
2576.98s - 2584.18s |  in order to be able to emulate it in the emulator.
2584.18s - 2585.90s |  This particular issue was identified
2585.90s - 2589.22s |  in the MMU and IOMMU domain.
2589.22s - 2591.14s |  And this is actually a very common pattern
2591.14s - 2594.22s |  in the GPU bugs reported these days,
2594.22s - 2597.38s |  where the physical pages for the back-end storage
2597.38s - 2599.98s |  are released back to the kernel, while at the same time,
2599.98s - 2603.54s |  there is a mapping in the IOMMU for the GPU,
2604.54s - 2607.90s |  which maps these released pages back to the virtual address
2607.90s - 2608.90s |  space of the GPU.
2608.90s - 2611.02s |  And this is very difficult to detect with fuzzing,
2611.02s - 2612.94s |  because this doesn't lead to any crash.
2612.94s - 2616.22s |  Even if we are lucky enough to hit the race condition here,
2616.22s - 2618.86s |  still, there is no sanitizers which
2618.86s - 2623.38s |  would report us that, hey, you have dangling MMU
2623.38s - 2625.50s |  entries in the page tables.
2625.50s - 2626.74s |  So this is one thing.
2626.74s - 2630.46s |  So probably manual instrumentation of the driver
2630.46s - 2632.18s |  with such checks would help.
2632.22s - 2635.46s |  But again, this is manual work, which makes it less scalable.
2635.46s - 2638.54s |  GPU has a very complicated state machine.
2638.54s - 2640.46s |  As we have seen, there is multiple components.
2640.46s - 2642.50s |  And sometimes, in order to hit certain functions,
2642.50s - 2648.18s |  we would need to have a set of syscalls executed
2648.18s - 2649.46s |  in a very precise sequence.
2649.46s - 2651.82s |  Or if we're speaking about fuzzing with syscaller,
2651.82s - 2653.94s |  probably this is additional custom syscalls,
2653.94s - 2656.02s |  which needs to be written for that.
2656.02s - 2660.82s |  And of course, fuzzing concurrency, concurrent code
2660.86s - 2663.34s |  is not straightforward.
2663.34s - 2665.86s |  Because there are some problems with reproducing
2665.86s - 2669.58s |  and problems with hitting those vulnerabilities.
2672.70s - 2674.58s |  Probably the final slide before we wrap it up,
2674.58s - 2676.42s |  the ultimate mitigations question mark.
2676.42s - 2677.26s |  Why question mark?
2677.26s - 2680.66s |  Because, well, I guess suggesting mitigations for GPU
2680.66s - 2683.06s |  is really not straightforward.
2683.06s - 2688.58s |  And this is more about thinking in points about how can we
2688.58s - 2691.58s |  make GPU security better in the mobile space.
2691.58s - 2693.82s |  First of all, one of the major points
2693.82s - 2696.82s |  why GPU is so attractive is because it is widely
2696.82s - 2699.10s |  accessible to untrusted code.
2699.10s - 2702.02s |  Because the untrusted code can directly open the driver
2702.02s - 2704.66s |  and send arbitrary data to it.
2704.66s - 2708.70s |  Android is very known for using IPC and binder in order
2708.70s - 2710.26s |  to isolate components.
2710.26s - 2714.30s |  So maybe one of the ideas is to move a GPU from in-process hull
2714.30s - 2715.70s |  into the out-of-process hull.
2715.70s - 2718.18s |  I know this will impact performance.
2718.18s - 2720.18s |  And performance is very important for GPU.
2720.18s - 2722.38s |  This might create some backward compatibility issues.
2722.38s - 2724.42s |  But this is one of the ideas to think about.
2724.42s - 2728.02s |  And additionally, the usage of memory-safe languages
2728.02s - 2732.26s |  in the driver, I think, based on our experience,
2732.26s - 2736.06s |  they might mitigate the majority of root causes, which
2736.06s - 2738.70s |  lead to problems such as integer overflows,
2738.70s - 2744.26s |  or in this particular case, integer race conditions.
2744.26s - 2747.30s |  And I think with that, we hit almost end of our time.
2747.30s - 2750.14s |  And last slide, thank you very much for your attention.
2750.14s - 2753.10s |  A small, shameless marketing plug here.
2753.10s - 2756.58s |  We have our Android offset with google.com,
2756.58s - 2758.90s |  where we publish our security research.
2758.90s - 2762.50s |  And with that, yeah, I think we're
2762.50s - 2765.94s |  happy to take any questions here on stage or offline using
2765.94s - 2768.90s |  this content information here.
2768.90s - 2770.82s |  Thank you very much.