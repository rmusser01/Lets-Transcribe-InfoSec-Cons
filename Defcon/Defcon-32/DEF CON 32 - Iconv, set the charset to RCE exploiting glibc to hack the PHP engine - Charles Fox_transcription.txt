{
  "webpage_url": "https://www.youtube.com/watch?v=11Yv2Ru7gF8",
  "title": "DEF CON 32 - Iconv, set the charset to RCE  exploiting  glibc to hack the PHP engine - Charles Fox",
  "description": "Upon its discovery, CVE-2024-2961, a very old buffer overflow in the glibc, seemed like a terrible bug. Within the prism of the PHP engine, however, the vulnerability shone, and provided both a new remote code execution vector and a few 0-days.\n\nThis talk will first walk you through the discovery of the bug and its limitations, before describing the conception of remote binary PHP exploits using this bug, and through them offer unique insight in the internal of the engine of the web language, and the difficulties one faces when exploiting it.\n\nAfter this, it will reveal the impact on PHP's ecosystem, from well-known functions to unsuspected sinks, by showcasing the vulnerability on several popular libraries and applications.",
  "channel_url": "https://www.youtube.com/channel/UC6Om9kAkl32dWlDSNlDS9Iw",
  "duration": 2580,
  "channel": "DEFCONConference",
  "uploader": "DEFCONConference",
  "upload_date": "20241016"
}

0.53s - 2.53s | This text was transcribed using whisper model: large-v2

 Hi
3.93s - 5.93s |  Yeah, thank you
7.97s - 11.33s |  Well, thank you for coming to my talk because I know it's the last talk for today
11.33s - 16.31s |  So I guess everybody's pretty tired of seeing talks, but hopefully it will be interesting
16.73s - 21.73s |  So the bug is a bug that I found by auditing PHP, but it's not on PHP
21.73s - 28.97s |  It's a bug in the gdpc and it targets icons, which is the character set conversion library of the gdpc
29.21s - 34.81s |  And I actually was able to use the bug to compromise the PHP engine in two different ways
35.25s - 38.37s |  Remotely and this is this is what I'm going to talk about today
39.89s - 41.01s |  So
41.01s - 45.61s |  First I will describe how I found the bug it was by complete accident by complete chance
45.85s - 51.53s |  But the way I will explain it to you will serve as an introduction to the next section
51.53s - 54.53s |  Which is gonna which is gonna be about attacking PHP filters
54.53s - 57.13s |  If you don't know what the PHP filter is, don't worry
57.13s - 61.73s |  I will explain what this is and also afterwards I will attack a different way
61.73s - 65.69s |  I will attack PHP by targeting direct calls to icons and
66.65s - 71.69s |  Well after this, hopefully we'll have time for a conclusion and maybe a little bit of a bonus
72.93s - 74.29s |  so
74.29s - 77.77s |  Regarding the discovery. Well to understand how I found the bug
77.89s - 82.09s |  We need to understand what you can do when you have a favorite primitive in PHP
82.09s - 85.69s |  So code such as this one, but it could also be a fellow
86.53s - 92.57s |  An F open followed by an F reads like any foundry primitive in PHP. What can you do with it?
92.89s - 96.09s |  Well, obviously you can read a file you can really TC password
96.73s - 101.09s |  but you can also force PHP into reading HTTP resource that would work and
102.01s - 104.13s |  FTP resource that would work as well and
104.93s - 107.09s |  there are also other protocols that
107.81s - 112.17s |  You can use which are PHP specific such as far colon slash slash
112.73s - 114.73s |  it will let you read the
116.29s - 122.17s |  Contents of archive. So for those who don't know for archive, it's like a jar for Java
122.17s - 126.33s |  So it's a collection of source files resources and also in PHP
126.33s - 134.05s |  It contains serialized metadata and when you access such a file using far colon slash slash the metadata will be deserialized
134.37s - 135.45s |  so
135.45s - 140.61s |  There was an attack for the longest time that was that you could upload a file to a server
141.37s - 148.25s |  Any file an image or anything and then you would use your file with primitive to load it as a far and that would give you
148.45s - 151.65s |  Arbitrary deserialization which oftentimes meant RCE
153.33s - 157.33s |  Sadly in PHP 8 they have disabled the deserialization of the metadata
158.13s - 166.01s |  Because they actually don't use the metadata. So it was completely useless and also in older versions big frameworks have been removing
166.61s - 171.13s |  The far colon slash slash protocol because they don't use it and they also know that
171.69s - 178.19s |  It is very dangerous like magento got completely demolished with this with the the far colon slash like bug
178.49s - 180.49s |  There there was like hundreds of bugs
181.25s - 185.05s |  reported to them using far colon slash slash so they just removed it entirely and
185.81s - 190.25s |  also, it's going to be harder to exploit even not on PHP 8 this bug because
191.13s - 194.49s |  Deserialization is going to get harder and harder to exploit as time goes by because
194.97s - 199.53s |  Mainly because actually types are making a comeback, but that's probably subject for another talk
201.41s - 206.13s |  So people have taken the interest into another PHP specific protocol, which is called PHP
206.93s - 212.05s |  Well, you can guess it's PHP specific and there's a sub part of this which is called PHP filter
212.05s - 218.15s |  And what it does is that it will read a resource and apply some filters that you have chosen onto it
219.07s - 224.63s |  It will then return the resource as if it was the original file, but we felt us apply onto it
224.63s - 228.79s |  So a good example of this and probably the simplest one that you can get is this string
228.79s - 232.79s |  So you have PHP filter then one filter which is convert the base 64 encodes
232.79s - 237.55s |  You can probably guess what it does converse to base 64 and then the resource is it is a password
238.19s - 242.53s |  So what you get when you do a file get contents of this is file get
243.13s - 244.65s |  Is it is password sorry
244.65s - 250.05s |  But basics if one code it and the good thing about these filters is that you can stack as many as you want
250.05s - 256.73s |  So instead of basic c4 encoding once I can do it twice, but I could also do it like a thousand times. It will work
258.85s - 261.57s |  Well, obviously you can do other things than basic c4 encodes
261.73s - 263.73s |  you might be able to
263.85s - 270.69s |  Put your string in uppercase with string dot upper or put it in lowercase with string dot lower and do some very very old
270.73s - 275.01s |  Crypto we've wrought 13. I don't know why it's there, but it actually works and
275.77s - 281.73s |  You can also use filters that are not documented, but very useful as an attacker such as D chunk
281.73s - 283.73s |  I will talk about it later and
284.05s - 286.41s |  Well, you can also use the star for today
286.41s - 292.81s |  Which is convert that icons that X dot Y and what it will do is that it will use the icon of library of the gdpc
292.81s - 298.29s |  To convert your stream from charset X to charset Y just to give you a quick example
298.61s - 301.69s |  Say that you have etc password you want to convert it from
302.29s - 305.41s |  UTF-8 to UTF-16 you can use this string
305.81s - 311.53s |  This PHP filter string and it will do it automatically as you can see in the X dump right underneath
313.81s - 315.05s |  So
315.05s - 318.21s |  Well these filters they've been like attacked a lot
318.45s - 322.65s |  There's been a lot of research on to them and the consensus in
323.17s - 329.93s |  2023 was that you could add using filters an arbitrary prefix to any file so you could dump etc password
329.93s - 334.97s |  but with an arbitrary prefix just by picking the right filters to apply on to it and
336.29s - 340.41s |  Myself what I wanted to see was whether or not I could get an arbitrary suffix as well
340.97s - 345.33s |  So an arbitrary prefix on some text and then some suffix as well
345.33s - 350.41s |  And the idea is very simple say that you have this piece of code of course you have a favorite primitive
350.41s - 354.55s |  But then right afterwards you have a JSON decode, so if the file is not valid JSON
355.05s - 358.05s |  Your favorite primitive is useless like you cannot read etc password
358.17s - 365.61s |  But if you can make your file look like JSON using an arbitrary prefix and suffix you can make the JSON decode works
366.09s - 372.77s |  work sorry and therefore you can well make PHP think it's JSON and return to you the contents of etc passwords and
372.93s - 379.85s |  This research it actually works. It has a few preconditions, but you can actually pull it off and I called the tool
379.85s - 384.77s |  Vraap Vraap and I have made a blog post about it. It's on our company's blog
384.77s - 387.61s |  so I'm bernie nix.io as you can see on the bottom and
388.73s - 392.65s |  Well the important part in all this is that at the beginning
392.65s - 396.29s |  I didn't know much when I started this research about PHP filters
396.37s - 400.57s |  So I built a few scripts just to try and do some conversion
400.57s - 405.21s |  So maybe from charset A to B then apply a basic C4D code then from C to D
405.37s - 409.45s |  Like lots of conversions just to see what I could get as a result
409.45s - 413.25s |  and I actually got a crash while doing this so I was pretty surprised and
414.05s - 419.13s |  I've been working with PHP for like 20 years, so I kind of felt like it was due to PHP
419.13s - 424.65s |  You know because it's always PHP, but this time it wasn't PHP. It was actually due to the glibc
424.65s - 427.95s |  So the base library for most Linux programs
428.29s - 435.09s |  because when PHP does the character set conversion using convert the type of it will use the icon library of the glibc and
435.45s - 439.89s |  What this library does is that you pick an input charset and an output charset
439.89s - 445.97s |  And then you feed it buffers, and it will convert from your input buffer to the output buffer from one charset to another
447.33s - 453.73s |  the thing is when you call the icon function you give it an input buffer with some size and an output buffer with some other
453.73s - 455.37s |  size and
455.37s - 460.61s |  Obviously it should guarantee that it will now read more bytes in the input buffer than it should or more
460.73s - 466.77s |  Write more bytes than it should in the output buffer and generally does so pretty well like there's no overflow
467.09s - 472.85s |  But sometimes it fails to do so and this is exactly why I got my crash. It is
473.37s - 477.41s |  That's when you convert to some very obscure charset, which is called ISO
478.25s - 486.33s |  2022 CNX in some cases it will not check the bounds of the output buffer before writing some escape sequences and
486.77s - 489.25s |  That means that as a result as an attacker
489.45s - 493.41s |  You if you are able to convert some text to ISO 2022 CNX
493.41s - 498.73s |  You will get an overflow of one to three bytes with the very specific values that I've written here
498.73s - 504.73s |  So your overflow could be with dollar star H or dollar plus I or dollar plus J any of these six values
504.73s - 506.73s |  But only these six values
507.97s - 511.77s |  To give you a quick idea of the characters that you can use to trigger the bug
511.93s - 516.45s |  Those are the characters that I trigger the bug with so those are Chinese characters
516.45s - 519.29s |  I have no idea what they mean, but they give you a buffer overflow
521.61s - 527.25s |  So the vulnerability that we have it's already pretty bad like it's a one to three bytes overflow
527.25s - 533.01s |  And it's fixed by values that you don't control the bytes in addition to this you have horrible conditions
533.01s - 535.01s |  Like you have to control the output charset
535.05s - 539.85s |  You have to set it to ISO 2022 CNX like nobody heard about it in in the room
539.85s - 544.21s |  I guess so yeah, you need to find an application that will let you pick your output charset
544.21s - 546.77s |  Otherwise you will not find an application that does it willingly
547.33s - 553.05s |  in addition to this you need to control part of the input buffer so that you can put in the Chinese characters and
553.89s - 560.13s |  Again a third condition is that you need to have a suitable output buffer if the output buffer is too small
561.05s - 566.01s |  Sorry too big compared to the input buffer even though you may have an overflow in theory
566.01s - 572.05s |  You're not going to be able to reach the end of the bounds of the output buffer before you trigger your escape sequence
572.05s - 573.41s |  And therefore you are not overflow
573.41s - 579.05s |  and this is like what was the most annoying part in looking for targets for this bug because I
579.45s - 585.77s |  Thought I had a bug in libxml2 because you can send an encoding using when you send your XML
585.89s - 592.49s |  But the output buffer when you did the conversion was way too big and therefore I couldn't exploit and that's only one of many
592.65s - 597.69s |  And so after probably weeks of looking for targets
597.69s - 603.77s |  I got super frustrated and I went back to PHP filters because that's the only thing that I could make crash and
604.33s - 608.85s |  That's actually the only thing that crashed without even me trying for it to crash. So I
609.61s - 614.69s |  was like, okay, that's probably my best bet to exploit this bug and I focus on to it and
615.25s - 623.53s |  The idea was to convert file read primitives in PHP any fabric primitive into remote code execution like straight up using this binary bug
624.53s - 627.73s |  So to explain to you how we might be able to do this
627.77s - 631.81s |  we need to think about how PHP does allocations and the allocations and
632.81s - 637.91s |  For this we need to understand PHP's heap, but don't worry. That's probably simplest heap that you're ever gonna see
638.25s - 642.97s |  So it's 500 500 sorry in 12 pages of OX a thousand bytes each
642.97s - 648.89s |  So four thousand ninety six bytes and each page contain chunks of some size. So it might be a chunk
649.53s - 655.61s |  Sorry in page 10, you may have chunks of size OX 100 in page 11. You may have chunks of size OX 30, etc
655.61s - 661.17s |  Etc. And then when you free a chunk, it will go into the free list for this chunk size
661.33s - 666.17s |  So if I free a chunk of size OX 100 it will go into the free list for size OX 100
666.17s - 671.73s |  If I free a chunk of size OX 10, it will go into the free list for chunks of this size as well
671.73s - 675.05s |  And the free list are singly linked list. They are lasting
675.57s - 679.81s |  First out so that means that if I free a chunk of some size and allocate a new one afterwards
679.81s - 686.25s |  It will be allocated exactly at the same spot and it's very similar for those who don't would do PT malloc
687.25s - 692.83s |  Exploitation to the leap city cage, but completely unlimited and without any protections
694.01s - 695.25s |  so
695.25s - 699.81s |  Just to give you an idea of what we can do with one to three bytes overflow in the PHP heap
699.85s - 703.21s |  Let's have a look at this example. So on the left you have the heap
703.65s - 710.33s |  Okay with five hundred and twelve pages and in page five in this example, I have chunks of size OX 400
710.45s - 712.61s |  So in page five, I have four chunks
713.17s - 718.73s |  In my example, I have chunk one that is allocated chunks free that is allocated checking two and four that are not
719.09s - 724.57s |  So in chunk two and chunk four since they are in the free list for chunks of size OX 400
724.69s - 727.49s |  That means that they contain a pointer to the next free chunk
727.89s - 732.73s |  So if I was to overflow even with one byte from chunk one
732.73s - 737.89s |  I would be able to at least partially modify the pointer that is control that is contained
737.89s - 743.85s |  Sorry in chunk two and that would be a way to alter some free list pointer and in the end probably
744.53s - 747.37s |  Be a good starting point for an exploitation
747.81s - 757.63s |  So the PHP heap it looks very very easy to exploit right? There's no metadata. It's page based. There's absolutely no protections
757.63s - 762.87s |  It's really easy to understand. So why is it that there are not that many remote binary exploits?
762.91s - 769.29s |  Well to me the main problem is that the PHP has the one heap for one request policy
769.39s - 773.27s |  So if you send an HTTP request PHP will create the heap
773.71s - 778.67s |  Allocate your HTTP parameters into it then run the script. So that means also compiling the script
778.67s - 782.99s |  So you will do like thousands of allocations and the allocations and then it will completely destroy the heap
783.31s - 787.99s |  So now imagine that you have a use-after-free on some VPN instance for instance
788.79s - 792.79s |  What you would do to exploits would be to send a few requests to set up your heap
792.95s - 800.25s |  Then one more request to like trigger your bug trigger your UAF and then afterwards send a few more requests to use your bug
800.63s - 805.67s |  But here you cannot do this. You have to find a way to trigger bug remotely
805.67s - 809.77s |  So you need a bug in the PHP engine you need an application that lets you trigger the bug remotely
809.81s - 815.13s |  But also you need to use the bug as the request is running before the heap is gone
815.13s - 820.05s |  And this is why it's hard because in between the triggering and the bug of the bug and the usage of the bug
820.05s - 823.83s |  You're not gonna have any way to interact with the HTTP request
823.83s - 827.89s |  Like you've sent every HTTP parameter and it's done like it's a black box now
828.37s - 832.01s |  And this is to me why it's really really hard to exploit on
832.85s - 839.60s |  PHP remotely
839.60s - 841.72s |  Okay. So in addition to this
841.72s - 847.32s |  There's one thing that we need to understand is how PHP processes PHP filter strings and to do so
848.12s - 850.28s |  You will have a two-step process
850.72s - 856.12s |  Where you will first read the resource as a stream and then it will apply filters one by one onto the resource
856.96s - 862.44s |  so fetching the stream it will use a very standard structure, which is called a bucket brigades and
863.80s - 867.80s |  Each part of the stream is represented as one bucket of a few bytes
867.84s - 868.96s |  So for instance
868.96s - 873.24s |  If you really see password the first bucket may contain five bytes of it is password
873.24s - 878.16s |  Then the second bucket will contain the next few bytes or for instance ten bytes and the buckets
878.16s - 881.32s |  We will contain a few more bytes that come right after etc, etc, etc
881.76s - 888.44s |  So that's a way to be able to represent any stream a list of buffers that are linked together and that may have different sizes
891.32s - 895.24s |  Once you have your stream you can start applying filters onto them
895.24s - 899.40s |  So you take the first filter and you take the first bucket and you apply the filter onto it
899.92s - 906.60s |  So for instance if it's base 64 decodes PHP will take the first bucket and decode the data disease that is into it
906.80s - 912.88s |  Then it will be able to process bucket 2 which it will do and then bucket 3 and at the end you get a new bucket
912.88s - 915.48s |  Brigade on which the first filter has been applied
915.60s - 920.52s |  So what you can do is start working on the second filter then on the third one, etc
920.80s - 926.56s |  Up until the end and now you have a stream that is being that has been completely processed with filters and
927.16s - 931.28s |  Your PHP filter string has been completely perfectly and look and old
932.24s - 934.68s |  So if we look back at everything now
934.68s - 939.52s |  It looks pretty easy to exploit this fabric because we have a fabric primitive and we want to get our C
939.52s - 943.12s |  But since we have a fabric primitive, well first we can read the binaries
943.12s - 948.12s |  So if I want to have the address of some of some symbol for instance in the lipsy
948.12s - 953.08s |  I just download the lipsy using the fabric primitive if I want to check if the lipsy is patched against the bug
953.08s - 955.56s |  I can also download the lipsy and check the code myself, you know
955.56s - 960.00s |  And so that means that you can find gadgets easily in addition to this
960.48s - 964.24s |  ASLR and PI are not a problem because I can just read proxmaps. So
964.80s - 970.92s |  Any address that I want is going to be probably in proxmaps. So ASLR and PI it's gone
971.44s - 977.28s |  A corollary to this is that the address of PHP the PHP heap is really easy to find in the proxmaps
977.28s - 980.32s |  So I have the address of the PHP which is going to be useful later
980.76s - 985.68s |  In addition to this it kind of feels like they can do arbitrary allocations and the allocations
986.12s - 988.80s |  Simply using the bucket brigade technology
988.80s - 990.68s |  So the way that the stream is
990.68s - 994.48s |  Represented if I can create as many buckets as I want with the sizes that I want
994.48s - 997.40s |  I will probably be able to build an exploit that works
999.32s - 1005.20s |  But on the other side I can I want to have an exploit that works well even in an unknown environment
1005.20s - 1009.00s |  So I don't want to build a new exploit when I'm targeting a wordpress or some very specific
1009.24s - 1014.28s |  Version of PHP or some magento with which has a lot of traffic on the website, you know
1014.28s - 1020.96s |  I want an exploit that just like straight-up works like basically a web exploit even though it's binary and also bonus points if it doesn't match
1022.48s - 1024.52s |  So how can we do this?
1024.52s - 1029.20s |  Well, the first one that we face is that even though there is the bucket brigade technology in PHP
1029.36s - 1032.00s |  You will always get one bucket when you read a stream
1032.00s - 1035.84s |  So if PHP reads ETC password, it will give you one bucket with the whole file
1036.08s - 1039.92s |  If it reads an HTTP resource, it will give you one brick one bucket
1039.92s - 1044.12s |  Sorry with the whole HTTP response into it same for FTP same for everything
1044.12s - 1050.32s |  You always get one bucket and one bucket. It's completely impractical for exploitation because we cannot spray the heap
1050.32s - 1053.60s |  We cannot pad the heap and we can't even use an altered free list
1053.60s - 1056.96s |  Like if we use one bucket to trigger the overflow, we have an altered free list
1056.96s - 1059.68s |  But then we need at least two more locations to be able to use this
1059.68s - 1065.44s |  This altered free list and we cannot do this because we have used our single bucket. So we're not going to be able to exploit
1067.16s - 1067.96s |  Luckily for us
1067.96s - 1073.28s |  There's a single filter that allows us to create as many buckets as we want and this filter is deadly bin flakes
1073.36s - 1075.36s |  What it does is that it will read?
1076.16s - 1078.16s |  your stream and decompress it as
1078.80s - 1083.28s |  With the Zlib algorithm and the way it works is that it will allocate eight pages
1083.80s - 1086.68s |  A buffer of eight pages and then decompress into it
1086.84s - 1091.16s |  If it's not big enough, it will create eight more pages and decompress the rest into it
1091.16s - 1095.24s |  If it's still not big enough, it will create a third bucket, etc, etc, etc
1095.56s - 1100.80s |  So this filter it gives us a way to go from one bucket to as many as we want
1100.84s - 1105.08s |  But the problem that we have is that every bucket has a size of eight pages
1105.08s - 1111.64s |  Which is way too big to exploit because well it takes more it takes two more space too much space
1111.64s - 1116.00s |  Sorry, and also it's not going to be allocated the same way as small chunks
1116.52s - 1118.52s |  so we need a way to change the size of
1118.96s - 1124.76s |  Each of these buckets and a way to do this is to use another filter, which is called G chunk
1125.24s - 1132.72s |  It's undocumented, but it's been used by many actors before so it's pretty well known and the idea is that it will take an HTTP
1132.72s - 1134.72s |  chunked uncoded
1135.08s - 1141.04s |  String and simply decode it. So for those who don't know the HTTP chunked encoding is very simple
1141.12s - 1142.12s |  it
1142.12s - 1144.00s |  consists of sending a
1144.00s - 1149.88s |  Size as ASCII X and then sending the data then a new size as ASCII X and then sending the data, etc
1149.88s - 1157.40s |  So the diction the teaching filter what it does is that it will read a size as ASCII X then reads the amount of bytes
1157.40s - 1158.64s |  That corresponds to this size
1158.64s - 1162.28s |  So for instance, if it reads 8 as in the example, it will read 8 bytes
1162.40s - 1166.36s |  Then it will read 11 and since it's ASCII X it's 17
1166.36s - 1172.60s |  So it will read 17 bytes and then you would read the read the D bytes and then it will read 0 and 0
1172.60s - 1179.96s |  It doesn't indicate an empty chunk. It indicates the end of the D chunking. So when you receive 0 it stops processing the data
1181.40s - 1182.64s |  so
1182.64s - 1186.48s |  Now you probably have an idea of how we can resize our chunks
1186.96s - 1189.96s |  We take bucket 1 if you wanted to have a size of 148
1190.16s - 1196.48s |  We write 148 then 148 bytes and then 0 if we want bucket 2 to have a size of 100
1196.48s - 1202.08s |  we do the same we write 100 then all bytes and then 0 and we do the same with every chunk and
1202.40s - 1206.96s |  Then when we apply D chunk on to this we expect it to resize every single bucket
1207.16s - 1212.24s |  but you may like notice that this will work because even though each bucket is
1213.20s - 1216.08s |  Different they are all processed as one stream
1216.12s - 1220.96s |  So if in bucket 1 you indicate that it's the end of the string of the stream
1220.96s - 1226.08s |  Sorry with the 0 at the very bottom. It will not process bucket 2. It will not process bucket 3
1226.08s - 1232.64s |  It will not process any bucket that comes after so you go back to a single bucket with an arbitrary size, which is completely useless
1233.28s - 1236.44s |  so luckily for us there's a way to improve this and
1237.20s - 1243.80s |  The way to improve this is to pad the size with thousands of zeros such as what we can see here
1243.84s - 1249.40s |  The idea is that in each bucket we will have one chunk size and one chunk data and that's it nothing else
1249.48s - 1252.04s |  So now if the D chunk filter is applied
1252.52s - 1255.20s |  We will have bucket 1 that gets processed
1255.20s - 1261.12s |  it will read the size read thousands of zeros then the real size then the data and then it will go on to bucket 2 and
1261.12s - 1267.00s |  Do exactly the same you will read the size read the data then bucket 3 read the size with the data and you can see
1267.40s - 1270.32s |  That's bucket 1 can be resized to the proper size
1270.32s - 1275.36s |  bucket 2 as well bucket 3 as well and bucket 4 as well and now we have a way to create as many buckets as
1275.36s - 1280.86s |  We want and change the size and this is only with two filters. So it's pretty promising
1282.96s - 1290.64s |  But that's not enough because we can only send one request so we need a whole exploits algorithm in a single request and
1291.28s - 1295.24s |  We have a single PHP filter string. So, how do we do this? Well instead of
1295.80s - 1302.44s |  Only being able to allocate once we cannot want to be able to allocate several times to represent the different steps of the exploits
1302.44s - 1306.60s |  In step one, I want to allocate a few times instead to I want to allocate a few more chunks, etc
1306.60s - 1308.98s |  Etc. And at this point we are not able to do this
1309.20s - 1313.40s |  But to do this what we can do is think about the PHP if it's page based
1313.40s - 1317.24s |  So if I focus my exploitation on one chunk size a single chunk size
1317.24s - 1322.36s |  That means that chunks that are bigger or smaller than this chunk size. They do not really matter
1322.36s - 1328.04s |  I will not have to think about them in my export algorithm if a chunk if of size or x 200 for instance
1328.04s - 1332.84s |  And I'm focusing on chunks of size or x 100 the chunk will not affect my exploitation
1332.84s - 1339.72s |  So at this point if I focus on some very specific chunk size such as weeks 100 chunks that are bigger or smaller
1339.72s - 1342.06s |  They do not matter. It's as if they were they weren't there
1342.06s - 1346.46s |  so the only thing that I need to be able to do is to be able to resize buckets as the
1346.52s - 1349.48s |  Exploitation goes on and to be able to do this. I built
1350.00s - 1351.48s |  buckets that are
1351.48s - 1357.52s |  Russian dolls of d-chunk algorithm. So the idea is that every time I call d-chunk on some buckets
1358.04s - 1364.76s |  Its size will change and that means that I can make buckets appear at some point in the exploitation and then others
1365.12s - 1367.56s |  appear at another step of the exploitation and
1367.96s - 1374.86s |  That basically means that I can allocate and deallocate at will and at this point. I'm really really close to getting an exploit working
1375.92s - 1377.04s |  and
1377.04s - 1383.20s |  the final idea here is that we have a one byte overflow using the icon bug and we want to
1384.92s - 1390.40s |  Use it to alter some free list and get complete control over it and the way that we can do
1390.40s - 1394.96s |  This is a six-step process, which is pretty simple, but I will still explain it to you. It's
1396.24s - 1398.16s |  First we will start in step one
1398.16s - 1402.96s |  So and we're gonna have three chunks ABC and each chunk is freed
1402.96s - 1405.96s |  We have A that points to B and B that points to C
1406.04s - 1410.20s |  Then we allocate these three chunks and we free them we get in step three
1410.20s - 1414.68s |  And the only difference with step one is that now we have C that points to B that points to A so we have reversed
1414.68s - 1415.60s |  the free list
1415.60s - 1421.24s |  Now we allocate in C a buffer which contains at offset 48 an arbitrary pointer
1421.28s - 1424.04s |  Which is represented here with 1 1 2 2 4 4
1424.68s - 1425.96s |  etc
1425.96s - 1432.16s |  Then we allocate B and A and then we free everything and we get into step 5 and we we have exactly the same
1432.76s - 1437.76s |  E play out and free list as in step 1 but in the chunk C
1437.76s - 1441.76s |  We have an arbitrary pointer at offset 48. So now you can probably see where this is going
1442.28s - 1445.76s |  We overflow using chunk A into chunk B
1445.96s - 1452.76s |  So the free list that was B to C is now B to C plus 48 and what we have in C plus 48 is
1452.76s - 1454.60s |  Another pointer that we added ourselves
1454.60s - 1460.96s |  So with three more locations, we will locate B C plus 48 and then we will allocate arbitrary pointer
1461.20s - 1468.16s |  And now we are able to have a write what where which is really really close to getting code execution
1470.16s - 1472.96s |  But now we have to think about like how we can do this
1472.96s - 1477.76s |  Well as I've said before the PHP heap, it's really easy to find it in proc set map
1477.76s - 1481.92s |  So we have it to us and also at the very top of the PHP heap
1481.92s - 1486.00s |  there is a send mmip structure that contains a few things and
1486.96s - 1490.48s |  Also a few alternative heap function pointers
1490.48s - 1493.48s |  So for those again, we do heap exploitation on ptMalloc
1493.48s - 1496.32s |  It would be the same as free hook malloc hook and realloc hook
1496.40s - 1500.40s |  Those are pointers that if you like set them to something else that null
1500.40s - 1503.16s |  They're going to be called inside of the original function
1503.16s - 1509.76s |  And so since it's basically the same as the glibc I can use the glibc technique and I can override free with system
1509.76s - 1515.24s |  So now when PHP wants to free a chunk, it will call free but it will instead call system and this gives me
1515.64s - 1520.12s |  This gives me sorry. Well way to call an arbitrary comment and
1521.04s - 1522.40s |  so
1522.40s - 1525.08s |  With everything put together. What do we have?
1525.20s - 1531.00s |  We have an exploit that works against any targets from PHP 8 to the current version
1531.00s - 1535.40s |  Which is sorry PHP 7 to the current version, which is h3 something
1535.40s - 1539.12s |  So that's 10 years of PHP covered with a single binary exploits
1539.12s - 1542.76s |  And also it works against any PHP application because we can pad the heap
1542.76s - 1548.08s |  So even if like the the website chooses a lot of chunks of size or extra hundred, it will still work
1548.08s - 1553.80s |  It doesn't matter in addition to this the exploit is completely deterministic. So it's 100% reliable
1554.00s - 1557.48s |  So you will never get a crash. So it's pretty cool and
1558.56s - 1561.16s |  final good thing about the exploits is that
1561.40s - 1566.80s |  The payload is really small because the first gadget that we use the first filter that we use is a Zlib inflate
1566.80s - 1570.32s |  so it will decompress the payload so originally it's compressed so it's very small and
1571.32s - 1578.60s |  The last good thing that we can say about the exploit is that it's completely self-contained like the old algorithm of the exploit is
1578.60s - 1583.60s |  In one PHP filter string, which means that you don't have to send additional get or post parameters
1583.60s - 1586.12s |  Like you just need your PHP filter string and you get SE
1586.68s - 1592.16s |  So every file reading primitive now that you have on PHP you have SE instead, which is pretty nice
1593.28s - 1597.00s |  I'm going to show you a demo that actually involves cosmic sting
1597.00s - 1601.96s |  Which is a Magento X6e which is pre-authentication and it came out after I published my bug
1601.96s - 1606.56s |  so it was in June and the original impact was being able to read files and
1607.40s - 1612.44s |  Using this file that you've read you would be able to craft API keys. And so you would get
1613.40s - 1619.16s |  An access which is similar to an administrator level on Magento, but you wouldn't be able to get SE
1619.40s - 1623.92s |  But with the bug that we have now we get the SE easily because we have an X6e
1623.92s - 1629.92s |  So we can force it into reading any file and therefore we can read a PHP filter string and get SE
1630.56s - 1633.09s |  so
1633.09s - 1635.01s |  quick demo
1635.01s - 1637.01s |  Which is not on the right screen
1643.53s - 1645.73s |  So I cannot see it but
1646.25s - 1652.61s |  It's probably pretty easy to understand you have the Magento website on the left and then you have an exploit on the right and in
1652.61s - 1655.73s |  A few moments you will have a shell on the bottom
1656.73s - 1664.56s |  There you go
1674.73s - 1676.73s |  Nope oh
1684.84s - 1686.84s |  Yeah, yeah, right, thanks
1687.92s - 1689.92s |  There we go, thank you
1691.00s - 1705.00s |  So, oh I lost my on the other screen. I lost it. Okay. There we go
1705.88s - 1707.88s |  Okay, does that work
1708.28s - 1709.60s |  Yeah
1709.60s - 1715.68s |  Okay. So now that we have exploited PHP filters, we want to do a completely different exploitation because
1716.24s - 1721.64s |  PHP filters are not the only way in which can reach icon using PHP
1721.72s - 1726.44s |  There's another way that is way simpler. It is when PHP calls icon directly
1727.16s - 1736.31s |  And so there's a PHP function that does this it's called icon. So
1736.95s - 1741.67s |  How do we exploit such a call to icon well, it's very very different to
1742.43s - 1745.27s |  The attack that we've seen using PHP filters
1745.71s - 1749.15s |  So here we don't have a favorite primitive
1749.15s - 1754.47s |  So we cannot just read proxy maps or read like the lipsy or anything like we need to go
1754.47s - 1756.15s |  I would say old-school
1756.15s - 1764.07s |  Exploitation where we need an info leak to get some pointers and then we can start going with the exploitation and in PHP generally
1764.07s - 1766.07s |  which when you want to have
1767.99s - 1773.35s |  An info leak what you do is that you will try and alter the length field of a ZenString
1773.55s - 1779.79s |  So ZenString it's the representation of PHP of your PHP string and the length field
1779.79s - 1781.41s |  It will store the size of the string
1781.41s - 1786.81s |  So if you are able to change the length of a string and then it gets it gets displayed
1786.81s - 1787.31s |  Sorry
1787.31s - 1787.81s |  well
1787.81s - 1795.39s |  you are able to make PHP display more bytes than it should and probably display like lots of useful information from the heap such as
1795.39s - 1797.11s |  addresses
1797.23s - 1802.83s |  Sadly for us the bug that we have as I've said really really bad. We only have one two, three bytes overflow
1802.83s - 1806.59s |  So if we try to overflow into a ZenString, we will just overwrite the ref count
1807.51s - 1810.39s |  With values that we don't even control. So it's pretty useless
1811.79s - 1813.79s |  so what we need to do is
1814.31s - 1819.75s |  Kind of the same as before where we alter some free lists and if we manage to alter some free lists
1819.75s - 1821.71s |  We are able to make two chunks overlap
1821.71s - 1827.03s |  And if we have two chunks that overlap we can use the first one to store a string that is bound to be displayed
1827.03s - 1832.43s |  And then use the second one on top of it to overwrite the length field and when the string gets displayed
1832.43s - 1836.39s |  We actually are able to see what comes afterwards in memory
1838.53s - 1842.83s |  The problem is that here we completely rely on the code beforehand
1842.83s - 1849.15s |  We could like implement an algorithm using PHP filters as I've shown but here we only have a single call to icon
1849.15s - 1851.15s |  And that's it. Nothing else. So
1851.39s - 1853.39s |  Getting it to work would
1854.03s - 1857.27s |  Make us like reliant on the code that comes after
1857.83s - 1863.55s |  The call to icon and to explain this a very simple example say that you have this piece of code
1864.99s - 1871.71s |  We control the output charset, we control the input text so it's clear that we can trigger the bug
1872.83s - 1876.27s |  But right after the bug has been triggered the script will end
1876.63s - 1881.79s |  So there's absolutely no way for us to use the bug after it's been triggered because the heap will be destroyed
1882.79s - 1888.31s |  If you're lucky, however, you might find a line such as this one after your call to icon
1888.87s - 1896.35s |  This line is the same as splits in Python. So it will take a string and explode it. So split it along a token
1896.35s - 1898.35s |  so here the token is new like and
1899.31s - 1901.39s |  If you have a line such as this one
1901.39s - 1907.43s |  you can create as many chunks as you want because it will take your string and split it along a non separator and
1907.75s - 1911.95s |  That will give you a way to use the bug right after it's been triggered and then probably
1912.51s - 1916.31s |  Exploits the bug. So this is what I call a code gadget actually
1916.31s - 1921.75s |  that's a way to get to using your bug starting from the
1922.55s - 1924.55s |  position where icon has been called and
1925.91s - 1930.47s |  To give you an idea of how it can be implemented in in the real world
1930.47s - 1935.23s |  I will show you a demo well and explain to you the demo on round cube
1935.87s - 1943.19s |  Round cube for those who don't know it's a web mail that is very much used in it's probably the most well-known in PHP
1943.23s - 1947.55s |  it's used by hostess generally or private companies even I've seen it a lot and
1948.91s - 1951.07s |  Well, yeah, it's it's used a lot
1951.59s - 1954.83s |  And so when you're logged into round cube and you want to send an email
1955.27s - 1957.63s |  You have to specify email addresses
1957.63s - 1963.95s |  And so you specify the two fields the CC field and the BCC field you can guess what they are
1963.95s - 1965.79s |  You've already sent an email
1965.79s - 1968.19s |  in addition to this you can send
1968.91s - 1972.75s |  Another parameter which is charset and every parameter that you send
1972.75s - 1975.67s |  So the underscore to underscore CC and underscore BCC parameter
1975.83s - 1980.35s |  They are all going to be cast to the charset that you said and it's going to be done using icon
1980.47s - 1985.19s |  So in this single script here, you have three ways of triggering your bug
1985.67s - 1990.79s |  you can trigger it using underscore to or with underscore CC or with underscore BCC and
1991.15s - 1997.95s |  Right after this there's something even better if one of the emails is not valid you will get an error message that says well
1997.95s - 2000.59s |  This is an invalid email colon your email
2001.31s - 2002.59s |  So what can we do with this?
2002.59s - 2008.71s |  Well, this is textbook the strategy that I was telling you about before the idea is that
2009.47s - 2014.99s |  You set underscore to to an invalid email so that invalid email gets it. It's ready to be displayed in the error message
2015.03s - 2018.83s |  so now what we want to do is modify its length before it's
2019.51s - 2020.95s |  Included in the error message
2020.95s - 2026.71s |  so then we use CC to trigger the bug and we have a free list that is altered and then we use BCC to
2026.71s - 2031.43s |  allocate a few strings so that we have a string that gets allocated on top of invalid email and
2031.71s - 2035.35s |  This will alter its size and therefore the error
2035.51s - 2041.35s |  When it gets displayed will display more bytes than it should and we will be able to get a memory leak, which is nice
2042.27s - 2044.99s |  So I implemented this and it was really fast. It took me a few hours
2044.99s - 2047.95s |  So I was really happy with it and I started it and it didn't work
2047.95s - 2053.03s |  And the reason for this is that when PHP when roundtube sends an error message
2053.03s - 2058.97s |  It's converted to JSON and when PHP converts to JSON every byte that is not valid UTF-8 is removed
2059.11s - 2064.13s |  so you have a memory leak, but you don't really have any bytes of interest because
2064.87s - 2067.07s |  Generally addresses are not going to be valid UTF-8
2067.07s - 2072.43s |  So they're just going to be removed any raw data in memory is not going to be valid UTF-8 is going to be removed
2072.43s - 2077.79s |  So what you get is a memory leak which consists of over like only ASCII characters and new bytes
2077.95s - 2079.55s |  Which is completely useless
2079.55s - 2083.47s |  But the idea is pretty good still we still want to do the same thing
2083.47s - 2087.63s |  but we just need to find a string that will not get modified too much before it's
2088.31s - 2089.83s |  Displayed and to do that
2089.83s - 2095.31s |  We just have to look at the framework and go a little bit deeper look at many many functions up until we find a viable
2095.39s - 2098.25s |  That gets displayed without being modified
2098.95s - 2103.87s |  Sadly for us when it gets displayed it gets displayed without being modified
2103.91s - 2110.99s |  It will not have a lot of codes in between the creation of the Bible and the display of the Bible
2110.99s - 2114.99s |  so it limits the number of gadgets that we can use and
2115.59s - 2116.75s |  well
2116.75s - 2121.19s |  It's honestly pretty much how to make this work, but you have to think at
2121.83s - 2126.23s |  Every line that you can use like every line in the code you can use it to
2126.67s - 2132.27s |  Go closer to your goal like every line can be an allocation or the allocation that would shape doing better for you
2132.27s - 2136.11s |  And I actually managed for that off in I think five days
2136.11s - 2139.99s |  It was really really long and I actually managed to get the leak
2139.99s - 2143.95s |  So it was nice because afterwards it's pretty easy to get a C
2143.95s - 2147.87s |  Once you have an address of some value in the PHP heap
2147.87s - 2154.35s |  You can just reproduce the same exploit, but this time use your free list corruption to arbitrate to allocate at an arbitrary
2154.95s - 2161.23s |  Position and that means that you can do that only attacks where you override some value that is in your session for instance
2161.27s - 2167.95s |  Maybe you want to overwrite your goals and set them to admin or maybe you want to override serialized data before it's the serialized
2167.95s - 2170.11s |  So that you have an arbitrary and serialized in PHP
2170.11s - 2174.79s |  Or you can also go like the standard way where you go for a binary attack
2174.87s - 2179.85s |  Where you want to control a YP like you started binary and you want to go like full binary
2179.91s - 2185.15s |  But I think the data only attack is more elegant and it fits more because you don't have to dump the binary
2185.15s - 2187.15s |  So it's it's easier
2187.51s - 2192.03s |  But like all of these that I'm saying it's actually only the visible part of the iceberg
2192.03s - 2196.23s |  It's really really like hard to pull off because first you need a proper heap setup
2196.23s - 2197.67s |  I haven't covered this part
2197.67s - 2202.63s |  It's really hard to do because the only thing that you can use to do your heap setup is HTTP parameters
2202.63s - 2207.47s |  But then the script gets compiled and you will use other scripts. They all get combined in the same heap
2207.47s - 2212.03s |  So you will like completely mess up the heap. It's really annoying to pull off in addition to this
2213.03s - 2214.07s |  Variable scope is here
2214.07s - 2219.95s |  Like if you have a method that is called and then it exists the method every variable that is in the method is going to be
2219.95s - 2221.39s |  freed so
2221.39s - 2223.47s |  Like it will completely change the heap as well
2223.47s - 2231.35s |  And also obviously it's very specific your attack to the server that you're targeting the application that you're targeting and also the settings
2231.35s - 2235.47s |  Like I think the original exploit that I built it was for roundtube in French
2235.47s - 2241.55s |  If I change the language to English it wouldn't work because the strings that I get allocated with error messages
2241.55s - 2246.95s |  They wouldn't be the same and that would completely change the shape of the heap. So again, it's a huge pain to pull off
2246.95s - 2248.95s |  So don't do it unless
2248.95s - 2250.71s |  really necessary
2250.71s - 2252.71s |  but it works and
2252.75s - 2254.75s |  I will show you
2256.82s - 2258.82s |  an exploit
2259.42s - 2266.80s |  Again
2270.44s - 2272.44s |  No, I need to find
2280.94s - 2282.94s |  Okay, same layout
2283.58s - 2290.06s |  you get a shell on the very bottom and exploits on top of this and the application on the left and
2298.06s - 2300.06s |  Now I need to remove it again
2301.30s - 2304.06s |  Each one of these this one. Nope
2305.66s - 2307.66s |  Nope
2307.94s - 2313.54s |  Yeah, okay a quick conclusion and maybe a few more words afterwards
2315.90s - 2323.26s |  So the bug was really bad honestly it had like lots of preconditions and even the bug was not that good like a really bad
2323.26s - 2325.14s |  overflow but
2325.14s - 2329.14s |  Luckily for us PHP exists and we actually are able to
2329.62s - 2331.14s |  do
2331.18s - 2332.26s |  Decent things with it
2332.26s - 2338.42s |  We have a new actor attack vector where we convert the favorite primitive into an RCE on any PHP version
2338.62s - 2344.66s |  Against any target if you're a favorite primitive you have RCE now, it's pretty nice. And also you add
2345.46s - 2349.46s |  application specific attacks such as the one that demonstrated on roundtube and
2350.22s - 2353.26s |  However, the bug is not PHP specific
2353.26s - 2358.74s |  So there could be a lot of other like targets, but I couldn't find any but maybe you will you know
2358.74s - 2363.74s |  and they might be discovered as time go by if people like tries to
2364.74s - 2368.78s |  well try to find a way to explain the bug and
2370.42s - 2376.22s |  The timeline will fast and I found the bug last year and I started exploiting it in February and
2376.54s - 2381.38s |  After a month and a half I could report it to the GDP security team and they were like really amazing
2381.38s - 2383.42s |  Like they were really fast after a week
2383.42s - 2387.54s |  I got a patch and they were really nice and they knew what they were doing which is
2388.46s - 2391.58s |  Well, it's not always the case to say the least and
2391.98s - 2396.38s |  So the bug got patched in a week and two weeks after after the embargo
2396.38s - 2400.58s |  it was released as CVE 2024 2961 and
2401.90s - 2404.54s |  Yeah, that's probably maybe the end of it for me
2404.54s - 2410.70s |  but I have published lengthy blog posts about the bug because there's so much to say about the bugs and
2411.02s - 2416.06s |  also the impact on the PHP ecosystem, which I couldn't cover here because we only have 45 minutes and
2416.38s - 2421.66s |  Also, there are exploits that are available on our github and also there's my Twitter if you want to ask questions
2421.66s - 2425.10s |  you can also have asked some questions like right after the talk and
2426.26s - 2429.06s |  Just to flex a little bit a few what-ifs
2430.70s - 2434.22s |  What if we have a favorite primitive, but we cannot see the output
2434.58s - 2438.62s |  We have a failure contents, but no echo in front of it. So we cannot read for except maps
2438.74s - 2443.74s |  We cannot read like any binary. So the expectation that I've shown you it doesn't work and
2444.30s - 2446.74s |  Also in some very very rare cases
2446.74s - 2452.02s |  they live in faith will not be present like you will not be able to decompress your stream so you will have to exploit with
2452.02s - 2454.02s |  one single pocket and
2454.26s - 2455.78s |  That looks impossible
2455.78s - 2460.98s |  but I was able to do both at the same time that was actually my very first exploits and
2461.62s - 2463.62s |  I will try and show you how
2465.38s - 2470.44s |  It's just a demo really sped up because it's really slow
2471.04s - 2475.64s |  Well at the end you get a shell the important part is on the left the source code
2475.64s - 2479.16s |  You can see at the very bottom you have a failure contents without an echo or anything
2479.16s - 2484.78s |  So I don't have the output and also on top of this. I have arbitrary allocation a random
2484.78s - 2490.68s |  Sorry allocations and the allocations just to show that the script is not very that it's not tailored to attack one PHP script
2490.68s - 2497.04s |  Like it could work against any PHP instance. And yeah, the exploit is not done yet. It's sped up like eight times
2497.04s - 2503.16s |  I think it's really really slow, but you get one bytes per one byte and at the end you have another shell. So yeah, that's it
2510.16s - 2512.20s |  Okay, I'm getting close. No
2512.88s - 2520.41s |  There we go
2520.41s - 2529.88s |  questions
2529.88s - 2531.88s |  Okay, I guess we're good. Ah, there's one
2535.59s - 2537.59s |  Yeah, thank you. This is amazing
2537.63s - 2544.15s |  So, how did you get to the round cube target and establish that those conditions were present that you were looking for?
2544.87s - 2546.87s |  so I
2546.87s - 2549.05s |  Thought that like emails to me
2549.91s - 2552.71s |  When you send an email you can kind of send the charset with it
2552.71s - 2558.51s |  So I cannot felt like webmails would be a good target to look at and I looked at wrong cube
2558.51s - 2565.27s |  And I saw that like it was a good target. So yeah, that's what oh cool pure intuition. That's amazing. Yeah
2565.99s - 2574.84s |  Well, thank you for listening to my talk