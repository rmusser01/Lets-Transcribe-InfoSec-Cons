{
  "webpage_url": "https://www.youtube.com/watch?v=KqKj_VY-AHY",
  "title": "DEF CON 32 - MobileMesh RF Network Exploitation Getting the Tea from goTenna - Erwin Karincic, Woody",
  "description": "False sense of security in devices that guarantee security is worse than no security at all. One device used by personnel who require communication security is goTenna Pro radio that creates an \"off-the-grid\" encrypted mobile mesh network.This network does not require any traditional cellular or satellite infrastructure and they may be found locally in your community. The datasheet says it is using AES-256 encryption. Has anyone bothered to verify that it is being implemented in the most secure manner? We examined this device and found that it was possible to fingerprint and track every off-the-grid message regardless of encryption. We also identified vulnerabilities that result in interception and decryption of the most secure encryption algorithm AES-256 as well as injection of messages into the existing mesh network. We don\u2019t just trust what datasheets say, we verify it for you. We will explain our testing methodologies and demonstrate exploitation in a live demo. We will discuss the operational implications of these vulnerabilities and safe ways of using these devices that decrease the chance of a compromise. The tools developed as part of this research will be released open-source to inform what was possible to inspire future research against similar devices. We will discuss how we worked with goTenna to remedy these issues.",
  "channel_url": "https://www.youtube.com/channel/UC6Om9kAkl32dWlDSNlDS9Iw",
  "duration": 2599,
  "channel": "DEFCONConference",
  "uploader": "DEFCONConference",
  "upload_date": "20241016"
}

0.05s - 4.05s | This text was transcribed using whisper model: large-v2

 Welcome to DEF CON. First speaker's up. Let's give him a big hand.
4.05s - 16.14s |  Thank all of you for being here. Really appreciate it.
16.14s - 20.14s |  So, the first thing we want to talk about is,
20.14s - 24.14s |  this whole talk has really been pushed because of how much
24.14s - 27.14s |  the technology out there is moving to mesh technology.
27.14s - 31.14s |  Everything's mesh. From cellular, we have mesh-tastic,
31.14s - 34.14s |  LoRa, all these different creations.
34.14s - 37.14s |  But one of the creations that has been around for quite a while
37.14s - 40.14s |  that we're going to talk about is Gotenna.
40.14s - 44.14s |  And we're going to talk about all three stages that we've seen it go through.
44.14s - 47.14s |  My name's Woody. This is Erwin.
47.14s - 50.14s |  Yeah, I'm Erwin Korenczyk. I go by Dollar Hyde.
50.14s - 53.14s |  And we also want to make sure that we give credit to Clayton Smith,
53.14s - 57.14s |  who really did a ton of work on the second generation
57.14s - 61.14s |  and made this talk possible. So, thank you very much for that.
61.14s - 68.26s |  Awesome. Yeah, thank you, Clayton.
68.26s - 71.26s |  Multiple mesh networks, the way that they typically work is,
71.26s - 74.26s |  one device will talk to another. You're able to go through and pivot.
74.26s - 77.26s |  And that way, you can get extended range.
77.26s - 80.26s |  You can have multiple people communicate at the same time.
80.26s - 82.26s |  There's a lot of things that you can do.
82.26s - 85.26s |  Now, one of the things with a traditional network is the way that your data
85.26s - 89.26s |  and your controls are handled versus the way that Gotenna mesh does it.
89.26s - 93.26s |  So, the Gotenna's capability of meshing is actually really efficient.
93.26s - 97.26s |  And that's one of the things that makes it fairly unique
97.26s - 101.26s |  is because they've combined that and made it pretty controllable.
101.26s - 106.82s |  So, some of you seven years ago may have seen the talk that I did
106.82s - 113.66s |  in the RF Hacker Sanctuary.
113.66s - 118.94s |  It was on Gotenna version 1, this one right here.
118.94s - 121.94s |  So, what you're seeing on the screen right now is as he goes through
121.94s - 126.94s |  and does the Gotenna or his script, this was our original exploit.
126.94s - 131.94s |  And what we figured out was the Gotenna is designed over Bluetooth
131.94s - 134.94s |  to communicate with a phone, at least the Gen 1 and 2 were.
134.94s - 139.94s |  Once that happens, then you can send a message that can be either open
139.94s - 144.94s |  in a broadcast or person-to-person or in a group, but you can encrypt it.
144.94s - 147.94s |  And that's what you're seeing here on the screen.
147.94s - 152.94s |  But we were able to see seven years ago that it was broadcasting
152.94s - 154.94s |  some things plain text.
154.94s - 158.94s |  And when it broadcasted things plain text, the things that you could see,
158.94s - 162.94s |  even in encrypted mode, were the unique identifier,
162.94s - 165.94s |  which for the unique identifier for the Gen 1 and 2 by default,
165.94s - 167.94s |  can anyone tell me what it was?
167.94s - 169.94s |  Your cell phone number.
169.94s - 174.94s |  So, this script is demonstrating how we could run against a Gotenna version 1
174.94s - 177.94s |  and pull your phone number out of the air,
177.94s - 179.94s |  even if you were using encrypted mode.
179.94s - 184.94s |  Now, they fixed that since, well, they've evolved since then.
184.94s - 188.94s |  And the new management has really made an effort to try to fix
188.94s - 190.94s |  some of the issues that have happened in the past.
190.94s - 193.94s |  But this on the screen is actually what it looks like
193.94s - 195.94s |  when we're able to come in here and pull this data.
195.94s - 198.94s |  Yeah, and you can see the phone number, call sign, and the message
198.94s - 200.94s |  in unencrypted mode.
200.94s - 203.94s |  In encrypted mode, payload is not visible, but the phone number still is.
203.94s - 205.94s |  So, this was Gen 1.
205.94s - 207.94s |  And if you want to see a live demo of this, come to RFHackers.
207.94s - 209.94s |  We're showing just the video here.
209.94s - 214.26s |  So, Gen 1, we see how it communicates.
214.26s - 218.26s |  Now, Gen 2, they changed some things.
218.26s - 221.26s |  Instead of using 2FSK, they moved to 4FSK.
221.26s - 224.26s |  But by default, there were still a couple things that were the same
224.26s - 227.26s |  that we were able to start exploiting.
227.26s - 230.26s |  Clayton specifically found some really great things
230.26s - 232.26s |  that were vulnerable here.
232.26s - 234.26s |  A lot of them were similar to version 1,
234.26s - 238.26s |  but you needed a 4FSK demodulator to do it.
238.26s - 240.26s |  But you could still find the phone number.
240.26s - 244.26s |  You could still find some of those unique identifiers.
244.26s - 246.26s |  And as we're going to discuss, those unique identifiers,
246.26s - 249.26s |  even if they're not your phone number, can be a bad day.
249.26s - 252.26s |  So, this is an example of exactly what we could pull
252.26s - 255.26s |  while you think you're doing encrypted messages.
255.26s - 257.26s |  And we start getting your phone number.
257.26s - 259.26s |  We can start seeing some of your messages,
259.26s - 262.26s |  depending how you're using it.
262.26s - 265.26s |  And we're going to talk how that can be effective
265.26s - 271.64s |  for other things as well.
271.64s - 276.64s |  Now, the current version of Gotenna, the Gotenna Pro,
276.64s - 278.64s |  we started working with.
278.64s - 281.64s |  One of the things that I do is I'm staffed in the RF Hacker Sanctuary,
281.64s - 285.64s |  the RF Village, so please come and try some of our challenges out later.
285.64s - 287.64s |  That's actually how a lot of these things get discovered,
287.64s - 290.64s |  is people trying them in challenges.
290.64s - 292.64s |  Some things that were fixed.
292.64s - 294.64s |  You did not have to connect via Bluetooth,
294.64s - 297.64s |  because we all know that Bluetooth by itself can be a unique identifier
297.64s - 300.64s |  that can be used to find somebody or come after them.
300.64s - 303.64s |  They improved it so you could use either Bluetooth
303.64s - 307.64s |  or you could actually hard line to your phone with the device.
307.64s - 310.64s |  And then the only thing that was communicating was either at, you know,
310.64s - 316.64s |  the 140 to 170 megahertz band or 445 to 480.
316.64s - 319.64s |  They also improved the channels you could use.
319.64s - 321.64s |  You had some bandwidth things you could control.
321.64s - 325.64s |  So, on initial viewing of this,
325.64s - 328.64s |  it looked like it was a much more secure device.
328.64s - 331.64s |  But this is what we're going to be talking about.
331.64s - 342.01s |  This is basically the Gen 3.
342.01s - 346.01s |  Why is it important for us to worry about what we give out?
346.01s - 349.01s |  Well, we have some representatives from Wiggle here,
349.01s - 352.01s |  and I'm sure that they can tell you how important it is
352.01s - 354.01s |  to protect your MAC addresses.
354.01s - 356.01s |  In fact, the industry has already started making sure
356.01s - 358.01s |  that unique identifiers start rolling
358.01s - 360.01s |  and that it's much more difficult to track them
360.01s - 363.01s |  because you can be tracked over space and time,
363.01s - 366.01s |  geographical location, and it can be used to fingerprint.
366.01s - 368.01s |  So that's why we're worried about this.
368.01s - 371.01s |  It also gives out unique identifiers about you.
371.01s - 375.01s |  What if I couldn't just tell that you were using that MacBook,
375.01s - 377.01s |  but I could tell you whether Tim was using it
377.01s - 380.01s |  or whether Jeff was using it, right?
380.01s - 382.01s |  That's even more refined,
382.01s - 384.01s |  and that's what we're going to start getting into in here.
384.01s - 386.01s |  And that is why, to us, it was so important.
386.01s - 389.01s |  Both of us, our primary jobs,
389.01s - 391.01s |  when we're not doing this stuff for fun,
391.01s - 394.01s |  is to actually help people protect their RF signature
394.01s - 397.01s |  and to help people have good cybersecurity
397.01s - 400.01s |  in vehicles, in equipment that they use,
400.01s - 402.01s |  and global travels.
402.01s - 409.79s |  So some of the problems that we started wondering about.
409.79s - 411.79s |  Is there any chance that we can find
411.79s - 413.79s |  some of the same vulnerabilities in a Gen 3
413.79s - 415.79s |  that we find in a Gen 1?
415.79s - 417.79s |  Yeah, so basically we're looking for those GIDs
417.79s - 418.79s |  for the call signs.
418.79s - 420.79s |  We're looking, are they present?
420.79s - 421.79s |  Have they fixed it?
421.79s - 422.79s |  Yeah.
422.79s - 424.79s |  Because it's been seven years,
424.79s - 425.79s |  we wanted to see whether or not
425.79s - 427.79s |  all those things had been fixed or not.
427.79s - 430.79s |  And some things had, and some things we found
430.79s - 432.79s |  were still somewhat vulnerable.
432.79s - 435.79s |  But having that base is what we moved from
435.79s - 437.79s |  to be able to do all the rest of this.
437.79s - 439.79s |  So having a good foothold,
439.79s - 442.79s |  and then from there, pushing out and finding new things.
442.79s - 448.73s |  So who are we? Erwin?
448.73s - 449.73s |  Yeah, so I'm Erwin.
449.73s - 451.73s |  I'm a security researcher.
451.73s - 453.73s |  I'm experienced in hardware and software reverse engineering
453.73s - 455.73s |  as well as RF exploitation.
455.73s - 458.73s |  My mission is essentially what's shown on the screen
458.73s - 460.73s |  as well as the overall mission
460.73s - 462.73s |  to protect this nation and its citizens
462.73s - 464.73s |  by identifying and mitigating threats
464.73s - 466.73s |  before those threats are even known to these people.
466.73s - 469.73s |  So this is one example of that mission
469.73s - 472.73s |  to protect the people that serve us.
472.73s - 473.73s |  My name's Woody.
473.73s - 475.73s |  I'm staff for the RF Hacker Sanctuary,
475.73s - 480.73s |  or the RF Village.
480.73s - 481.73s |  I was one of the co-authors
481.73s - 484.73s |  of the original Gotenna attack, Raptor Captor,
484.73s - 487.73s |  some other vehicle exploits, and some things like that.
487.73s - 489.73s |  I spent 20 years in special operations
489.73s - 492.73s |  before I started playing in this world.
492.73s - 495.73s |  And the reason that this is so important to both of us
495.73s - 498.73s |  is we work with law enforcement.
498.73s - 499.73s |  We work with government.
499.73s - 502.73s |  We work with corporations.
502.73s - 505.73s |  And we educate them on how to control
505.73s - 507.73s |  and understand all the different aspects,
507.73s - 509.73s |  not just the physical, but also the digital
509.73s - 512.73s |  and even the light aspects of what happens in your life
512.73s - 514.73s |  and why it's important.
514.73s - 517.73s |  So that's what got us to this point.
517.73s - 524.86s |  So just having encryption is not enough.
524.86s - 525.86s |  Configurations matter.
525.86s - 529.86s |  Imagine having an amazing router with WPA3,
529.86s - 533.86s |  an incredible password, and everything's good to go,
533.86s - 535.86s |  but you just leave it as an open network.
535.86s - 539.86s |  You still have encryption, but does it matter?
539.86s - 541.86s |  Not at that point.
541.86s - 544.86s |  Configurations, and that's what we're going to talk about.
544.86s - 546.86s |  Yeah, so this was our testing setup.
546.86s - 549.86s |  So we were testing in an anechoic chamber at the university
549.86s - 552.86s |  where I'm pursuing my PhD in electrical and computer engineering.
552.86s - 555.86s |  We used a representative sample of both iPhones and Androids
555.86s - 557.86s |  connected with Gotenna Pros.
557.86s - 559.86s |  And then we used just open-source hardware and software,
559.86s - 562.86s |  so HackRF1 connected with open-source software
562.86s - 564.86s |  running on an Ubuntu laptop.
564.86s - 567.86s |  So very simple.
567.86s - 569.86s |  So the first step of any sort of RF analysis
569.86s - 572.86s |  starts by identifying the frequency and capturing the signal.
572.86s - 575.86s |  This can be done either by analyzing FCC documentation,
575.86s - 576.86s |  by scanning the whole spectrum.
576.86s - 578.86s |  In this case, it was configurable.
578.86s - 579.86s |  We figured out where it was configurable,
579.86s - 581.86s |  so we set those frequencies,
581.86s - 583.86s |  and then we appropriately captured it in GQRX
583.86s - 585.86s |  as seen on the waterfall on the right.
585.86s - 587.86s |  And this doesn't take expensive equipment.
587.86s - 591.86s |  $30 TV dongle, some $100 radios.
591.86s - 594.86s |  You can really start moving along very quickly.
594.86s - 596.86s |  100%.
596.86s - 598.86s |  So then we started analyzing the signal
598.86s - 601.86s |  and figured out that Gotenna Pro was using 4FSK.
601.86s - 603.86s |  That is four-level frequency shift keying.
603.86s - 607.86s |  That's where the carrier shifted between four discrete frequencies.
607.86s - 608.86s |  As we can see on the screen,
608.86s - 612.86s |  it goes between negative 1.5 and positive 1.5.
612.86s - 614.86s |  We implemented a custom GNU radio flow graph
614.86s - 620.86s |  that can decode this exact type of 4FSK that Gotenna was using.
620.86s - 623.86s |  Once we were confident that our demodulation was successful,
623.86s - 626.86s |  we started analyzing raw bytes,
626.86s - 628.86s |  and their ASCII representation.
628.86s - 630.86s |  In this case, in Gen 1 and Gen 2,
630.86s - 634.86s |  we were able to see the GID, the call sign, and the payload
634.86s - 636.86s |  all unencrypted.
636.86s - 639.86s |  So this was sort of like we're seeing here.
639.86s - 643.86s |  It is encrypted somehow because we cannot see any of the data.
643.86s - 646.86s |  It's more of an obfuscation, really.
646.86s - 651.86s |  So then we sent two identical messages, and we compared them.
651.86s - 655.86s |  So we see that in yellow color, they're mostly the same.
655.86s - 657.86s |  They only differ in the red color,
657.86s - 660.86s |  and red only is the one that changes
660.86s - 662.86s |  if the same packet is being sent.
662.86s - 667.86s |  So this is very commonly some form of static encryption in use.
667.86s - 670.86s |  This observation is actually data whitening,
670.86s - 673.86s |  not to be confused with white shadowing.
673.86s - 679.36s |  Mainly because white shadows rarely work.
679.36s - 680.36s |  Yeah.
680.36s - 682.36s |  So data whitening is a technique that ensures
682.36s - 684.36s |  that there are no long sequences of zeros
684.36s - 687.36s |  that can cause drops in communication.
687.36s - 691.36s |  It uses XOR with a static set of bytes.
691.36s - 693.36s |  Those bytes are typically generated by something
693.36s - 695.36s |  called linear feedback shift register,
695.36s - 697.36s |  and we're going to talk about it later.
697.36s - 699.36s |  It's important to note that while this is similar
699.36s - 701.36s |  to XOR encryption, it is not cryptographically secure,
701.36s - 705.77s |  as we will demonstrate in the next few slides.
705.77s - 708.77s |  So our de-whitening process is shown in this algorithm.
708.77s - 711.77s |  We transmit a handful of As followed by a handful of Bs.
711.77s - 713.77s |  So for those who are not familiar with
713.77s - 716.77s |  ASCII representation in hex, capital A is 41,
716.77s - 718.77s |  so you'll see that a lot through our presentation,
718.77s - 720.77s |  and B will be 42.
720.77s - 723.77s |  So we transmit a handful of number of As,
723.77s - 726.77s |  we extract a byte from that transmission,
726.77s - 730.77s |  and we XOR it with 0x41, which is capital A,
730.77s - 733.77s |  and then that will give us our potential key stream.
733.77s - 736.77s |  We then use that key stream against the second message,
736.77s - 738.77s |  which is with Bs, and then we repeat that
738.77s - 740.77s |  for the length of the entire message.
740.77s - 742.77s |  And then we only keep the bytes that produce
742.77s - 745.77s |  the accurate result, i.e., we receive the Bs.
745.77s - 751.69s |  At that point, we found our offset at 42.
751.69s - 755.69s |  This means that Gotenna is offsetting this
755.69s - 757.69s |  like the entire, probably the header,
757.69s - 759.69s |  because we've seen in the beginning
759.69s - 761.69s |  that the header and data are combined.
761.69s - 764.69s |  So in this case, the payload will start off at 42,
764.69s - 767.69s |  and we found all of the green bytes in the first green line.
767.69s - 769.69s |  And when we apply that against the message,
769.69s - 772.69s |  we get 42s, and we translate that to ASCII.
772.69s - 773.69s |  Those are Bs.
773.69s - 776.69s |  So we have a partial whitening key.
776.69s - 778.69s |  Then we can use this against a different message.
778.69s - 781.69s |  So here we have the payload between 0 and 71.
781.69s - 784.69s |  We can de-whiten everything after 42,
784.69s - 786.69s |  so all part in orange, we de-whiten,
786.69s - 789.69s |  and then we can receive that, okay, we have seen 10As.
789.69s - 792.69s |  So we have 1041s and also the 0A
792.69s - 794.69s |  that's also represented as the lengths.
794.69s - 798.69s |  However, Gotenna is using a custom header,
798.69s - 801.69s |  so we do not know what the 0 to 41 is.
801.69s - 805.69s |  And the only way to find a whitening key for something
805.69s - 807.69s |  is you have to know what's there.
807.69s - 809.69s |  So we keep looking.
809.69s - 811.69s |  So we're investigating special conditions,
811.69s - 813.69s |  so we reiterate that we cannot,
813.69s - 816.69s |  we don't know what's below 42.
816.69s - 819.69s |  So we observe a special condition
819.69s - 821.69s |  when we set 100As.
821.69s - 823.69s |  What happens there is that the message splits.
823.69s - 825.69s |  As you can see here, our capture
825.69s - 827.69s |  received two different messages.
827.69s - 830.69s |  So then let's investigate that.
831.69s - 833.69s |  So we run the same exact strip
833.69s - 835.69s |  that was shown in that algorithm
835.69s - 836.69s |  against the second message,
836.69s - 839.69s |  and we see a potential XOR starting at byte 2
839.69s - 841.69s |  instead of 42.
841.69s - 843.69s |  So this means this is a fragment split,
843.69s - 844.69s |  the message split,
844.69s - 847.69s |  and the payload started at offset 42.
847.69s - 850.69s |  So we now have extra 40 bytes shown in green.
850.69s - 852.69s |  We combine them with the already existing key
852.69s - 856.69s |  that we found earlier between 42 and 96.
856.69s - 860.69s |  And then that gives us a key between 2 and 96.
860.69s - 862.69s |  Now we use that, we use that key,
862.69s - 864.69s |  so we take our packet,
864.69s - 866.69s |  we apply the key between 2 and 96,
866.69s - 867.69s |  and now we're seeing the payload,
867.69s - 869.69s |  but we're not only seeing the payload.
869.69s - 870.69s |  We're also seeing the call sign.
870.69s - 872.69s |  So my call sign is $hide,
872.69s - 874.69s |  and we can see that in blue.
874.69s - 876.69s |  That is very critical.
876.69s - 878.69s |  So another part that Gotenna was using
878.69s - 881.69s |  was Gotenna Identifier, or GID.
881.69s - 883.69s |  So in this case, we could not easily identify there.
883.69s - 885.69s |  It was not, like, easily seen.
885.69s - 887.69s |  So, but we do have a known value,
887.69s - 889.69s |  and this is very important against known values.
889.69s - 891.69s |  If we have a known value, i.e. in the app,
891.69s - 894.69s |  it told us the very bottom part at 1029,
894.69s - 895.69s |  that's our GID.
895.69s - 896.69s |  So we're looking for that.
896.69s - 898.69s |  So eventually, we discover it in the green,
898.69s - 901.69s |  in the orange part in the packet.
901.69s - 904.69s |  It is encoded in a very special way.
904.69s - 907.69s |  So first, the seven bits
907.69s - 909.69s |  that are containing the actual number,
909.69s - 910.69s |  and then the most significant bit
910.69s - 912.69s |  indicates where another byte is following.
912.69s - 915.69s |  So that's how they avoid the use of, essentially,
915.69s - 916.69s |  for example, as you can see,
916.69s - 919.69s |  the 0A in both the payload and the call sign,
919.69s - 920.69s |  that's the length.
920.69s - 922.69s |  That's how they can sort of avoid, like,
922.69s - 924.69s |  be more efficient of the use of the data stream
924.69s - 926.69s |  within the radio.
926.69s - 927.69s |  So that's simple enough.
927.69s - 929.69s |  We can write this Python decode script
929.69s - 930.69s |  to decode the GID,
930.69s - 932.69s |  and then we can take the orange bytes at the top
932.69s - 934.69s |  and get the orange bytes at the bottom.
934.69s - 936.69s |  Relatively simple.
936.69s - 938.69s |  So now, our next part was, like,
938.69s - 940.69s |  okay, let's discover the byte zero.
940.69s - 942.69s |  So FCC comes to the rescue.
942.69s - 944.69s |  They have a lot of useful information.
944.69s - 946.69s |  I highly recommend FCC documentation.
946.69s - 949.69s |  So that says, the FCC essentially says
949.69s - 952.69s |  that GOTEN is using SI4460 radio,
952.69s - 954.69s |  and that radio, based on its documentation,
954.69s - 957.69s |  adds length as byte zero.
957.69s - 958.69s |  So that means that we can find our node.
958.69s - 959.69s |  We take our packet.
959.69s - 960.69s |  We take the length.
960.69s - 962.69s |  We get that 69.
962.69s - 964.69s |  So then we have to subtract 1
964.69s - 965.69s |  because that is the length byte.
965.69s - 966.69s |  So we get 68.
966.69s - 969.69s |  We convert decimal 68 to hex,
969.69s - 970.69s |  and we get 44.
970.69s - 972.69s |  And then the ciphertext was 47.
972.69s - 974.69s |  We extort a 2, and we get 3.
974.69s - 979.69s |  So that is our widening byte at byte zero.
979.69s - 981.69s |  For byte one, we did a lot of testing,
981.69s - 983.69s |  and eventually we figured out it was 96.
983.69s - 985.69s |  So we'll kind of skip all the detail there
985.69s - 987.69s |  because it's a short presentation.
987.69s - 989.69s |  So in our current de-widening status,
989.69s - 991.69s |  we have pretty much everything from byte zero to 96.
991.69s - 994.69s |  We do not, unfortunately, know what last 10 are.
994.69s - 998.69s |  So, of course, we do more investigation.
998.69s - 1001.69s |  We find that the 2 bytes immediately following the message
1001.69s - 1005.69s |  are a result of CRC16 CCITT variant.
1005.69s - 1008.69s |  CRC16 stands for Cycle Redundancy Check.
1008.69s - 1011.69s |  It's used as error-correcting code
1011.69s - 1013.69s |  that is capable of determining
1013.69s - 1016.69s |  whether or not the payload has been corrupted in the transmission.
1016.69s - 1018.69s |  So that's a very quick way to determine that.
1018.69s - 1020.69s |  So we also do more analysis.
1020.69s - 1023.69s |  We figure out that this CRC is initialized with zeros,
1023.69s - 1025.69s |  and it uses 1021 as the polynomial.
1025.69s - 1028.69s |  So then we take the entire packet up to those 10 bytes,
1028.69s - 1030.69s |  and we compute the CRC16.
1030.69s - 1033.69s |  So here on this slide, you can see the Python script that we implemented.
1033.69s - 1037.69s |  So it's using zeros, and 1021 is the polynomial.
1037.69s - 1039.69s |  So then we run it through that function.
1039.69s - 1042.69s |  We put the packet that we saw earlier through that function,
1042.69s - 1046.69s |  and then we get the CRC16 value is DCD2.
1046.69s - 1049.69s |  And then our widened message, the ciphertext, was BCAA.
1049.69s - 1051.69s |  So then we take, we XOR the two,
1051.69s - 1055.69s |  and we get that the key at that offset is 6078.
1055.69s - 1056.69s |  Okay, pretty great.
1056.69s - 1058.69s |  So then the last eight bytes
1058.69s - 1061.69s |  are a result of Reed-Solomon error-correcting scheme.
1061.69s - 1064.69s |  So Gotenna is using both CRC and Reed-Solomon
1064.69s - 1066.69s |  for error detection and correction.
1066.69s - 1069.69s |  So a very powerful part about Reed-Solomon
1069.69s - 1072.69s |  is that it can not only detect the errors,
1072.69s - 1074.69s |  it can also correct them.
1074.69s - 1076.69s |  So they are using eight error-correction symbols
1076.69s - 1078.69s |  and first consecutive root set to one.
1078.69s - 1080.69s |  Using Reed-Solomon library and these four lines
1080.69s - 1082.69s |  to essentially compute the Reed-Solomon
1082.69s - 1084.69s |  against the packet we found earlier.
1084.69s - 1089.69s |  Once we do that, we get the line in the first bullet.
1089.69s - 1091.69s |  So those are those eight bytes.
1091.69s - 1093.69s |  We get the widened message, the ciphertext.
1093.69s - 1095.69s |  We XOR the two, and we have the entire key.
1095.69s - 1099.69s |  We have now the entire sequence from zero to the end.
1099.69s - 1101.69s |  So that's pretty awesome, right?
1101.69s - 1109.74s |  So now a big part here that we want to note
1109.74s - 1111.74s |  is that this entire sequence has been generated
1111.74s - 1113.74s |  by something called linear feedback shift register
1113.74s - 1115.74s |  or LFSR polynomial.
1115.74s - 1117.74s |  A very powerful thing about this algorithm
1117.74s - 1118.74s |  called Berlikamp-Massey.
1118.74s - 1121.74s |  So we can use this sequence within Berlikamp-Massey
1121.74s - 1122.74s |  to retrieve this polynomial.
1122.74s - 1125.74s |  The polynomial is shown at the bottom.
1125.74s - 1127.74s |  But there is more to here.
1127.74s - 1129.74s |  So in case that we could not determine something,
1129.74s - 1131.74s |  like byte one or any other part,
1131.74s - 1133.74s |  like we could have a very partial sequence,
1133.74s - 1136.74s |  we could use Berlikamp-Massey and mathematical techniques
1136.74s - 1140.74s |  to determine this polynomial and the associated sequence
1140.74s - 1141.74s |  even if we don't know things.
1141.74s - 1143.74s |  So we could technically, with enough time
1143.74s - 1145.74s |  and enough brute force, using Berlikamp-Massey,
1145.74s - 1148.74s |  only knowing the payload, figure out the header,
1148.74s - 1150.74s |  even if they were not being split.
1150.74s - 1152.74s |  So math is a pretty awesome thing.
1152.74s - 1155.74s |  So we can do that.
1155.74s - 1157.74s |  So, yeah, so this is the polynomial.
1157.74s - 1158.74s |  So they're using X to the 23.
1158.74s - 1161.74s |  So, you know, and this is not,
1161.74s - 1164.74s |  this is just meant to ensure that the receiver
1164.74s - 1166.74s |  and the transmitter do not lose connection.
1166.74s - 1168.74s |  So this is not meant as encryption.
1168.74s - 1171.74s |  Yeah, this is really acting almost like a form
1171.74s - 1173.74s |  of two-party authentication to make sure,
1173.74s - 1174.74s |  yes, they received the message,
1174.74s - 1176.74s |  yes, I've received the message,
1176.74s - 1180.74s |  and using that as a way to almost have a packet count.
1180.74s - 1184.79s |  So in our current decoding process,
1184.79s - 1185.79s |  so this is done in Green Radio,
1185.79s - 1187.79s |  and we're doing this essentially live,
1187.79s - 1190.79s |  and this is just a screen capture of my console.
1190.79s - 1192.79s |  So we get the raw bytes,
1192.79s - 1193.79s |  and we automatically extract the GID.
1193.79s - 1194.79s |  We apply the function.
1194.79s - 1196.79s |  We can translate that to ASCII.
1196.79s - 1198.79s |  We get the call sign, the payload,
1198.79s - 1200.79s |  including multi-fragmented messages.
1200.79s - 1201.79s |  So even in multi-fragmented,
1201.79s - 1204.79s |  we can still extract the payload.
1204.79s - 1205.79s |  So what GoTenor chose to encrypt.
1205.79s - 1208.79s |  So we played a bit with encryption,
1208.79s - 1209.79s |  and we see that it's only the payload.
1209.79s - 1211.79s |  So what does it mean, essentially,
1211.79s - 1213.79s |  once we can read all of the other signs?
1213.79s - 1215.79s |  Because in encrypted, unencrypted mode,
1215.79s - 1217.79s |  all of these are visible.
1217.79s - 1218.79s |  So everything you see in red here
1218.79s - 1222.79s |  means that at this point, where we currently are,
1222.79s - 1225.79s |  we are able to see the message length.
1225.79s - 1226.79s |  That can be pretty valuable.
1226.79s - 1228.79s |  That can definitely add up to things in the future,
1228.79s - 1232.79s |  especially with long-term collection techniques.
1232.79s - 1233.79s |  The GID.
1233.79s - 1235.79s |  The GID is gonna be your unique identifier,
1235.79s - 1237.79s |  which used to be your cell phone number,
1237.79s - 1239.79s |  and you had to pick for it to be a randomized one,
1239.79s - 1242.79s |  which we found out was just actually epoch.
1242.79s - 1245.79s |  But you now can still, with this,
1245.79s - 1246.79s |  they don't do the phone number.
1246.79s - 1248.79s |  So that's a much better improvement there.
1248.79s - 1251.79s |  But that GID tells me that is that exact same device.
1251.79s - 1253.79s |  And you can change it,
1253.79s - 1256.79s |  but understand that that GID is a unique identifier
1256.79s - 1258.79s |  like a MAC address that follows you.
1258.79s - 1260.79s |  Now, the call sign's a little bit different.
1260.79s - 1263.79s |  This goes back to my former community.
1263.79s - 1264.79s |  When you have call signs involved
1264.79s - 1266.79s |  that can be read in the clear,
1266.79s - 1270.79s |  now I possibly know how many people are in an organization
1270.79s - 1273.79s |  because typically they have a numerical sequence after it,
1273.79s - 1274.79s |  and I can start telling more
1274.79s - 1276.79s |  about that individual organization.
1276.79s - 1280.79s |  So by having the equipment and the call sign,
1280.79s - 1282.79s |  I can now start linking equipment
1282.79s - 1284.79s |  to not only organizations but individuals
1284.79s - 1287.79s |  to who was using the equipment at what time.
1287.79s - 1290.79s |  Payload length, again, much like message length,
1290.79s - 1292.79s |  that gives us really valuable things
1292.79s - 1295.79s |  to know what is it that we need to focus on
1295.79s - 1296.79s |  and what are they saying.
1296.79s - 1297.79s |  Is it short messages, long messages?
1297.79s - 1300.79s |  Are they using brevity?
1300.79s - 1302.79s |  And the CRC and the Reed-Solomon,
1302.79s - 1303.79s |  we're going to look and see
1303.79s - 1306.79s |  that those become fairly valuable in the end.
1306.79s - 1308.79s |  But these are the reasons this really concerned me.
1308.79s - 1310.79s |  100%.
1310.79s - 1311.79s |  So now, in this case,
1311.79s - 1313.79s |  we've shown what we've discovered so far,
1313.79s - 1315.79s |  so we go more in our analysis, right?
1315.79s - 1316.79s |  So that's what happens, right?
1316.79s - 1318.79s |  So we analyze the remaining fields.
1318.79s - 1319.79s |  We see the highlighted in blue.
1319.79s - 1321.79s |  We decode that and figure out that's the timestamp.
1321.79s - 1322.79s |  So you see here January 12th,
1322.79s - 1325.79s |  that's when we did the very initial capture,
1325.79s - 1326.79s |  so that's pretty awesome.
1326.79s - 1332.79s |  So we also discovered these tags.
1332.79s - 1339.54s |  So...
1339.54s - 1340.54s |  There we go.
1340.54s - 1341.54s |  And we knew we were on our way
1341.54s - 1344.54s |  to something great at this point.
1344.54s - 1346.54s |  So an additional thing with this presentation
1346.54s - 1348.54s |  that we want to do is we want to teach you
1348.54s - 1349.54s |  how we do reverse engineering.
1349.54s - 1352.54s |  So we discovered that this protocol is using tags.
1352.54s - 1355.54s |  So they're using tag 57, tag 24, and others.
1355.54s - 1357.54s |  So this is important to note.
1357.54s - 1359.54s |  So we'll use this in the rest of the presentation,
1359.54s - 1361.54s |  but it's important to note how we discovered that,
1361.54s - 1364.54s |  okay, so 57 or 39 hex,
1364.54s - 1369.54s |  after that, there is the UTC timestamp.
1369.54s - 1371.54s |  So then we use this in tag-based identification
1371.54s - 1372.54s |  in our script.
1372.54s - 1376.54s |  So we take the tag is equal to 57,
1376.54s - 1378.54s |  and then we appropriately apply the Python code
1378.54s - 1380.54s |  to decode that.
1380.54s - 1381.54s |  So that's what we're doing.
1381.54s - 1383.54s |  So at this point, we're a bit stuck, right?
1383.54s - 1385.54s |  So we could keep going the same things
1385.54s - 1386.54s |  over and over again,
1386.54s - 1388.54s |  and, like, eventually we'll get everything.
1388.54s - 1389.54s |  Maybe we won't.
1389.54s - 1391.54s |  But, you know, what happened in the V1 here?
1391.54s - 1394.54s |  So this is where I kind of fell back to the version 1
1394.54s - 1398.54s |  when I worked with Tim Kerster on that.
1398.54s - 1400.54s |  And he and I had kind of a light bulb moment.
1400.54s - 1401.54s |  He's an engineer.
1401.54s - 1402.54s |  I'm a knuckle dragger.
1402.54s - 1404.54s |  So we looked at it two totally different ways.
1404.54s - 1407.54s |  So he went home that night to start working on
1407.54s - 1411.54s |  an automatic demodulator for the FSK,
1411.54s - 1413.54s |  and I started seeing what I could find
1413.54s - 1415.54s |  so we could try to compare knowledge,
1415.54s - 1416.54s |  and he comes back the next day and goes,
1416.54s - 1419.54s |  Woody, I really hope that, you know,
1419.54s - 1421.54s |  this demodulator that I made is working.
1421.54s - 1422.54s |  I wish there was some way that I could check
1422.54s - 1425.54s |  against what the actual code that's coming out is
1425.54s - 1427.54s |  to make sure that everything's correct.
1427.54s - 1429.54s |  And I said, well, hey, we can just compare it
1429.54s - 1430.54s |  to the stuff that I've been looking at
1430.54s - 1433.54s |  through the UART, and then we'll just know, right?
1433.54s - 1434.54s |  At which point he said,
1434.54s - 1436.54s |  what do you mean you have UART?
1436.54s - 1439.54s |  I just assumed he'd check.
1439.54s - 1441.54s |  Yeah, so we don't have UART in this case
1441.54s - 1443.54s |  with Gotenna Pro, but we have something better.
1443.54s - 1445.54s |  So Clayton just casually mentions,
1445.54s - 1446.54s |  why don't you read from the app?
1446.54s - 1448.54s |  It was useful when I did Mesh.
1448.54s - 1449.54s |  Wait, what?
1449.54s - 1450.54s |  We had code the entire time?
1450.54s - 1451.54s |  Like, what?
1451.54s - 1452.54s |  I go online, and, like, I'm supposedly
1452.54s - 1454.54s |  this, like, reverse engineer, right?
1454.54s - 1455.54s |  And, like, I didn't look at the app.
1455.54s - 1456.54s |  What?
1456.54s - 1460.54s |  So everything in the app is plain text.
1460.54s - 1461.54s |  Yeah.
1461.54s - 1462.54s |  Look at this.
1462.54s - 1463.54s |  So we go in, decompile it.
1463.54s - 1464.54s |  Boom.
1464.54s - 1465.54s |  We can see the firmware in there.
1465.54s - 1466.54s |  We can see the source code.
1466.54s - 1467.54s |  Like, I was looking for this,
1467.54s - 1470.54s |  but, like, it's right there.
1470.54s - 1471.54s |  Wow.
1471.54s - 1473.54s |  Yeah, so companies really don't think like hackers.
1473.54s - 1475.54s |  So, like, hackers, like the guys in these pictures,
1475.54s - 1477.54s |  they can find full source code and firmware available
1477.54s - 1479.54s |  completely unencrypted and obfuscated.
1479.54s - 1481.54s |  It exists.
1481.54s - 1482.54s |  Yeah.
1482.54s - 1483.54s |  And this is where we said,
1483.54s - 1486.54s |  oh, I think things are going to be a little bit better now.
1486.54s - 1488.54s |  Because in version 1,
1488.54s - 1490.54s |  we just had to kind of bare knuckle through it
1490.54s - 1491.54s |  and hope we were close.
1491.54s - 1493.54s |  We just knew that our demodulation was working.
1493.54s - 1494.54s |  We didn't have tags yet,
1494.54s - 1496.54s |  which I think we're going to get to.
1496.54s - 1498.54s |  Yeah, so we go back, and we look through the source code.
1498.54s - 1499.54s |  We find these tags.
1499.54s - 1501.54s |  Remember that we were talking about reverse engineering tags?
1501.54s - 1502.54s |  We see 57 right here.
1502.54s - 1503.54s |  So we were spot on.
1503.54s - 1506.54s |  Our reverse engineering, like, methodology was very spot on.
1506.54s - 1508.54s |  So that's what we wanted to show you.
1508.54s - 1509.54s |  We find more tags, right?
1509.54s - 1510.54s |  PB broadcast.
1510.54s - 1512.54s |  We see key data coordinates.
1512.54s - 1514.54s |  So, you know, we have a bunch of tags, right?
1514.54s - 1517.54s |  So you're assuming that we use this Java source code
1517.54s - 1519.54s |  and essentially slowly update our script.
1519.54s - 1521.54s |  This may take, like, a couple months,
1521.54s - 1523.54s |  and eventually we'll have a better product.
1523.54s - 1524.54s |  Well, not quite.
1524.54s - 1527.54s |  Ain't nobody got time for that.
1527.54s - 1529.54s |  So we find an interesting observation.
1529.54s - 1531.54s |  There's a file descriptor,
1531.54s - 1533.54s |  and we find something called Proto 3.
1533.54s - 1535.54s |  Some of you are familiar with that already,
1535.54s - 1537.54s |  but we weren't, right?
1537.54s - 1539.54s |  So we looked this up, and it's a protocol buffers.
1539.54s - 1541.54s |  It's used as an open source library
1541.54s - 1544.54s |  developed by Google to help companies and other people
1544.54s - 1546.54s |  to develop custom protocols,
1546.54s - 1548.54s |  and they're supported by all kinds of languages,
1548.54s - 1552.54s |  Python, Java, C, like, all kinds of things, right?
1552.54s - 1556.54s |  So we go online, and we kind of take the string,
1556.54s - 1559.54s |  the binary string, and we kind of figure out,
1559.54s - 1561.54s |  okay, these may be the fields, right,
1561.54s - 1563.54s |  the sender, the call sign, and then let's try it, right?
1563.54s - 1565.54s |  So we put in the hex at the bottom,
1565.54s - 1568.54s |  and then, wow, the whole thing is there.
1568.54s - 1571.54s |  But literally, you just put it in the program on one side,
1571.54s - 1573.54s |  push a button, and it gives you everything on the other.
1573.54s - 1575.54s |  Like, it's automatic.
1575.54s - 1577.54s |  Like, this did not happen in V1 or Mesh.
1577.54s - 1580.54s |  Like, this is, like, way easier.
1580.54s - 1582.54s |  So, yeah, so we then go in,
1582.54s - 1584.54s |  and then let's do this for real.
1584.54s - 1587.54s |  So we go to all of the decompiled stuff.
1587.54s - 1589.54s |  We take the file extractors.
1589.54s - 1592.54s |  We put in our own custom file called Proto extraction,
1592.54s - 1594.54s |  and then we run, that will generate a binary file,
1594.54s - 1596.54s |  and then we use PBTK.
1596.54s - 1598.54s |  This is an open-source tool.
1598.54s - 1600.54s |  We use this against this binary file,
1600.54s - 1603.54s |  and that gives us all of these things at the bottom,
1603.54s - 1604.54s |  like all the proto files.
1604.54s - 1607.54s |  So the base header essentially sets up the message.
1607.54s - 1609.54s |  This imports the header protobuf.
1609.54s - 1611.54s |  The header protobuf was what we were doing
1611.54s - 1612.54s |  in reverse engineering in BlackboxRF, right?
1612.54s - 1614.54s |  So, like, it shows us all the things.
1614.54s - 1617.54s |  What's important here is this data type, right?
1617.54s - 1620.54s |  This enum would be very difficult to reverse engineer.
1620.54s - 1622.54s |  Like, we would have to take so many samples
1622.54s - 1624.54s |  and then hope that we can maybe figure out
1624.54s - 1626.54s |  the text is 3 and then ping is 5.
1626.54s - 1628.54s |  That would be very difficult.
1628.54s - 1630.54s |  So let's go back full circle.
1630.54s - 1631.54s |  What were those tags, right?
1631.54s - 1633.54s |  So if we compile this protobuf in Java,
1633.54s - 1635.54s |  because that's what Gotenna is using,
1635.54s - 1636.54s |  we can see these cases.
1636.54s - 1638.54s |  So these cases are used as different parts
1638.54s - 1641.54s |  of the protocol to essentially define different things.
1641.54s - 1643.54s |  So we were spot-on, right?
1643.54s - 1644.54s |  These tags were cases.
1644.54s - 1645.54s |  That's pretty awesome.
1645.54s - 1647.54s |  And we got 57 and the rest of them.
1647.54s - 1650.54s |  And you also noticed that you could see things
1650.54s - 1652.54s |  like when they requested, I don't know, keys.
1653.54s - 1655.54s |  You could see the code of how to request a key.
1655.54s - 1656.54s |  100%.
1656.54s - 1657.54s |  So, yeah.
1657.54s - 1659.54s |  So a cool part about protobuf
1659.54s - 1661.54s |  is they can be compiled for Python.
1661.54s - 1663.54s |  What else is using Python?
1663.54s - 1666.54s |  I believe there's a little thing called GNU radio.
1666.54s - 1667.54s |  Yeah, that might be cool.
1667.54s - 1669.54s |  It's so easy, even I can do it.
1669.54s - 1670.54s |  Yeah.
1670.54s - 1672.54s |  So we go in and we import a base message data type
1672.54s - 1674.54s |  and we make a blueprint statements
1674.54s - 1675.54s |  to associate everything.
1675.54s - 1678.54s |  And perfect decode.
1678.54s - 1683.07s |  Victory.
1683.07s - 1685.07s |  But wait, we haven't found a single vulnerability yet.
1685.07s - 1686.07s |  We just decoded the thing.
1686.07s - 1688.07s |  Like, there's 30 more slides of actual vulnerabilities.
1688.07s - 1691.07s |  So, you know, stay seated.
1691.07s - 1694.07s |  So with this decode, now that we can read things,
1694.07s - 1699.07s |  we can do frequency decoding, shared location.
1699.07s - 1702.07s |  We can do emergency messages, all kinds of things.
1702.07s - 1704.07s |  The only thing where we received the challenge
1704.07s - 1706.07s |  was in coordinate decoding.
1706.07s - 1709.07s |  So in the app, we can make, for example,
1709.07s - 1711.07s |  like around this island, we can make coordinates.
1711.07s - 1713.07s |  And then when we're capturing it,
1713.07s - 1716.07s |  we see binary data represented as Base64 and JSON.
1716.07s - 1719.07s |  And in this case, there isn't much, right?
1719.07s - 1721.07s |  So, like, we can't see here.
1721.07s - 1722.07s |  So we go back to proto.
1722.07s - 1723.07s |  They're defined as bytes.
1723.07s - 1726.07s |  So that means that decoding on our side has not been added.
1726.07s - 1727.07s |  So that's very simple.
1727.07s - 1730.07s |  We just use decode as little n, the n double double,
1730.07s - 1732.07s |  and then boom, we get the coordinates.
1732.07s - 1733.07s |  So that's fixed.
1733.07s - 1736.07s |  So now we found our true first vulnerability, right?
1736.07s - 1737.07s |  So, like, we encrypt the message
1737.07s - 1739.07s |  and we're just kind of looking at things.
1739.07s - 1742.07s |  So what can you do when somebody can capture yes or no
1742.07s - 1743.07s |  and tell the differences?
1743.07s - 1745.07s |  When you start dealing with organizations
1745.07s - 1747.07s |  that are using brevity for communication,
1747.07s - 1749.07s |  simple things like the length of a message
1749.07s - 1752.07s |  become very easy even without going into advanced steps
1752.07s - 1754.07s |  to be able to tell what kind of communication may be happening.
1754.07s - 1756.07s |  Are they only sending coordinates?
1756.07s - 1757.07s |  Are they sending commands?
1757.07s - 1759.07s |  Are they just sending comms checks?
1759.07s - 1761.07s |  So this starts becoming really important,
1761.07s - 1764.07s |  being able to understand these message lengths.
1764.07s - 1765.07s |  Yeah, so it's crucial.
1765.07s - 1768.07s |  So then let's go look at how they're doing encryption.
1768.07s - 1771.07s |  So one form of encryption is encrypting the broadcast.
1771.07s - 1773.07s |  So this is the process how it works in the app.
1773.07s - 1774.07s |  So we generate the new key.
1774.07s - 1775.07s |  We put in the name.
1775.07s - 1777.07s |  It can be either broadcast or QR code,
1777.07s - 1778.07s |  and we're going to get to that, right?
1778.07s - 1779.07s |  That's not important.
1779.07s - 1782.07s |  But what we go in is the validation thing.
1782.07s - 1783.07s |  It's kind of interesting, right?
1783.07s - 1784.07s |  We do this a bunch of times.
1784.07s - 1787.07s |  Like, they're kind of short.
1787.07s - 1792.07s |  So, and it's all lowercase or numbers, and that's it.
1792.07s - 1793.07s |  But there is a space.
1793.07s - 1796.07s |  So I guess we have nine, but the space is consistent.
1796.07s - 1798.07s |  So, nope, really just eight.
1798.07s - 1801.07s |  So you have lowercase numbers, or I'm sorry,
1801.07s - 1802.07s |  lowercase letters and numbers,
1802.07s - 1804.07s |  and that's all you have to figure out,
1804.07s - 1805.07s |  and you only have to figure out eight of them
1805.07s - 1808.07s |  and put a space in the middle for your dictionary.
1808.07s - 1809.07s |  Yeah, so very interesting.
1809.07s - 1810.07s |  So then we go in.
1810.07s - 1812.07s |  Okay, we capture this QR broadcast, right?
1812.07s - 1815.07s |  QR broadcast gets sent unencrypted over the air.
1815.07s - 1817.07s |  So this key data is actually encrypted, right?
1817.07s - 1819.07s |  So what we have here is encrypted.
1819.07s - 1821.07s |  But, you know, we do some of our analysis,
1821.07s - 1822.07s |  and then long story short,
1822.07s - 1824.07s |  to make the fit in the presentation,
1824.07s - 1826.07s |  we were able to decrypt it.
1826.07s - 1827.07s |  And the nice thing, too,
1827.07s - 1829.07s |  is it told us where the IV and the salt was
1829.07s - 1831.07s |  because we were able to find where they were.
1831.07s - 1835.07s |  So it made it much easier because we knew which was which.
1835.07s - 1839.07s |  So then, essentially, the key data is fed into the PBKDFHMAC
1839.07s - 1840.07s |  with 10,000 iterations.
1840.07s - 1841.07s |  This is a very good hashing,
1841.07s - 1844.07s |  but it's protected by a state character password.
1844.07s - 1846.07s |  So let's say password is known.
1846.07s - 1848.07s |  It's going to give us the encryption key.
1848.07s - 1851.07s |  And encryption key, along with the IV and the GID,
1851.07s - 1853.07s |  can decrypt the ciphertext.
1853.07s - 1856.07s |  GID as GCM will give us the plain text and HMAC.
1856.07s - 1859.07s |  We also, you know, to be good communications people,
1859.07s - 1860.07s |  we can compute our own HMAC
1860.07s - 1862.07s |  and verify that message was correct, right?
1862.07s - 1864.07s |  So now one may ask, like,
1864.07s - 1867.07s |  how complicated is it to get this password?
1867.07s - 1870.07s |  So in MD5, this will be very quick.
1870.07s - 1872.07s |  PBKDF2 is pretty strong.
1872.07s - 1876.07s |  So we do hashcat, and we essentially analyze.
1876.07s - 1878.07s |  This is an actual engineering analysis.
1878.07s - 1881.07s |  So with RTX4090, one card,
1881.07s - 1883.07s |  one can figure this out in 15.33 days.
1883.07s - 1886.07s |  A very common commercial cracking rig can have 12 of these.
1886.07s - 1889.07s |  So in 1.27 days, one can determine this password.
1889.07s - 1892.07s |  Now we look at more well-funded adversaries.
1892.07s - 1895.07s |  A100 is used by chat GPT, neural nets, AI.
1895.07s - 1897.07s |  That's the whole thing now, right?
1897.07s - 1899.07s |  This one card is actually worse, right?
1899.07s - 1901.07s |  But if you have 10,000 of them,
1901.07s - 1903.07s |  you can figure it out in 5.31 seconds.
1903.07s - 1905.07s |  It's important to know that all of these times here...
1905.07s - 1907.07s |  Minutes. 5.31 minutes.
1907.07s - 1908.07s |  It's important to know that all of these
1908.07s - 1910.07s |  are kind of worst-case scenarios.
1910.07s - 1912.07s |  That means that your script found the password
1912.07s - 1913.07s |  the very last time.
1913.07s - 1916.07s |  So it's likely it's going to be, like, about half the time.
1916.07s - 1919.07s |  So we go in, and we can essentially...
1919.07s - 1922.07s |  If we know the key, we wrote our little script,
1922.07s - 1923.07s |  and then we can decode it.
1923.07s - 1924.07s |  We can get the hex key,
1924.07s - 1927.07s |  and now we can add this to our automatic decoding script,
1927.07s - 1929.07s |  and now we can decrypt live.
1929.07s - 1930.07s |  Awesome.
1930.07s - 1931.07s |  And we can also decrypt everything
1931.07s - 1932.07s |  that happened in the past, so...
1932.07s - 1934.07s |  So now we have it all.
1934.07s - 1936.07s |  Yeah, but there's more.
1936.07s - 1939.07s |  So another form of communication
1939.07s - 1940.07s |  is point-to-point,
1940.07s - 1941.07s |  and that uses public-key encryption.
1941.07s - 1943.07s |  So public-key encryption on its own
1943.07s - 1944.07s |  is a lot more secure.
1944.07s - 1947.07s |  It uses PKI, or public-key encryption,
1947.07s - 1948.07s |  to share the symmetric key.
1948.07s - 1951.07s |  It doesn't require any of this manual key sharing.
1951.07s - 1953.07s |  However, in our code,
1953.07s - 1956.07s |  the message receiver class did not cleanly decompile,
1956.07s - 1958.07s |  so we could spend some time, do that,
1958.07s - 1961.07s |  but in help with some Craigslist, eBay, and Freedom,
1961.07s - 1963.07s |  maybe we can figure it out without it.
1963.07s - 1966.07s |  So initial conversation starts with public-key sharing.
1966.07s - 1968.07s |  So here we get the GIDs and the public keys.
1968.07s - 1970.07s |  Pretty cool.
1970.07s - 1972.07s |  So then we get to the source code.
1972.07s - 1976.07s |  We figure out that the public key and the private key
1976.07s - 1979.07s |  are generated using ECDH384R1 curve
1979.07s - 1981.07s |  to generate the shared key.
1981.07s - 1983.07s |  The shared key is used as first input
1983.07s - 1985.07s |  to HMAC SHA-256.
1985.07s - 1987.07s |  The second input is not known here,
1987.07s - 1989.07s |  so we could not figure out what are the parameters here.
1989.07s - 1991.07s |  So using Freedom,
1991.07s - 1994.07s |  we can essentially intercept this crypto-MACDU final.
1995.07s - 1999.07s |  So we essentially instrument this phone right here,
1999.07s - 2001.07s |  which is an Android phone.
2001.07s - 2003.07s |  This is connected with Gotenna,
2003.07s - 2005.07s |  and then we send a P2P,
2005.07s - 2007.07s |  and then we capture this.
2007.07s - 2009.07s |  And then from this kind of hex string,
2009.07s - 2011.07s |  we can figure out, okay, the second parameter
2011.07s - 2013.07s |  is actually concatenated GID, public key,
2013.07s - 2015.07s |  and the shared key.
2015.07s - 2017.07s |  We do know the public key and the GID.
2017.07s - 2019.07s |  We just found that in the slide earlier.
2019.07s - 2021.07s |  We don't know the shared key, so let's look for that.
2021.07s - 2023.07s |  So we go in the device, and we find the Gotenna folder
2023.07s - 2025.07s |  in that same phone,
2025.07s - 2028.07s |  and we find something called Gotenna Key Encryption.
2028.07s - 2031.07s |  I wonder if that's used for encryption.
2031.07s - 2033.07s |  So we go in, and, okay,
2033.07s - 2035.07s |  it's using private keys, shared keys,
2035.07s - 2037.07s |  but now, to, you know, the best of luck,
2037.07s - 2039.07s |  all of this is encrypted, right?
2039.07s - 2041.07s |  Fully encrypted. We can't read it.
2041.07s - 2043.07s |  But let's verify.
2043.07s - 2045.07s |  Okay.
2045.07s - 2047.07s |  So we go in, and we find the file that's using
2047.07s - 2049.07s |  Gotenna Key Encryption.
2049.07s - 2051.07s |  It's encrypted as an IV.
2051.07s - 2053.07s |  But we can't tell from that function,
2053.07s - 2055.07s |  so we track this over two different functions
2055.07s - 2057.07s |  and figure out it's not only used as a static,
2057.07s - 2060.07s |  as an IV, it's used as a static IV to AES-GCM.
2060.07s - 2063.07s |  So keys are AES-GCM encrypted,
2063.07s - 2066.07s |  but static IV allows complete encryption bypass.
2066.07s - 2068.07s |  This is when AES is doing what not,
2068.07s - 2070.07s |  what AES is not meant to do, right?
2070.07s - 2073.07s |  And then using the public key as a known plain text
2073.07s - 2075.07s |  and the encrypted public key,
2075.07s - 2077.07s |  we can XOR them to get the key stream,
2077.07s - 2079.07s |  and we can decrypt essentially everything else.
2079.07s - 2081.07s |  And what's stored in a database are public keys,
2081.07s - 2083.07s |  shared keys, broadcast keys,
2083.07s - 2086.07s |  the top two, the pin, pretty much everything.
2086.07s - 2088.07s |  So we have a lot of stuff here.
2088.07s - 2091.07s |  So then, yeah, there is AES.
2091.07s - 2095.07s |  There is. However, there's also
2095.07s - 2098.07s |  AES sitting here, and then implementation
2098.07s - 2100.07s |  or configuration sitting here.
2100.07s - 2102.07s |  This is kind of like having a really nice
2102.07s - 2105.07s |  blast-proof, bulletproof door at your house,
2105.07s - 2107.07s |  and then realizing that when the bad guys come,
2107.07s - 2109.07s |  they just cut a hole through the siding
2109.07s - 2111.07s |  and the drywall right next to it.
2111.07s - 2114.07s |  Yeah. So let's now summarize this
2114.07s - 2116.07s |  just so kind of everybody can be on the same page.
2116.07s - 2118.07s |  We get the public key and the public key ciphertext
2118.07s - 2121.07s |  in the XML. We XOR them to get the key stream,
2121.07s - 2123.07s |  and then we take the key stream and XOR that
2123.07s - 2125.07s |  with the private key ciphertext to get the private key.
2125.07s - 2128.07s |  Then when we have the public key and the private key,
2128.07s - 2130.07s |  we use ECDH to get the shared key.
2130.07s - 2133.07s |  Shared key is used within HMAC SHA-256
2133.07s - 2135.07s |  along with GID public key and the shared key
2135.07s - 2136.07s |  to get the encryption key.
2136.07s - 2138.07s |  That, along with the IV and the GID,
2138.07s - 2141.07s |  can decrypt the ciphertext of P2P encryption.
2141.07s - 2143.07s |  Group encryption is another form of encryption.
2143.07s - 2146.07s |  It's the last one that we'll talk about,
2146.07s - 2148.07s |  or the last one supported, really.
2148.07s - 2149.07s |  So it's using the very same method,
2149.07s - 2152.07s |  so same exact attack against P2P works against this,
2152.07s - 2154.07s |  and we can show here that we have done it.
2154.07s - 2157.07s |  So this is our true vulnerability summary, right,
2157.07s - 2158.07s |  of encryption summary finding.
2158.07s - 2160.07s |  So broadcast is vulnerable and allows unauthorized decryption.
2160.07s - 2163.07s |  Using setup QR message, which is captured over the air,
2163.07s - 2165.07s |  and brute force password, we can decrypt it.
2165.07s - 2167.07s |  We can also get it if the phone is compromised
2167.07s - 2169.07s |  and we get the key from there.
2169.07s - 2172.07s |  P2P and group are both vulnerable to unauthorized decryption
2172.07s - 2174.07s |  if, again, the phone is compromised
2174.07s - 2175.07s |  and we get some of these.
2175.07s - 2177.07s |  So if you want to know the feasibility,
2177.07s - 2179.07s |  you can check out our DEF CON talks and things like that
2179.07s - 2181.07s |  to sort of really know that.
2181.07s - 2182.07s |  There's no authentication public key,
2182.07s - 2184.07s |  so man-in-the-middling is possible.
2184.07s - 2185.07s |  Short messages, less than one fragment,
2185.07s - 2187.07s |  use less secure AES CTR,
2187.07s - 2189.07s |  so less than 35, 45 characters
2189.07s - 2191.07s |  depending on the message,
2191.07s - 2193.07s |  are using CTR, so that has integrity concerns
2193.07s - 2195.07s |  even though it is encrypted.
2195.07s - 2198.07s |  And then longer messages use more secure GCM,
2198.07s - 2201.07s |  but you need to be sending, like, 50 characters to get to that.
2201.07s - 2203.07s |  So we also, you know,
2203.07s - 2207.07s |  we could also transmit directly from our GNU radio.
2207.07s - 2209.07s |  We can spoof GID call sign, the message.
2209.07s - 2211.07s |  We can get into the existing...
2211.07s - 2216.07s |  So I could take a HackRF or an NS or a Blade
2216.07s - 2220.07s |  and I can actually make my own Gotenna out of it.
2220.07s - 2221.07s |  Yeah.
2221.07s - 2222.07s |  And just start using my computer.
2222.07s - 2225.07s |  We also added support for Wireshark,
2225.07s - 2228.07s |  so we have essentially that,
2228.07s - 2230.07s |  so all the messages are fed into Wireshark.
2230.07s - 2231.07s |  We don't have the decode there currently,
2231.07s - 2234.07s |  but we'll add it eventually.
2234.07s - 2236.07s |  So now let's get to live demos.
2236.07s - 2238.07s |  So if you have a Gotenna Pro,
2238.07s - 2240.07s |  then you can get the frequency on the left
2240.07s - 2242.07s |  and the encryption in the middle
2242.07s - 2243.07s |  and validation on the right.
2243.07s - 2246.07s |  So we have six minutes, so let's be quick.
2248.07s - 2249.07s |  I wouldn't scan it,
2249.07s - 2257.86s |  because we're both sketchy guys, but still.
2257.86s - 2258.86s |  So it's firing up live right now.
2258.86s - 2260.86s |  He's just turning the program on.
2260.86s - 2263.86s |  You can see it's already starting to sniff and listen.
2263.86s - 2265.86s |  We like to have a little waterfall
2265.86s - 2267.86s |  so we can see when we are or are not capturing.
2267.86s - 2269.86s |  Now he's going to send a message,
2269.86s - 2271.86s |  and there you go.
2271.86s - 2281.09s |  There we go.
2283.09s - 2284.09s |  We have enough time,
2284.09s - 2286.09s |  so let's see if we can decrypt something.
2287.09s - 2290.09s |  So now being able to do the same type of process
2290.09s - 2292.09s |  for an encrypted message.
2292.09s - 2293.09s |  So that was a broadcast.
2293.09s - 2294.09s |  Now broadcast means it's sent out
2294.09s - 2296.09s |  so that anyone that has one of these devices
2296.09s - 2298.09s |  is able to catch it.
2298.09s - 2300.09s |  It's meant for an emergency situation
2300.09s - 2302.09s |  or you're just looking for other people around you,
2302.09s - 2305.09s |  but the next step is
2305.09s - 2307.09s |  all those things we talked about
2307.09s - 2308.09s |  by combining that information,
2308.09s - 2311.09s |  can you take an encrypted message
2311.09s - 2313.09s |  for a group or a person-to-person
2313.09s - 2316.09s |  and actually decrypt and see it?
2316.09s - 2318.09s |  So when you think about this,
2318.09s - 2320.09s |  this is where everyone feels safe.
2320.09s - 2321.09s |  Oh, yeah.
2321.09s - 2324.14s |  One second here.
2324.14s - 2344.22s |  So while we're going through this,
2344.22s - 2345.22s |  he's going to set the demo up.
2345.22s - 2348.22s |  You're going to be able to see it.
2348.22s - 2353.84s |  And we'll go ahead.
2353.84s - 2355.84s |  Are there any questions right now
2355.84s - 2357.84s |  while he's setting this up?
2357.84s - 2358.84s |  We have a minute or so.
2358.84s - 2363.84s |  Any questions over anything that we've seen so far?
2363.84s - 2365.84s |  Okay.
2365.84s - 2369.22s |  Here we go.
2369.22s - 2371.22s |  Now one of the things that I want to make sure
2371.22s - 2372.22s |  that we cover in this is that
2372.22s - 2374.22s |  when we reached out to Gotenna
2374.22s - 2376.22s |  for the version 1 exploit,
2376.22s - 2379.22s |  they had zero response
2379.22s - 2380.22s |  other than the fact they said,
2380.22s - 2382.22s |  that's fine, we don't care.
2382.22s - 2383.22s |  Under the new management,
2383.22s - 2385.22s |  Gotenna was extremely receptive.
2385.22s - 2387.22s |  We got a call back within one day.
2387.22s - 2390.22s |  They were happy to take the advice
2390.22s - 2391.22s |  that we gave them
2391.22s - 2393.22s |  and they are actively working
2393.22s - 2395.22s |  to try to fix these issues.
2395.22s - 2397.22s |  That's why we are going to make sure
2397.22s - 2399.22s |  we wait at least two months from today
2399.22s - 2401.22s |  before we release the full code publicly,
2401.22s - 2403.22s |  but then we will.
2403.22s - 2404.22s |  Now for Gen 1 and 2,
2404.22s - 2407.22s |  the code's already out there.
2407.22s - 2408.22s |  Okay, so now we're ready.
2408.22s - 2410.22s |  So I'm going to send something encrypted
2410.22s - 2411.22s |  just so we can see that messages
2411.22s - 2412.22s |  are indeed encrypted.
2412.22s - 2415.22s |  So we can see they're encrypted now.
2415.22s - 2431.46s |  Now this part here decrypted.
2431.46s - 2434.46s |  So this was added to our local database.
2434.46s - 2436.46s |  So we're going to run our script again.
2436.46s - 2437.46s |  So this is going to now
2437.46s - 2440.46s |  pull the keys from there immediately.
2440.46s - 2442.46s |  And then we will transmit again.
2442.46s - 2449.74s |  Boom, this was encrypted.
2449.74s - 2453.05s |  So now it's full circle.
2453.05s - 2461.74s |  So, you know, live demos are something
2461.74s - 2463.74s |  that I'm a big fan of.
2463.74s - 2466.74s |  So Erwin did an amazing job
2466.74s - 2468.74s |  of writing all this crazy code.
2468.74s - 2471.74s |  I don't want anyone to misconstrue that.
2471.74s - 2473.74s |  The big thing that we want to make sure
2473.74s - 2475.74s |  that everyone takes away from this
2475.74s - 2479.74s |  is it is up to everyone in this community
2479.74s - 2481.74s |  to test equipment.
2481.74s - 2483.74s |  Just because something says it's secure,
2483.74s - 2484.74s |  don't believe it.
2484.74s - 2485.74s |  Challenge it.
2485.74s - 2486.74s |  And when you find it,
2486.74s - 2488.74s |  see if the manufacturer's willing to listen.
2488.74s - 2489.74s |  Occasionally they are.
2489.74s - 2490.74s |  Gotenna was.
2490.74s - 2492.74s |  Most of the ones I've dealt with aren't.
2492.74s - 2495.74s |  So if something's been done in the past,
2495.74s - 2497.74s |  don't be afraid to try to recreate it
2497.74s - 2498.74s |  when something new comes out.
2498.74s - 2500.74s |  You might find that they didn't change
2500.74s - 2501.74s |  a lot of the things
2501.74s - 2502.74s |  and then you can move forward
2502.74s - 2504.74s |  and do well with it.
2504.74s - 2507.74s |  Yep, so let's talk about join.
2507.74s - 2508.74s |  I mean, you already mentioned this,
2508.74s - 2510.74s |  so they were very receptive.
2510.74s - 2514.89s |  And yeah, the conclusion.
2514.89s - 2518.89s |  Yeah, so the big things we wanted to say about this is,
2518.89s - 2520.89s |  you know, we reached out to industry.
2520.89s - 2522.89s |  We were able to have a good relationship
2522.89s - 2523.89s |  with them doing this.
2523.89s - 2525.89s |  They took away key points,
2525.89s - 2527.89s |  acknowledgments of what we want to make sure
2527.89s - 2528.89s |  we talk about here.
2528.89s - 2530.89s |  So we want to reach out to White Shadow
2530.89s - 2531.89s |  who unfortunately couldn't be here
2531.89s - 2534.89s |  because he's actually doing some responsible things
2534.89s - 2535.89s |  for his family,
2535.89s - 2536.89s |  but he is going to be here later.
2536.89s - 2538.89s |  But don't tell him I said anything nice.
2538.89s - 2539.89s |  What the Freak,
2539.89s - 2541.89s |  which is the wireless CTF team
2541.89s - 2542.89s |  that-
2542.89s - 2543.89s |  Let's do a shout.
2543.89s - 2544.89s |  We got a win today.
2544.89s - 2546.89s |  Which I'm glad they're here
2546.89s - 2547.89s |  because now all the other teams
2547.89s - 2548.89s |  are jumping ahead of them.
2548.89s - 2549.89s |  Yep.
2549.89s - 2551.89s |  So we also want to thank EFF and CISA.
2551.89s - 2554.89s |  Both of them were amazing organizations
2554.89s - 2555.89s |  and very easy to work with.
2555.89s - 2557.89s |  The RF Hacker Sanctuary,
2557.89s - 2558.89s |  please go there.
2558.89s - 2559.89s |  Try some challenges.
2559.89s - 2561.89s |  It's everything from Wi-Fi,
2561.89s - 2562.89s |  Bluetooth,
2562.89s - 2563.89s |  tire pressure sensors,
2563.89s - 2564.89s |  Go Tennis.
2564.89s - 2566.89s |  All of these challenges will be there as well
2566.89s - 2567.89s |  for you to solve
2567.89s - 2568.89s |  for all the Go Tennis stuff.
2569.89s - 2570.89s |  We want to make sure that,
2570.89s - 2571.89s |  you know-
2571.89s - 2572.89s |  Yeah.
2572.89s - 2573.89s |  Jason Rojas and Cisco Systems.
2573.89s - 2574.89s |  I want to thank them
2574.89s - 2576.89s |  for making my trip here possible
2576.89s - 2577.89s |  and Potify Media
2577.89s - 2578.89s |  for making this team
2578.89s - 2579.89s |  for this presentation.
2579.89s - 2580.89s |  And Buffalo Trace
2580.89s - 2581.89s |  because without them
2581.89s - 2582.89s |  I probably wouldn't get done
2582.89s - 2583.89s |  as much work as I do.
2584.89s - 2588.10s |  Thank you for your time.
2588.10s - 2589.10s |  Are there any questions?
2590.10s - 2595.10s |  Well, thank you and enjoy the con.