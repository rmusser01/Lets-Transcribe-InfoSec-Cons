{
  "webpage_url": "https://www.youtube.com/watch?v=t4fUvfzgUbY",
  "title": "TROOPERS24: IBM i for Wintel Hackers",
  "description": "Talk by B\u00e1lint Varga-Perke, Zolt\u00e1n P\u00e1ncz\u00e9l - June 26th, 2024 at TROOPERS24 IT security conference in Heidelberg, Germany hosted by @ERNW_ITSec\n\n#TROOPERS24 #ITsecurity \nhttps://troopers.de/troopers24/talks/7sfsbf/\n\nMore impressions:\nhttps://twitter.com/WEareTROOPERS\nhttps://twitter.com/ERNW_ITSec\nhttps://infosec.exchange/@WEareTROOPERS\nhttps://infosec.exchange/@ERNW https://ernw.de",
  "channel_url": "https://www.youtube.com/channel/UCPY5aUREHmbDO4PtR6AYLfQ",
  "duration": 3475,
  "channel": "TROOPERS IT Security Conference",
  "uploader": "TROOPERS IT Security Conference",
  "upload_date": "20240902"
}

This text was transcribed using whisper model: large-v2

 Thank you very much.  So yeah, the talk is titled IBMi for Wintel Hackers.  This needs a little deciphering, maybe.  So IBMi is the brand new name for AS400, which is an IBM product from the 1980s, basically.  And Wintel is a word for, like, the Intel-based Windows-like systems, but it really covers  also Linux and Unix.  So the presentation is basically about how to hack AS400s if you only have experience  in Windows, Linux, Unix, and all the regular stuff.  So a few words about us.  My name is Valent Varga-Perka, and here with me is Zoltan Pantsev.  We are co-founders of a company called Silent Signal.  Our main focus is on penetration testing, and since 2022, we've been focusing on IBMi  as the platform, because it turns out many of our clients have these systems, but they  don't really know, didn't really know how to test and pen test it.  So we bought our own machine, our own IBMi, and started to experiment on that.  So what is IBMi?  IBMi is called a mid-range or mini-computer platform, which is kind of similar, but really  not the same as mainframes.  It provides high reliability, backwards compatibility, which are really important features if you  plan for the long term and need to serve your customers constantly.  It is really a critical system at financial institutions, telecommunications sector, retail,  et cetera.  So there are not many of these systems, but when you face them, they probably do a really  important job.  So yeah, and IBMi was a platform that was produced to make such a system affordable  to small, medium businesses, but over time, those businesses grew, and now you can find  these systems in the largest corporations, basically.  IBMi has been revolutionary in many aspects, the first of which is the object-oriented  operating system.  On IBMi, everything is an object that lives on the so-called single-level storage, which  is like a huge address space that covers both disk and memory.  So you don't have a file system.  Everything is an object, and just like in Java, objects can encapsulate data, and some  data, some properties can be made private, and these private properties can be only accessed  via public methods.  So the simplest example is that the system doesn't really distinguish between program  files and running processes or running jobs, but treats programs as objects that can be  executed.  On execution control, it's transferred to code inside the single-level storage, but  most users cannot see the actual code, what's inside the system.  On the other hand, users are free to look into the contents of file objects, because  we have file objects, and read and write from them, but they cannot be executed, because  files are for serialized data streams and not for executable code, right?  In IBMi also means integration, an example of which is the integrated database, so basically  all these objects that exist on the system are accessible via a SQL database, DB2, like  a regular relational schema.  So since this is a security conference, we won't really go into the deep details of how  the system works and how it can be operated, instead we will try to give you a crash course  basically on the attack surfaces that we exploited, so you will be able to apply your existing  hacking skills to IBMi.  We will cover a lot of bugs, a lot of demos, and a lot of new material, so fasten your seatbelts.  First of all, what are our targets?  IBMi can run on different security levels, we are targeting now security level 40, which  is the first security level that provides any meaningful security in the modern sense.  Processes are isolated, users need a password to log in, etc.  There is also a different higher security level, and this is the last one, security  level 50, but the exploits that we will show also work on that.  So it doesn't really matter.  We will work in the user domain, you can think of this as user space exploits, and we will  work above the so-called machine interface.  You can think of machine interface as a form of byte code, a byte code interpreter built  into the operating system that hides the low-level system architecture from programmers, and  we will demonstrate basic logic bugs so we don't have to dig into the nitty-gritty details  of risk.  The first things to discuss in terms of security are authorities.  Authorities are equivalents basically to access control entries.  They define who can do what with a particular object.  There is a well-defined list of authorities, but the type of control they provide can differ  depending on the type of the object they are applied on, and here I show you an example.  Here we can see the authorities of a service program, here you can see the object type,  and a user profile, here you can see the object type again, and both have this use authority  set.  In a service program, this use authority means that the public, meaning all users, can execute  this program, while the same use authority in terms of this user profile means that the  escalate user, which is a different user, can become basically user A1 if they want  to.  Confusingly, privileges given to users are also called authorities or special authorities.  We are now mostly interested in all object that surprisingly provides full control over  all objects, this is God mode basically, and here I wrote to the slide a security administrator  that can manage users basically, and one of the default user accounts is called the Q  security officer, we will see that in the demos.  It is like the root account on the system, and this account has both of these privileges.  The next thing to discuss are libraries, libraries are object containers or namespaces similar  to directories, only they cannot be nested, so libraries form a single level structure.  Libraries may seem innocious, but they are key elements of multiple vulnerability classes.  Here we can see an example.  This is the command that we are executing work on the object, which is called obj bar,  and it lives inside the library libfoo, it's simple as that.  Libraries are useful to organise objects, but sometimes you don't know in which library  to look for a particular object, and this is where the library list comes into the picture.  This is a special property associated to a logon session that defines a default look-up  order for object references that don't include a library name, so if I want to work with  an object, I know the object's name but I have no idea where the object lives, the system  will use the library list to look it up for me.  This is how the library list looks like.  Here at the top, you see the system part.  This cannot be modified by users, and it holds the most important libraries for the system.  Then come the product libraries.  Applications can set this part of the library list for themselves, then the current library,  and last, the users can manipulate this user part to include their favourite libraries  where their objects usually live, for example.  The library list is, of course, really similar to the path environment variable that you're  all familiar with from Windows, Linux, whatever, and, of course, you may already be familiar  with vulnerabilities arising from incorrect path definition, right?  Just like the one shown here, this configuration, when we just list the path on our Windows  system includes this C slash Oracle directory, and, of course, because of inherited privileges,  if I just drop DLLs or EXEs in the directory, this can lead to horizontal or vertical privilege  escalation on Windows, and this is very similar to what's happening on IBM I, as we will see.  This is why IBM explicitly discourages the so-called unqualified library calls when we  try to call a program like this instead of this, because, as the manual shows, the user  may end up working with an unexpected malicious object in the end.  Unfortunately, not everyone takes IBM's advice to heart.  We sent a bunch of reports to IBM, and then we started to see IBM fixing bugs in their  own software, and this is one of the very typical descriptions of the program, and  this basically describes an unqualified library call program where QGPR, for example, it's  a publicly writeable library, anyone can place objects in them, but the vulnerable programs,  for example, this facsimile support performs unqualified calls, so the one user who innocently  wants to run facsimile support may end up running attacker code instead.  But this is not what we showed IBM in our original vulnerability reports.  We are pentesters, and we usually don't have time or opportunity to wait for users to fall  into our traps to execute the right programs the right way.  To perform privilege escalation without user interaction, we needed to add another ingredient,  which is called adopted authority.  Adopted authority is basically set UID for IBM.  It is a property you can set on program objects that makes the program inherit the privileges  of its owner instead of the invoker of the program, just like set UID.  This is how it looks like in practice.  Here we can see this QFFSTR FCPP program which has the Q out prof user profile as its owner,  and here these two lines show that this program, when executed, it will run with the privileges  of the owner.  Set UID with the control of the environment variable is of course a vulnerability class  on Unix-like systems.  This is, for example, a local privilege escalation exploit for AIX from 2013, abusing this very  same issue.  As we will see, this knowledge was not really transferred between IBM's teams.  The only question is how do we find vulnerable programs on IBM that can be used for privilege  escalation?  So let's talk about research methodology a bit.  To harvest some low-hanging fruits, we can use the integrated database that I told before  to filter program objects that can be executed by anyone and run with owner privileges.  And now Zsoly will show you how to check the selected candidates for library-related vulnerabilities.  Thank you.  These basic tools are surprisingly effective in discovering potential vulnerabilities in  BGM and SRVBGN objects.  IBM uses EBCDIC character encoding scheme, therefore I need a converter to view strings  in a human-readable format.  Strings and grab commands are used for collecting, searching, and filtering.  The display program references IBM ICL command is used to verify the potential library list-based  findings.  The save object is also an IBM ICL command, and I use it to save the BGM and SRVBGN objects  for local analysis.  And of course, I need a Java decompiler, and you will see why soon.  Let's look at a real-world example through the vulnerability of the Crufax package.  Here is one of the affected BGM objects.  As you can see, the public authority is set to use, so every user can call it.  The affected BGM object owner is qoutprof, and it runs with the elevated privileges of  this user.  This simple shell command prints the references based on the library list.  Libel is the object type of the library list.  At this point, we cannot determine the types of the referenced objects.  It is possible they are only message files, and we cannot exploit it using the technique  that will be demonstrated.  So how can we determine the types of the referenced objects?  For example, we can use the display-program-references-cl command to verify there is at least one BGM  or SRVBGN object.  The highlighted object below is a BGM and is referenced through the library list.  If the seemingly vulnerable BGM object does not set the Crufax library during runtime,  this unqualified library call can potentially be exploited for privilege escalation.  This is the basic exploitation concept of unqualified library calls.  The user B1 user calls the vulnerable Crufax program object and that runs with the elevated  privileges of the CruoutProf user and makes unqualified calls to other program objects,  in this case the CrufQsys.  If the user B1 can modify the library list and the vulnerable program does not set the  library containing the original CrufQsys, this could lead to arbitrary command execution  with the CruoutProf privileges.  Let's assume at this point, the red one, we have CruoutProf authority, but this user does  not have any special authority.  Or does it?  The CruoutProf user has use authority on the Crufax MSF profile and the Crufax MSF profile  has all special authorities such as all object, IDDQD, if you know what I mean, and second  min.  So, what can we do?  In the IBMI environment, there is a term called profile swapping.  Profile swapping is a legitimate mechanism on IBMI to change the current user of a job  to another user.  Basically, it can be done if you know the username or the profile name and the password  combination or if you have use authority on the profile being swapped.  If you have use authority, surprise, the password is not required.  Let's continue with the exploit chain.  I used the highlighted CL script to perform profile swapping.  It gets and sets the new profile handler, assuming the current user has use authority  on that profile.  As I mentioned, the password is not necessary.  That's why I used the highlighted noPVD parameter in the getProfileHandle API.  Let's see this in action.  Maybe the picture will be clearer.  I'm logging in with user B1 and this user doesn't have any special authorities.  Printing the profile and as you can see, none.  I have already compiled the necessary PGMs in the user B1 library, but let's see the  source of the QFQSS PGM.  Here is the malicious PGM called by the vulnerable QFX component and as you can see, I only  call a command line.  I'm adding the user B1 library to the library list and displaying the accessible user profile.  We have access to these four user profiles.  Do you know why?  Violent?  Yeah, because we only have proper access over these user objects, obviously.  Yes, but the system contains dozens of other user profiles.  After that, I'm calling the vulnerable component and I have a command shell, so-called.  Printing again the accessible user profile.  As you can see, we have access to the QLProf and the QFXMSF profiles and I only have one  step to this exploit process, the profile swapping and if I print the accessible users,  you can see all the system users.  One thing to know about these library list issues is that we've already discovered literally  hundreds of these.  This is not an exception, it seems to be the rule.  IBM is cleaning up the place right now, as you can see in their advisories.  But yeah, it's a really rich attack surface and as you can see, it's like basic logic  bugs, you can find it if you have access to such a system really easily using basically  strings.  But this is not the only way to elevate our privileges.  There is also a command injection which is not a usual thing to use for local privilege  escalations, but on IBMI, it really works and the following example will also be useful  to introduce some new concepts.  One of these new concepts is the concept of service programs.  Service programs are objects that expose reusable code.  If you want to reuse this code, you don't have to load it from some shared file because  we don't have a file system or anything like that, so there are no SOs or DLLs, but all  the code is already available as addressable objects inside the single level storage.  So you can think of service programs as the love children of shared libraries and maybe  Windows services.  You can call an external thing like a service, but you are still technically in the same  address space.  So what does this mean?  Yeah, important things first.  Service programs can also run with adopted authority, of course, because they are programs.  Just like you can call a Windows service that runs with system, so it seems like a really  good previous opportunity, right?  At the same time, if we think about calling a service program like a call to a DLL, it  seems logical that control is just transferred inside their address space and there should  be no trust boundaries present, right?  And this is kind of how the situation looks like, so combining these two ideas, we end  up in a setup where higher privilege code is accessible basically without authentication.  And this is kind of similar to permissive pseudo configuration, as I show you here.  For example, this service program called QGAD lib A can be used by anyone, so the code inside  can be called by anyone, but it also runs with adopted authority, so this can be basically  translated to this pseudo configuration.  The QADR SRV user can be impersonated to run this command without password.  It would be a shame if there were some trivial exploitable bug in there, and Zsoli will of  course show you that there was.  My first step during an offline analysis is to check the strings in a PGM or SRV PGM object.  This SRV PGM object contains quite interesting strings, as the picture shows.  The SRV PGM calls Java to run code from multiple jars, therefore I examined all of them.  After a while, I identified the following vulnerable code section.  It's too trivial, but can you spot the issue?  The vulnerable code section creates a process using the parameter of the SRV PGM's one and  only exported procedure, and of course, why not, arbitrary user can set this parameter  and call the vulnerable SRV PGM.  This is the relevant part of the exploit, based on the JT open library.  The proper parameter convention is extracted from the healthmanager.jar.  This is too easy, isn't it?  I didn't believe it until I saw the created test file owned by a CUSAC officer.  So another demo about this.  I'm logging in with the user B1 profile and call CUSA to run Java.  And the second terminal.  Yeah, we are using two terminals, one with the CUSAC officer, which is basically root,  as you know, just to show you the users on the system.  I'm checking, there is no hacker user in the system.  Yeah, it's hopefully.  And I run this exploit with the user B1.  Refreshing the console.  And there is the hacker user.  With all object and second main special authorities.  Yeah, my favorite part, sometimes there is no need for an injection, low-hanging fruit.  The affected SRVPGM exports a bunch of procedures.  Most of them are used for creating files, directories, and so on.  And there is this system procedure.  You can find it in the last line.  What could possibly go wrong?  I guess the parameter convention based on the C library function system.  After that, the exploit was trivial, as you can see.  So, demo time.  Little twist.  For the demo, I created the exploit in CL, not in Java, to present a different approach.  So, let's see the source.  Also, because you like to hurt yourself sometimes.  I like the challenges.  This exploit runs two commands.  Creates a file object and sets the new owner to QDeerSRV.  Do you know why I had to use hex represented ASCII for the commands instead of strings?  Yeah, close.  These strings will be stored in fcdic after compilation.  But the SRVPGM expects ASCII as an input.  So, that's why.  Exit.  Let's check this file with QSACOfficer.  No such file in the system.  And call the exploit.  Sorry.  Yeah, and maybe, after refreshing, there is a new file.  And as you can see, the owner is QDeerSRV.  That's all.  So, I have another one, of course.  Multiple JAR files belong to the management central service.  During the assessment of these JAR files, I constructed the following code to achieve command execution with an SQL query.  This query is run by the management central Java server profile.  You can extract the exploit code from the mcclient.jar file.  And Balint will explain the QCMD ASCII function later.  So, let's see how this exploit works.  This exploit, we run a command that creates a new file object with the authority of the management central Java server profile.  I'm logging in with the user ribbon.  And call QSACOfficer.  Checking this file. No such file in the system. Great.  Yeah, running the exploit.  Oh, no, I'm just joking. The error message doesn't matter.  Okay, refreshing the console.  And as you can see, the owner is the management central Java server profile.  So, I have another one.  This service program exports a profile swapping procedure. Why not? Accessible to everyone, of course.  And this exploit only calls the exported procedure.  And the current JAR will have QBRMS authority.  The funny story about this.  After I had sent the bug report to IBM, they sent back an email informing me that this issue already had a patch.  My question was, where can I find the CVA for this patch?  Oh, we plan on generating a CVA, blah, blah, blah.  But after they did it, so case closed.  Digging deeper into the management central JAR files, I identified an interesting code section in mcprefserver.jar.  The IBM-developed code uses this service program, which has two important procedures.  We can use these procedures for profile swapping, and because of the adopted authority of the Qsys user,  we can run operating system commands with all object authority without a password.  Almost the entire exploit code is in the JAR.  You can only need to extend it with the command execution function, so house of GABA, or homework to do this.  Okay, a little bit of demo.  Yeah, we already signed in. Okay.  This exploit, we run a command that creates a new file object with the authority of the Qsys officer.  Let's check this file.  Okay, there is no such file in the system.  Another CUSA, and here is the exploit.  Running it.  Refreshing the console, and as you can see, there is a new file owned by Qsys officer.  Thank you.  Yeah, so it's almost getting boring, right?  There are so many venues for attack locally, but the question is how do we get there, right?  So far we've shown multiple ways for local privilege escalation.  And also previous publications about IBMI, security in particular, highlighted the common configuration issues,  including default passwords, weak passwords, misuse of the limited privilege on user profile, for example,  which is highly misunderstood, and unfortunately these are still problems, but you can read up on this in the literature.  We'll have some links.  Of course, the unique subsystem running inside IBM called PACE, and from this subsystem it's not virtualized or separated in any way,  so you can just run commands from there, and from the native command line you can run PACE commands and vice versa.  So that's also an easy venue, I would say, and of course there are always web applications.  Everyone's favorite web application, Vulnerability Test, is of course SQL injection.  That can also affect IBMI programs locally and remotely in a similar fashion that we showed,  because stored procedures are also compiled to program objects at the end of the day.  The important thing to highlight here is that the integrated nature of the system really blurs the lines  between the database component and the operating system component.  These are not really components.  The database is the system and the OS is the database, sort of, and this makes things interesting.  So hunting for SQL injection vulnerabilities is of course easiest during SQL.  I ran similar queries on the system to find some nice bugs,  but first of all, some of the system components are obfuscated or wrapped in IBM's terminology,  so their source code is not really visible.  I even found some actual injection issues, but they were so limited in terms of character length,  like you could inject two characters into a SQL query, which is kind of impossible to exploit.  So this didn't lead anywhere.  Also, I have to emphasize that in DB2, the infamous execute immediate statement  that basically evaluates this string as an SQL statement,  is limited in the sense that you cannot run selects like this,  so a foot gun is taken away from developers, and this is good.  But at the same time, our usual dynamic tools just work as expected  and can find vulnerabilities at each layer of the software stack,  from the web scripts to the translated SQL programs that exist on the system.  And if you find an injection like this,  first of all, you will be tempted to play around with the system objects,  because they are, again, translated to this relational schema,  but there is an even better way for post-exploitation.  This image shows the default permissions of QCMD exec,  which is a SQL function, which is kind of equivalent to XP command shell from Microsoft SQL Server,  so you can execute OS commands with it,  and as you can see, the public can use, aka execute, this function,  so SQL injection likely means remote code execution on IBMI.  We unfortunately cannot show you a demo of this on the base system,  but here's an example from one of our Pentest projects,  and as you can see, here's a trivial SQL injection vulnerability  that we used to call QCMD exec,  and here's the result giving us the output of the native command,  in this case, with the rights of the core accounting system,  if you recognize that name, maybe.  I have to emphasize that this component was not the vulnerable one,  it was an external extra development,  but still, the core accounting system became vulnerable because of this.  So, we still kind of want to have an authenticated remote code execution on the base system,  and this is, as of today, not enough,  so we have to knock it on the knop a notch,  and Zoj will lead the way in that.  Thank you.  This is one of our unauthenticated remote code execution vulnerabilities,  and its explanation.  Honestly, I like dumbfuzzing.  It's easy to do, quick, and can be very effective.  I have found some issues with this technique,  for example, a format string vulnerability in the Apple Remote Desktop service,  and the buffer overflow in the SSL implementation of Ascada software.  When I tested the DDM architecture,  I focused only on the unencrypted version of the DRDA service,  and I'm not a huge fan of reinventing the wheel,  which is why I used this really good paycab-based fuzzer with some modifications.  So, how does the DRDA protocol work, and what is it?  DRDA means distributed relational database architecture,  and this is a standard protocol to interconnect databases and applications.  This protocol, by design, allows command execution after authentication,  and you can see the normal and simplified way of this protocol.  The client sends authentication information to the sign-on service.  The sign-on service sends back some kind of token after successful authentication,  and then the client uses this token to re-authenticate to the DRDA service,  and after that, the client is capable to send commands.  This picture shows the expected behavior in case of incorrect credentials,  but what does the fuzzer do?  It completely ignores the sign-on packets and works only with the DRDA packets.  We can send a whole DRDA PCAP without any problem.  If the authentication information is wrong, the service will run the command with its own authority.  So, let's review the steps of this discovery.  First, I'm running the fuzzer to identify the authentication issue in the DDM architecture.  Here is the DRDA communication saved in a PCAP file.  The strings are in EPSIL format, so I have to change the encoding.  So, this command creates a testcmd file object in the QGPL library,  and uses the user v1 user and uses the scrambled password and token mix.  The important part here is you cannot just replay packets because of the authentication mechanism,  but if you just send corrupt enough packets, then it will just work, hopefully.  Let's check this object.  Sorry.  Yeah, no such file in the system.  I'm running the fuzzer.  It's really quick.  Yeah, it's not every day that you see a fuzzer finding a bug on stage, but this is live, actually.  Yeah, refreshing the console, and as you can see, there is a new testcmd file object  and the owner is a Q user.  As I mentioned, because the authentication information is wrong,  so the service will run this file object creation command, and this service has a Q user authority.  Based on the PK file, I wrote an exploit that can run arbitrary CI commands.  Next, I'm going to present the exploit which runs a BindShell.  Yeah, BindShell.  Is the font size visible? Sorry. On the back? Okay, thanks.  Yeah, BindShell, because during Pentest projects, we use a VPN and cannot use ConnectBackShell.  So, before that, sorry.  I'm checking. There is no listening service on the port 4444.  Yeah, good.  And I'm running the exploit.  Fingers crossed.  And we have got a shell.  We have got a shell.  Yeah, so it's not looking good, is it?  So, you're probably wondering what defenders can do to prevent the compromise of their IBI systems.  And honestly, we are attackers. This is the attack research track.  So, we are not really going into details, but I tried to give you some ideas or ways to think about.  First of all, the main issue seems to be is that IBIs seem to live on islands with little interaction from other parts from IT.  And by little interaction, I don't mean that these systems are isolated, so they can be definitely reached after a client-side attack.  And they can even be reached via the Internet.  There are some IBMI exposed services out there. You can find them and show them.  By little interaction, I mean that the IBMI administrators and the security team don't really talk to each other.  So, for example, the IBMI might be connected into a log management system, but the blue team, the SOC, doesn't really know how to interpret the log messages at all.  Because the system is just so different.  And also, the other way around, many sysadmins still think that, for example, setting a user profile to limited is a security guarantee,  while even IBM documents that this limitation, which means that you basically cannot get a command-line shell, sort of, only applies to some services, but not all.  And if those other services are reachable, then your defense doesn't worth anything.  So, at more fortunate places, I would say, we see a good number of exit programs deployed.  Exit programs are automatically executed programs that are hooked to different system events.  Like, when you execute a SQL query, an exit program can analyze that query and interrupt the execution for security reasons.  And these solutions, I can say, are working just fine, but they also suffer from the same problems like antiviruses and EDRs.  Namely, where do you hook into the system?  How do you determine about the piece of data, whether it's malicious or not, etc.  You can think of any antivirus bypass.  How do they work?  And this is kind of a similar issue with the exit programs.  But if you have them, especially if you implement some custom defenses that the attackers cannot prepare themselves for, they can be really useful.  Also, speaking of custom defenses, we also propose a simple way to implement canaries on IBMI.  And we would love to see such deceptive technologies being deployed on IBMI and catching actual bad guys.  Because my working theory, personally, is that the attackers are already on these systems.  We just don't have the telemetry to tell where they are or whether they are on this system or this system.  So, you can read this in our blog.  It basically works with placing triggers on file objects, which is like mixing the file system with SQL, which is really interesting.  But a little bit out of scope for this presentation, please read our blog post.  For robust mitigation, we believe in configuration hardening.  If you listen carefully, you could probably spot opportunities like limiting the profile swapping API seems like a good idea, right?  And also reducing the attack surface by discovering which programs have adopted the authority and maybe reducing that number.  So, there are not that many bugs that we just showed you.  In our experience, such hardenings can make a huge difference, but they have to be really carefully tested because sometimes really crazy configurations are required for the normal operations of the system.  Fortunately, there are usually test systems, so this is doable, but it's not trivial, unfortunately.  So, the most important message that I want to convey here is we have to have stronger integrations, both for ideas and both for data to come across the regular IT and the IBMI world.  So, we can exchange knowledge about this very special system and exchange knowledge that is known about the current threat landscape and how attackers work and how do we catch them.  And these bridges, I think, are the only way to make sure that this actually really great platform can operate securely in the decades to come.  So, this was the main part of the presentation. We will just show you one last demonstration, which kind of puts all the things that we talked about together.  Yeah. I chained remote command execution and local privilege escalation, and this exploit will create a new user called hacker.  So, quickly check. There is no hacker user in the system. Yes, it's good.  And I'm running the exploit.  Bless you.  Yeah, and refreshing the console. There is the hacker user. Thank you for your attention.  So, are there any questions? Is this my task to ask this?  Usually, I do that, but you can also ask for questions, of course. Yeah, we have time for some questions. Are there any in the room?  Yeah.  Yeah, from my side, at first, thank you for the interesting talk, and my question is, how common are attacks against IBM IA systems?  Like, do you actually see that something like this is exploited in the wild?  That's the point. We don't know, really. We are not doing, like, DFIR work, so we don't really have that kind of insight.  But, for example, I wouldn't recall the name of the person who does this kind of jobs, and he has some posts about people beware, because there are hackers on IBM IA, too.  But, of course, because of MDA and la-la-la, we don't have anything specific, and especially we don't have anything like technical details about how the attacks actually work.  Do they exploit these particular vulnerabilities or something completely different? What kind of data are they after?  So, we would really need more telemetry from this.  Thank you.  Any more questions? Over there.  Thank you.  At the beginning of this interesting talk, you were telling us that you're dealing with midframe, IBM midframe. Do you know if that's the same problem, the mainframe, with the big systems?  We don't have experience with System Z and the big guys, but I would say you can find much more hacking content about proper mainframes than for IBM IA.  That's why we choose this niche. Like, how come that, okay, the PC world has all the hacking stuff going on. Even the mainframe world has the hacking stuff going on. Not that much, of course.  But, somehow, there was very little information about this middle ground. I cannot say anything about the big iron.  Yeah, and we don't have money to buy a machine.  Thank you for the talk. It was awesome. Do you have any indications as to how many of those systems are still being used out there? I mean, they used to be pretty popular in the late 80s, early 90s, but how many of those are still being used?  Do you have numbers, maybe, Sully?  On Shodan, maybe 3,000 or 4,000. I don't know.  And those are internet reachable, obviously.  Yeah, but most of our clients are using this technology. That's why we try to learn the IBMI system and the exploitation.  Yeah, I would say that...  Banks, telecommunication companies.  Yeah, retail is huge. And just a wide estimate that if you see 3,000 exposed systems, then you can easily multiply it by 10, maybe.  Yeah, and there is a homepage, maybe all400s.com, something like this. And this collects all the machines.  Yeah, from public information, they are keeping a list. But the fact that they can keep a list kind of tells us that it's not the same like PCs.  Yeah, it's really prevalent.  All right, any more questions?  Then please thank the speakers with another round of applause.  Thank you.  And we have a coffee break.