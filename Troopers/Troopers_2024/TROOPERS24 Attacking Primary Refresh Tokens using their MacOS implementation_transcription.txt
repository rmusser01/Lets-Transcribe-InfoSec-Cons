{
  "webpage_url": "https://www.youtube.com/watch?v=wFhe0-RRkFA",
  "title": "TROOPERS24: Attacking Primary Refresh Tokens using their MacOS implementation",
  "description": "Talk by Olaf Hartong and Dirk-jan Mollema - June 27th, 2024 at TROOPERS24 IT security conference in Heidelberg, Germany hosted by @ERNW_ITSec\n\n#TROOPERS24 #ITsecurity \nhttps://troopers.de/troopers24/talks/3vlccy/\n\nMore impressions:\n  / wearetroopers  \n  / ernw_itsec  \nhttps://infosec.exchange/@WEareTROOPERS\nhttps://infosec.exchange/@ERNW https://ernw.de",
  "channel_url": "https://www.youtube.com/channel/UCPY5aUREHmbDO4PtR6AYLfQ",
  "duration": 3327,
  "channel": "TROOPERS IT Security Conference",
  "uploader": "TROOPERS IT Security Conference",
  "upload_date": "20240909"
}

This text was transcribed using whisper model: large-v2

 Hello everyone, welcome to our nice storybook, probably the most over-engineered slides I  ever created, but I hope you enjoy them.  So we're going to talk about Prima Refis tokens, primarily what we found on Mac, we might say  some stuff about the Windows implementation, but the focus will be Mac, maybe.  So a couple of things that we're going to talk about today, right?  So we're going to start with explaining a little bit about Prima Refis tokens, it has  been announced a couple of times over the last two days, but you may have been somewhere  else, so we're going to talk about it regardless.  Then we found during our research that there are actually multiple versions of the protocol,  and this is very important because maybe the Microsoft documentation is not very accurate  on that side.  We'll briefly talk about the Secure Enclave on Mac, which is their implementation of the  TPM, which Microsoft mostly uses, and quite well actually.  So there won't be a lot of zero days sadly today.  We did report our findings to Microsoft and then they wanted to call with us, so you can  sort of figure out what it was.  So we thought it was like a benign thing and out of courtesy we would report it.  Turned out it was a critical vulnerability and they wanted six months to fix it.  So we can't do all the demos.  So we might allude to some things, but not too much since we promised not to talk about  it.  But there's still a lot of interesting stuff.  There will be interesting things, for sure.  So for the people that don't know me, I am Olaf, I like warm hugs, I'm a detection engineer  and security researcher at FalconForce, a Dutch-based company where we do a lot of cool  detection engineering, but also red teaming work.  And if you want to still listen to me afterwards, you can follow me on Twitter and reach out.  Yes, I'm Dirk Jum, I think this is my fourth time at Troopers, so I always love being there,  so thanks again for having me, always a pleasure to be here.  I do research and pen testing and training, mostly on Microsoft products, started with  Active Directory, moved to Entra because that's where all the fun stuff is at, and as Sean  described, there's already like 20 years of history in researching Active Directory, but  with Entra it sometimes felt like I was the first one that was looking at it together  with Nest 3.  So there's a lot of stuff to explore, there's a lot of new stuff, there's new stuff coming  out every month.  That is also why we're going to talk about something that I don't think anyone really  covered so far.  And this actually goes back a little bit, because we already started with this research,  or I think it started when Olaf sent me a message like, hey, you talked about Prime  Refresh Tokens, why not have a look at how it works on Mac?  And that was in 2022, and then we did a bit of research in December 2022, and then we  were like, oh, yeah, it's pretty fun, maybe we should submit it for Troopers, but then  the last year Troopers deadline was already gone, so we kind of kept it and it was there.  And then this year we were like, okay, well, let's submit it to Troopers, that way we for  sure have to finish the research, and then we actually finished it in the last few months.  We also find some time to actually send the report to MSRC, so even though we already  knew the details, like in 2022, we only really worked it out, fleshed it out, written all  the proof of concepts, submitted it to Microsoft last few months, and then we also found out  that all the research that we did was already outdated, because Microsoft had a completely  new implementation.  So that was, of course, more fun for this talk, so now we'll also cover the latest and  greatest implementation.  And the story, we have a few characters.  Yeah, this is just to sort of indicate what we're talking about, right?  So we have our little squirrel, who's implementing code, maybe not always in the most secure  way, sometimes actually it is, so you have sort of a highlight.  We have our little bear, who's trying to find a tech path during our whole exploratory thing  through EnterID.  We have our little beaver that's trying to build dams and trying to build security, and  then we have our little kingfisher, who, of course, likes fishing.  So there's a lot of weird puns in there, dad jokes as well.  And we weren't the first to look into this, actually Thomas Naunheim from Glukanya already  looked a little bit into using the primary refresh token implementation on Mac, and he  played with it a bit.  At that time, Dirk-Jan's roadtools and roadtx wasn't compatible with it yet, so he figured  out some things, but not everything.  But definitely his research, when we were looking into it, helped us a little bit or  clarified some bits.  So we want to thank him, at least for writing this blog, because this predates our research.  And as promised, we're going to dive a little bit into PRTs, and we're going to go very  deep into them afterwards with a lot of crypto fun, so I hope you are very awake after lunch.  Otherwise, good luck.  And it starts in the simplest way, right?  So a user might want to log into Teams, so they do, they sign in, Teams talks to EnterID,  it gets some tokens, it requests tokens, it gets tokens, and then with that, it will actually  use the refresh token to get an access token to the Teams backend, but also to Exchange  or SharePoint, all these kinds of resources.  And it's kind of important where the application and resources are scope-based, right?  So they can only be used for certain types of activities.  And from there, we can move on to how the implementation is on Windows.  Yeah, because this is the simple case, this is just basic OAuth, access tokens, refresh  tokens.  But the problem with this is that every app kind of has to manage its own tokens, which  is of course a bit of a, well, it's not ideal, it's much better if you have one source of  all these tokens, and on Windows, that is the primary refresh token.  And if you have a primary refresh token, then this flow of this little bear trying to sign  into Teams, it's a little different, because in this case, this bear actually doesn't sign  into Teams, but they sign into Windows.  So you can do that with any of the authentication methods, you can do that with Windows Hello,  you can do that with a username and password, with a Fido key, but essentially you're passing  your credentials to this LSS service, the Local Security Authority subsystem on Windows,  and LSS is going to talk to Entra and ask for this primary refresh token.  And this primary refresh token acts as a single sign-on token in your session, so any app  that runs in your session is going to use that, but it's not going to directly talk  to LSS, but instead it's going to use a broker.  So on Windows, this is the WAM, or Web Account Manager, and a client like Teams, it can talk  to this broker and ask for some tokens.  If the broker already has tokens, it can directly pass them to Teams, and if it doesn't have  tokens, then it can ask LSS to actually use the primary refresh token.  So LSS has access to all the key material, all the secrets, which are most likely in  a trusted platform module, so actually hardware-backed, and LSS is going to give the right details  to the token broker, the token broker talks to Entra, receives the tokens, gives them  to Teams, and Teams can send these to all the backend services.  So this is how it works on Windows, but actually the implementations we're going to look at  today are quite similar.  Of course there's different processes involved, but it all works with the broker that is basically  responsible for doing the authentication flows, using the PRT, and then passing the tokens  to the clients.  So just a little bit more details on primary refresh tokens, I'm assuming most of you are  familiar with them, because we have been talking about them already quite a bit.  So they are single sign-on tokens in your session, you can not only use them for web  apps, not only for native apps, but also for web apps in the browser, so it really can  sign in your account to everything.  And they are also what links your user identity to the device that you're on, so if you're  working with conditional access policies and you require compliant devices, how does Entra  know that I'm on that device?  It knows that via the primary refresh token.  So the primary refresh token contains the device, and that will be sent whenever I authenticate.  And this primary refresh token, it has a lot of cryptography involved, and one of the keys  it needs is the session key, and on Windows this session key will be protected by a trusted  platform module if you have one, and that means that the PRT is also always bound to  a device, so you cannot have a PRT without first having a device.  So if you look at like how many of these tokens are present, usually there's only a  few PRTs on Windows, but of course at any time there can be many refresh tokens which  are more scoped, because they're scoped with a specific app, and a lot of access tokens  because you need a specific access token depending on the service that you're talking to.  So this is basically the stuff on Windows, and Windows has a set of APIs that it uses  to request these tokens, and then we started looking at macOS, and there it was a little  bit different.  So on Windows it's basically the API version 2, and macOS has API version 3, and what also  surprised us is that a primary refresh token is not always tied to a device, but you also  have device-less primary refresh tokens, but to look at that we first have to look a little  bit back and look at all the cryptographic keys, because there are a lot of keys, different  keys used for different platforms, and we have two important keys slash certificates.  So on Windows what it's using is the device certificate, so whenever you register the  device it asks for a certificate, and it has a private RSA key, and it also has a transport  key that it uses to basically encrypt data whenever it's talking to enter.  On macOS, at least with PRT version 3, it's quite similar, there's a little bit difference  in details, because Windows has these internal Windows structures that it uses to send these  keys, and on macOS it's using the JSON web key specification to actually transfer these  RSA keys, or at least the formatted ones, and all these specifications are open source,  they are based on RFCs, and most of the RFCs are written by this guy Michael Jones who  works at Microsoft, and most of this research was basically figuring out what Michael Jones  came up with, and how the rest of Microsoft butchered his implementation in very weird  ways, so the RFCs are already difficult enough to implement, but if you also need to figure  out what ways Microsoft deviated from that, then it's a whole different headache.  So we'll see this name a few more times.  So how does this work to actually ask for a PRT on Windows?  So this should mostly be familiar, because we've already talked about this previously  as well.  Basically you start with some authentication material, and that is sent basically to Entra,  and that's sent with a payload that's actually signed with your device key, so it proves  that this device is the one actually requesting that primary refresh token.  So Entra will then send us back a primary refresh token, and it will also send us the  session key, so the session key is the most important part here, because that is needed  to use the primary refresh token.  The session key is encrypted with a transport key, that was the second key that we just  talked about, so the device can decrypt the session key and then it can use that to actually  request tokens.  When it does that, it creates a payload containing the PRT, it signs the payload with the session  key, it sends that to Entra, Entra sends it back some tokens, which are again encrypted,  so there's a lot of encryption involved here, but this last part it uses the session key  with a protocol called JSON web encryption, there's RFC for that, written by Michael Jones,  et cetera, et cetera.  So there's a lot of different layers of encryption, and the device can decrypt these tokens and  then use them.  So this transport key is used during the initial step, and then the session key is also used.  So this is the Windows flow.  Now when we looked at macOS, it was a little bit more complicated, and when I say a little  bit, I mean quite a bit, because I work with tokens every day, I understand most of the  flows, but even for me all these different flows and all the different parts and the  different protocols, it's mind boggling a little bit.  So I tried to summarize it, but it's not the only way, and not the only way to do this.  Basically if you want to do this on macOS, then you first need to sign in.  So this actually follows a OAuth flow, which is the authorization code flow, so it's the  same flow you would use if you log into a website.  And the components running on your device, it receives an authorization code.  And then it's actually going to create a transport key, like on the fly, because at this point  we don't have a device yet, so there is no device certificate, there is no registered  transport key, so it just creates one.  And then it gets back a primary refresh token.  But this primary refresh token is not actually linked to a device.  It's basically a device-less primary refresh token that we can use for single sign-on.  We also get a session key, the session key is encrypted with this transport key that  we made up over here, and then we can use that to maybe register the device, so it first  has a device-less PRT, we can already use this for single sign-on.  Or we can basically use this to upgrade it to a PRT that is tied to a device.  So with this single sign-on PRT, we can ask tokens, we can register a device, we can also  do single sign-on directly, so this part is not always needed.  But if we want to upgrade this to a full PRT that is linked to a device, then we can actually  register the device and then send this PRT plus the signature that is based on the device  certificate and the device key to Entra, and then we get back a full PRT.  So this is similar again to Windows, it's just these extra steps in between that we  don't see on Windows.  So once we have this PRT, then we can use it again, so we can use the session key that  we got that is now encrypted with the actual transport key, we can send that to Entra,  and then we can receive back the token.  So again, it's similar to Windows.  But the big difference is that there is basically two PRTs here, one that is not linked to any  device because at this point there was no device yet, and one that is actually linked  to a device, to your Mac in this case, that register itself somewhere here in between.  So don't ask us why it works this way, because it's just some observations we made.  There's also a slight variance on this, but this is basically the flow that we observed.  Yeah, that's also one of the things that you should take away.  There was a nice little orange sun, or whatever it's called, so there's a couple of slides  that are the most important ones.  So when you download the deck, make sure to look at this and then also understand that  this bit is a little bit optional, so you can be creative with that, maybe.  And there's probably more, right?  So we have some caveats, because we only looked at the implementation for Edge.  This is how we discovered the device-less PRT.  So if you log on to Edge on Mac, it will ask you, hey, do you want SSO within Edge?  And that's basically where it generates only that device-less PRT that will use the same  flow as before, but without the device-bound registration to actually log on to all the  services that you are accessing with Edge at that moment.  So that's one of the ways why we discovered this in the first place.  The other implementation for PRT3 is if you enroll your device into Intune, which has  been possible for quite a while on Mac, and Microsoft built their own little SSO extension,  which is basically being pushed once you enroll, and that will actually generate a device-bound  PRT.  So that full flow that Dirk-Jan showed you earlier will be applicable.  In the meantime, you might have two PRTs on your system, so you can still, as an attacker,  play with that if you would want to.  Depends a little bit on what you want to do, right?  But during our conversations with Microsoft, we also learned that this was not the only  implementation of this.  So there are also examples on Android, iOS, and we didn't see them on Windows, but maybe  there is an Edge case there as well.  So there's way more implementations than we are probably aware of.  And on Mac, it looks a little bit like this.  So this is probably not very legible, but this is just a normal logon request where  I put my password in, which you shouldn't be able to read, even though if you could  read the slides, and it will basically do a POST request to the normal login.microsoftonline.com  website.  Where we'll send is the special authorisation code that Dirk-Jan mentioned earlier, and  that on-the-fly generated RSA key, which is in memory at that moment, and it will receive  its initial primary refresh token by then, right?  So this is just in that JWK protocol, there is this blob where there is a 64 encoded RSA  key that will be used as the public key for that exchange.  And then, if that's successful, you get the normal stuff back, just a Fokey token and  some refresh tokens where you can play with.  And this is then our primary refresh token.  So what we see here is the refresh token, and the way that we know it's a primary refresh  token is because there's this session key on the bottom which is encrypted, so we can  use the private key of this public RSA key that we just sent to decrypt all that stuff,  and then we have our device-less PRT, because the key, the transport key, was not coming  from a device, it was just like generated on the fly.  Thank you.  And that's also basically when we get our full PRT, if we start to upgrade it for a  PRT, we'll actually get a encrypted PRT back, right?  So this is the request which has the whole, it posts that signed refresh token, and from  there we will actually get an encrypted PRT back which is encrypted with the transport  key and the session key.  And basically what happens then is it will be saved in our keychain, and the keychain  is sort of the secured storage for passwords and other key material on Mac, and it basically  stores everything in the password field over here, which you need user passwords to actually  access it, right?  So it is a bit protected, or it's quite protected in a way.  There's also all kinds of access control on it which I'll show you later which has entitlements  only for the Microsoft programs that have access to it.  So the item itself is quite well protected, but if you know the user's password, for whatever  reason, you can actually just copy this whole blob, and if we would look at it a little  bit more, you see as well that we see a secret, that it is a PRT, and we also see the session  key next to it.  And if we've ever played with PRTs in the past, we know that we can just use RhoTX to  actually exchange these for all kinds of very nice access tokens that we want, right?  So that's maybe not the biggest hacking technique.  No, no, no, this is a very big technique, so we held off from releasing these very difficult  steps, because obviously Command-C, Command-V is way too difficult.  We're joking a little bit, but on Windows, there's like a lot of layers, and if you have  a TPM, it's like in a TPM, and the user, even if their system cannot reach it, and on macOS,  it's like, well, if I go to this keychain app, I type my password, and I copy-paste  it to wherever in the world, then you can use it, because it's not bound to a device,  it's just like if you have a PRT and a session key, you can use it, and that's it.  So if you have a macOS device that's managed by a company, and you want to, I don't know,  access some resources, exfiltrate some data, you just Control-C, Control-V, or Command-C,  Command-V on macOS, and then you can use your compliant device state from anywhere  in the world via this PRT.  Yeah, so this is not great, right?  And this is probably still the more commonly used implementation, because recently they  actually improved the whole stack, where we're going to go after this slide, but if you would  run into a Mac during an engagement right now, most likely that you would find this,  or maybe even worse, the device-less version, where you can just have the same and upgrade  it and register your own device, potentially.  So I also talked a little bit about the PRT4, right?  We alluded to it a little bit.  Intune now added support, I think a couple of months ago, where they are actually supporting  the Apple-based platform SSO module, and the big difference there is that that module is  designed by Apple with different standards, maybe sometimes also better documentation,  which is not common for Apple, to be honest.  And they also use the secure enclave, which is the TPM implementation on Apple.  So the big difference there is that due to this implementation, Apple actually brokers  for the whole authentication flow, which Microsoft describes as similar to Windows Hello for  Business.  We've all seen Dirk-Jan's talk on those kind of things, so that still doesn't mean it's  fully perfect, but it is definitely better than the previously alluded-to slides.  And it's also very different than the Microsoft self-built SSO plugin that they had.  You can still use that, I wouldn't recommend it, though.  So the secure enclave is similar to a TPM, I'm very terrible with crypto, I at least  understand that it's an isolated compute node where it actually deals with the key material  in a very secure way and not very easy to access it.  So if you would want to run this, these are a bunch of screenshots from Intune.  So basically if you build your own Intune policies, how you onboard devices, you can  select the authentication method.  So this is fairly new, it's like two, three months old in general availability, it's been  in preview for quite a while, seems quite stable, so if you can, try to convert towards  it.  And here you can select the user secure enclave key.  So that basically enforces the use of the whole TPM implementation on Mac.  And if you would enroll a device, it will also register it in Entra.id, and if you have  the right policies, it will also be compliant, of course.  And after that, you need to reboot, so that the platform SSO module on Apple can actually  ask you for your credentials, again, you also need to do MFA, again.  And with that key, it will actually start building a PRTv4 that will also be used as  a passkey.  So it's just actually kind of neat.  From that perspective, we have a couple of very nice flows that Dirk-Jan will allude  to.  Yes.  So we're going to look at how PRTv4 basically differs from the other PRT flavors.  So if you have PRTv3 or the Windows implementation, which is v2, then it starts with the device  registration, and for v4, you also need to have a device that is registered with Entra.  And the differences, they kind of start with this request.  So this is also very similar to how a Windows Entra registration looks, but the difference  here for v4 is that the key type is actually based on elliptic curve cryptography.  It also says key security secure enclave.  This adds a lot of value because, of course, you can just write that string there, it's  not going to make a lot of difference.  But it is using different key types.  So PRTv4 is not backwards compatible with the other versions because it uses a completely  different way of doing cryptography.  I don't think that it was Microsoft's idea to do this because Microsoft is just using  the platform SSO module and using whatever Apple provides, and Apple decided to go with  this is my assumption.  Transport key is also an elliptic curve key.  Basically what they call this with Apple is basically the signing key and the encryption  key, but that's kind of analogous to the transport key and the device key that we see on Windows.  All right.  So this is the request that we sent.  We get back our device certificate from Entra.  So again, this is the same on all the platforms.  Essentially you register your device and you get back a device key, just different cryptography  involved.  It's also different from the v3.  So if you have PRTv3 on macOS, then you have your device certificate, which is backed by  an RSA key.  You have your transport key, which is an RSA key sent as a JSON web key.  But if you have v4, then actually both keys are elliptic curve keys.  And in this case, the keys are also in the secure enclave.  So all the encryption is kind of tied to the secure enclave.  So you cannot just access these session keys or copy them from somewhere, because they're  all bound to the secure enclave.  So how does it actually work with PRTv4?  And again, you'll notice this little sun.  So this is an important slide that if you do remember a few slides, this should be one  of them.  And actually the mechanics here are slightly easier.  The actual implementation is definitely not easier.  But again, we start by authenticating.  So you log in to your device or to the Intune company portal app.  And then it's actually going to register your device.  And then for the PRT request, it's going to send a payload that is signed with ECDSA,  or elliptic curve digital signature algorithm.  So it's just using basically the equivalent of a RSA signature on the payload, but now  with elliptic curve keys.  And then it gets back a primary refresh token.  So this is already a device-bound primary refresh token.  There's no device-less implementation in v4.  It's all device-based.  But the biggest difference is that here there is no session key.  So PRTv4 does not work with session keys.  It only works with PRTs directly.  And all the usage security is basically tied back to the device certificate.  So how does it do that?  Basically whenever we try to use the PRT, we sign the payload.  In this case, we don't sign the payload with the session key, but we use the device certificate  again to sign this payload.  And it's actually going to request like ECDHES, which is basically doing elliptic curve Diffie-Hellman  with ethereal static keys.  If I say that correctly, we'll look at the actual implementation later.  What it's essentially doing is a Diffie-Hellman key exchange.  And every time it tries to use the PRT, it's going to kind of negotiate a temporary session  key that is only valid for this specific response.  So I use my PRT.  I send it to Entra.  Entra sends me back this encrypted response.  And this response can only be decrypted by completing the Diffie-Hellman key exchange.  Then I can derive my key that is actually used for encryption.  And then I can decrypt this response and the token.  And of course, this key is in the secure enclave.  So even if we can intercept all of this without access to the secure enclave, we cannot access  these tokens.  So how does this look on the wire?  So we do see the PRT protocol version 4 being used now.  That was a lot of fun when we first saw this.  We were like, oh, yeah, we're just going to take a look at PRTV3 and how it works with  the new SSO extension.  And then it was suddenly V4.  And we're like, what?  Anyway.  So it's sending a signed request.  And it is embedding this device certificate.  So this was a certificate that was issued to our device earlier.  So we're saying, like, this is our device.  We are presenting our certificate.  We are signing this request with our private key.  The signature algorithm here is based on elliptic curve cryptography again.  So we're using ECDSA to actually sign this whole request.  And then we get a PRT.  So normally, if you request a PRT, you get the PRT and you get the encrypted session  key.  But in this case, there is no session key.  So we get the PRT basically in plain.  There's no encryption involved.  And it doesn't really matter, because the PRT is bound to our device.  And we can only use it by sending, again, something that is signed with the device key.  So if we want to use the PRT, we send a very similar request.  Again, we sign it with our device key.  We prove who we are.  And then when we get back, this is a little complicated.  So this is essentially the part where Entra generated, like, a temporary private key or  an ethereal key.  And we need our private key in the secure enclave to then calculate the session key  that's used on the fly.  And with this algorithm, we can then calculate the AES key that is used to decrypt this whole  blob.  So it's just using AES GCM.  And we can decrypt it.  And then we actually get the tokens.  So this is, of course, a little complicated.  It's nicely described in this RFC.  Or I say nicely, but it's not thatï¿½ maybe they should use a language that actual humans  can understand.  But essentially, it is using elliptic curve Diffie-Hellman static keys in combination  with the concat key derivation function in this section 581 from NIST something document.  Luckily for me, there's already libraries that implement this.  Because I tried some cryptography, and that didn't work out very well.  But basically, we can use all of this stuff and kind of create our own implementation.  And I'll let you guess who wrote this document.  All right.  So if you implement all of this, and we did.  And actually, the helpful thing here was, again, the Apple documentation.  Because Apple also realized that this is maybe a bit complicated.  So they did give you an example of what all these inputs at different steps would be and  what the resulting cryptographic key would be.  So then you can kind of write your own implementation and at least make sure that it's working for  this sample request.  Yeah.  And it was kind of funny during the research.  I didn't understand this bit at all.  So Dirk-Jan was going through it, and I was like, damn, this is complicated.  And then he started pushing in some code.  He did a test and completely dumbfounded that it worked.  First time ever.  That was really cool.  Super impressive to see.  Still don't understand fully how it worked.  But it's pretty impressive.  Me neither.  But I do have a working implementation.  He mostly got it to work.  So many layers of like layered and stacked cryptography in there that it's probably even  Mr. Jones doesn't fully comprehend it anymore since it is 2015 that he wrote this.  Again, back to the keychain.  We get a similar item.  Maybe if you recall, the previous one was only like called dash one.  It doesn't increment, but it's always called dash one.  And here it's actually sort of named with the device and the tenant name in it.  Similar information.  We still see this, right?  If we click the button and we enter our passwords, we'll get information there.  That information is still protected like the previous one.  So there's all kinds of entitlements on it.  It's pretty difficult to change this.  So it's relatively secure.  And in this case, it doesn't really matter.  Because if we look at the same blob, we see secrets.  We see that it is PRT version 4.  But we don't see that session key anymore.  As explained, we can't really use this directly.  And maybe some refresher on the refresher.  According to the Microsoft documentation, PRT always contains a device ID and a session  ID.  We just learned it doesn't.  It doesn't need either or.  So there's multiple implementations of this.  And this is, of course, the last really memorable slide that you should have in your brain.  Is where we have the different versions with their different implementations, right?  So we have a device bound one, which is fairly similar to the Windows implementation.  With the exception that it's slightly different cryptography.  And it's, of course, all of them are stored in the keychain.  Version 2 isn't.  Because it's a Windows thing.  The device one doesn't have a device ID.  Because it's not bound to a device.  And version 4 doesn't have a session key.  Because that's handled with the secure enclave.  And of course the crypto is completely different.  The use by is with the caveat that this is the stuff we looked at and we are aware of.  We also are aware of that the device bound V3 is also used on different operating systems.  So have fun researching that if you want.  So still interesting to remark, even though the PRT itself says 14 days, that's still  a lie.  People make wrong assumptions sometimes.  It's actually valid for 90 days, right?  So if you manage to capture this, then you will actually have fun for 90 days.  And maybe you can do some other things with it.  So one of the things is that we can fish for this.  And Dirk-Jan has a demo for that.  And of course, except from the first line, none of that is documented anywhere whatsoever.  Yes.  All right.  So what can we actually do with this?  Because we can do a lot of attacks.  We can do phishing attacks.  We can do token stealing attacks.  But one of the downsides often of phishing people, that is that we often need a device  to get a PRT.  So there are ways around that to register your own device on the fly.  But most of the time, you see people phishing for, like, cookies.  And cookies, they're all right.  But I don't like cookies.  Because Microsoft treats cookies as, like, basically a black box.  And I can send a cookie at one point, and then it will be fine.  And if I send it five minutes later, then suddenly my cookie is revoked without any  clear error message.  So I don't like things that I cannot explain.  So if I phish someone with, like, evil jinx, and then I have a cookie that may or may not  work for X amount of time.  But what we can also do is we can phish people and ask for a deviceless PRT.  Because we saw the deviceless PRT flow just starts with the OAuth authorization code flow.  And we can just use the correct client ID, for example, emulating edge.  And then we get this special authorization code that we can use to request a single sign  on a PRT.  And that is a lot more solid.  Because PRTs are normally not revoked.  At least there's no magic to revoke them.  Unless, of course, you hit that revoke tokens button in the admin panel.  Or do that via PowerShell.  But it's not like Microsoft has some magic when it will not accept a PRT.  Unlike with cookies, which they often just refuse for no reason.  All right.  So I'm gonna do a small demo of actually phishing that deviceless PRT.  I don't know if some of you saw my video I posted, like, earlier this week.  For phishing for a full PRT.  There were a lot of steps involved.  But this one is a lot simpler.  So in this case, I'm using Evil Jinx.  And I am getting a URL for this.  So I'm just using it locally.  I don't actually own this domain.  But it's basically a phishing domain that will ask me to follow the authorization code  flow.  And I've already...  Sorry.  Videos.  And I've already, like, prefilled the client ID there.  Oh, come on.  Well, we'll do that from scratch.  I'm not gonna touch it.  So I've already filled in all the parameters.  Or made Evil Jinx do that.  So it is gonna ask for an authorization code for the right client with the right scope.  And that are basically hidden over there.  So I'm gonna enter the credentials for my victim.  I'm gonna enter the password for my victim.  I'm gonna enter the MFA for my victim.  And then it is gonna give me a blank screen.  Just because I'm lazy.  I didn't want to make a whole page.  But I did receive this authorization code.  And this authorization code is normally used by Edge.  But I can also use that with RoadTX.  So I just throw this in the devices PRT command.  And you see that we get a primary phish token.  And with this primary phish token, I can also authenticate.  So I can log into any website.  I can log into any app.  I can get tokens on behalf of teams.  On behalf of Outlook.  And this will just work for 90 days.  Because it's a single sign-on token.  I didn't need to go to the whole device flow.  I could just use this whenever I liked.  If we want to have some more fun with this, of course, we can also follow the rest of  the flow that Mac normally does.  And we can actually use this to register our device.  And then upgrade to a full PRT.  So I am using this with the PRT off and the v3 version.  The funny thing about PRT v3 is that there's no big difference between version 2 and version  3 in how they're used.  So you can send macOS PRTs to the Windows API.  You can send the Windows PRTs to the macOS API version 3.  Version 2 doesn't really matter.  It's only version 4 that's really different.  So just for fun, I'm gonna register a device using the new secure enclave flow.  And I'm gonna follow this device command.  So I'm gonna register it.  And in this case, the device type is macOS 14.  So this will trigger my script to use elliptic curve keys.  And of course, these are not actually in a secure enclave.  They're just on disk here.  And with this, I can request a PRT.  So I'm using basically the device list PRT.  And I'm gonna upgrade that to a full PRT.  So I'm just gonna add my device certificate and signature to that.  And you see that I get back now this full PRT that is bound to a device.  And you see that the session key is empty.  So normally, if you do this with the Windows protocol, you will see the session key here.  And that is the one you actually need to use this PRT.  But in this case, session key is empty because there is no session key in PRT v4.  And I can only use this if I actually wrap that with a elliptic curve signed body with  my certificate, which we can do with the PRT off, also with version 4.  We can provide the scope that we want.  So in this case, we're doing the authentication on behalf of Teams.  We're getting a token for Microsoft Graph.  And the only extra thing is that now I have to provide my device certificate because I  need to sign this request.  And I also need to provide my private key.  Because the response...  There's no session key there.  So we don't need to use a session key.  But the response will be encrypted.  And we need to use this Diffie-Hellman key exchange with the temporary key.  Which...  Well, there was an implementation for it in cryptography.  The Python library.  So that saved a lot of time, I think.  Because I didn't want to do that by myself.  But it did work.  So that's great.  So we can decrypt it with the whole cryptode Diffie-Hellman difficult.  But it works.  And then we get some tokens out of it.  So we used the PRT device list that we got via phishing.  We upgraded that to PRTV4.  We got a device that's PRTV4 capable.  And now we have PRTV4 token.  It is really significant, different.  I mean, it's mostly just fun.  It's not like that having a PRTV4 token suddenly allows us to do a lot of things.  There is one thing that we are not allowed to mention.  So there are a few shenanigans in all this flow.  Some tricks you can do, actually, if you combine the Windows PRT with the macOS Flow or some  other stuff.  Can't give too many details.  Because we did post this talk, of course, on Twitter or X when we were gonna speak here.  And then some people at Microsoft reached out.  Two, three separately.  Yeah, they were very eager to talk to us.  We were like, okay, this is very complicated.  We don't even understand fully how it works.  It's probably not a big thing.  But they did consider it a big thing.  So they are gonna patch not this, because this is all intended that we talked about.  But some other shenanigans that were not quite intended.  But of course these protocols are so complicated that also nobody at Microsoft understands  them.  So they found out that across all of the platforms, all the platform teams made some different  implementations that weren't exactly compliant to this flow always.  So we thought, well, if you just do this, then it's fixed.  And they were like, yes.  But then everything breaks.  And I said, okay, that's fair enough.  So we cannot talk about that.  But we will probably talk about it at some future point.  Yeah, I think they gave us a deadline of three months for a certain implementation and six  months for the other one, which most likely will be slightly more, given the experience  that we have with them.  So at some point we'll release a blog and talk about the full flow, which could be very  interesting to play with if you find it out yourself, if you're very creative, look at  our slides very well, and maybe interpret it in certain ways.  So there shouldn't be that much directions anyway.  But of course, we also want to do something against this in general, right?  Not only the flow we're not talking about, but also some of the other ones.  And that's going to be difficult.  I think there's options to consider.  None of them would fully protect you, because this is also a sort of by design flow.  And as we know, most organizations have a very broad user base, which they want to support  and all kinds of weird side steps that they want to do.  But of course, we can build some conditional access policies to mitigate some of the actions  that we showed.  On top of that, we can try, and I hear some organizations actually manage to do this,  but we can require only compliant devices, which will make it harder to actually do some  of these steps.  I mean, you can still do it, but then the attackers do quite a lot of research into  finding out what these policies are, how to create a machine that is actually compliant  with all the rubbish that is required, which might actually restrict him from doing other  stuff.  So very powerful, but also pretty difficult to do well.  One of the somewhat simpler things, which might not always work, is restrict device  registration.  By design, you have way more than one.  I think you have five or 10.  And you can restrict that to one, right?  So usually, a user only onboards one device.  But if you also want to bring in your mobile, you already have two, and then you can leave  gaps, right?  So it's brittle, but it is a thing you could do.  The same with limited token lifetime on non-corporate devices or non-managed devices.  So for instance, in our own tenants, we have certain tokens that only live for eight hours.  So every day, I log on to DevOps or other stuff.  In order to sort of protect it a little bit more.  It's a bit of a nuisance, but for the very protective environments, you want to do this.  And maybe some of the other ones, a little bit less.  But that will mitigate bits of it.  And of course, we can also start building some detections on some of the behaviors.  So one in particular that will be interesting is to look for new device registrations from  an already registered device, because that should never happen.  That's kind of weird.  And there might be some other detections that you should be looking at.  And Microsoft, of course, as we mentioned earlier, is working on patching the vulnerable  flows that we didn't discuss.  And they're also exploring ways or mechanisms to actually disallow reuse of certain tokens  for device registration, which will also mitigate part of this attack.  So of course, we're not done here.  Michael has a couple of RFCs, so maybe there's some additional things that we can start looking  into.  Or primarily Dirk-Jan, because I don't understand half of it.  And with that, I think we are at the end, and we are ready for questions.  Thank you very much for your great talk.  Questions?  Great talk.  Can you go back to the PRT v3 flow diagram?  I think you answered this question, but I want to confirm that I understand.  So...  Yeah.  Yeah.  I think.  Yeah.  So you first get a device list PRT, and you exchange that for a device bound PRT.  And I think the table you mentioned later said that the device list PRT is still valid,  even after that exchange.  Yeah.  Yeah.  So the thing with PRTs, like access tokens, they're all stateless.  So unless you revoke a refresh token or a primary refresh token, they're all going to  stay valid forever.  It's just that the device list PRT is not bound to a specific device.  So if there is a policy that requires your device to be in a certain state, then the  device list PRT is not going to work.  But apart from that, yeah, both PRTs are still valid.  And I think even if you have, like, macOS with single sign-on, there might be some devices  PRTs left in the edge cache, depending on which order you set it up.  But there's so many different ways to actually do this.  We also didn't look into all of them and what, like, artifacts are left behind.  Right.  Because you don't have...  You can't block a device.  So you need to block the user, which usually, in the PRT mindset of a defender, they block  the device.  And then we're all right.  But in this case, the attacker might still have some persistence.  Yeah.  Something to be aware of.  That if you do some mitigation on a device, always, always block the user and disable  the user at least temporarily so that you know that all the tokens are in one place.  Okay.  Second question.  In the keychain screenshot that you had, there was a PRT that was stored and that had a GUID  and display name.  I think you said it was the tenant GUID?  I think it was the broker client ID, the first one.  I see.  Okay.  So in the V3, it's just like this one thing.  Oh.  And in PRT V4, but they usually put, like, some client ID or a user ID in there.  So I think here it was...  There it was.  Two IDs.  Yeah.  The object ID of the enter object.  And then there's a lot of stuff behind it.  I think this is the tenant ID.  Yeah.  And this is basically where it comes from.  And the 29 looks like the token broker client ID.  Okay.  Do you know what rights are necessary to enumerate that name?  Not the content of the secret, but that name.  The name in the keychain?  I think...  The rights to enumerate?  It's not there.  So you can use Cody, your colleague's tool, and Locksmith, and you can just dump the whole  keychain item list with their entitlements, the generic description, all the stuff apart  from the key material.  And that will throw pop-ups.  You don't want to do that in a red team, because there's going to be, like, hundreds of pop-ups.  But you can enumerate everything.  We had some bonus slides, which I can't show now.  But there's also some implementations on other Microsoft products that actually have key  material in other parts than the key.  Nice capture, huh?  Okay.  Thank you for this super interesting talk.  I've got two questions.  The first is...  If I do condition access control and require a registered device, is PAT version 3, MacFlow,  authentication flow going to work?  So if you require a certain device state, there's still, like, exceptions to that.  So we didn't test this with all the different compliancy policies.  But in general, there's, like, exclusions to these policies, like, that still allow you  to do the device registration.  Because, of course, at device registration, you cannot yet have such a device.  But I do believe that if you require, like, a registered or joined device, then the device-less  part is not going to work.  Okay.  Thank you.  And if I don't have bring your own device, can I just prevent my users from registering  any devices at all?  Yes.  But many Intune scenarios, also for corporate devices, are also user-driven.  So usually you do need to allow a subset of users to register or join.  And then you can restrict in Intune which devices can be joined.  So then you can, like, only allow certain...  Or only allow corporate devices, which, depending on the platform, might be based on, like,  autopilot or on the serial number or on the state that it gets from, like, the Apple MDM.  So sometimes you have to allow people to register or join devices.  And then anyone can do this.  But then the required compliant device, and the compliancy always comes from Intune, is  what can save you in that case.  Because then you also need to prevent people from getting devices into Intune and getting  them compliant.  And that is then usually where the attacker is blocked.  Because if you don't allow personal devices in Intune...  Except...  Well, maybe some ways to wiggle around that.  But most of the cases, that will block the attacker from getting such a rogue device  into Intune.  Do you know if the v4 is limited to the platform SSO?  Or will it make its way into the current implementation?  Because if not, you have, like, a huge attack surface.  Because the current state is v3, I think.  With the SSO extension.  Yeah, I don't know if they will backport or that they will upgrade the normal extension  also to v4.  It might, but...  I mean, v3 is also used on other platforms, like on Android.  And I don't know if Microsoft wants to switch to, like, elliptic curve keys also on Android.  I don't even know how easy it is to do that on Android.  So it's just because Apple likes EC keys a lot more, apparently.  That they use this in their platform SSO implementation with a secure enclave.  But I don't know if Microsoft wants to go that same way.  And if this...  I also don't know if this peer-to-peer v4 was just a way to wiggle around the Apple requirements.  Or if they actually thought, like, okay, elliptic curve with Diffie-Hellman key exchange  and binding it to the device instead of the session key  is the way that we want to have for our product.  So I don't know.  Okay. And last question.  You said the PRTs are valid 90 days.  And the fastest way to revoke is disable the user?  No, so there's this...  So if you disable the user, then they cannot use the PRT.  But if you then enable them again, they can still use it again.  So the best way is to revoke tokens.  So it's like the block you have in the portal or the...  There's also PowerShell command for it.  And that will revoke all refresh tokens, all primary refresh tokens.  And then they only have, like, the access tokens left, which you cannot revoke.  Unless they're, like, continuous access evaluation access tokens.  Okay. Thank you.  More questions?  Thanks.  I just wonder whether you've seen any key attestation  or application attestation being done.  Probably not, if you were able to implement the version 4 protocol by yourselves.  But it's something I would have expected, honestly.  So I think in the device registration flow,  there is, like, the AIK fields, at least on PRT v3.  But they're empty.  The only way that Microsoft currently does, like, attestation is via Intune.  And there it's also very limited.  And they're just adding right now.  I believe it went, like, in preview last week or something.  That you can actually require TPM attestation at enrollment.  But it's only Intune. It's not...  Android doesn't do anything with attestation.  Like, you cannot even differentiate and let you know,  do some real hacking between a PRT that's actually in the TPM  versus one that's software only.  Okay. Thanks.  No more...  Okay.  So we are done with this talk.  Heinrich?  Thank you very much.  Microsoft Mechanics www.microsoft.com  www.microsoft.com