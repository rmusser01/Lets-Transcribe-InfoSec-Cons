{
  "webpage_url": "https://www.youtube.com/watch?v=FtQiaSDrJaw",
  "title": "TROOPERS24: The Registry Rundown",
  "description": "Talk by Cedric Van Bockhaven and Max Grim - June 27th, 2024 at TROOPERS24 IT security conference in Heidelberg, Germany hosted by @ERNW_ITSec\n\n#TROOPERS24 #ITsecurity \nhttps://troopers.de/troopers24/talks/jlaupj/\n\nMore impressions:\n  / wearetroopers  \n  / ernw_itsec  \nhttps://infosec.exchange/@WEareTROOPERS\nhttps://infosec.exchange/@ERNW https://ernw.de",
  "channel_url": "https://www.youtube.com/channel/UCPY5aUREHmbDO4PtR6AYLfQ",
  "duration": 1905,
  "channel": "TROOPERS IT Security Conference",
  "uploader": "TROOPERS IT Security Conference",
  "upload_date": "20240909"
}

This text was transcribed using whisper model: large-v2

 Hi everyone, today indeed we'll be talking about the Windows Registry, hopefully also  teach you something new.  My name is Cedric, I'm here with my colleague Max, and we are two red teamers and offensive  researchers at Outflank.  We're a niche company that performs red team consultancy gigs and next to that we develop  offensive security tooling, Outflank security tooling that we then also have other red teams  reuse around the world.  Personally I have a network security background, my colleague Max has more of a software engineering  background and in our spare time we like to also hack other things like hardware or develop  more hardware hacking challenges for students.  Today's agenda is a bit about the history and anatomy of the Windows Registry, probably  known for a lot of you already, then we'll move on to how can we interface with the registry  remotely using a remote registry protocol, we'll look into ways we can abuse this and  then we'll summarise to conclude.  So starting with the history and anatomy, the Windows Registry was first introduced  with Windows 3.1 back in 1992, I think that's when Max was born basically.  So for com-based components only, so registered CLS IDs and then in Windows 95 it was extended  also for including all sorts of application settings, computer settings that were traditionally  stored in any files.  So hierarchical database and it looks a bit like this, we have a number of root keys that  we can access and the ones we see here in dark are the ones that you will also see in  the Windows Registry editor in Windows and we have a few ones that are greyed out on  this slide that are actually not visible to end users, also because they're just aliases  or well they're not that relevant for this talk.  Starting with hklm, hklocal machine contains computer specific data, so computer settings,  local policies, group policies you will find here.  Basically settings that apply to the entire computer.  This is in contrast to hkeyusers, this is another hive containing all the user specific  settings and this one is a bit more interesting for us today, so in hkeyusers we'll find the  hives related to individual users that connect or interface with the system, so we have S1521  SIDs, these are hives related to for example domain users and also the local users that  log on to the system and we have some other SIDs here, S1518 for local system, 19 for  local service and 24 network service, so also these system services they also have settings  stored in the registry.  Now there's a few ones here that have the block sign next to them, so not necessarily  everything we can access using the permissions that we work with.  There's an interesting one here on the slide which is S1518, it's actually a symbolic link  to the default hive, the default hive is for usage for the local system account for storing  its settings, so for example used by win logon and logon UI, so basically programs that display  the interface for logging into the system.  Some people think that this default hive is used as sort of a template that other new  users are based on, it's actually not the case, so if you want to use a template for  creating new users and have settings applied to that user, you can actually make use of  the default user, so C user, default user and the user.dot file and work with that instead.  So HKLM and HKEY users, they are real hives, they are disk backed, in contrast to some  other hives, so HKEY classes root and HKEY current user specifically, they're a bit different  than that, so HKEY current user here gives you the view of the registry as a current  user that you're working with, the token of current user that you can access the registry  with and display that information.  Settings related to the user are stored here but also COM object registrations you will  also find here in the registry, then we have HKEY classes root, which is a combination  of two views, HKLM software class and HKCU software classes and then provides you a consolidated  view containing those two overlaid on one another.  What's important here to remember is that HKCU takes precedence over HKLM, so if you  specify specific settings or COM object registrations for your user and you launch an application  under your own user context, then the settings from HKCU will be respected, which will become  important later on.  Specifically what we'll find here in HKEY class roots are also the COM object registrations  as well as file extension mappings, so what is COM very briefly, component object model  and it provides you a way of doing inter-process communication, so this framework that allows  software components to interact with one another, not only locally but also across the network  if we're talking about DCOM, which we heard about in the potato attacks, so there's a  small example over here in the slides where we are using a piece of VBA to instantiate  an object of the internet portal application class and then navigate towards a website  and how that object is instantiated, that's information you will find in the registry  then which DLL is responsible for providing the interface that you work with.  When you install Java, for example, you will find a huge dump of CLS IDs in the registry  containing or prefixed with CAFE, so if you look into your own registry it's actually  quite a huge list of CLS IDs that are in there.  So now that we know how the registry works roughly, we're going to look at how we are  going to access it remotely and there's at least two ways that we know of on how to connect  to it remotely.  The first one is via MSRRP, the remote registry protocol.  This is handled by the remote registry service and by default this is configured as autostart  on servers and unfortunately on clients it's disabled, but on servers you can trigger it  by accessing a name pipe and it will shut down after an activity.  So if we start this, we access the IPC dollar share and in there we retrieve the WINREG  file and that will remotely trigger the service to start and you don't need local admin privilege  to do that, any user can actually start this service remotely and then we can start interacting  with it.  This is used amongst others in the RectalPy from impact but it's also built into the registry  editor of Windows itself.  It's very well documented, so you can see here that there's like different functions  to open a key, enumerate it, delete it, save it to disk, whatever you want to do.  And then there's one alternative via WMI, WMI uses DCOM and DCOM in turn works over  RPC via high random number TCP port and the advantage of this is that it's both available  on clients and on servers, but the downside is that you require local admin on the remote  machine and in this research we were more interested in what you can do as a domain  user remotely, so we're going to primarily focus on the remote registry protocol.  We still extended impact with WMI RectalPy that uses WMI instead of the SMB RPC and as  you can see here as a regular user you are not allowed to do it, but if you are an admin  user you can do similar things as with the remote registry protocol.  So now that we know how to remotely interact with the registry, how can we as attackers  abuse this?  There's already some stuff out there, so for example with secretsdump.py you can remotely  dump credentials from the SOM and security hive, but obviously for this you need local  admin on the machine and there's various other things that you can do, you can configure  persistency via the run key, you can do COM hijacks, there's many more things that you  can do as an admin in the registry.  But what can we do as a domain user?  So reading HKLM is not allowed as a domain user, you need to be admin on the remote system  to do so.  If you are admin you can read AV exclusions, you can read group policies, you can enumerate  for EDR software, et cetera, et cetera, but it turns out as a domain user you can still  see quite some things.  So as a regular domain joint user you can read HKU and HKCR and if you access the HKU  you have access to both the dot defaults that Cedric earlier mentioned and if the domain  user remotely is logged in in some way you can also enumerate everything that's under  the domain user SID.  For HKCU it's similar, so you normally no, sorry, HKCU is the current user, HKU is all  the users, so if you would query HKCU, if the user is not logged in remotely you will  get a sublisting of dot default and if the user is logged in you will get the user SID  enumeration instead.  And this dot default already reveals quite some information about the remote system.  So what can we see in there?  We modified the reg.py a little bit, because normally if you query HKU it will default  to HKCU and then you won't see everything, but in this case if you enumerate it you will  see all the SIDs of users that are at that moment interactively logged into the machine  and this is also how, for example, PS logged on works and how Bloodhound collects some  of its data so that you can see who is actually logged into the computer at that point.  So if the user is logged in, the SID will be in the entries, if it's not logged in,  the Hive will not be loaded and it will not be accessible.  But it turns out there's more.  We found another key in the dot default subkey and this contains an overview of all the SIDs  of users that have ever logged in interactively on the machine and the UTC timestamp of the  first time that they logged in, so if you want to see how a system is being used in  the past and not at that specific moment, you can here see whoever has logged in to  the machine, which is quite nice for attackers to know.  Now I did mention that for HKLM you need to be local admin to read the keys, but there  are exceptions of course.  There's two specific keys configured, allowed exact paths and allowed paths and they give  a list of things that you are still allowed as a regular domain user to read.  With exact paths you are allowed to only read that specific key and no subkeys and with  allowed paths you are also allowed to view all the subkeys that are under there and all  the data.  I highlighted a few examples here which I'm going to dive deeper into, but first I want  to mention that before when we were doing this research, we actually found out that  even though something was marked as an exact path, you were still allowed to read the subkeys  as well, which was a vulnerability.  But unfortunately somebody else was earlier than us and probably less lazier in reporting  it to Microsoft and they reported it and got the CVE assigned.  So what you can, for example, see remotely is like the exact build and the server version  that is running.  If it's not a volume license ID, you can also view the digital product ID, I don't know  why, but you can see the activation key of remote systems.  You can also see which event log providers are installed.  So you can, for example, see if CrowdStrike is installed on the machine, which is also  again nice for an attacker to know.  You can enumerate printer drivers, this is what we used for print nightmare, because  the original exploit actually used the printer protocol enumerated drivers, but we wanted  to be a bit more stealthy and it turns out you can read it from the registry remotely  as a domain user, so we used that instead.  And you can read HQCR, so you can get com objects, you can see what kind of software  is installed, what is regularly opened with the open with list on devices, et cetera,  et cetera.  So this is just a nice bit of overview of recon that you can do as a regular domain  user.  But now comes the interesting stuff, because we actually found some RPC information leaks  and they leak limited information about the remote system, which is unintended.  And we have two of them.  So the first one, again, as a regular domain user, you cannot read HKLM keys remotely,  that's not allowed.  But we discovered that with the remote registry RPC calls, you can actually still deduct if  the remote key exists or not.  So what we do in step one, we try to open the key and we give it a sum desired of key  set value, so we want to write to it, we want to delete it, and this should always for a  domain user result in our access denied.  And we do this as a safety measure, because the next step is we're actually going to try  to delete the key.  And generally you don't want to delete keys on a production system.  So that's why we do this.  And then the response code to this delete call actually leaks some information.  So here's it visually, we first open the key.  We're going to check if we get access denied.  And if we get if we don't get an access denied, we abort, we say, okay, you shouldn't run  it under a different user.  Then we try to delete the key.  And on the basis of this response, we can actually get two responses.  One is error file not found, which means that the key does not exist on the remote system.  But if we get an access denied, then we know that the key exists.  So if you put this in a script, which we did, you can feed it with a list of known subkeys  of what you want to see if it exists on the remote system and then get a sense of what's  installed there.  So you can see what kind of services are installed.  You can see what kind of programs are configured in some way.  And there's probably more.  But this is just a nice example of what you can see.  And the second one is about remote file existence.  So as a domain user, you cannot generally check like for random files if they exist  or not.  But with these RPC calls, you can remotely as a domain user.  So what we do is we open the root HKU key, which we should be allowed because we're a  domain user and that's how remote registry works.  And then we try to save that key to a specific place on disk.  And here, again, the response code leaks information on if the file exists or not.  So we first open the key.  Then we try to save it to a specific place.  And then we check the return status.  And if it gets an invalid name or a path not found, we know that the directory does not  exist and there's still distinction in there.  If it says path not found, it means that somewhere along the path already a directory does not  exist.  So it's recursive, right?  And then if you get an invalid name, you know that the directory itself does not exist.  And again, if you get an already exist, then you know that the directory exists.  And this you can also put into a script.  So here would be a numerate for known installation paths for EDRs.  That can be really anything on disk that you want to check.  And then it tells you if this exists or not.  We reported both of these to Microsoft.  That's still in process.  But unintended information leaks.  With in process, he means the ticket got closed after we provided the book and slides and  yeah.  We had a whole zip with these slides in it and videos and example codes and we got a  reply in an hour that said you need to provide more information.  Okay.  On to the next thing.  And ADCS, I think it's already been mentioned in the past two days quite a bit.  So I'm going to be very quick on what it is.  It's the PKI implementation and based on certificate templates, you can request certificates.  And often these are misconfigured, which we abuse as hackers.  And it turns out that these certificate templates are also cached in the registry.  So this is by default in the default domain policy of a domain controller.  It says that here it says with the configuration model, it says not configured, which is default.  And this is used for auto-enrollment.  So within ADCS you also have an auto-enrollment feature, so that the computer will enroll  the certificates for you.  And by default, all the certificate templates that are configured will be cached on every  domain-joined machine and they're also remotely readable by domain-joined users.  And you would think with such a feature that it would only cache the certificate templates  that are configured for auto-enrollment, but no, no, no, they are all in there.  And that means that if you write a nice little Python tool, you can either from a local machine  export the registry or query it remotely, feed it into this tool, which we're going  to release in the coming weeks.  And then you can offline already see if there's escalation paths in your ADCS without triggering  any known detections.  At this moment.  At this moment.  All right.  This was for the reconnaissance part.  We have a few other tricks up our sleeve.  While testing some of these APIs that we could call with the remote registry protocol, we  also noticed that some of these calls had some other unintended side effects.  For example, with the base reg safe key call, while you normally specify a path on the local  system to save a key, you could also specify a network path.  So point it simply to an SMB share and then it does need some magic flavoring because  otherwise you don't receive the hash.  And then it tells you error, you don't have the privileges needed, and in the meantime  you receive a hash.  Magic.  Funny little side effect of this.  While you do this, even though you do not have permissions as a local administrator,  for example, you do this against a domain controller and you specify a local path on  the system.  So it needs to be, for example, C Windows temp, where all users should be able to write  if they're logged in locally.  If you specify that sort of path, you can create these empty files, but they will be  empty.  But you can make it look like your domain controller is being crypto awkward, which  is sort of a mayhem thing, it's not really useful, but we thought it was funny.  Then let's move on to some lateral movement ideas, and so this is based on just regular  registry persistence through com hijacks, there are other ways to do this as well.  But the same mechanisms can be leveraged for lateral movement as well.  So if you want to execute code via remote registry protocol, the simplest way to go  about that would be to modify the hklmhive remotely, or hqhive remotely, and then modify  a com object, and when that com object is loaded, you get code execution.  And there's also ways to do this without having to drop a DLL on the disk if you want to.  So there's one issue with that sometimes, is that when you want to modify these CLS  keys under hklm, you'll find that a lot of them are owned by the trusted installer user,  which means that we cannot modify them remotely, as if we log in with a local admin.  Instead we found that there's this magical key called software Microsoft app model lookaside  machine, and if this key exists, the registry will also attempt to lookaside into a different  registry key, whether or not you have created a similar looking key.  So you get a second chance, and this second key does not have trusted installer permission  set, which means that with our local admin permissions, we can now actually do that com  hijack that we wanted to do in the first place.  We still don't know what this functionality is really used for, but if anybody knows,  let us know.  Still we have one more problem, we need to trigger somehow our com object to be loaded  or wait to be loaded.  It happens quite quickly usually, com objects are loaded all the time, the difficulty is  mostly in finding a com object that doesn't crash the entire system and lock you out.  There's a few services actually on the system that are not that often used, so what we did  is find some services that weren't in use and modify a com object related to those and  then trigger that service to start.  It happens to be that around 50 servers also can actually be triggered using an RPC call  to be started automatically, even if it's a domain controller for example, it doesn't  really matter, as a regular domain user, you just send an RPC ping and that service will  magically start.  With system rights or equivalent, might be running a network service, but then you use  a potato exploit and you get also system rights.  These services also shut down afterwards, they will load that com object without any  form of authentication whatsoever, besides, yeah, sending that ping out.  A quick demo of this, we use the Dev Query Broker service, it's stopped currently, then  we had a small script for sending the RPC ping, you see there's no credentials in here,  it sends this ping to the interface, it says triggered and then a few moments later we  see that the Dev Query Broker service is actually running.  And the weird thing to me still is that you can do this with also services that run on  domain controller, no issue whatsoever, no authentication.  Okay, so this was about modifying HKLM with admin rights, so there are also a few things  we can do as a regular domain user, so no admin rights.  As Max explained, we can modify the HKCU of the user, which means that we can also modify  com objects under that user.  So remember for the classes root, root key, HKCU has precedence over HKLM, so if we modify  a com object under HKCU, we can then get a com hijack working under that user.  So the difficulty is still in which com objects to target, so we have a little demo here which  modifies a CLS ID as well.  In this case, I forget what we actually modified, but now we get a nice little calculator popped.  What else can we do?  If we want to find something that doesn't, so difficulty with modifying these com objects  is sometimes we have to wait for a com object to be triggered and get code execution.  If we want to find a way to actually trigger it ourselves, there are a few other ways to  go about it.  We can find handles to registry keys that are open with notify access, which basically  means that there's applications monitoring for these keys to be modified, or anything  else happens with them.  So this is a screenshot of system informer in which we see a number of processes with  open handles, and there's a key on the screen here that they're waiting for and looking  for any modifications to it.  So if we take that key and we just modify some things around there, it wasn't rocket  science, we just modified some values, and oops, suddenly process crashes, great.  We crash explore.exe, which triggers in this case the error reporting service and magically  the error reporting service loads com objects that we can hijack as well.  So that's useful.  Then we also found some other interesting side effects when looking into some client  environments that were using Citrix.  Maybe some of you have seen this screenshot before where Citrix says you do not have access  to this system directly because you're not part of the direct access group.  So this is shown when you try to connect to a VDI remotely over RDP without going to the  Citrix gateway.  And this message is actually being shown on the user desktop while their Hive is already  loaded.  So you can already see the implication there.  Since the Hive is already loaded, we can connect again to the remote registry of this user,  modify some com objects related to the user, and afterwards click okay.  And figure out that, yeah, apparently normally you would be logged out instantly again, but  since we broke something now, that mechanism doesn't work anymore and instead we get access  simply to the remote desktop of the user.  So this bypassed potentially also some MFA requirements that the customer might have  set because you instantly connect to the VDI without maybe going through that gateway that  mandates MFA.  Quick summary.  So we looked at some remote reconnaissance, some information leaks related to RPC, ADCS  has some certificate templates stored in the registry that we can obtain.  We can figure out a course authentication in the registry and there's also ways to use  basically still com hijacking, a known technique, but also use that for lateral movement.  If you want to learn more about registry, there's some great resources, Mysteries of  the Registry by Pavel Josifovic.  There's also a great write-up by Joru on Project Zero blog on exploitation of registry vulnerabilities.  And yeah, thank you.  So we'll be sharing some blog posts in the next few weeks about remote registry.  We'll also share blog posts about Grim Resource that may or may not have been a payload of  one of ours.  And also Max has been working on this new tool for automating phishing attacks for device  code off based on research of Derek Young and yeah, something to look forward to.  Thank you very much.  Any questions?  Yes.  Thank you.  Great talk.  Has Citrix, have you informed them about this MFA bypass, direct access?  So the thing is I only realized while presenting this could be an MFA bypass, so no.  But even the direct access group bypass is I guess also a vulnerability.  Even the direct group membership bypass is, you know, you have IDP but you're not a member  of the direct group.  Yes.  But this is a bypass of that.  Yes.  So this was like a client environment where we tried to figure out what mechanism was  in place here, but we couldn't really find that back.  Or even if it is a bypass in Citrix, but maybe it is.  So the thing is normally the system shouldn't be directly reachable anyway, but here it  was.  I shared it.  Hmm?  I shared it.  Yes.  Are you planning to release like a blog post with more details about that Citrix bypass?  Or is that the information that we will get?  So the funny thing is we didn't really see the Citrix thing as that big of a deal because  normally it shouldn't be accessible anyway, but yeah we will be blogging about these vulnerabilities  in the remote registry in the next few weeks.  That's cool, yeah, because in the Bloodhound Enterprise team we hear a lot about like customers  complaining about invalid CAN-RDP edges to Citrix machines and it sounds like that they're  not invalid based on what you showed here, at least in some cases.  So yeah, that's why I think it's quite interesting.  But thanks for a really great talk.  Cheers.  So during your research was CrowdStrike flagging these connections over RPS suspicious?  So not yet, I guess.  No.  Thank you.  Thank you for your talk.  With the RPC ping feature, would you be able to force, for example, the web client service  from WebDAV to run on a server?  What was the question?  With the RPC ping feature that you showed that you used to run the DevQuery service,  would that be usable against WebDAV?  If it's not enabled but installed on the server, to force it to run?  If that works against the WebDAV client, no, not to my knowledge, no.  There's only a limited amount of services that actually allow you to trigger them using  an RPC call.  If you want to have a look at those, System Informer makes that really easy to look at  which ones do have these RPC interfaces that are triggerable.  Sorry?  Oh sorry, your question was about RPC filtering specifically.  No?  Okay.  No more questions.  So thank you again, Cedric and Max, for your talk.  Welcome.  Thank you.  Thank you.  Thank you.  Thank you.  Thank you.  Thank you.  Thank you.  Thank you.  Thank you.  Thank you.  you