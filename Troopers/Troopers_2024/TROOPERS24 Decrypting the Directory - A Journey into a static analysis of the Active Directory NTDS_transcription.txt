{
  "webpage_url": "https://www.youtube.com/watch?v=PZcLCh8ru6Y",
  "title": "TROOPERS24: Decrypting the Directory - A Journey into a static analysis of the Active Directory NTDS",
  "description": "Talk by Bastien Cacace, Florian Duthu - June 26th, 2024 at TROOPERS24 IT security conference in Heidelberg, Germany hosted by @ERNW_ITSec\n\n#TROOPERS24 #ITsecurity \nhttps://troopers.de/troopers24/talks/8ekvxr/\n\nMore impressions:\nhttps://twitter.com/WEareTROOPERS\nhttps://twitter.com/ERNW_ITSec\nhttps://infosec.exchange/@WEareTROOPERS\nhttps://infosec.exchange/@ERNW https://ernw.de",
  "channel_url": "https://www.youtube.com/channel/UCPY5aUREHmbDO4PtR6AYLfQ",
  "duration": 2646,
  "channel": "TROOPERS IT Security Conference",
  "uploader": "TROOPERS IT Security Conference",
  "upload_date": "20240902"
}

This text was transcribed using whisper model: large-v2

 Hello, and welcome to our talk.  My name is Bastien, and I'm with Florian, and today we will talk about the Active Directory  Database, also called NTDS.dit, in order to identify misconfiguration and vulnerability,  and the purpose of this talk is also to give you, to want, to explore your own NTDS after.  So we are from a French security company, a security consulting company called XMCO,  and so we are auditors, especially for Active Directory, but also other stuff, and we are  also contributors from our own solution, Active Directory, in our company called IAMBUSTER,  based on NTDS analysis.  So today, what we will see, why we would like to analyse the NTDS.  So what is interesting inside the NTDS.  And also we will have a quick look at the format and the structure of the database,  and how to get, to parse and get the data, outside a Microsoft environment.  And at the end, we will take a look on the trending topic, which is ACL and control path,  and also present our little script to help you to dig inside NTDS.  NTDS stands for NT Directory Service.  You have a copy, so this is basically a big file, it could be small, but usually it's  kind of big.  It's stored on each domain controllers of your domain, and the format is EAC format,  it was created by Microsoft, and was shipped first with Windows NT in 1995, and after Microsoft  used this format also for other Windows solutions, Active Directory as well, and Outlook.  And you may be wondering why Microsoft didn't use SQL formats at that time.  We didn't find any official statement, but multiple sources say it was mostly because  of performance issues and technical issues.  But if you have an official statement, we can share it after.  So the story behind this presentation.  So we were pen tester before in Active Directory environment, and after compromise a domain,  we like to grab the NTDS and test the password strength.  So it was a kind of bonus for our customer in the report, with other findings.  And after that, some customer start asking us a specific Active Directory password audit.  So then we start like building our own script with Python, we were familiar with Python,  and so we used impact at that time, and we were wondering if we can go further than just  auditing password.  So there's a lot of previous work on the NTDS.  Joachim has made great work, he released format specification paper in 2011, and also library  in C language, libescdb.  His work inspired other tools, impact, NTDS, Airbus BTA, and we are not exhaustive here,  other tools as well.  And later, also Microsoft published managed ESCNT that provides access to the library,  to the DLL, ESCNT.  I know DS internal uses it, maybe other tools as well.  So a little bit more on the NTDS, what you can find inside.  All data on your Active Directory is inside the database.  The size of the database could start from 30, maybe, megabytes, to like 15 gigabytes.  15 gigabytes is actually the most biggest one we have seen in production.  Maybe you guys have the biggest one.  15 gigabytes, it's like 200,000 users, and the domain was created in 2001.  Because when your domain is old, you have a lot of backlog transactions, and the size  of the NTDS gets bigger.  So yeah.  So does someone have a bigger one than 15?  Maybe?  Okay.  It could go until, I think, one terabyte, or something like that, according to Microsoft.  So to dump the NTDS, you need domain admin rights by default, and you can dump it easily  with NTDS util tool, this is the most common one.  And the database is almost the same on each domain controller.  I said almost, because we will see later in the presentation, some attributes value are  not replicated between them.  So finally, why we want to analyze it.  It's an alternative way to audit your Active Directory offline.  You can conduct an offline audit, or a light forensic, in comparison to a dynamic tool,  you know, like Bloodhound, or Purple Knight, or whatever.  So you don't need to be connected to the system, the information system, or to your domain.  You just need to have the file.  And it's the only way to audit the password, because this is the only place you will find  the password hashes.  So at the end, it's useful for Bluetimer that doesn't want to generate extra nodes on their  network.  It could be useful also, especially when you audit a sensitive environment.  I know when we go to a factory, industrial factory, they don't like too much when we  connect to the network, and sending many requests, so they prefer, like, offline audits.  They are afraid that we can maybe break their machine.  And also it could be useful for pen testers, after compromising a domain, to have extra  findings in the report.  So we will see what could be interesting in security perspective.  So you have everything on users, like activity, if they have SPN, if there are security attributes  or not, delegations, and also the membership.  You have the password, so the password properties, which is you can try to break passwords with  tools like John the Reaper or Ashcroft, because you have the password hashes.  You have the format, LM or NT, so you can find if they still use LM obsolete format.  You can detect passwords we use.  A fun fact is we have a customer, he has a tiering in his domain, but one domain admin  uses the same password on his T0 account, T1 account, and T2 account, so breaking the  whole tiering.  And we didn't break the password because it was strong, but you can compare the password  hashes to say, okay, so you use the same password, so if your T2 admin is compromised, you can  also compromise your T0 account.  And you have also information about the password change date, et cetera, system, because every  machine on your active directory has an account, so you have also property on the system machine.  You can detect if the Kerberos password has been changed recently or not.  You have information on the trust, the way of the trust, if LAPS is installed on your  domain, et cetera, et cetera.  And of course, ECL are part of the NTDS.  I will let Florian talk about that later.  A little bit feedback.  We have analyzed last year 80 domains, 80 different NTDS from different companies.  Password is still an issue, but I think you already know that.  But high privilege accounts are less weaker than before, less weak than before.  Before we have seen more than that.  We still have LM formats in 2023, but it's mostly service accounts that haven't changed  their password since their creation.  And a thing is interesting, it's changing your password regularly doesn't make your  password stronger, because the user will have an extra character at the end of the previous  password or whatever.  So this is, we have cracked almost the same amount of password that was changed before  six months ago and after six months ago.  And a little bit of overview of your system in production today.  So this is a good graph to see Microsoft version failed, because we've never seen Windows Vista  and Windows 8 maybe a couple of times, but Windows Vista never.  And we have still Windows XP, Windows 2003, and today, yeah, Windows 10 is the most used  for clients, and Windows 2016 is the most used for servers.  Other categories is non-Windows system.  So Mac OS, Linux, maybe NAS storage, et cetera.  We have talked about what we could find in the NTDS, but what is not part of the NTDS,  but very interesting in security perspective.  Event logs for forensic investigation are not part of your NTDS.  Of course for your NTDS.  If event logs were in your NTDS, it will be so big, you won't be able to read it.  That's why conduct an offline forensic with your NTDS, it's very light, because you don't  have event logs, and event logs are more precious, because you have everything, if you have good  logs of course, to track user action, account action.  GPO details are not part of the NTDS as well.  You have GPO reference, like the name of the GPO, the ID of the GPO, the creation of the  GPO, but the content, the XML file, are stored in your sysvol share on your domain controller.  So you will need to go in this folder to see what exactly do a GPO.  DCS templates also are not in the NTDS, as well as Windows patching level and Windows  system configuration.  If you want to know the last KB installed on a Windows machine, you will need to go  after the machine directly and ask it directly.  You just know the version of the Windows, like Windows 10, 11, et cetera.  So a little bit about the format and the structure.  So as I said before, to dump the NTDS, you need NTDS util.  It dumps by default three files, if you run the command, as you can see here.  The NTDS.file, of course, the system hive, and the security hive.  System hive will be useful for us.  We will see why after.  Here another view of the NTDS tables.  You have more than 12 tables.  Most of them are useful to run the service, the Active Directory service.  And four of them are very useful for us, because they contain data, very interesting.  The MISC subject data table, sorry, it contains metadata on all other tables, especially for  the data table.  The data table contains information on objects, so this is the huge one, and the biggest one,  and you have all information on user, machine, groups, GPU, et cetera.  After you have the link table, useful to know the relationship between objects.  And the SD table that contains security descriptor of objects.  Useful to edit the SEL, SCE.  So the data table could be also named as the hollow table, because it's full of hole inside.  Why?  So you could have more than 3,500 columns, but depending on the type of the object, most  of the column will be empty.  So for instance, if you have a domain object, the domain object has different attributes  than machine accounts or user accounts.  So it could be represented like this.  So each entry represents an object, user, computer, domain, et cetera.  And as you see, depending on the kind of entry here, we have the column empty or filled out.  It depends.  But the problem is when you read at first time the data table, you can see that the  name of the column here, I completely abstract for you.  You don't know really what is inside, and so you can guess, maybe.  Here we can take a look at this column, and you will see Legolas, Gimli, Aragon, maybe.  This is a SAM account name, maybe.  But when it starts to be a number, it's hard to know what's exactly inside and what kind  of data is in this kind of column.  And just a word on the SD table, the SD table contains a security descriptor.  It's very small comparing to the data table, and only four columns.  So we will talk about at the end of the presentation.  So how you can parse and get the data of your NTDS.  As we said before, the column name is abstract.  So the first thing to do is to go to the MC subject, and inside the MC subject, you have  all the column names in your data table.  And so you can grab the ID of the columns, and in the data table, you have an attribute  ID columns that helps you to identify on the same line the LDAP name.  And the LDAP name, it's usually more familiar for you.  And when you know the ATTM590045 here, corresponding to the SAM account name, after you just need  to go to this column and grab the SAM account name for your domain users.  So this process is kind of boring, and you don't want to do that each time you look at  your NTDS.  So it's not really documented by Microsoft.  I can't find, like, a really good dictionary of translation from the Microsoft website,  where we just released a script that outputs all the translation between the abstract attributes  and the LDAP name.  It will be the same on all Active Directory, except depending on the version, if you have  a Windows 2003 level, comparing to Windows 2016 level, Microsoft had some attributes,  of course, so you will have more attributes.  The more recent your level is, the more attributes you have.  So to get the data, you have different libraries, C, like LIMP, SENT, Python, you have IMPAKET,  you have DESECT, and Go also.  But with external library, so to get the data, you cannot use like a kind of SQL language  to directly grab your data.  You will need, like, a file to read from the beginning of the data table to the end to  find your data.  So here, if we want to find how many, the user that logged ten times on your domain  controller, you will need to iterate all over your data table, and save the corresponding  SAM account name.  So reading the old data table, for a small NTDS like 30 megabytes, it's kind of ten seconds,  but for 15 gigabytes, it could take several hours, so you won't do that many times.  So you prefer maybe read at least at once, and store all the results in another database  like SQL or NoSQL to request it for your audit or your forensic.  If you're working exclusively on Microsoft, on Windows environments, if you can use the  managed TLC library, this one should be faster.  We haven't tried yet, but we should.  But this library can use internal index that Microsoft uses, and it could be really faster,  and maybe you don't need to store the whole NTDS data in another kind of database.  This is a very basic function that reads your data table, and looking for accounts that  log ten times, so you just need to specify which attributes you want to look at, and  after you iterate all over the data table, and you print it out, the SAM account name  and the log-on count value.  So here, we use the Fox IT library, which is great if you want to take a look.  Data in the NTDS has types, of course.  Different types.  We are not exhaustive here, but you have integer, large text, et cetera.  In the column names, you have a letter, and this letter indicates what kind of type is  inside your column.  So for instance, if you have a G, it should be an integer, should be, because sometimes  we have some surprise, M, large text, et cetera.  So just a very short list of what kind of attributes in that translation.  And you have also special kind of attributes.  So you have encrypted attributes for sensitive data, such as like LM and NT password hashes.  Those attributes are encrypted with the PEC.  The PEC, so the password encryption key, it is also encrypted with the boot key, and the  boot key, you will grab it in the system hive.  That's why when you do like an NTDS util, it dumps the system hive, and with the system  hive, you can grab the PEC, and you can decrypt the NT and the LM hash.  Exception also, yeah, the boot key is unique for your domain controllers, so don't mix  them up with other domain controllers of your domain, it won't work.  And also, the LAPS legacy, so the first version of LAPS didn't require a boot key to read  the password, because Microsoft stored them in clear text in the NTDS.  Now they released a new version last year.  We haven't seen in production once, only once, but it's, I think it will start to be  more common, and now it's encrypted, but you can still store it unencrypted, but you can  normally, it should be encrypted in the future.  Just a word on the description field, it's not designed to store the password, but we  still see password in this field, and sometimes it's privileged account, so it was not designed  to do that, to use it, to store sensitive information, and it's accessible to every  user on your domain.  Other kind of attributes are non-replicated attributes.  So the attribute value are not synchronised between domain controllers, so, for instance,  if we take an example with logon counts, so if the Gimli goes on the DC1 and the logon,  so on the DC1, the counter will be incremented, but on the DC2 and DC3, the counter won't  be incremented.  So if you want to know how many times Gimli logged on on your domain, you need to get  the three NTDS and addition the logon count together.  So those kind of attributes, if you have only one copy of your NTDS, you cannot trust  them.  Usually, Microsoft documents on his website if they are replicated or not.  Normally.  And the last kind of attributes are dynamic attributes.  We call it dynamic because they are not at the active directory installation.  They are added after by third-party software, like LAPS legacy, for instance.  So when you install LAPS, this solution modifies your active directory schema and adds new  attributes in your active directory.  So to retrieve the LAPS password, for instance, first of all, you need to look at the LDAP  name of LAPS password, which is MSMCS IDM password.  And when you have a match, it means LAPS is installed on the domain.  You have to look at the special ID, int ID, and then you will be able to retrieve the  right column to get the LAPS password.  So you don't need to miss this object for this one, you just need to go.  But each time, on each new domain, it's different.  So now I will let Florian talk about the SD table and ACL, and also talk about our little  scripts.  Thank you, Bastien.  So yeah, for now we were mostly focusing on the data table and what kind of interesting  findings we have when we look at the configuration of users, machine, system, and so on.  But the ACL topic is very trendy and we wanted to add that to our tooling.  So first we started by looking at what was already done in the past.  So mostly these two projects made by also French people, so AAD Contropas and BTA.  They are not maintained anymore, but were a great start for us to understand how ACL  works.  So that was there and very helpful for us.  And also, of course, Sean mentioned it this morning, and ASAP the sleeve, this white paper  was really great to have a starting point in understanding how ACL works in an active  directory, so thank you to them.  So what was our plan to tackle the SD table, how to parse it, and how to identify potentially  vulnerable ACLs through the analysis of the NTDS?  So our goal was to make a Python script to do that, because in our company we mostly  use Python and it's easy to code in Python, and we don't want to have a really big infrastructure  to do that, so we just want to store the information in CSV files, from now at least.  So we saw that BTA was actually made in Python as well, so for us we were very lucky.  It's not maintained anymore, but some pieces of code we think can be reused for us.  So we will look at that a bit later.  Also even though mPacket is really useful to parse the NTDS and at least some part of  it, we saw that the DSEC library from Fox IT is actually very much efficient than mPacket  to do so, and it's really easy to use, we will show you that also later.  For testing purposes we used LOAD, which is an Active Directory environment that can deploy  easily on AWS, so if you wanted to play with permissions, set new permissions, perform  an extract of the NTDS and see what it does on the data, it was convenient for us.  For the future, we want to have the same terminology than Bloodhound when it comes  to the AC edges that we identify, so for example the white owner, white account restriction  and so on.  So how do we find the ACL for an object in the NTDS?  So let's take an example, so first we look at the data table which contains information  for every object in the Active Directory, and let's pick a specific object here, Aragon.  So we see that its NT security descriptor is 296, and that is really important for us  because we want to cross-reference that with the SDID value in the SD table, which contains  the data related to the security descriptors and so the permissions on the objects.  So in the SD table we look for the SDID value that matches 296 and we grab the SD value  that contains the actual permissions on the object.  So in practice, how does it look?  So with Dissect, it's just a few lines of code to parse the SD table and we choose these  two values, so the SDID and the raw value of the SD value, and it looks a bit unfriendly  at first, but fortunately there is some documentation about the structure of a security descriptor  by Microsoft, and so the most interesting bits in the structure for us and our topic  are the owner and the DACL elements.  So the owner is of course the object's owner of the object we are analysing, and the DACL  or Discussion Area Access Control List contains actual permissions that are set on the object.  Let's take a deep look in the DACL.  So you can see it as an array of access control entries, and each access control entry is  like that.  So there is a size, a type, for us the most interesting types are access allowed types,  but you can find access denied types, because sometimes you want to deny a permission to  an object, but if you want to look for suspicious ACL that could be used in a pen test or so  on, we just look at allowed.  There is an access mask which contains the actual permissions that are set on the object,  and there are some object flags.  And finally the SID of the object that has a permission on the object that we are analysing.  So let's take a look at the object types.  So basically there are GUIDs, and they are present only where some specific ACLs are  set.  So for example, read property, write property, or control access.  Let's take two specific examples.  So if in my ACL I have the write property access mask with this object type, which translates  to the MSDS credentialing attributes that you can find in the documentation of Microsoft,  you can conclude that you actually have a NAT key credentialing permission on the object.  And what does that mean?  It means that you can perform a shadow credentialing tag and take control of the object if you  have a PKI infrastructure in the environment that you are auditing.  One example with the control access mask, and this object type, which translates to  the user force change password extended write.  It means that you can force change password of the object that you are analysing.  So by doing that and iterating over each ACL, you can conclude what permissions an object  has over another object.  And there are some specific cases for the GUID of the object type and iterated object  types.  So the zero GUID, or even when there is no GUID, which means that you actually have all  the permissions, you have the rights on all the properties or extended rights on the object.  So for example, write property with a zero GUID, you can write any property on the object.  So in practice, to pass the ID value, the BTA project was very helpful for us because  we could take its code and readapt it a little and make it work.  So it helped us translate the binary data to a more friendly readable JSON structure.  And in this JSON structure, you can actually find the table of the ACL structures I showed  you earlier.  So now let's take a practical example.  Let's say I am an administrator and I want to configure the modify owner right on the  Aragon object for Gimli.  So I will use ADSI or any PowerShell scripting to set up this permission for Gimli on Aragon  and you can see on the right screenshot that it is actually set.  So Gimli can modify the owner of the Aragon object.  In the Bloodown world, it would be like that.  You would see this edge after running SharePoint and importing it in Bloodown.  So you have a white owner edge from Gimli to Aragon.  So let's do what we did earlier to find these privileges in this table.  So first we find the anti-security descriptor of Aragon and then we look in the post as  the table for the DSL of the object that matches the SDID 296.  So it looks a bit like that which is, you will agree, much more readable than before.  And now we have this big array that contains all the ACL and so we iterate over it to analyze  all the permissions and we finally end up on this ACL.  So we can see that there is an access type, access allowed, a white owner flag set to  true and an SID.  And this SID, if you look in the data table, we can actually see that it is actually Gimli.  So what this structure means, it means that Gimli has the white owner right on Aragon  which the anti-security descriptor is 296.  So we made a script that automates this process and dumps all the suspicious ACL into a CSV  file and so if we were to take the example of Bloodhound that we showed before, the white  owner edge is represented here in our script so you have Gimli that have indeed white owner  rights on Aragon.  So final words, we released an open source script in Python that does automate all of  this or the parsing and dumping of data table and its table in CSV files so it's really  easy to use, you just have to provide it with the NTDS and the system hive and it will do  the work for you.  So you will find all the information on the GitHub.  It looks like this, so we put some calculation of execution time for each function, usually  the bigger the NTDS the longer it will take especially for the parsing ACL part and the  tool dumps the data in six different reports matching domain data, group data, user data,  suspicious ACL, trust data.  We still have some work to do on the script, there are some bugs that are somehow related  to the libraries that we use to parse the NTDS, so the sect and there are open issue  on the project but it will not be treated in the coming year I think.  We have also some way of improvement regarding the new labs attributes that are not incorporated  at the moment and we haven't made the mapping for the generic call, generic write permission  on that, just a matter of deciding what sum of writes the objects have and do that, so  it will be done in the future.  Also things that we want to do to improve the tool are maybe to decry everything and  have something that is really ready to use and everywhere, maybe use a proper DB to store  the object because actually at the moment we are just using CSV files and doing all  the parsing in Python without actual storage of the data.  We are thinking of doing some interactions with Bloodhound, for example being able to  translate our data into Bloodhound compatible data so that it will be ingested in the tool  and it draws the beautiful graphs so we could maybe perform the Bloodhound audit directly  from having the NTDS which would be really cool and maybe enrich the data that is in  the Neo4j database by actually pointing out which user will use the same passwords that  would allow us to identify more attack paths in Bloodhound.  Also we think that we have some work to do on the ACL for some containers or GPO so that  will be also something for the future and maybe collecting even more interesting attributes,  so Bastien talked about dynamic attributes like LAPS but other tools from vendors can  also modify the schema of the Active Directory, so we saw for example in Pentest that some  tools actually had an attribute that is readable by all users and that contains the MD5 of  the password of the user, so that would be interesting to recover and yeah, if you have  suggestions do not hesitate to put us on GitHub, we would be happy to treat it and also if  you have put requests there, they are welcome.  So yeah, we're good.  Thanks guys.  Any questions?  All are good.  Thanks again.  Ah, where's one?  Sorry.  Just I have one question, regarding the tool set that you are going to provide, do you  have like any roadmap on what you want to still continue to push and contribute to the  community on the script, like what is the next step for your parts and today's script?  I think adding new attributes, extra attributes, just like we have talked just before and also  I think put everything in the MongoDB database that it could be interesting to perform most  suffocated requests for audits after.  Any other questions?  Okay, thanks again.  Thank you.  you