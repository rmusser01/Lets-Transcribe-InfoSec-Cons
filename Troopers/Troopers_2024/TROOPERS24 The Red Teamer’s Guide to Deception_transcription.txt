{
  "webpage_url": "https://www.youtube.com/watch?v=Gmtwtw1uKss",
  "title": "TROOPERS24: The Red Teamer\u2019s Guide to Deception",
  "description": "Talk by Balthasar Martin, Niklas van Dornick - June 26th, 2024 at TROOPERS24 IT security conference in Heidelberg, Germany hosted by @ERNW_ITSec\n\n#TROOPERS24 #ITsecurity \nhttps://troopers.de/troopers24/talks/8fjh87\n\nMore impressions:\nhttps://twitter.com/WEareTROOPERS\nhttps://twitter.com/ERNW_ITSec\nhttps://infosec.exchange/@WEareTROOPERS\nhttps://infosec.exchange/@ERNW https://ernw.de",
  "channel_url": "https://www.youtube.com/channel/UCPY5aUREHmbDO4PtR6AYLfQ",
  "duration": 3063,
  "channel": "TROOPERS IT Security Conference",
  "uploader": "TROOPERS IT Security Conference",
  "upload_date": "20240902"
}

This text was transcribed using whisper model: large-v2

 Welcome, today we want to talk about our sRLabs deception strategy that we developed to catch  attackers in your network, a few of our favorite AD honeypots, and then how we built the honeypot  that didn't exist before but that we always wanted to have to help the defense teams.  My name is Balthazar, I'm leading the red team at sRLabs and I'm here today with my  colleague Niklas, he's also part of the red team.  What you see here on this screenshot is a root shell on one of the target systems in  our recent engagement, and you can also see a mistake that I made.  So I needed a command, I asked my colleague Fabian to send it to me, and I made the mistake  of copying the command from Microsoft Teams, and despite just selecting the text in the  middle, somehow it managed to throw in metadata and some line breaks into my clipboard, I  made the mistake of pasting directly into the terminal.  In the course of this, also throwing the name of my colleague Fabian under the bus, who  had nothing to do with this.  So why do I show you this?  As attackers, we are only human and we make mistakes.  So in most engagements, there are ample opportunity to detect us.  Maybe this to detect is not so easy, but there are a lot of other options as well.  However, we still end up compromising most target environments.  Let me give you a few examples.  So one recent engagement was with a telco, we got into the network via code execution  in an internet exposed system, then found SSH keys, moved around in the Linux environment,  and finally got some credentials for a production automation user.  With this user, we could achieve all our goals, we could access arbitrary systems, including  subscriber data and reading SMS.  In this case, it was quite hard to catch us because we didn't trigger an alert, partially  due to a living off the land approach in the Linux environment.  So very hard to catch us.  Second example is a financial company.  We actually sent a few phishing campaigns with malware, but our payload was detected  and blocked by the EDR.  However, we found a different way in, and from there did password spraying from the  internet, exploited some Java servers to strengthen our foothold.  Then we abused several AD problems, in the end had some admin for the identity management,  and got control of the objective over one of the core banking interfaces.  So here we actually had the detection in the beginning, however lateral movement and privilege  escalation were on under-monitored systems and stayed undetected.  And then last but not least, a manufacturing company.  We started with an assumed breach account, got a bit of a foothold, and then performed  quite a few Active Directory attacks, like Kerberosting, configuring delegation, running  Bloodhound, things like this.  And several were detected, but the investigation did not reveal our original accounts, our  foothold.  So even though there were a few alerts, some were even dismissed, and others weren't enough  to kick us out of the network.  So what do we learn from this?  So if we look at an attack over time, the deeper an attack goes into network, of course  the more effort it becomes.  At the same time, most attacks fail early, and only a few make it through to the end.  Now there's two problems.  Because the effort at the start is not too high, attackers that are really determined  can try again and again until they get in at some point.  And when they are in, we really see there is a lack of effective detection and response  for the lateral movement and privilege escalation stages of our Red Team engagements.  Question is, why is that?  Because SOC is really hard.  First you have the problem of achieving good lock coverage.  You might be able to onboard 80% of the systems rather quickly, but the last 20% are really  a lot of effort and communication.  So attackers with time can often find this one under-monitored system from where they  can operate.  Second, corporate networks are really complex, and very weird things happen.  So let's say you want to build an alert for a bloodhound LDAP enumeration.  You might have some legacy tools in the network that regularly dump the full active directory.  So suddenly you get a lot of false positives, and the real bloodhound alert might end up  not followed up upon, because the volume is just too high to perform an in-depth investigation  on all alerts.  One more is that even if there is investigation, the SOC sometimes does not have the knowledge  of the specific administrator or the specific domain they're investigating for, and there's  a lack of communication with the administrators in many cases.  This can also lead to incorrect classification of alerts.  And then last but not least, it's often a stressful job.  People have to work in shifts.  So whenever people are trained to be really, really good at it, they often leave for roles  they think are more desirable because of this style of work.  So what does that mean when combined?  Attackers with time, luck, or skill, however you call it, they can perform attack chains  that usually just trigger a few alerts.  And SOCs against the large alert volume are optimized to handle this large volume with  okay-ish precision.  So attack chains that just have a few medium alerts have a realistic chance to get through.  So we think Blue Team needs some form of a smoke detector for these cases that pass  initial defenses to catch them before they compromise the full domain, to catch them  before the full fire is already burning.  And we think for this problem, honeypots are a very underutilized but effective solution.  So to be clear, I'm talking about internal honeypots, so not honeypots you put on the  internet for threat intelligence, but vulnerable systems or traps you place in your internal  network for attackers to find and then trigger an alert when they try to exploit them.  They are also called canneries or deception technologies sometimes.  Example could be a pair of invalid credentials hidden somewhere and you put an alert on when  someone tries to use these credentials.  We think they are good because if you already have a SIEM, you can place a few honeypots  in some smart locations and already have quite a nice coverage.  You don't need an extra tool if you have a SIEM and they have a low footprint and not  too much maintenance.  What's also nice is because they are not used by legitimate users, you usually get a very  low noise detection.  So if someone is doing something maliciously looking with a honeypot, it's quite likely  that it's really an attacker.  And last but not least, they detect for lateral movement and privilege escalation.  So they detect cases when an attacker is already in your network and it's really urgent to  do something about it.  So the alerts have a high relevance.  That means you can also directly send them to a senior analyst to investigate.  So combining this together, we think that internal honeypots provide effective alerting  to prevent the worst in cases where attackers make it into your network.  They also have a great cost-benefit ratio.  And even if attackers anticipate their honeypots, they have to be super careful and they will  start doubting the real vulnerabilities as well.  So even if they don't trigger them, because they're very, very careful, it slows them  down.  So this is why we think you should implement some deception strategy.  But before the people here that work for the deception software vendors or in the sales  department there get too happy, let's look at a case study from a recent test.  We were up against the top-right quadrant deception tool, as I would call it.  It was rolled out on all corporate laptops, placed in canneries, including in the Alsace  process, and it had a set of different credentials deployed to each laptop.  So not two laptops were looking the same in terms of honeypots.  This picture here is actually from their website.  However, how did it go?  The setup was totally ineffective.  And the main reason here is the coverage gap.  They were rolled out with a lot of effort to all laptops, but we didn't come in via  a laptop.  We got into the network via another infection vector.  But even if we would have ended up on the laptops, putting credentials in the Alsace  process can sometimes be quite hard to find for attackers, because the laptops where the  deception solution is rolled out, these are also the laptops where you usually have a  strong EDR and where Alsace protections like credential guard might be in place.  And so even if an attacker ends up on the laptop, that doesn't necessarily mean they  will find these honey tokens.  So overall, the solution was somehow over-engineered with a lot of effort, but at the same time  not tailored enough to the specific environment.  What we took away from that is that simple and well done often wins.  So you need to make sure your honeypots integrate well in the environment.  And ideally, you also have some admins to support you in the rollout, because they know  better how to blend in.  Also, if you are on a budget, you don't need a tool.  It's nice to have, but you can do quite a nice setup without specific tooling to buy.  So for how to deploy honeypots in your network, we would like to talk about a few principles  that we follow there.  First one is discoverability.  So the attacker actually has to see the honeypot to trigger it and to find it.  Let's say this is the network that you have.  A node is basically some resource.  An error means it can attack another resource.  Question is, where do you place the honeypot?  Of course, you place it on the path where most attackers somehow can see it.  The bubble at the bottom would maybe be honeypots on laptops only.  Next, even if an attacker sees a honeypot, to make them step into the trap, they have  to think they get something out of it.  So it needs to look appealing as if it advances your privileges in some way.  One example here is if your honey users in Active Directory look like basic corporate  users, as a red team, we can often get these via external password spraying or a lot of  different ways.  So it's not worth the risk of using these credentials if we find them, if we can get  similar accounts just from password spraying.  So in this case, we would place the honeypot, of course, on the path to a high-value system.  Next principle is authenticity.  Here, you need to make sure your honeypots do not stick out when you place them in the  environment.  There is a great blog post by Sean Metcalf, who I think is right now in Hall 2.  Nicholas will talk about that a bit more later.  But let me give you one example.  You have deception solutions quite a bit that place cached credentials to be found on Windows  machines.  However, there is a registry key that specifies the maximum number of cached credentials that  are allowed.  If there are more cached credentials than this number actually specifies, attackers  can figure out something is fishy.  So here, you would also place the honeypot where it looks the least suspicious.  Maybe one more comment on authenticity.  Don't be too concerned about it.  In the sense of it looks too vulnerable.  With this, I can say attackers are used to seeing something that looks unusually vulnerable.  So also, don't overthink it.  Next one is simple.  Safety aspect.  Honeypot shouldn't be exploitable.  Otherwise, you really introduce new risk into the environment.  Some people recommend placing real credentials in the network and setting the logon hours  for the account to deny.  We think this can be a little bit risky because someone changes the logon hours without knowing  the context and suddenly you have a real vulnerability.  And then last but not least, honeypots are only useful if they have a good signal to  noise ratio.  So you need to limit false positives and you can consider this in how you set up the honeypot.  Also, when the alert triggers, you need to have the locks available for an investigation.  And let's say you have a honeypot with a credential that you somewhere hide in the network.  If someone uses that credential, you need to be able to know the source IP where they  are coming from.  So if you have a gateway somewhere in the network, that can prevent you from actually  figuring out where the login came from.  So when you follow these steps, you should get to a nice setup.  The question is how to start.  For that, we differentiate the different types of internal honeypots in a few categories.  First is honey network services.  So these look like a normal service in the network like SSH or HTTP and they can often  be deployed as containers, sometimes even as dedicated hardware devices.  And they alert when someone tries to use or attack these network services.  There's also the differentiation between low interaction and high interaction honeypots.  High interaction means attackers can explore them a bit more and don't notice so fast it's  a honeypot and you can observe their behavior more.  So this is possible with these types of honeypots because you can just give them some shell  when they log in in SSH, change route it, and then they can still look around.  So that's kind of nice.  But at the same time, this whole concept of network services, especially in large networks,  is hard to roll out with good coverage.  Because you might have thousands of network services and then there is one honey service  in the middle.  How are attackers going to find specifically this one if they do not scan the full network?  In this case, we would also recommend honey tokens.  We split them up into honey files and authentication secrets.  Files are, for example, office documents or PDFs you place in your network.  And when you open them, they trigger a DNS request so you know someone opened the file.  They are a bit more prone to false positives because also normal users can find these on  a file share and open them.  The nice thing is the location is very flexible.  You can place them in your on-premise network, but also in your cloud, on SharePoint, in  some storage buckets.  But next to the false positives, you also need to make sure that the traceability is  given.  Let's say you have this document that triggers a DNS request.  The attacker downloads the document, opens it in their network, and you get the DNS request.  Well, then you know that somewhere there's an attacker who got the file, but you need  to be able to trace back from where in your network they got this file.  So you cannot just take the same file and place it in a lot of different locations.  Very similar here are the authentication secrets.  Here the advantage is that not only does an attacker have to find them, but also try to  authenticate, something that normal users probably wouldn't do.  So there is a lower rate of false positives, and you only alert on attempted authentication.  This could also be some AWS API token you hide in your source code.  They're also quite flexible, have a bit less false positives, but also here you need to  be sure, especially for cloud systems, that you have the traceability if someone uses  that token coming from the internet.  And then, last but not least, Active Directory Anipots.  So these are AD objects that suggest some worthwhile attack path.  And you need a CM or some monitoring for AD events to actually alert on these.  We also count hiding credentials for Active Directory accounts to this category, instead  of authentication secrets, because in how they work and how you alert on them, they  are quite similar.  More details Niklas will give you in a minute.  They are nice because most attackers optimize their tool set for Active Directory, and a  lot of users can also see Active Directory, so they're easy to find and easy to exploit  for hackers.  However, you might need support from some domain admin, and usually they are quite a  bit busy to set these up.  So in what order would we recommend to deploy them?  Because they can be quite hard to discover, we would recommend to do the Honey Network  services last.  For that, we would say use the authentication secrets, because they can flexibly cover a  lot of different environments together with the Honey files.  And it depends a little bit what your actual architecture is.  If you're more cloud-first, this can be more useful.  And here we actually think there are ZAS products where you can set this up with a reasonable  cost and effort.  And then, what we would tell you to start with is Active Directory Anipots.  Most attack chains of hackers touch Active Directory at some point, so it's the perfect  location for deception in our view.  So let's see what we can do here.  Maybe one small tip.  If you have past Red Team reports for your environment, you can read them to get inspiration  for great Honeypots to build, because these were real vulnerabilities that were exploited  by attackers.  All right.  Let's have a quick look at our favorite AD Honeypots and how they relate to the design  goals that we laid out earlier.  So the first one is pretty straightforward.  So the general idea being that you hide some fake credentials for AD accounts somewhere  in your internal network.  And how you do that, there's many options for that.  You can get really creative with this one.  One example would be using the AD description attribute in that account.  Or otherwise, a real classic is the hard-coded credential.  You can see down here in some scripts that you distribute.  So that makes it quite easy to discover for an attacker.  And to make these accounts look appealing to attackers, you would like to give them  some interesting privileges via group membership, and make sure these permissions are visible  in LDAP.  So attackers enumerating them will see that.  Or just by using an interesting naming scheme for the account.  Authenticity-wise, there's two options here.  One is to use an active account that has very rare failed logons so far, so you don't get  too many false positives.  Or even better, use a dedicated Honeypot account by recycling old decommissioned accounts in  your network.  That way, you get very good, realistic values for all sorts of different attributes, like  the last logon, the password time, even the RID.  A lot of these are mentioned in Sean's blog post, but be sure to check it out for more  details.  Safety-wise, this Honeypot shouldn't be a problem at all, as long as you make sure that  account has a secure password, and the password hint that you distribute are not actually  related to that.  And as mentioned before, we advise against using the logon hours deny hack.  For alerting, you can actually just use the built-in Windows events.  They contain sufficient information to build solid alert rules for your SIEM.  So the next one.  This one relates to Kerberos thing.  Quick recap.  We're all on the same page here.  The Kerberos thing attack targets the Kerberos authentication protocol, the basic idea being  an attacker can request a service ticket from the domain controller, which is encrypted  with the hash of that account's password.  So an attacker can extract that and try to crack it offline.  And if he succeeds, because of a weak password, use that for authentication.  We can use that to create Honeypot for this, which would be very easy to discover.  A lot of attackers look around for these kind of vulnerable accounts and query out for users  with an SPN set.  But to make these accounts look appealing, you would want to make sure that the password  hasn't been updated for a long time, or make sure it's a human account, because humans  are usually quite bad at picking good passwords.  Authenticity-wise, we have two options here as well.  Either set an SPN on a normal user, making it look like it was some forgotten test case  an admin tried out at some point.  Or otherwise, again, use a dedicated Honey account by recycling decommissioned accounts.  Also regarding authenticity, you should consider how common RC4 is in your environment.  It would make it a bit easier for an attacker, and therefore more appealing.  But if it's the only RC4 account in the whole network, it might look a bit suspicious.  Safety-wise, same as with the other Honeypot, just ensure the account has a very strong  password, and then you're good to go.  And if it's not a dedicated Honeypot account, make sure the owner is aware of that.  And there's some built-in event IDs, again, that you can use to build solid alert rules  for your SEM.  And then finally, the third one, not based on accounts, but on groups.  So the idea here is that starting with Windows Server version 2016, it became quite difficult  to enumerate RDP privileges.  So how can you use that for Honeypot?  You create a group that is named, or otherwise looks like it provides RDP privileges.  Make sure that all users are members of domain users in LDAP and part of that group, so attackers  can easily find that when enumerating them.  And yeah, make sure these appeal to the attacker by also giving local admin to that group.  And ideally, do all of this on a machine that seems sort of relevant and important in your  internal network.  And yeah, most attackers will try to connect using RDP, because there is no other way to  find out if this group actually provides these privileges.  Safety-wise, you're good to go, as long as you make sure you don't provide actual RDP access.  And it's also quite important to make sure that the admins in your organizations are  aware of this, so no one will actually add real RDP privileges in the future, thinking  a mistake has been made.  And for alerting, there's some event IDs here you can use again.  They even have a logon type specifically for RDP, but you might also include some others,  because there's some options which would probably result in a different logon type as well.  And actually, this general approach does not only work for this RDP privileges, but for  example, you could also use VMware or vCenter in your organization for the vCenter admin  group, which usually also looks quite interesting for threat actors, especially ransomware groups.  So that's been our favorite AD honeypot.  Yes, but even though that list is already quite nice, there was one type of honeypot  that we think would catch us very reliably, and that we always wanted to build.  So for this one, let me give you a brief introduction to ADCS, to Active Directory Certificate Services.  This is the PKI solution by Microsoft that's integrated with Active Directory, and it can  be used to create certificates for TLS, email, code signing, but also for client authentication  in your network.  So if you have an authentication certificate for a user or a machine, you can basically  do the same thing as if you have a password.  In that sense, it's a very crucial component, because when compromised gives huge access  to basically full domain compromise, it's usually also considered Tier 0.  How does the process work to get an authentication certificate?  So the available templates for certificates are published in Active Directory.  They list a few properties.  They also include the permissions who can enroll in a certain template, and the users  can query Active Directory to get a list of certificate authorities and supported certificate  templates.  Then the user creates a certificate signing request from one of these templates, authenticates  to a CA, and sends this signing request.  The CA then checks this request against the templates it actually supports, evaluates  it, and if everything checks out, sends back a signed certificate to the user that the  user can now use to authenticate in the Active Directory domain.  So this is a process that we often exploit in our engagements that gives us a huge amount  of privileges.  So we wanted to see if we can build Anipod for it.  So first of all, why can you exploit ADCS so easily?  There's a lot of misconfigurations that can happen because ADCS is quite complex to configure.  And I'm sure a lot of you know that great white paper by Will Schroeder and Lee Christensen  from SpectreOps from two years ago, I believe, who published the first eight of these very  common misconfigurations.  And then in the following years, we've seen some more being published.  Quick summary for those that we see the most often, the ESC1 is basically based on some  flags that you can set in these certificate templates, enabling the enrolling user to  specify who that certificate is going to be valid for.  So you can actually just request an authentication certificate for other users or the domain  admin, for example, and then take over the whole environment.  Then ESC2 and ESC3 basically result in the same thing, but with a bit more complex setup.  So there's this feature in ADCS called Enrollment Agents.  And if you have one template that enables a low-privileged user to get a certificate  for Enrollment Agents, you can then use that certificate in combination with a second template  for Enrollment Agents to also get an authentication certificate for domain admin.  And then finally, misconfigurations we also see quite often are ESC8 and 11, which are  based on missing protection against relay attacks, but we're going to talk about that  in a bit.  So as you can see, this bad boy can fit so many misconfigurations, which makes it a prime  target for attackers, but also an excellent location for a honeypot for multiple reasons,  actually.  So first of all, access to ADCS is super easy.  All you need as an attacker is a domain user, and you're good to go to interact with the  CAs, which makes it very easily discoverable for attackers when you implement an ADCS honeypot.  Then as we've just seen, the configuration can be quite complex.  There's a lot of things that can go wrong, and we've also seen there's a lot of tutorials  out there with quite good SEO that suggests enabling some of these options without properly  talking about the security implications.  So that's one of the reasons why these misconfigurations are so common.  On the other hand, for a honeypot, that would make for very good authenticity.  Attackers are used to seeing these misconfigurations and wouldn't get suspicious.  Furthermore, there's some great tooling out there.  For example, CertiPy, to automatically scan for all these misconfigurations, and then  also making it very straightforward to exploit them, again, making an ADCS honeypot easily  discoverable.  And we've seen that these kind of tools, CertiPy or Certify, are a part of the playbooks of  many threat actors out there.  And with the central role that ADCS plays in an AD environment, compromise or some of  these misconfigurations usually have significant impact.  When you find some of these, usually it results in full environment compromise, which greatly  appeals to attackers.  ADCS is a very juicy target to exploit.  And finally, from our experience, ADCS is usually quite undermonitored.  So when we exploit misconfigurations, we mostly stay undetected afterwards.  So that's why attackers usually feel quite safe about exploiting ADCS.  So yeah, we see this is a great target to create honeypots for, but how do we do that?  Our first idea was to create a honeypot for EC8.  So basically, there's a feature in the CA that you can enable so that you can also do  a certificate enrollment via a web API that supports HTTP, which is, of course, vulnerable  to relay attacks.  But also with HTTPS, there are some misconfigurations that can happen that enable relay attacks.  And if an attacker already found a way to coerce authentication with the domain controller,  they can use that to forward the NTLM v2 authentication handshake to the CA and then  receive a domain controller certificate.  So yeah, quick analysis.  The great thing about this, the attacker tooling, for example, CertiPy for this, doesn't check  for the templates in this case, but just connects to the CA via HTTP to see if this feature  is enabled.  So this makes it very easy to implement a honeypot.  You would just have to mock parts of that interaction with the CA web server.  However, we think because this requires the whole relay and coercion setup to be present  already, it can be quite tricky for attackers to exploit, or at least the majority of attackers  would not super easily step into this trap.  So there's probably better options for honeypots here.  And we followed down quite a few paths.  So after the ESC8 honeypot, we looked quite deeply into ESC3.  And the interesting thing about ESC3 and these enrollment agents, you can actually play  restrictions in the CA on the enrollment agent part so that the exploitation of the  second template will fail, but attackers are not able to enumerate this beforehand.  So you would actually be able to make a setup that is safe against ESC3, but still looks  vulnerable from the attacker perspective.  However, an attacker would still obtain an enrollment certificate from that first template.  So there might be some opportunities in the future for an attacker to still find another  template with the configuration that's valid for enrollment agents, and thereby still be  exploitable at some point.  In our opinion, it's just too risky to actually roll out this honeypot.  We tried to make it more safe using approaches like auto-revocation, but certificate revocation  is a complex topic.  There's a lot of caching happening, and it's not very straightforward to make sure revocation  actually happens instantaneously, and there's no time window where an attacker could potentially  exploit vulnerability with a valid certificate.  So we haven't been too happy about our options until we finally found out about policy modules.  So what are policy modules?  Policy modules provide a way for you to implement some custom logic in the CA for certificate  issuance or denial, and it's actually just implemented with a DLL that you load on the  CA server then.  And we found a very great implementation of such an ADCS policy module called TameMyCerts,  which is developed and maintained by Uwe Gradenegger.  And this allows for very fine-grained control about this certificate issuance checks that  can be specified in XML, and it also provides some additional logging capabilities, which  are great for building honeypots.  So we decided to go with this and use it to build a very simple yet effective honeypot  for ESC 1.  So quick recap, in ESC 1, it's based on some flag that is set in the certificate template,  which basically enables the requester to specify a subject alternative name in the  certificate signing request, which would then result in a certificate that is also valid  for other accounts, like the domain controller or domain admin.  And yeah, it's very easy to specify a policy like this in XML that would just deny all  incoming certificate signing requests where the subject alternative name is set, thereby  making it impossible to exploit ESC 1 in this case.  But still to the attacker, using tools like 3rdPy, it would look vulnerable.  So yeah, let's talk about alerting in this case.  So we actually, so far, implemented two different kind of alerts for this.  There's some built-in event sources in the CA, which you first have to activate by enabling  the extended audit log, and then you actually get some events that also contain the template  that has been used.  And we can use that to create medium alerts whenever this honey template is used.  But then with the extended logging from Tameisource, we can also create a very highly critical  alert whenever someone actually tries to exploit ESC 1 in combination with that template on  the CA.  And in the future, we've already talked about with the maintainer of that module, it's easily  possible to extend the logging capabilities even further for more customized alert rules.  Yes, alert rules, great thing about these is you can create them in the Sigma rule format,  which is CM agnostic.  So that's what we're doing.  So you can generate Sigma rules and then import these in whatever CM solution you're using.  And in the future, we're planning for some more improvements when we support some of  these other honey templates that you've seen before.  All right, and now it's time to announce CertiCeption.  So as part of this conference, we're going to release our tooling to set up ADCS honeypots.  What CertiCeption provides for you is it sets up a new certificate authority, adds a vulnerable  ESC 1 template to just that CA and enables it there.  And then also installs and configures the TameWise policy module and configures it in  a way to make sure ESC 1 cannot actually be exploited.  And also enables the extended audit log and creates these Sigma rules that you can import  into your CM to get alerts.  And then, yeah, there's still one tiny issue.  So as you see, the templates are centrally published in the AD LDAP.  So if you have multiple CAs in your environment, someone in the future, some admin who is not  aware, might import that vulnerable ESC 1 template into a different CA that doesn't  use the policy module to make it safe, thereby resulting in an actually exploitable configuration.  So that's why we set up some continuous monitoring to check if this happens or any other vulnerable  configuration is created using Certify as a tool.  So yeah, how do you use CertiCeption?  All you need is a domain joined Windows server that the CA is then created on.  CertiCeption uses Ansible that communicates via WinRM, so you need to make sure that connectivity  is set up, and then you need to have accounts with the privileges that are required to create  and register CAs and import the policy modules.  And then what you do is choose some unique parameters, like the template name, the name  of the CA, to make sure it fits into your environment.  Optionally, if you have some EDR deployed, you'll want to make sure that the continuous  monitoring that is scanning for vulnerable template configuration does not trigger any  alerts there.  And then just run CertiCeption.  It's setting up everything for you.  Connect the event logs to your CM, import the signal rule there, and then go for a test  run to validate the setup.  And then you're good to go to catch some attackers with this ADCS honeypot.  Some small disclaimer at this point.  Of course, use of CertiCeption is at your own risk.  Read the code.  It's not that complicated.  Understand what it does.  And we expect some potential for improvements in the future after this release.  You will be able to find it under the GitHub link.  Now it's time for some demos.  Okay, so what you see here is the configuration file where there are some parameters in there  to customize your setup so it doesn't look the same and obvious in all environments.  And then in this video, Niklas executes the Ansible playbook, provides the passwords for  the accounts.  And what follows now is a bit of a longer Ansible run that I think we can skip over  here, but it basically sets up a new CA and configures it.  On that new CA, installs the policy model and the restrictions, and afterwards creates  the template.  And so we don't create the template first and then place the restrictions later if something  happens in between, you have a problem.  But the order is switched.  And then in the end, prints the sigma rules.  So let's skip a little bit further to when the Ansible playbook completes.  We can take a look into the sigma rules here.  That should be, this is the template, the sigma rule should be here.  You can see it's customized based on the parameters you entered previously for your CA to be set  up.  And then we can take a look how it looks from the attacker perspective.  So in this case, we use CertiPy first to enumerate the available templates.  And there you can see, after this, you can see the CA we just set up in the output.  And you can see the template is recognized as vulnerable to ESC1 by the tool.  Next, when attempting exploitation, so trying to get a certificate for the domain administrator  by specifying a subject alternative name, you will see the request actually fails.  In this case, the error message is invalid name, but this is actually the error message  right now you get when the request is denied by the policy module.  Now when you have onboarded your logs to the CM, brief view how that will look.  So right now we have the medium alert for someone interacts with the CA, and we have  the critical alert for someone actually trying to exploit it.  So this is how it could look in your CM.  Good.  Because not all attackers use CertiPy, we also took screenshots of the three most common  tools that we know of for checking this.  In each three of the tools, the template appears as vulnerable.  The two of these that also exploit, you see that exploitation fails in both.  There's still a bit to do.  First after this talk, we will publish the repository.  And then we want to implement more different honey templates aside from ESC1.  There's a lot more options what we can do here with this policy module.  We also want to support placing honey templates on existing CAs.  Then you need to maintain one CA less, because right now the tool sets up a dedicated CA.  Also we want to see what other hardening options we can put in place.  And for this, we are happy to receive the scrutiny of the community.  Now it was just released, please look at it.  Do you find any other ways how this might be exploited?  Some additional hardening potential?  Please let us know.  And then we also want to tune a little bit the error messages that are sent, so that  even these can be customized in the future.  So even when an attacker steps into it, they don't see so easily that it's a honeypot.  So please try to use it.  Please have a look.  What you take away from today is first that we think honeypots provide great and meaningful  detections for cases where attackers make it past your initial defenses.  But it is important that you make sure they are custom-tailored to your environment and  that you think through how you deploy and how you place them.  And of course, as Ellipse, a deception is the honeypot that would definitely catch us  and that we thought defenders always wanted to have.  Thank you.  So I think the QR code right now still leads to an empty page.  We will publish it during Troopers and then also make the slides available in the repository.  Everything will be there.  Any questions?  Thanks for the great talk and the great deception idea.  One thing I think might be a risk if the attacker compromises the CA host itself and extracts  the CA certificate.  What are your thoughts about removing the CA certificate from the NT art store so that  even if the certificate is stolen or the policy module doesn't work, the certificate can't  be used for authentication?  So first, yeah, definitely a risk.  Good point.  We would first recommend that if you set this up, you have to treat it like any other CA  in your network in terms of hardening.  I think somewhere also in the security considerations in the repo, it says there is no HSM used.  If all your other CAs use an HSM and this one doesn't, then it would be weakening your  security.  We tried playing around a little bit with removing it, but we didn't have much success  where everything still worked smoothly and looked like from the outside everything is  fine.  It is one of the hardening options we still want to see a little bit if we can add this  as an additional flag for more security if you want to deploy this in production.  It's a good idea.  We tried it out and couldn't make it work yet, but it's still on the radar.  Do you know if Certify or Certify looks for that the CA is actually in the NT art store?  So I think in our test yesterday, we saw it didn't, but that's a check that can be easily  implemented, right?  I think that's something the two developers would probably fix reasonably quick.  Also, like the root certificate of the Honeypot CA is currently not added to the trusted root  certs in the domain, which is also not checked by Certify.  Yet.  Thanks.  We have a question.  Thank you for your talk regarding your experience you've made.  Would you recommend and suggest only set up and install your individual Honeypots that  fits quite well into your existing infrastructure?  Because I'm assuming if you buy one of the big deception technology products, they come  off with their own virtualization, their own orchestration.  And when it comes to timing and fingerprinting, or even routing tables, when you are on prem,  it should be quite easy to detect that there is a Honeypot in place.  So yeah, I think there are options to detect that if it's set up with, let's say, commercial  tooling compared to really doing it yourself.  I agree with your points.  I still think that for a lot of attackers, they are enough.  And like a normal ransomware gang wouldn't measure the response timings on certain services.  But yeah, if you want to do it perfect, and if you want to catch, let's say, the big nation  state actors, that's definitely a consideration.  Okay, thank you.  Any more questions?  Doesn't look like it.  Then thank you very much for your presentation.  Appreciate it for your contribution to Troopers.  So I'll give a round of applause.  Thank you.  Thank you.  Thank you.  Thank you.  Thank you.