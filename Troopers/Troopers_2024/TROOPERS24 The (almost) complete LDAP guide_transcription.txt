{
  "webpage_url": "https://www.youtube.com/watch?v=W1Tn_-OExIM",
  "title": "TROOPERS24: The (almost) complete LDAP guide",
  "description": "Talk by Sapir Federovsky - June 27th, 2024 at TROOPERS24 IT security conference in Heidelberg, Germany hosted by @ERNW_ITSec\n\n#TROOPERS24 #ITsecurity \nhttps://troopers.de/troopers24/talks/kynuwx/\n\nMore impressions:\n  / wearetroopers  \n  / ernw_itsec  \nhttps://infosec.exchange/@WEareTROOPERS\nhttps://infosec.exchange/@ERNW https://ernw.de",
  "channel_url": "https://www.youtube.com/channel/UCPY5aUREHmbDO4PtR6AYLfQ",
  "duration": 3075,
  "channel": "TROOPERS IT Security Conference",
  "uploader": "TROOPERS IT Security Conference",
  "upload_date": "20240909"
}

This text was transcribed using whisper model: large-v2

 Okay. So, hello. Thank you for coming to my talk, the almost complete LDAP guide. So,  the reason I chose the word guide for the title of this talk is because I truly believe  you will be able to use these slides as a guide in order to know LDAP better or improve  your LDAP detection or maybe discover a new enumeration technique. So, I really hope you  find it useful. So, about me, my name is Sapir. I work at CrowdStrike in the Identity Protection  Group as a security researcher. Basically, I love everything related to identity. In  the past couple of years, I had the chance to research Azure EnterID, AWS Identity Center,  Active Directory. So, today we are going to speak about LDAP. So, what's LDAP? It's the  Lightweight Directory Access Protocol. So, when we say directory, in this talk, we will only talk  about Active Directory. So, LDAP can be implemented for different type of directories, but this is  obviously the AD track, so we are going to speak about Active Directory. So, we all know that AD  object has attributes and we use LDAP to query these attributes or modify these attributes to  get more information. So, some of you may ask yourself, do people still use LDAP? So, let me  just delegate permissions to Twitter to answer on my behalf. People most definitely still use LDAP.  So, even though LDAP is old and also a lot of people already talked about it, I really hope  that each and every one of you will learn something new from this talk. Maybe except a few people here  that I probably can't teach you anything. So, what are we going to speak about today? We'll start by  talking about the usage. So, who uses LDAP and why? Then we'll speak a bit about the traffic  flows of the initialization function, connect, bind, and these are quite important since we'll use  them to understand what encrypted LDAP session means and how we can decrypt GSS API encrypted  traffic. Then we speak about Active Directory web services and later we talk about some attack tools  and enumeration techniques and how we can detect those. And finally, we speak about how we can use  LDAP for defense and what we can do with ETW when it comes to LDAP detections. So, usage. Most of you  probably think, okay, LDAP, we know data explorer, a lot of attack tools and techniques to enumerate  Active Directory environment. That's obviously correct. But also some IT administrators use LDAP  just to get information about their environment and maybe create users and stuff like that. And  there is also another party that uses LDAP and that's Windows. So, Windows by default uses LDAP  and this is quite important since if you want to create good LDAP detection and avoid false positives,  you should be aware of the golden image of your environment, what's the default behavior in your  environment. So, I gave you two examples. So, the first one is GPO. You can see the GP link and GP  options attributes. So, some of you may think this is the GPO enumeration query and indeed some of the  GPO enumeration queries look the same. But this is also the output of the GP update command, which is  default Windows behavior. And actually here, so, some spoiler, the way to differentiate between the  default behavior and maybe attacker's behavior can be, for example, using the time limit, which here  is 240. So, this will always be for GP update. So, this might be a nice way to differ between these two  scenarios. And also we can see the GMSA, so the group managed service accounts. So, each time a  machine wants a service to run on a GMSA account permissions, it needs to retrieve the password from  the MSDS managed password attribute. So, this might look like an attacker tries to read the MSDS  managed password attribute, but this can also be just how GMSA works. So, the previous slides kind  of lead me to this one, which is the plan. So, the plan is to know LDAP the best we can and then it  would be easier for us to detect LDAP anomalies better. Or maybe I should even say that the plan  is to know LDAP better than the attacker does. And then it will be easier for us to catch it  where in the places that it even doesn't aware that it looks anomalous. So, some basic concepts.  So, when we speak about LDAP search query, we have some parameters that we should probably know.  So, the first one is the base object. This is basically the folder that we are going to  search in. And we can control the depths of the search using the scope parameter. So, for example,  the whole subtree, right? The whole subtree will search the folder and all of its subordinates,  but we can also search only the folder or maybe the child folder. And this will have a great effect  on the amount of results we are going to get. Then we have the parameter. So, this one is quite  interesting. So, from what I've managed to understand, actually Active Directory doesn't  support this feature. So, this value should always be zero. So, it might be quite interesting to check  if you have in the environment some LDAP traffic with non-zero value here. Maybe its attacker tries  to color its packet or something like that and it doesn't aware that it looks very anomalous.  And then we have the size and the time limit. So, the size limit limits the size and the time limit  creates a timeout for the query. And this can actually be quite useful, as I already spoke  about it in the GPO example, to defer a default behavior and attacker's behavior, maybe even sign  specific attack tools. Then we have the filter, which we will talk about in a couple of more  slides, and the attributes. So, the attributes, basically, it's what information we want to  retrieve on the object that fits our filter. And this is quite important as well, since every attack  tool look or ask for a different set of attributes. So, we can use them to sign the specific tool.  Now, let's talk a bit about the flow. So, first, we need to initialize a connection towards the  LDAP server, which is our domain controller. So, we have two functions we can use. The first one  is LDAP init and the second is LDAP SSL init. So, this slide is quite important. So, we all know  LDAP default port is 389. This is the port, the default port for the LDAP init function. And we  know that LDAP S is mostly seen at port 636. So, this is the LDAP SSL init default port. And we  also have the global catalog ports, which are 3268 and 3269. So, first of all, if you monitor  LDAP traffic in your environment and you use it using the 389 port, you should probably be aware  of the fact that there are three more ports that has LDAP traffic as well. And if you think that  LDAP with port 389 will always be unencrypted, this is actually a mistake. LDAP with port 389  might be encrypted and even most of the time encrypted using JSS API and we'll speak about it  in a moment. So, maybe you should just check your environment, see maybe you're blind to a lot of  traffic you have in your environment that you assume that is unencrypted, but it's actually  encrypted. So, I just gave you a couple of more options that you can play with the LDAP set option  function that actually have a great effect on the traffic itself. So, after we initialize the  connection towards the domain controller, we need to create the LDAP connect function. Actually, if  we don't use it, the LDAP bind function just do it for us. So, the bind function is very important  function because it's responsible for the authentication. So, there are two functions that we  can use here as well. The first one is the LDAP simple bind S function. So, this one just gets  username and the password and creates a clear text authentication. So, you can actually make sure  that you don't use this kind of authentication in your environment. So, just check that the  authentication type is not zero. Since if it is zero, you have clear text credentials in your  traffic, which is probably not a good idea. And also, if we already are speaking about  authentication in LDAP, so maybe we can ask why do we need authentication in LDAP? So, first of all,  every domain user have read permissions on the active directory. So, why is it important with  which user you authenticated? So, first of all, not all the attributes can be read by all the users.  For example, I talked about the MSDS managed password attribute. So, this one can only be read  by members of the principles allowed to retrieve password attribute. So, it's quite important which  user you are. Also, you can modify attributes in active directory, not only query them. And for  that, obviously, you need to have the right permissions. So, it's quite important with which  user you authenticated. But maybe we should say you can also authenticate as anti-authority  anonymous user. So, this actually allows you to authenticate anonymously. So, the GUI, you can see  it's the LDP EXE tool. So, this one is default on Windows and it's quite easy to use. So, you just  provide an empty string for the user and the password. And as you can see, I'm authenticated  using the LDAP simple binders function as anonymous logon. But you can see when I actually try to  perform LDAP search query, I get an error. But later, we will see that we still can use anonymous  logon user in order to brute force enumerate users in active directory environment, which is quite  cool. So, the most common authentication function is the LDAP bind as function. So, using the  method parameter, you control the authentication type, which is very important because the key  to decrypt the GSS API encrypted traffic is located inside the authentication inside the  bind response. And we will see it in a minute. So, it's quite important to understand what  authentication method you used in order to decrypt the data itself. So, now we'll speak  about the LDAP filter. So, I just thought to myself it would be easier if we just take an example.  So, I chose the delegation vulnerable accounts filter since it combines a different type of  filters and it's quite interesting. So, we have three types of delegation. This filter is  extensively used in multiple attack tools and attack techniques. So, it also can be used for  detections. So, the first type of delegation we have is the resource-based constraint delegation.  And to detect this one, we just want to make sure the MSDS allowed to act on behalf of other  identity attribute is not empty. So, for that, we just use a wild card to make sure there is  some value in it. Then we have the constraint delegation filter. So, here we have two options.  The first one is the MSDS allowed to delegate to. So, again, we just want to make sure this  value is not empty and we use a wild card. But there is also another option and other settings  that locate inside the user account control. The trusted to us for delegation flag. So, here we  have a bit of different situation because this is not an attribute. This is a flag located inside an  attribute. So, we actually need to perform some bit end operation on the attribute in order to  understand if the flag exists inside this attribute. And for unconstrained delegation,  again, we have the same case. The trusted for delegation flag which located inside the user  account control. So, we need to understand how we can find it. So, for that, we use something called  LDAP matching rules. So, this actually allows us to perform operations on LDAP attributes. So,  in this case, we will just use the following syntax. So, we have the user account control  attribute and then we apply the LDAP matching rule. In our case, it's the bit end rule. And  you can see the OID that represent it. And then we supply the flag we want to search inside the  user account control. So, this is how we can check if the user account control has these flags.  And to create the full filter, we just want to give an OR statement between either of these  conditions. So, we combine them all together using the OR statement. And this makes our  complete filter. And the last thing we will talk about is the LDAP controls. So, this is actually  kind of a set of functions or options you can apply on your search request that has a great  effect on the response. So, I think best way to understand it is by an example. So, for example,  we see the LDAP server show deleted OID. So, this one actually asks our LDAP server to retrieve  also deleted object that fits the filter. There is also another option at the dirsync. So, this  one actually retrieves an object that changes from the previous dirsync search. So, this can be  actually quite comfortable maybe even for just use LDAP as a defender to make sure see what  change and stuff like that. Now we'll talk about encrypted LDAP sessions. So, I'm not going to  speak about LDAPS in this talk. Since it's well documented and I think we are quite familiar with  it and there is also a lot of tools that support decrypting LDAPS traffic. So, I'm going to speak  about GSS API encrypted sessions. So, we have two cases. We have Kerberos and NTLM. And we're  going to decrypt each of them and understand the decryption flow. So, we'll start with decrypting  LDAP that encrypted with Kerberos. So, first of all, you can see in the upper left picture, you can  see we have some LDAP bind response. And inside of it, you can see the Kerberos blob. So, this blob  is actually the AP response and we are going to extract the key from there. We'll see it in a  minute. And in the bottom right picture, you can see the actual encrypted data. So, this is LDAP  search request. But it's encrypted using GSS API. And we can actually see this GSS API use Kerberos  since we have the Kerb5 token ID, which is 0405. So, when you're actually looking at the code, it  looks like 0504. But this is a good way to know that we are looking at Kerberos encrypted LDAP  traffic. So, let's decrypt our data. This is the encrypted payload and we want to decrypt it and  see the actual LDAP message. By the way, this is port 389, as you can see. So, again, I'm just  reminding you, if you think port 389 means unencrypted traffic, you should make sure you know  what you're blind for in your environment. So, first we have one prerequisite and that's a hash.  So, obviously, to decrypt information, we need hash. So, we can use the KerbDGT hash, the service  hash, the domain controller hash or the user hash. So, I suggest using the KerbDGT hash since using  it, you can decrypt all the LDAP traffic in your environment and not just a specific session. So,  the flow that I'm going to present here is used with the KerbDGT hash. So, first of all, we have  the AS response packet and inside of it, we have the encrypted ticket part. So, we use the KerbDGT  hash to decrypt this part and extract a key from there. Then we have the TGS response packet.  Inside of it, we have the encrypted TGS response part. So, we use the key we extracted in the  previous from the encrypted ticket part and decrypt this packet. And, again, we use that key  to decrypt the encrypted AP response part which located inside the bind response itself. We  extract the key from there and using that key, we decrypt our actual LDAP message. So, actually,  Wireshark has been very kind and they just visualize us this whole process. So, let's use  Wireshark to see it and it will be much clearer. So, we can see the AS response packet here. You  can see the encrypted ticket part and you can see it's already decrypted and there is a key inside.  And if you look at the blue line on the bottom, it actually tells us it used the KerbDGT hash to  decrypt this information. So, I provided the KerbDGT hash and Wireshark uses to extract that  key. Now, we are looking at the TGS response packet. And, again, we can see the encrypted  TGS response part. It's already decrypted and it got us another key. And, again, the blue line on  the bottom tells us it used the learned encrypted ticket part key from the previous frame. Now, for  the bind response. So, again, we can see we have encrypted AP response inside of it and the  decrypted key inside of it. And, again, it used the learned encrypted TGS response part key from  the previous frame. And, finally, we have the actual decrypted LDAP message. So, you can see,  actually, Wireshark knows this is LDAP and it actually parses it as an LDAP message. So, it's  not you will see later in NTLM decryption that it's not always the case. And you can see the  blue line I highlighted this time. It decrypted it using the learned encrypted AP response part  subkey from the previous frame. So, this was a Kerberos decryption flow, which is quite easy to  understand. Unfortunately, that wasn't the case on NTLM. So, LDAP encrypted with NTLM. First of all,  you can see the encrypted payload here. We can see now it's not Kerberos. We have the NTLM SSP  verifier. And in that picture, you can see the decrypted data tab. So, as opposed to Kerberos,  when Wireshark decrypts NTLM information, it doesn't actually understand this is an LDAP  message and it doesn't parse it. So, when you use Wireshark to decrypt LDAP, you will see,  actually, the encrypted payload blob and the data will hide in a different tab. So, this leads me  to a story time. So, last year, I tried to decrypt LDAP traffic using Kerberos and then using NTLM.  And I find a really good article explains how to do it using Wireshark. So, I did it. And for three  days, I stared at the Wireshark screen, couldn't understand what I'm doing wrong. Since all you  need to decrypt LDAP that's encrypted using NTLM is just provide a clear text password. So, I  changed the password and tried again and changed the password and tried again. And nothing I did  help. I couldn't decrypt the data. So, I was pretty frustrated and I sent a message to the  author of this article, which is this guy, which is, by the way, amazing and helped me a lot.  And, like, ten minutes later, he replied saying that this is working and I just looked at the  wrong tab for three days. So, I was quite sad. And he actually thought to himself, okay, if it  happens to her, maybe it will happen to another people. So, he added an arrow to the article.  This is a screenshot from the article. So, it won't happen to you as well. The decrypted data  is in this tab. So, this arrow is actually my greatest contribution to the security community  until this day and I'm very proud of it. And at the same time, I also spoke with Dirk about it.  So, we talked about the fact that you can't see the data in a comfortable way and I said, yeah,  maybe I'll write something that shows it more comfortably. So, actually, I did. So, I developed  a tool that implements the decryption process of Kerberos and NTLM encrypted traffic and also  parses the actual end up message and search for specific attack tools patterns. So, I will demo  a POC of this tool at the end of the talk and it will also be uploaded to a GitHub repository and  there is also another surprise you will see in the end. Okay. So, let's speak about the actual  decryption flow of NTLM. So, first, again, we have a prerequisite. This time, obviously, we don't have  the KerbDGT hash. So, we need the service which is the domain controller hash. So, just want to say  the flow is very random. I have no idea who created it. So, I don't know. It's not me. So, first, we  take the user name and the domain name and we concatenate those and we aggregate them. This is  located inside the NTLM SSP which is located inside the bind request. And then we use the  service as a key and we create something that's called NTWF. So, this is like a parameter from  Microsoft documentation. Then we use this one as a key and we take the antiproof which is the 15  first bytes of the response and we create something called base session key. Then we use the base  session key as a key and we take the session key which is not the same from the NTLM SSP part,  again, inside the bind request and we create a decryption key. Then using two clear text hard  coded strings, one is the server seal text and the other is the client seal text, we create two  decryption keys. So, a server decryption key and a client decryption key and we use these to decrypt  the actual GSS encrypted payload which retrieves us the actual information. So, it's quite important  to say since this is our C4 and we need to keep the context. So, it's very important that you  decrypt it in this exactly same order that the message appears since otherwise it won't work.  So, I said I won't speak about L2S and I'm not going to. I just wanted to say that it's very  well documented. All you need is a key log file. You have multiple ways to extract the key log  file. I here put Frida and SSL key log but there's many options. This is how the encrypted data looks  like and as you see, like Kerberos and not like NTLM, after it decrypts the data, it actually parses  the message so you can actually walk through the decrypted pick up and understand what's going on  there. And I just want to say there is the article I talked about. So, I put a link to it here. It  explains all the process to decrypt NTLM and Kerberos information using Wireshark. So, for  Kerberos, you need a key tab file. It's quite easy to use. So, key tab file is just a file that  maps user and it's hashed password. For NTLM, you need one option is a key tab file with RC4  passwords or just a clear text password. And for SSL, you need the SSL keys. So, you can see this  picture is the Kerb5 preferences. So, I just supplied the key tab file for it and it decrypts  the data for me. And here you can see the SSL decryption. So, I just provide the key file and  the key file password and it decrypts the data for me. And for the NTLM, I provide the clear text  password and we can see the decrypted data tab. So, this is if you want to use Wireshark. Now,  for my favorite topic of this talk, which is Active Directory Web Services. So, maybe you think  this is a talk about LDAP. Active Directory Web Services is a different protocol. So, what am I  doing? So, this was actually quite amazing. So, what AWS is doing is that it actually creates a  SOAP XML message. This is its structure. And you can see this is actually have all the LDAP  different parameters. We can see the filter, base object, scope, attributes. It also has controls.  So, this is actually pure LDAP, but in a different form. A different syntax and a different port. So,  if you monitor LDAP traffic, you're not monitoring AWS, but it's the same thing. So, a couple of  more things about it. It's actually much faster than LDAP, which is quite an advantage when you  try to enumerate a whole domain. It cannot be seen with LDAP ETW client provider and we will  see it a bit later and we will see how you can use ETW to see AWS traffic. It's not supported  by Wireshark. So, we will see it in a minute as well. But the thing is that when it gets to the  domain controller, it actually wraps, it unwraps the SOAP message and runs LDAP locally on itself.  So, behind the scenes, it's still LDAP. You just don't see it in your traffic. And it's relatively  unknown. So, I'm not sure if it's unknown, because as defenders, we're not aware of it and  attackers use it all the time. Or that attackers are not aware of it either and now they're going  to start using it. But it's so useful and I think we should all be aware of that. So, before I move  to the next slide, I just want to say thanks to Falcon Force and MDSec, which were the only  information sources I found that really helped me to understand the AWS concept. So, I put links to  the two articles I used and really explaining this stuff really good. So, who uses AWS? First  of all, I was really surprised to hear that the Active Directory PowerShell module uses AWS by  default. So, every time you perform the get user command, for example, you're not creating LDAP  traffic. You're creating AWS. And there are actually two tools that got released. One of  them released just a few months ago, the sharp AWS that actually took all the known LDAP  enumeration techniques and just implemented them in AWS. So, if you're an attacker that wants to  hide from all the LDAP detections, you can just use these tools and you're finished. So, this is a  screenshot from Wireshark when you try to understand AWS. So, you can see it looks kind of  different. The port is different, as we already said. So, we have the end check done. And when you  actually check it out, you can see this is GSS API. So, actually, we can decrypt it since we already  implemented the unwrap function for GSS API. So, maybe we need to parse it a bit different since  this is not a bind response information, but it's still GSS API. So, the data itself, even though  Wireshark knows how to decrypt it, you can see this is decrypted. Wireshark actually doesn't  decrypt the data itself. I don't know why. Probably just not implemented. But we can implement it. So,  I did it. So, this is a screenshot from the data. So, you can see it starts with 0504. So, if you  listened, you know this is Kerberos encrypted GSS API. So, Wireshark, for some reason, doesn't  understand it. But it doesn't mean we can't. So, I'm not going to speak about the decryption  process since it's quite similar to the other GSS API decryption process. It just requires a  different parsing. But actually, after we decrypt the information, we can see this pure LDAP. Okay.  A bit different looking. But this is an LDAP query. And it has a different structure, but it's still  LDAP and the response will be exactly the same as performing this LDAP query. So, this is quite  interesting. Remember it for later. So, let's talk about difference. So, we have a lot of  enumeration techniques we can talk about. And also, these are quite they're well documented.  A lot of people spoke about BLADA and AD Explorer before. So, I only tried to bring something new  regarding each and every one of them. Since the known queries and stuff like that are already  well documented on the internet. So, we're actually going to start with LDAPNOMNOM. So, I think  LDAPNOMNOM is an amazing name for a tool. And this is also a really cool tool. So, how you can create  this amazing tool and not create a logo for it? You can't. So, I decided to take this task on me  and I asked Dali to create a logo for this tool. So, these are Dali's suggestions. As you can see,  each logo incorporates elements of directory service with a playful touch, suitable for a tech  project. I actually like the left one. I here approach to the author of this tool, you're more  than welcome to use this as logo for your tool. So, what LDAPNOMNOM actually does? So, actually,  it's really cool. It uses something called LDAPING, which is generally used to verify the  liveness of domain controller. But it uses it to enumerate users. So, this tool is actually using  the anonymous logon user. You don't need to be authenticated as a domain user in order to use  this tool. So, what it does, it actually has a really static syntax, which is quite useful when  you try to detect it. So, you can see in the example, but it's actually the same every time.  You have the anti-version. This is static. Then you have the AAC. So, this one represents the  user account control attribute. So, 10 represents normal account. But actually, you can implement  it by yourself and maybe search for different user account control values. Maybe for, I don't know,  different types of account. And then you just apply the user. And if the response starts with  17, it means the user exists. If it starts with 19, it means it doesn't exist. So, this is actually  quite cool. And quite easy to detect. Although, as I think I saw in the GitHub repository, that you  can actually use it with LDAPest as well. And then it's encrypted. So, it's a bit more harder to  detect. Now, for AD Explorer. So, we mainly use it for the snapshot utility. So, you can use it to  take a complete snapshot of your AD environment. It's automatically encrypted LDAP traffic using  NTLM. And it was actually really hard to make it encrypted traffic using Kerberos. You actually  can't make it encrypted traffic using Kerberos with the GUI. You have to use the CLI. So, in my  detection process, I actually checked the NTLM case. And I noticed something quite interesting.  The domain name in the bind process is always null. So, in order to make sure, I used IDA. And  as you can see, there is only one call to the LDAP bind as function. And just before it calls the  function, it stores the ADX register, which used to symbolize the domain name attribute. So,  actually, it will always be null. And just to make sure of it, I downloaded a couple of random  pickups I saw online for people that used AD Explorer and it was null as them as well. So, I'm  like 99% comfortable that the domain name will always be null when you use AD Explorer. So, this  might be a fun way to assign the specific tool. So, if you're suspecting someone use it, maybe you  can use it to make sure. Since if you're monitoring LDAP volume traffic, you probably will notice  someone is reading your active directory data. So, now for Bloodhound, which is an amazing tool.  So, this one is well documented. And we all know if we search online, we can see a lot of  documentation about different Bloodhound queries. Since this one actually enumerates your environment,  so you can probably see it. It actually has some Kerberos encrypted traffic. But not all of  its traffic is encrypted. So, I just added two things here. The first one is the fact that I  noticed it uses the LDAP server show deleted OID control. I'm not sure I tried to search in the  code if it actually purposely used it. And I couldn't find it. But it requires a bit more  research since I didn't finish the searching. So, I'm not sure. But we can use it, again, just to  find a specific tool since I noticed that other tools doesn't use this control. And I actually  added here something that you can maybe use as a cheat sheet when you're trying to understand  LDAP filters. So, this one is quite known filter when it comes to Bloodhound. We can see it a lot.  So, I actually translated it to plain English. So, it can be quite useful because this one is  pretty complex. So, you can actually use it if you try to understand better the LDAP filter  structure. Now, for some random enumeration techniques that are widely used in different  attack tools. So, there is a lot of buzz around certificate templates in the couple of more  last years after the certified article was released. So, we can see a lot of queries that  kind of look similar to that for the PKI certificate template. But actually, this screenshot is from  certify code. And it's quite interesting since each attack tool asks for a bit of different set  of attributes. There are non-attack tools that look exactly the same set. So, you can actually  can use the set of attributes to differentiate between the different attack tools. Which is  quite nice. Because, yes, you can know someone's tried to enumerate your certificate template.  But it can actually be quite nice to know with which tool I tried to do it. Also, I added  one filter that looks for security groups. I like this filter. I don't know why.  And also, the DS internals MSDS link. So, this one, firstly, I saw it in this internals. But  later, I realized a lot of other attack tools used it as well. And there is actually a really  good talk by Michael that I recommend you to watch that explains all the behind the scenes of why  this filter is interesting. So, really good talk. Now, for sharp AWS. So, this is Active  Directory Web Services attack tool. I really liked it. So, you can see here, for example,  I used the command. So, all this command does is actually take the known Kerberos filter. So,  it's users with SPNs and just implemented it in AWS. So, you can see in the decrypted data,  we're looking for user that has wildcard in the service principal name. So, quite easy to detect.  And also, something interesting I noticed, every time sharp AWS performs a query, it also performs  this query, which kind of makes it obvious that this is sharp AWS. I don't know why it does it,  but it does. So, it can be quite easy to detect after you decrypt the data. This one actually  encrypts its data using NTLM and Active Directory PowerShell module encrypts its data using Kerberos.  So, now for the demo of the POC. So, once I release it, obviously, it won't be a video of  my sad Python screen and also hopefully CrowdStrike will help with my horrible UI skills.  But this is what we have for now. So, basically, the tool receives  some pickup. It can be encrypted with NTLM or Kerberos. So, in this example, you will see that  this is a pickup for AD Explorer traffic. So, we can see the bind request. We can see that inside  of it, we have an NTLM authentication. Also, we will be able to see that the domain is null  since it's AD Explorer. And then we can see the data. So, it's encrypted. You can see the  decrypted data tab, which we can obviously not work with this thing. So, I actually provide this  pickup for my tool. I also gave it other pickups that describe different attack tools, the nom nom,  the sharp hound command, some delegation filters and stuff like that. So, I give everything to  the tool. It decrypts everything and also the undecrypted LDAP data. It also documented it.  And it creates a log for you. The log will contain all the decrypted LDAP filters. So,  this is first thing. If you want to just walk through the decrypted pickup and see what's going  on there. And the second thing that the tool will do is to actually search for known attack tools  signatures and create another table for you. Only with the signatures it detected. So, for each  signature, you will see the tool and the technique and we'll see it in a minute. So, this is just the  plain decrypted data. So, you can see it's quite easy to use. Also, I provided we'll see it in a  minute. But I also gave AWS encrypted traffic for that. So, we'll see it in a minute.  So, this is the table that show you, for example, for nom nom, it show you which user it try to  enumerate. So, you can see some filters, some certificate enumerations. You can see some  delegation filters. So, for RBCD. And some more enumeration techniques. And also for Active  Directory Web Services. So, again, I provided a pickup for it which encrypted. This is the  sharp AWS pickup. So, again, decrypt everything. Put it in a nice way inside the log file. And  also shows you the table with the signatures. So, we'll see it in a minute.  Again, horrible UI skills. But you can see sharp AWS. You can see the delegation filter. You can  also see the attributes in this case. So, this is quite nice. Okay. Now, we speak about what we can  do with LDAP for defense. So, actually, the purpose of this slide is not to provide you all the  possible queries you can do with LDAP. But to show you that with just a couple of lines of PowerShell,  you create a pretty good defensive tool. Which obviously won't cover all the requirements for  defending your environment. But there is nothing to lose by doing that. It's free. It's default in  Windows. So, this is actually a really good thing to do. So, I just provided examples here from some  interesting LDAP filters you can do as a defender. So, there are multiple advantages to do this.  First of all, attacker will probably run the same LDAP queries. So, you can see what the attacker  will see when it will enumerate your environment. So, this can be useful so you know your risk spots  and also maybe you can create some honeypots for it. So, it's quite nice. It doesn't require  anything. So, I provided the account filter. So, just users with a service principal name.  The authentication disabled. So, if you have results for this one, you are in a big problem,  you should disable it immediately. The members of groups is one of my favorites.  Since it actually shows you all the members of, for example, here the administrators group.  Even if there are members of a group that inside the administrator group. So, if you perform the  net comment, for example, you won't be able to see the nested group memberships.  And the last one are two different filter queries for GPO. So, you can't actually read the content  of your GPO using LDAP since it's not located inside the entity state. But this is a quite  nice way to just enumerate the passes of your GPO and the names and the priority and a bit more  information about them. So, it's quite a good start to make an automation that works with your  whole policies and then maybe go to the file itself and query it. And our last topic is ETW.  So, what we can do with ETW, we have two options. The first one is on client. So,  we have the Microsoft Windows LDAP client ETW provider. So, to understand this one,  I use ETW Inspector, which is a really nice new tool and also Microsoft Message Analyzer.  So, there is a problem with this provider since in the documentation, it tells you it actually  documents multiple LDAP events. For example, the bind event. But when you actually use it,  you see for some reason or maybe in my environment, it only documented event ID number 30,  which is the most important event. So, at least that. This is the search event. So,  you can see the search filter here. So, and the attributes. So, there is quite a big advantage  using this. You need to enable it and this is on the clients. So, you have one disadvantage,  which we spoke about it before. You can't see ADWS traffic or filters using this one since  it's not LDAP. But for that, we have another provider. So, this one located on the domain  controller and this is the Microsoft Windows Active Directory domain service ETW provider.  So, to enable this one or to make sure this one documents all the LDAP filters, you need to mess  with the registry a bit. So, I put all the things you need to change on the registry in order to  enable this. And this is actually very, very useful. Since it's on the DC, we can also document  the ADWS events. So, it's quite cool. For example, this screenshot, it's from the get user command.  So, this is Active Directory web services and you can see the IPv6 for local IP because Active  Directory web services runs locally LDAP queries on the domain controller. So, you can see the  filter and the attributes and you can also see the user, which is very cool. So, this is, I think,  the best way to do it. But obviously, it's a bit problematic since it creates tons of events  on your domain controller. So, if you have a problem with storing these events, it's not that  easy anymore. So, just to conclude everything we talked about. So, LDAP is very much alive.  It's widely used. If Active Directory is still relevant, then LDAP is definitely still relevant.  Decrypting LDAP traffic is very important because otherwise you're probably blind for most of the  attack tools and most of the LDAP traffic in your environment. Also, monitoring Active Directory web  services traffic is important. I don't know why or if attackers use it or not, but you can actually  avoid every big company security product detection if you just use Active Directory web services.  And you can easily discover misconfiguration in your domain using LDAP for free. It's default.  I really don't see any reason not to do it. And you can, and I think the word easily here, it's  maybe not very correct since it's quite heavy because it creates a lot of logs. But it's easily  from the fact that you only need to enable a couple of registry values to monitor LDAP and  Active Directory web services traffic using ETW. Oh, that was it. Thank you.  Thank you very much for your great talk. Thank you.  Hi, thanks. First of all, I didn't think I could learn anything new and interesting about LDAP and  I was very wrong. So thank you. Thank you for the talk. On one of the slides, you mentioned that  Active Directory web services had much better performance than LDAP. And I also read that in  documentation for Pincastle, where you have an option to either do the queries through ADWS or  through LDAP. But I never understood why. Maybe, do you understand why it adds performance? Because  I would expect decreased performance because of the proxying through web services. Yeah, I  actually expected that as well. To be honest, I didn't expect that at all. I didn't expect  Yeah, I actually expected that as well. To be honest, this time, and maybe I was wrong, I just  believe Microsoft documentation that says this is a much faster option. But now that you ask it,  maybe I shouldn't believe it. So that's a great question. To be honest, I also expected it would  be harder to do it since you need to unwrap and run it. So I don't know. It's actually a really  good question. Yeah, thank you. Yeah, thanks for this very interesting talk. You said that ADWS  proxies the queries to the actual LDAP service on the domain controller. I expect the Kerberos  GSS encryption to be terminated at ADWS. So how does authentication from ADWS to the backend  service work? Have you looked at this? Can you say something about it? So I'm not sure I understood  the question. It's not proxying the traffic. It's just the traffic from the endpoint to the  domain controller, but it's not LDAP. But when it gets to the domain controller, the domain  controller actually knows how to unwrap the solve message and runs the LDAP on itself. But it's not,  there isn't something like in between them that proxies this traffic. This is one.  The LDAP service on the domain controller, he needs to authenticate the user who's querying.  And I expect this to be done with the user that authenticated to ADWS.  I actually have no idea.  Active directory domain control in delegation. So I would expect ADWS to do unconstrained  delegation for the user and to delegate them to LDAP. I'm not 100% sure. I need to check that.  But I would definitely expect. No, it makes sense. It's enabled by default on the domain  controller. So yeah, it makes sense. No, Andrea.  First of all, great talk.  I have a very, very easy question. So don't worry about ADWS. At the end, you told us that  it's a simple LDAP query performed locally on the domain controller. So my question is,  is there any chance a part ADWS to intercept huge and a large amount of queries by simply  logging the LDAP queries on the domain controllers? Because normally you intercept  SharPound or whatever tool for gathering information because you have normally a lot  of queries provided, which comes from the same workstation and so on. So you can trigger some  filters. So the question is, is this possible to translate it directly on the domain controller  if the source is ADWS or something like that?  I believe so. I mean, it makes sense. I think so, yeah. It might be interesting to do.  Also something I forgot to mention. So you can also have LDAP encrypted using RC4 Kerberos.  So I don't support this yet, but I'm planning to. So this is quite an important side note.  So I have a question too. If you want to decrypt the traffic, you need the KerbTG?  Or the DC hashed password or the user hashed password?  Yes, of course. I would recommend to perform this in an organization because  at the KerbTG Tiki, you are able to create golden tickets. You have the full power. So  this means that such devices need very special treatment.  Yep, definitely. So maybe it's easy to say when coming from organizations such as CrowdStrike,  but yes, obviously you need to retrieve the hashed password and you need to store it somewhere in a  very safe way. But I think all of the defense tools these days have very strong permissions.  Most of them also use the KerbTG hash for other stuff. So yeah, you need to store it in a safe  way. But you also remind me another thing I wanted to say. So the GSS API encrypted traffic,  it's not only for LDAP. For example, RPC can be encrypted using GSS API as well. So the code for  doing this, it's actually the same code except retrieving the key is a bit different since in  RPC, for example, we don't have bind response. But you can actually use GSS API decryption process  for other protocols as well. So it's quite important. So yeah, just reminded.  In addition to what Fridvard asked, if you retrieve the KerbTG hash, would you recommend  as soon as you've done that and you've done your exercise to then reset that password?  Once, obviously, or twice within a specific time frame. So it depends. If you want to continuously  decrypt LDAP traffic in your environment, you can do it because then it will keep changing.  But if it's for like a specific thing, I actually don't know because I don't have a lot of  experience with real world environments. I think in large environments, changing the  KerbTG password can cause, you may probably say more than I do, a lot of issues. So I think it  might be a problem because things will stop work. But obviously, there is a risk with retrieving  the hash of the KerbTG account. And obviously, you need to either store it or change it.  Depends on what you're trying to do with the hash password.  If you want to continuously decrypt the data, you can't change the password.  Any more questions?  No?  Thank you.  Thank you.