{
  "webpage_url": "https://www.youtube.com/watch?v=F92L4ibglgQ",
  "title": "TROOPERS24: Say Hello to your new cache flow!",
  "description": "Talk by Geoffrey Bertoli, R\u00e9mi Jullian, Th\u00e9o Gordyjan (@___t0___) - June 26th, 2024 at TROOPERS24 IT security conference in Heidelberg, Germany hosted by @ERNW_ITSec\n\n#TROOPERS24 #ITsecurity \nhttps://troopers.de/troopers24/talks/a8zf7h/\n\nMore impressions:\nhttps://twitter.com/WEareTROOPERS\nhttps://twitter.com/ERNW_ITSec\nhttps://infosec.exchange/@WEareTROOPERS\nhttps://infosec.exchange/@ERNW https://ernw.de",
  "channel_url": "https://www.youtube.com/channel/UCPY5aUREHmbDO4PtR6AYLfQ",
  "duration": 2731,
  "channel": "TROOPERS IT Security Conference",
  "uploader": "TROOPERS IT Security Conference",
  "upload_date": "20240902"
}

This text was transcribed using whisper model: large-v2

 So, thank you very much for coming to our talk.  So we will be talking, as I said, about cache information when you are using Windows Hello  for Business and Tri-ID.  So first of all, who are we?  So we are three security researchers from SYNACTIV.  So Theo and I are from the Penetration Test Team, and Remy is from the Reverse Engineering  Team.  So just a quick word about SYNACTIV, I won't be talking too long about that.  So we are an offensive security company based in France.  We are almost 200 security experts focusing on penetration tests, red teaming, reverse  engineering, vulnerability research, development, incident response, everything that a security  company can do.  And we also have a conference in Paris, Execon, so if you do nothing in October.  Just a quick agenda, so we'll be just focusing on how we came up with this research, have  a lot of definition about Windows Hello for Business and Tri-ID.  We will be talking about the cache data format, what is possible to do for offline authentication,  a quick demo of our tool sets, and a word on DPAPI because it's quite important on the  new cache information.  So to start, all this research started during a penetration test.  We had to perform an audit on a workstation.  The client wanted to know what's possible to do if we stole a laptop from us.  So the workstation was encrypted, BitLocker and TPM, but no pin code was required to boot.  So we just sniffed the BitLocker key through the bus, decrypted the disk, and we saw that  the computer was in a fully Tri-ID environment with Windows Hello for Business and there  was no MSCache store on the computer.  So we know that it was possible to access to the domain even when we weren't connected  to the internet, so we know that there is some cache data somewhere.  So we decided to have a look at it.  So just a few definitions.  What is Windows Hello for Business?  It's different from Windows Hello.  Windows Hello is just a way to authenticate on your computer.  It's pretty straightforward, using a pin or biometric gesture or everything to log  in on your computer, on your personal computer.  And it's basically just a password when you are using Windows Hello.  It's just an easier way to connect to your laptop and not to remember a password.  So you can use a special thing, faces, fingerprints, pin, you can use a physical security key.  And basically, when you are using this, you can retrieve the password of the user, since  if you are using only Windows Hello, the SAM hive is no longer used, but due to DPAPI,  you will have to have the password of the user somewhere.  In fact, you only have to have the SHA-1 of the password, but Microsoft stored the Cleartext  password somewhere.  So this research was already done by Thijs de Net, and that's a lot of crypto implied.  I won't be going too much into detail here, because we are going to do the same for Windows  Hello for Business.  So if you want to have a look, just go there.  What you have to remember, if you have a pin, you can, at the end, decrypt the password  of the users.  So we found this research, and we said, OK, when Windows Hello for Business, can we have  access to the Cleartext password somewhere?  That was really nice to be sure, but Windows Hello for Business is not the same as Windows  Hello.  It's not password-based, it's some kind of asymmetrical authentication.  So the pin that you use will be used as the public and private key.  So when you are joining a domain, you have to reboot the computer, and then you will  be able to join Windows Hello for Business.  You create a pin, and the pin basically creates you a private key and a public key, and the  pin is an entropy to protect the private key.  So it won't be possible to retrieve the password that way, but we found that if you are using  a TPM, the pin is used to access the private key, and the private key is stored on the  TPM.  But if you're not using a TPM, the same process applies, but everything is lined on the local  drive.  So it could be interesting, because we know that every workstation now uses a TPM, but  we know that a lot of servers, a lot of virtual computers, do not use TPMs.  So it could be interesting for at least a few years, again, before everything is virtualized.  So we decided to have a look.  Just to remember, how does it work when you have an authentication with Windows Hello  for Business and you have access online.  So Winlogon just asks you for the credentials, so you're using your pin, your faces, everything.  You just send it to the Cloud App Provider, and the Cloud App Provider just requests a  nonce to Entry ID, and this nonce is signed with the private key that was used by Windows  Hello for Business.  So once you sign the nonce, you send it back to Entry ID, Entry ID validates that you have  access to the private key.  If you have access to the private key, it means that you have the pin, they say, okay,  validate it, and it sends you a PRT, which is equivalent to your access to the Entry  ID tenant.  With the PRT, you decrypt the session key, you import the session key in the TPM, your  authentication is successful.  There was a lot of definition, I think most of you are pretty familiar with it, but I  will go a little bit with them.  What's interesting is that if you have access to the PRT, you basically have access to the  Entry ID of the users.  It can be seen at the TGT on Microsoft Active Directory.  What you have to understand is if you have access to the PRT, you will be able to do  as much as everything you can with it, since it's valid for 14 days.  DJ here did a lot of research on that, and you can use that.  So it's pretty nice to have access to the PRT.  Another part of the process is the Cloud Authentication Provider, the Cloud Authentication Provider.  It's basically just the provider that is using LSAS to authenticate you to the Entry ID.  It's basically all the functions that are in CloudAPI.dll.  It's live in lsas.exe process memory, and it uses an authenticated you to the Entry ID.  So it implements the SAKE package function table structures, as every credential provider,  and the function responsible for the authentication is LSAAPLogonUserX2.  It's not documented by Microsoft, as a lot of things are done by Microsoft, but you can  find a lot of documentation in LSA with ProWikis, since it's just a credential provider.  Yeah, sorry, I was just looking at the clock.  So what if Entry ID cannot be reached?  Then the user is still able to perform local authentication, and it's based on the cache file.  So when you are using the LSAAPLogonUserX2, it's executed with the cache interactive  instead of the remote interactive.  So we know that there is a cache information, and as you can see, the server is supposed  to send you the PRT, but you don't have access to the server, so the cache information must  contain your PRT.  So it could be really interesting for us.  Thank you, Geoffrey.  So now let's talk about the cached data file.  So we'll talk about where it's located on the file system, what is the internal format.  So the cached data file is located under the system32 directory, so you will have a bunch  of different folders.  Then you will have a cloud.apcache and azure.id directory, and then you will have a unique  h.  So this h will change for each entry user who has already logged on on the computer,  and then you will find a cache folder, and finally the cached data file.  So it's the file that we are interested in, and the file that we are going to talk about.  So its admin privileges are needed to read it, because it contains encrypted secrets,  as well as, as we can see, we can use this file to do brute-force attacks.  So as I just told you, there is one cache folder per entry user.  In order to match a cache folder with an entry user, we can use a registry.  So under the h.qml hive, we can find a logon cache folder, then we'll have a GUID, and  then a name trace ID entry, and basically within this entry, we'll find here each h  for each unique user, and then we'll have different entries, like for each user, we  can find the SID of the user, its sun name, its display name, and so on.  So that's all for the file location.  So why is it an interesting file?  Because we can use this file to retrieve the password and the PIN.  So this will involve doing a brute-force attack.  So if we would like to brute-force the password, there is no limitation.  However, if we want to brute-force the PIN, if there is a TPM on the computer, we will  be limited by the TPM.  And if we manage to get the PIN or the password, we can use it to obtain the PRT as well as  the user GPAPI query key.  So it's pretty interesting.  So now let's talk a little bit about the previous work that has been made related to the cached  data file.  So there is one PowerShell script, prtutil.ps.  So this script has been released on the AAD internal repository, and basically it allows  to decrypt a PRT file when a password is used.  However, it does not allow to decrypt PRT if a PIN was used for the authentication.  Also on the GPAPILabNG repository, there is a script which was released.  It's called ngc-cryptodeck.py.  And this script allows to perform some Windows Hello NGC PIN decryption.  So as we will see later, there is a private key involved.  And when we use the PIN, we need to decrypt the private key.  So within this script, there is a lot of stuff that we used for our research.  So what was our contribution?  So we worked mainly on the cached PRT file decryption when a PIN was used.  So we released a Python script which can be used to brute force the PIN or the password.  And we also worked for increasing the comprehension of the cached data file format.  So in order to do that, we had to do some reverse engineering.  So we had to target CloudAPI.dll.  So we looked at the authentication process as well as all the interaction with the cached file.  So to do that, we had to do some static analysis as well as some dynamic analysis.  So for the static analysis, we used IDA on the X-Ray decompiler.  So it's quite usual for reverse engineers.  Something pretty nice is that the PDB file was available for CloudAPI.dll.  So for those who are not really familiar with PDB file, it's simply some debugging files  that will include some, for instance, the name of the functions as well as the name  of the global variables.  Actually it's quite common for Microsoft to release a PDB file for the built-in DLL.  When we want to do some reverse engineering, having the name of the function as well as  the name of the global variables, it's pretty nice.  In addition, we also did some dynamic analysis.  So to do that, we created a TTD trace.  So TTD means Time Travel Debugging.  So we created a trace for the LSASS process using WinDbg.  And it's really cool because the same trace can be shared among different users.  So for instance, my colleague Tiol created the trace and he sent it to me for analysis.  And even if I didn't add the proper Entry ID environment, I was still able to work on  this trace.  And also, each DLL which is inside the trace can be easily extracted for static analysis.  So it's pretty cool.  So now let's talk about the cached data file format that we managed to understand.  So actually it's quite a simple file format.  So it starts with a header.  We'll find inside the version number.  We'll have a GUID as well.  We'll have an integrity checksum for the rest of the file.  And we'll have an integer which defines the number of nodes.  And then we'll have an array of cached node header.  So basically, a cached node header will be used to describe a node.  So it will define the type of the node.  For instance, is it a node related to pin authentication or is it a node related to  password authentication?  And then we'll have the size of the crypto blob as well as the size of the encrypted blob.  So the crypto blob is the blob in green on the schema.  So basically the crypto blob is used to check for the user credentials.  And the encrypted blob is the blob which contains the encrypted DPAPI equate key as  well as the PRT file.  So both the DPAPI equate key and the PRT are encrypted in the same encryption operation.  So let's say, for example, that you can log with pin and password.  Then you will have two nodes in your cached data file.  So we only analyze pin and password based authentication, but we know that you can use  other means such as a smart card, for instance.  Okay, so a few words about where the parsing of the file occurs.  So the function deserializeCloudAPcache is the one who is doing the parsing of the file.  So it will populate a structure of type CloudAPcache.  And within this structure, we'll find a pointer to an error structure.  And the type of this error structure is a tagged cached node identifier.  So it will contain as a node type, as I just told you, there are different types.  So one is for password based authentication and pin 3 and 5 is for a fin-based authentication.  And then we'll have two pointers, one to the crypto blob and one to the encrypted blob.  So the format of the crypto blob will change according to the type of the node.  Let's take a look at what the crypto blob looks like when we use a pin-based authentication.  So as Wilteo explained to you in a few slides, when you use pin-based authentication, it  involves asymmetric cryptography.  So you have a private key that needs to be decrypted by using the pin.  So what you will find in the cached data file is the public key, which is associated with  this private key.  So the public key will be stored in a decrypt RSA key blob.  So this is a publicly documented structure by Microsoft.  And then you will find different secrets.  So you will find an AUS key, which is encrypted using the RSA private key.  Then you will find a second AUS key, but this one is encrypted with AUS.  And basically, once this key is decrypted, it can be used to decrypt this one.  And this one can be used to decrypt, finally, the PRT file, as well as the DPAPI query key.  So we will talk a bit about that in a few slides.  So as I just told you, the format of the crypto blob changes according to the authentication  means.  So this is what it looks like when you use a password-based authentication.  So it's simply a blob of 0x30 bytes, and it's the result of an AES encryption using  as an input the derivation of the password using pbkeydf2, and using as a key the derivation  of the query key also using pbkeydf2.  And it uses a null IV for the encryption operation.  So if you manage to compute the crypto blob, this means that you managed to retrieve the  input password.  That's why you can do some brute force to retrieve the input password.  A few words about the DPAPI query key.  So it's stored in a structure named a credential key.  It's a blob of 0x60 bytes, so it contains a GUID, as well as the key, which is stored  in a 0x40 byte buffer.  And this DPAPI query key will be used to derive another key, like the latest master key.  And to do that, we'll use the HMAKE function, and as an input, we will use the SHA1 of the  query key, and we'll also use the user's ID.  So as I just told you, it's stored encrypted in the cached data file.  Something interesting to note is that when it's in memory, it's encrypted by the LSA  protect memory callback.  And so in memory, it's encrypted using a symmetric cryptography, and the keys are generated by  the LSA initialized protect memory function.  So basically, in memory, the key will be stored encrypted, and if you reboot, you won't have  the same key in memory.  So now I will let my colleague talk to you about the cached data file usage for offline  authentication.  Okay.  So now let's dig into the process involved for offline authentication.  We'll start by explaining how it works when using a password.  So Microsoft wants to get rid of it, as it is the less secure method indeed.  When the password is used, the PRT is encrypted with an ES key derived from the password,  and as Remy already said, by analyzing the function derived key from secret function  from the Cloud API DLL, it just takes the password as an argument to create a key, and  this key is created using pvktf2.hmac, without assault, and it's iterating over it 10,000  times as for dpAPI encryption.  The resulting key is used in an AES-CBC decryption, on the cached data encrypted blob.  So now we'll dig into pin-based authentication, and before that, we need to understand what  is NGC.  NGC or next-gen cryptography, or dpAPI NG, are the same terms for the same thing.  It provides a set of APIs that can be used to easily encrypt and decrypt content to authorization  principles.  It works with providers, protectors, and items, and about the provider, it's a component responsible  for managing cryptographic operations and interacting with the NGC framework.  You have two different types of providers.  You have the key storage provider, which will be of interest for us for the following slides,  and the cryptographic service provider.  And about the protector, it's just the method or technique used to encrypt and protect sensitive  data.  So the NGC folder is located here.  You need system privileges to access it.  And we see that there are some metadata inside to retrieve, and we can retrieve it because  it's not encrypted.  There is just one file encrypted inside this folder.  So here you have an example of the tree command if you use it on the NGC folder.  So we have a GUID, and a protector, and some .dat files.  So inside the NGC folder, you'll find the NGC GUID folder, which contains some .dat  file.  And for example, inside the 1.dat file, you'll find the user SID.  And in 7.dat, you will find the main provider.  So here is the output of a script using DPAPILabNG, and it just parses all the different .dat  files to retrieve this GUID, the user SID, and other stuff.  About the provider, so here we'll talk about the key storage provider.  And you'll find, if you use the TPM, the Microsoft Platform Crypto Provider.  So here the protector is stored in the TPM chip.  And without any TPM, you will find the Microsoft Software Key Storage Provider.  And here, the protector is stored locally.  That's why we will try to brute force some things here.  You can find also other providers, like SmartCard Key Storage Provider, but we didn't dig into  this provider.  Again, it's the output of some script from the DPAPILabNG repository.  And as you can see here, we have a TPM, and here we don't have any TPM.  About the protectors, we will be interested in the 15.dat encrypted data.  And you can find also other stuff inside, like the name of the protector, the key GUID  of the protector.  This key GUID will be missing if it's stored on the TPM.  And finally, all the different items, and you'll find the name of the item and the provider  name.  So for now, we know that Watch is NGC, and we see how the PIN interacts with it.  I'm sorry the boring part is not finished yet, as we will have to talk about cryptography  again.  But remember that our goal here is to decrypt the cache data file by finding the PIN.  So without any TPM, it's a quite complex process.  It first starts with a first RSA private key, which needs to be constructed from an encrypted  blob, and this blob is called a bcrypt RSA private key blob.  And thanks to this first RSA private key, we'll be able to decrypt the 15.dat file to  obtain a decrypt PIN.  And this decrypt PIN will be used to construct a second RSA private key from another cryptobob.  All the different cryptobobs are stored inside this folder, and again, even if there is some  encrypted data inside, we'll be able to find clear text metadata inside it.  So as you can see here, we can find the GUID at the beginning.  So the first blob linked with NGC is encrypted using DPAPI mechanism after multiple steps,  which involves the system master keys, the GUID of the protector, system and security  hives, the PIN, and some static entropy strings.  And after being able to decrypt this bcrypt RSA private key blob, we will be able to construct  the first RSA private key, because inside it contains the modulus, the exponent, prime  1 and 2.  If you are interested in this process, again, on the blog of TJonet, you will find all the  information about the static entropy strings, et cetera, et cetera.  Then thanks to this first private key, we are able to decrypt the 15.dat file, which  contains three different PINs of 32 bits, and the decrypt PIN, which will be interested  for us, is the second one.  And we'll use the exact same method to decrypt, to obtain a second RSA private key by using  a first crypto blob key, using the name of the item for Windows Zero for Business, which  is this one.  And we will be replacing the PIN with the decrypt PIN.  So if we try to sum up all the things that I said just before, we want to decrypt a first  crypto blob here.  To decrypt this crypto blob, we'll need the PIN, the system and security hives, the DPAPI  master key, and thanks to this blob, we will be able to construct a first RSA private key.  Thanks to this first RSA private key, we'll be able to obtain the decrypt PIN.  And again, for the same process, we'll be using the decrypt PIN and another crypto blob  to obtain all the information you need to construct a second RSA private key.  Okay, thank you, Theo.  So now that we have the second private key, let's try to see how it's used for decrypting  the PRT file as well as the DPAPI code key when using a PIN.  So we will use this second RSA private key, and we will see that it's used to encrypt  an iOS key using RSA.  So basically, the result of the RSA encryption is an encrypted iOS key, so it's stored as  a blob of 0x100 bytes.  Why?  Because this is simply the size of a big integer of 2048 bits, which is the result of the RSA  encryption using PKCS1.5 padding, because simply when you want to do an encrypt operation  with RSA, you need to pad the input with some stuff so that it matches the size of the key.  Well, let's go back to our cache data file again.  So this is the crypto blob when using a PIN.  We saw earlier that here we have the public key which matches the RSA private key, and  this is the second RSA private key that Theo told us just before.  So first, we will do an RSA decrypt operation.  We will take an encrypted iOS key, which is encrypted using RSA, we will decrypt it, and  we will get a first iOS key.  Then we will use this iOS key to decrypt a second iOS key.  So to do that, we'll do an iOS CBC decrypt, and we will use a custom IV, which is stored  in the cache data file, and the input of this operation is an encrypted iOS key, and it's  also stored in the cache data file.  So this is this operation.  So here we have the iOS key, which is decrypted.  It was this one before, so now it's decrypted here, so we use it as a key for the iOS decrypt  operation.  Here we have the input, which is an encrypted iOS key.  For this iOS decrypt operation, we'll use an IV, which is also stored in the cache data  file, and we will get a second iOS key, which is now decrypted.  So it's almost finished.  Now we have this final iOS key, and we can use it to decrypt the PRT file, as well as  the DPA PR equate key, using also an iOS CBC operation decrypt with another custom IV,  which is in the cache data file.  So there it is.  We have our final iOS key.  We use it in an iOS CBC decrypt operation.  We'll use another custom IV, which is stored in the cache data file.  We'll give as an input to the decrypt operation the encrypted API PR equate key, as well as  the encrypted PRT blob, and finally we can get the DPA PR equate key, as well as the  PRT file.  So this was the part related to PRT and DPA PR equate key decryption using a PIN when  there is no TPM.  So now let's briefly talk about when there is a TPM.  So using a TPM, the format of the cache data cryptoblob actually is the same.  The main difference will reside in the RSA private key, the one that Theo told you about.  So this time, with a TPM, the private key will be stored directly on the TPM, and the  PIN will be used to access it.  So brute force will be really hard.  It will be limited because of the TPM.  So nowadays, there are two main implementations of TPM, TPM 1.2, and with TPM 1.2, the connection  is implemented by the manufacturer, so all chips are not equal regarding the mechanism  in place.  But if there is a TPM 2.0, Windows is able to configure it to lock after 32 authorization  failures, and it will forget one authorization failure after 10 minutes.  So if you have a TPM, it will be way harder to brute force the PIN, and then to get the  DPA PR equate key, as well as the PRT file.  Last word about the TPM.  So on the Windows system, you can use the get-tpm snippet.  It will tell you if there is a TPM, if it's enabled, which manufacturer is it, and so  on, is it activated.  You can also use the TPM tool with the get-device information, which will give you the version  of the TPM.  So now let's have a quick demo of the toolset that we released in order to decrypt the PRT  as well as the DPA PR equate key.  So I just created a quick batch script to extract all the information needed.  So as you can see here, we extract the cache data file here, then all the NGC folders,  the different system and security hives, the crypto keys folder, and also the master keys.  I run this script as a system to be able to extract the content of the NGC folder.  And then you can see that all the data are here.  So I will just extract all the data on my host.  And then I just copy the folder here.  So here it's done.  So I just start by dumping the cache data format file.  I think I have one folder.  I forgot to unzip the folder, excuse me.  In progress.  Again.  So here, as you can see, demo effect.  We have two different nodes, the one for the password here and the one for the pin here.  So we know that there is no TPM, so we'll be able to brute force the password and the  pin.  So we just start by brute forcing the password.  I think it will be okay now.  So I just specified to the script that I want to brute force the password, the cache data  file, and then a dictionary containing the passwords.  And here, you can see that here we were able to brute force the password.  So we are able to decrypt the PRT and all its information.  And we are also able to obtain the derived trick.  And now, for the pin, it's a bit more complicated.  We have to specify all these arguments, the cache data file, a dictionary which contains  all the pins, the NGC folder, the master keys, the system and security hives, and  the crypto keys.  It starts by printing all the different information about the NGC folder, the different providers,  and the items.  So as we can see here, this item is related to Windows Zero for Business, and it tries  all the different pins here, and then we can see that we were able to find a good pin,  and we find the PRT here, and finally, the crack.  The script is available on our GitHub, and of course, PRs are welcome.  Just a little word to finish regarding dpAPI.  First of all, we were just trying to gain access to the PRT because that's what we wanted  to do, and access EntroiD.  Nevertheless, by understanding the format of the cache data file, we found the dpAPI  crate key.  So what is it?  Just a quick word, I won't give you a lecture about dpAPI, but dpAPI is just an API of Windows  in order to protect data, and protect it by encrypting it.  The main example that we often use is the Google Chrome password database.  So it relies on the master key.  The master key is not a key per se, it's just a strong secret, and this strong secret is  then used to generate a session key, which is the real key used for the encryption.  So the master key was derived from the password users, so for local users, it was derived  from the SHA-1 of the password.  That's why when we talk about Windows Hello, not the Windows Hello for Business, we saw  that we needed the password of the user.  In fact, we only needed the SHA-1 of the users, but who knows.  Regarding the domain users, it's just derived from the MTH of the users, and for the system  environments, they have their own master keys, it's lying on the registries, it's often used  for SSID, and it's used for what we saw earlier.  So what is this DPAPI cred key, because we never saw it in there.  Actually, Microsoft wanted to get rid of passwords.  They implemented Windows Hello for Business in order to have asymmetrical authentication.  So the DPI master key, the DPI cred key, does not rely on passwords, it's just something  that is stored on your cache data file, and can be decrypted with the PIN.  So no, the master key is derived from the cred key by using an HMAC SHA-1 of the cred  key and the user SID.  So I think there is a lot to do now with this cred key, and it could be interesting to know  where that could lead us.  We would like to thank our colleague, Lexa, we've done a pull request on the tool in order  to integrate this new master key type.  So in conclusion, what is possible to do with a cache data file?  So if the users already used the password on this computer on a full Entry ID environment  within the last 14 days, you will be able to brute force the cache data.  Of course, it's a PBKTF2 10,000 round with the IIS, and we still need to implement it  in John the Reaper, but it's a work in progress.  So you will be able to do an offline brute force.  And after that, you could use the PRT to access the Entry ID, with lots of tools to do that.  Broad Recon is one of them.  And if you are using a PIN, if your TPM is enabled, sorry to talk to you about it, but  for now on, we don't see anything that you can do.  We hope someday.  But if TPM is not enabled for, I don't know, computers that are not TPM, of course, virtual  computers, you will be able to retry the PRT, you will be able to retry the DPIPA cred key.  And then after that, the same thing applies, since you have the PRT file.  So in conclusion, we still have more research to do to understand how it works when you  are using other mean of authentication.  For instance, smart card, if there is another node in the cache data file, do we need to  do some crypto crazy like that again?  We know that the cache data is really a goldmine, there is a lot of information in there.  You will find stuff such as DPIPI, PRT and everything that you want.  The bad news here is that TMP enhance drastically the security for credential and asymmetrical  authentication with the TPM will certainly lead to the end of cache data being a goldmine  for penetration tests.  We would like to thank a lot of people, because a lot of work has been done on everything  like that.  So there is a few in the room here, we had a lot of reference for our talk.  I will let you have a look at our article on the blog post of Synactive if you want  to.  And we've been a bit quick, but if you have any questions, please.  Thanks, first of all, congrats to the mind-blowing research, like, great.  I always wanted to meet the person at Microsoft who designed DPAPI and all that crazy shit  which you reverse-engineered.  But now back to my question regarding the DPAPI CRET key, have you played a little bit  more with it?  I did some experiments of my own with it, and I came to a conclusion that it is device-bound,  so each device gets its own CRET key, and it also depends on time.  So if you ask EntroID in a month or in two months, you get a different CRET key on the  same computer.  And there is a key in EntroID, in an attribute which used to be a searchable device key attribute,  but Microsoft moved this data to a different EntroID attribute.  But it used to be there, readable by all users, no longer the case.  But my question actually is, have you figured out how Microsoft derives the CRET key from  the data stored in EntroID?  Yeah, thanks.  So actually, no, I'm sorry.  It was really just the burner thing, because we were looking at the PRT and we found the  CRET key here, so we're just trying to understand a little bit what it's used for and why is  it here.  So no, we didn't have a look further, but yeah, that could be really interesting research  to do, yeah.  Thank you.  Thank you very much.  Thank you.