{
  "webpage_url": "https://www.youtube.com/watch?v=JVWFfSmIlRY",
  "title": "TROOPERS24: V2GEvil: Ghost in the wires",
  "description": "Talk by Thomas Sermpinis (a.k.a. Cr0wTom) and Pavel Khunt - June 27th, 2024 at TROOPERS24 IT security conference in Heidelberg, Germany hosted by @ERNW_ITSec\n\n#TROOPERS24 #ITsecurity \nhttps://troopers.de/troopers24/talks/lx7rvf/\n\nMore impressions:\n  / wearetroopers  \n  / ernw_itsec  \nhttps://infosec.exchange/@WEareTROOPERS\nhttps://infosec.exchange/@ERNW https://ernw.de",
  "channel_url": "https://www.youtube.com/channel/UCPY5aUREHmbDO4PtR6AYLfQ",
  "duration": 3496,
  "channel": "TROOPERS IT Security Conference",
  "uploader": "TROOPERS IT Security Conference",
  "upload_date": "20240909"
}

This text was transcribed using whisper model: large-v2

 Hello, everyone. Thank you for joining us today. And let's do this. We are Pavel and  Thomas. And our topic is V2G, evil goats in the wires. I, with Thomas, do this for  my master thesis. And I successfully finished it earlier this year. So, thanks to Thomas.  And we will present our tool today and the whole journey, which was for all of this.  And my name, as I said, is Pavel Kunt. I am currently working as the cybersecurity researcher  in Auxilium Pentest Labs. And my colleague is Thomas Srempenes.  I'm Thomas Srempenes. Many of you might know me as ProTom. I'm the technical director of  Auxilium Pentest Labs by day and security researchers by night. I was the supervisor  of the thesis for the Czech Technical University that we did with Pavel. And, yeah, as discussed,  we successfully finished it. And we are keen to, like, we really want to share with you  this information today. And, yeah, basically, to start off, I want to give you an understanding  of what we'll get out of this talk. And basically, our main goal is to analyze the state of  cybersecurity in the automotive industry and get an in-depth look in the EV architecture  specifically. And this undeniably emerging attack vector that we see outside in the streets.  We want to explore and understand the communication protocols used in EV charging today and introduce  you to the security tool that we built, which is called V2G, the result of the thesis we  did, and create a reference point for EV security research and evaluation, something  that we feel that our industry is lacking, alongside other vectors in the automotive  security landscape, of course. So, let's start by getting introduced to vehicle cybersecurity  and understand the current state of this. And it goes without question that the automotive  industry cannot be considered new, of course. We're basically talking about 100-plus-year-old  mechanical engineering industries. And hopefully, you see where this is going. The constant  need for connectivity and technological aspects of this pushed those companies to make restructuring  and start implementing technologies that didn't have the know-how or the capacity to do so,  which is good for us. We have work in the end, but really bad for the security and safety  of the affected vehicles. On the other hand, you have all these startups that started as  technology companies first, which have a way better security posture and culture. But the  industry as a whole struggles for the last decade. And to be honest, I cannot see a clear  light in the end of this tunnel. And isolating the part we will focus on this talk, we have  the emerging industry of electric and hybrid vehicles, mainly developed to decentralize  pollution and make better use of clean energy solutions. And additionally, you have several  advantages in comparison to internal combustion engine vehicles, as an example of the heavy  gains in efficiency and speed and others. And while early models used basic charging,  in the last decade, charging standards are applied and enforced in many ways, which led to the  standardization of the ports, protocols and underlying data in a wide range of applicability  for different continents and standards. This, of course, in addition to the digital communication  needed during charging, expanded the attack surface of the vehicles as we knew them before  and created new attack vectors that we can start playing with. What I'm saying is not something new,  of course, or groundbreaking by any means, but the state of EV charging security is barely  touched topic by researchers. During our work, we felt that it definitely needed a bit more love.  And here we have a really simple representation of a modern vehicle, which normally includes a bunch  of interconnected ECUs, electronic control units, as we call it in our industry, responsible for  different functionality inside the vehicle. This can be from simple headlight ECUs to huge DC-DC  converters. What we see, though, is that while the vehicle till now was reasonably isolated by the  outside world, now we have a newly externally accessible port, which connects to the charging  stations. This leaves a big room for error, and if not properly implemented and designed, several  unexpected instances can occur. And here we have a more realistic representation of a modern vehicle,  as it needs to be said that it's not only the charging port, but other interfaces are introduced  that can expose our vehicle and need special consideration on the architectural and design  parts of developing a vehicle. While this might not seem as important, there are numerous instances  that architecture played a big part of how severe our findings are during a pen test or research  projects, and how in the end can or cannot affect the safety of the driver, the passengers, and the  pedestrians. And as we keep diving deeper and deeper, let's discuss a bit about charging in terms of  vehicles and the automotive industry. And first of all, there are several charging methods, including  conductive, wireless, and some exotic ones that are only seen in some manufacturers like battery swaps  and bidirectional charging between two vehicles. On top of that, there are different types, depending on  the needs of the user and the capabilities of the vehicle, including AC and DC charging, supplying  different advantages and disadvantages, as we will see later. And finally, during the charging, there are  also different modes of charging. Basically, there are three modes focused on the AC, and the fourth one is  mainly focused on the DC. Talking a bit, starting to talking about the boring stuff and something that  you don't even need to look at, because you will get dizzy out of all the sizes and the standards,  there are a lot of different standards out of them. And as our main focus is the combined charging  standard, or CCS, mainly focused on Europe, we just have this undeniably big list of standards for  different levels of full implementation, ranging from the connector itself, what we connect to the  vehicle, to the high-level communication needed between the EV and the charger itself. This CCS  standard is basically an effort towards a single unified system for electric vehicle charging, which  in the latest news, you might not agree with it, because there are several new things in the  industry, and one of them is that basically a lot of manufacturers in the US are trying to adopt the Tesla  standard alongside others, and basically different continents have different standards for charging  in the whole stack of communication and the OSI layer in general.  And as we look at this slice of the CCS connector, we can distinguish several pins.  First of all, the AC phase 1 and 2 pins, which are the power lines that provide the alternating  current to the vehicle. We have the neutral pin, which completes the electrical circuit. The PE  line is basically a safety feature that helps to prevent electric shocks, and then we have the CP  and PP lines. Basically, the CP line is the one managing the communication that we will be  interested in later, because we want to attack this power line communication, high-level communication,  in order to perform our testing. And finally, the PP line, which ensures that the correct connector  is used and provides information on the current carrying capacity of the cable.  Then we have the DC charger, mainly used for faster charging of vehicles.  Basically, the AC can be used for overnight charging for long periods of time, and the DC  for a fast burst over a road charger. And basically, it's also known as combo 2, and it  incorporates the same pins as the AC charger, but adds two additional pins specifically for the DC  charger, for the fast charging. Here we can basically get an understanding of how this works  internally, in the different implementation of DC and AC charging. On one hand, we have the DC  charging when the power electronics for conversion of current exists in the EVSC side, so in the  charger, while when we want to use the slower solution, the AC charging, the conversion is  happening inside the vehicle itself, by the onboard charger. And this gives us an understanding of  the communication channels also, that exist in all those scenarios, really important, as we will  see later for our research. Basically, we clearly understand now that charging is not only  simple power transfer in vehicles, and data exchange is also happening under the hood, many  times with important information like payment details, voltage, and current requirements, time of  charging, and other things flowing there. And to get a better understanding of how this communication  is structured, I will pass it now to Pavel. So, first of all, for start the charging communication,  we need the plug-in, so you need the CCS inlet and CCS connector, and then for some charging,  for all of the charging modes, can start the low-level communication, and if these pre-conditions  are matched, like the duty cycle 5%, and some specific measured voltage that indicates that  the vehicle is in state B, then can be triggered the high-level communication. And this high-level  communication is what we are aiming to. So, this is how my thesis journey began,  and first of all, we need some description of the low-level communication.  Maybe it will be a little bit boring, but I had to say so, sorry about that.  Low-level communication, it's also called the basic signaling, which is basically physical  signaling over the CP and PE pins, which is also called control pilot circuit, and there is used  voltage measurement and the pulsed modulation signals over this line, and based on the voltage,  there is like the EVSE, which is electric vehicle supply equipment, can indicate or  can see in which state is the EV, because the EV adding the resistors to the circuit can control  the voltage in the circuit. So, here is the table, for example, the state B is that the EV is  connected and is not ready to charge, and for example, the state C is that the start can be,  charging can be started. Also, there is the EVSE side, which control the duty cycle,  and with the duty cycle, it can inform the vehicle about the available current or what  is the maximum current, and it can even force the high-level communication. That is, forcing  high-level communication is done by setting the duty cycle to 5%, so we are interested in this  part that EVSE set the duty cycle to 5%, and then the high-level communication can be triggered.  So, as you could see, the low-level communication is not so interesting from cyber security  perspective, but we need to know about it because it triggers the high-level communication in which  we are interested. So, let's start, let's explore the HLC, high-level communication. First of all,  high-level communication, first of all, why do we need that? Why it's not enough or  sufficient to have the low-level communication? That's basically because with the, sorry,  with the growing, the number of electric vehicles and complexity of our energy ecosystem,  we need to extend some more information. For example, for the DC charging, we need to exchange  more specific information to avoid the battery damage because every vehicle has different  battery and it needs some specific voltage value or the current value and so on, and it's also,  this high-level communication should serve for enhanced user experience, which is basically,  for example, plug and charge. So, in the future, you can just plug your vehicle to the charging  station and the identification and payment is done out of the box over this high-level communication.  So, as I mentioned, the precondition for high-level communication is the low-level communication  with some specific voltage measured and with the specific duty cycle. High-level communication  is applicable only for the charging mode 3 and 4. Charging mode 3 is the last AC one for which  the high-level communication is optional, but as I mentioned, for the DC communication,  it's mandatory because we need to exchange this information about the power, like power management,  like the voltage and so on. So, and this communication is handled by EVCC and SECC,  which is EV Communication Controller and Supply Equipment Communication Controller,  and these protocols for high-level communication are defined in this ISO 15118.  So, let's start with this ISO. The full name of this ISO is Vehicle-to-Grid Communication  Interface. Vehicle-to-Grid has acronym or abbreviation V2G. That's also why we called  our tool V2GEvil, because it's focused on evaluation of the V2G communication.  Also in the ISO is defined that the communication is done over the PLC,  and there is some slack, which is some setting data link layer, which is defined in this  Home Plug Green Physical. So, first two layers in the high-level communication are defined in  the Home Plug Green Physical, and then other layers above. First of all, the network is  over classical IPv6, then it's used UDP, TCP or TLS. Then there is this protocol V2GP,  which we'll explore it later. And for presentation layer, this is the EXI,  which is Efficient XML Interchange, which is basically binary encoding for XML messages.  For you, you can see how the specific layers are defined in the different part of the standards,  and we are mainly focused on the ISO-2, which defined the third layer and above.  So, as you can see, there is a lot of protocols which are used, and so this is more complex than  the low-level communication, so it's also bigger space for mistakes. So, that's why we are aiming  on this high-level communication. And we can focus now on the V2G communication flow,  which is starting with the state E, which indicates that the EV is not connected.  Then you connect the EV to the station, then it's indicated with the state B,  that's okay, I am connected and not ready to charge yet. And after that, with this duty cycle  5%, it indicates that it should force this high-level communication. So, first of all,  there's this establishment of IP-based connection via PLC, and then the communication using the  standard protocols like UDP can start. So, first, we have the SDP request and the response.  I will explain every message later, so this is just the high-level overview. And  this SDP request and response is basically to find the proper TCP port and IP address to communicate.  Then we have V2G EXI messages, which is for exchanging the charging information like the  payment details, identification, authorization, and so on. Then there is  exchange to, let's start over this V2G EXI messages, there is exchange, let's start the  charging, and then also the low-level communication indicates it to this EVSE controller. So, now,  the charging is started, and during the charging, there is exchange of the charging loop information  after the charging is completed. There is also the change to the state B. After that, there are  some V2G messages, which are basically for acknowledgement of that the session stopped.  All of these are V2G TP messages. So, now that you know how the V2G communication flow looks like,  we can focus on the V2G messages PDU, which basically consists of the header and the payload.  And header is 8 bytes, and the payload length is variable. So, we need this because with our tool,  we need to communicate with the EV, so we needed to do all of the exploration of the  message structure and so on. So, here's how the header looks like. The most important part for us  is the payload type, because based on that, we can parse the specific information of the message  to know which is the payload. So, the payload types are basically for the SDP request, SDP  response, and EXI encoded V2G messages, and there's also space for some manufacturer-specific  use. And first of all, we need to understand what is in the SDP request. The SDP request,  it stands to SECC, Discovery Protocol, which stands to established or EV requires some security  and some transport protocol. And this SDP request looks like this. This is the payload type,  the yellow one, which indicates that this is SDP request. And first byte of the payload is  requested security. It can be TLS or no TLS, and the second byte indicates the transport protocol.  This message is needed for our enumerator module, because based on that, we can enumerate  if the EV requires the TLS or not, or what is the transport protocol.  Then for the SDP request, the SECC response with the specific message,  it contains the IP address, port, and security byte and transport protocol byte.  This information, the EV use for next connection to the TCP port, and the SDP response looks  like this. So, there are all of the information, like IPv6 address for the connection, the TCP  port, and the security byte and transport protocol byte, it always follows the request message.  After this exchange of the SDP messages, if the EV accepts the SDP response,  it can connect to the SECC, to the specific IP address and the port, and establish this TCP or  TLS connection based on the previous security byte and transport protocol byte.  After this establishment, there can be done the V2G messages exchange.  And that's with our tool, with the Fuzzer specifically, we are aiming to this V2G EXI  messages. I will explain it in the next slides, why we focus on these messages.  So, basically, with the EXI encoded V2G messages, we have two types, the application  layer protocol handshake messages and the V2G application layer messages.  The protocol handshake message is for the exchange, which application protocol should be used,  and the application layer messages are like the identification, payment information, load  leveling, some energy transfer control information, and so on. So, why are we aiming to these  EXI messages? Because there's the V2G message concept, and it's based on the shared XML schemas.  Because basically, the V2G message is XML document, and for the transfer, you need to  encode it to some more efficient data structure for transferring over the TCP.  So, we are aiming to that side, on the EVCC side, when it's done the structure coding and decoding,  and also the content coding and decoding, and on the conversion to the data structure.  And that's the aim of our tool, that we are fuzzing the information in the messages, like the values  of the parameters, and aiming to cause some failures in this process. Here, you can see how  the plain XML message can look like. So, it's basically the XML document. You can see that  there is the header and the body, and on the bottom, you can see also how this message is  encoded to the EXI data stream.  We also need to know how looks like the V2G application layer protocol message.  So, the EVCC request or offer to SECC some specific application protocol, and version, and so on.  Then, the SECC responds to this request and choose one of the requested application protocol.  And why I'm telling you this? It's because our animator tool is focused also to  extract all of the information which are offered from the EVCC.  Here, you can see how this request looks like. So, basically, the EVCC can offer multiple  application protocols, and in the response, there is one specific schema ID, which was also  in the request, and it indicates that there was successful negotiation of application protocol.  And finally, we can move to the V2G application layer messages, which are all of the other  messages in V2G charging communication, as I already said, like for identification, exchange,  power, information about the power transfer, like the voltage, and so on.  It consists of the header and the body. Here, you can see the example message of this body, and  basically, we are aiming, for example, with our fuzzing tool to fuzz every single  parameter in the message, and then it can cause some failures on the EVCC side when it's trying to  parse first the EXI to XML, and then XML to some internal data structures.  So, now, we will present the testing environment, and it's Tom's turn.  So, understandably, to approach this, the whole stack that was described, we needed some equipment.  We needed some testing environment to physically connect to this port, and for us, the tool that  worked and supported us during this research and during our penetration testing is this DLAN Green  PHY EvalBoard with the Green PHY module, and it gives us the ability to send our messages over  Ethernet, which is later bridged to the power line communication. It can, of course, be used  for normal PLC communication over the wall, but for our use case, the applicable lines  were discussed previously. It was perfect. And an important aspect of this board is this  Qualcomm A7000 chip and the Green PHY firmware, which basically allows us to supply the data link  layer to our application to avoid building it ourselves. So, we invested time to the rest of the  OSI layers. Here we have a shot of our complete development setup, where one board acts as the  vehicle and one as the charger or EVSE. There are several ways that we can perform the PLC  communication, as you see, but we chose to use the coax cable, as it will also be more appropriate  for use in a real-world scenario to avoid interferences from other cables.  And to conclude, you will be surprised if I tell you that many of these cheap Chinese  controllers for Ethernet over power line use the same Qualcomm chip. And if you are on a tight  budget, in most cases you can reflush this chip with the same tools and the appropriate firmware  and run our tool with a budget of around 20 euros. All of this, we're referring to the first  two layers. For the rest of the layers, we used as a reference the joint operating system for EV  chargers, or Joseph, which in the start we used for both the EVCC and SECC parts in order to  properly implement all the parts of the communication. And later on, we developed our own  malicious SECC part to test against the EVCC reference implementation and the target EVs that  we're testing on our penetration testing endeavors. And now we'll move to the demos, finally.  To the intro.  Excuse me?  To the intro of the tool.  Yeah, intro of the tool and demos, so we can have some proof that we actually developed all this.  So I hope it will be more fun than before, than describing the ISO and so on. So finally,  we managed to implement the V2G EVIL tool, which we aim to be the modular tool, and therefore we  have some modules. The most important is V2GTP module, which implement basically the V2G transfer  protocol. And now I will describe how we, how was our approach, like step by step with the  implementation. So first of all, we needed to implement the V2GTP module to be able to  parsing the V2GTP packets, to decode them for decoding EXI message to XML and vice versa.  We used V2G decoder. And to verify if our implementation of V2G transfer protocol was  successful, we also developed the sniffer module. And this sniffer module, we tried on that  reference implementation that Tom already mentioned. And the sniffer module is capable to live  sniffing and also the static sniffing of V2G communication. So it's like any other sniffer for  some others protocol. It's also a free decoding and some filtering capabilities. Then we move  forward to the message module and the station module. We do it both at the same time because  they have too close relationship. So basically, the station module is our implement or is our  malicious implementation of SECC. And to be able to properly communicate with the EVCC, we need  this message module, which defines some dictionaries to have the proper responses for the request,  because we cannot do it like in the runtime, because we don't have the real station with the  real voltage values and so on. And the station is the core for security modules. So on top of the  station, we built, first of all, the enumerator module, which is able to enumerate the TLS, like  if the TLS is required by the EVCC or not, and if the TLS is used, what is the TLS version or TLS  supported cipher suites. Also, as I described the application protocol message, it was because the  enumerator module, based on this request, is able to capture all of the information about the  application protocols, which are offered by EVCC. And also, if you want to add any other V2G EXI  request, you can simply add some other functions to this module or methods in Python, and it can  be also enumerated parameters and values in this request. Then finally, we implement the fuzzer  module, which is testing the robustness and resilience of the EVCC implementation. And as I  said before, it focuses on the part which is the parsing and decoding the EXI message to XML and  then to the data structures. So with the fuzzer, we are basically sending some invalid values for  some parameters. We have different modes of this fuzzer. The most important and interesting is the  config mode and the messages mode. And as I said, we focus on this parsing issues and that we can  cause some message processing failures. And finally, there will be the demo part. We will start with  the sniffer module. So first of all, we have the reference implementation of SECC. We start the  running, then we start the sniffer. And we run it only with the V2GTP option, which basically  parses the TCP raw data and interprets it as the V2GTP. And then we start the EVCC, also the  reference implementation. And now you can see that EVCC was connected to SECC and the message exchange  started. And this is the output of the tool. So we can also put it instead of only the V2GTP option,  the decode option. And it's more like for humans. So you can read if it was the SDP request, what is  the security byte, what is the transport protocol byte, what does it mean, and so on. And also for the  V2GXI messages, you can see this, how it looks like the XML document. For example, here is the first  message of V2GXI exchange, the supported app protocol request. So this was the sniffer. And the first  time it was like only for verify our implementation. So then we implement the V2G evil enumerator  module. And also here's a demo. So we start the enumerator module as all, with option all, which  should enumerate all of the information that I already said, like DLS version, DLS cipher seed.  And supported app support or required protocols, application protocols by EVCC. So the enumerator  module basically start our malicious SECC and then wait for the connection from the reference EVCC.  After that, we can see the results. As I said, there is offered supported app protocols. In this  case, it's only one. And then on the bottom, you can see that there are the DLS check results that  in this case, the EVCC requested the DLS and transport protocol was TCP and the DLS version  was 1.2 and also the negotiated cipher suite and so on. So that was the enumerator module. And the  last security module is the fuzzer, which is most important. So in this demo, we run it in the  config mode. So in the config mode, you can basically specify which message and also which  parameter you want to fuzz. And there are also some specific mode for specific parameters, because  you can have like parameter, which is simple type, for example, the integer or string or base 64 and  so on. So also in this case, when we start the fuzzer, we start first our malicious SECC, which  are waiting for the SDP request, then it responds with the SDP response. And then the EVCC making  the connection. So all of the initial messages are exchanged. And then after some time, we fuzz  this message, which is called service discovery response. And as you can see, for example, the  response code, which is here, it's some, you see the number and it's usually like the  integer. But in this case, it's, for example, the overflow of this integer and so on. And for the  example, in the payment option, there are also some, let's say, invalid values.  And this on the EVCC side, it caused the error. And this for like for this EXI decoding error,  we can have some other modules, which will further exploit these issues.  But at the time, we only implemented like this fuzzer module and other modules can be built on  this fuzzer module to implement also some exploitation steps. We have also some screenshots  for the config module, which is aiming only one specific message. So in this case, it's the same  like service discovery response, the details like which parameters and which values should be  fuzzed. You can also specify in the config file.  So here is like the start of the malicious station. First of all, there is the normal exchange of the  or proper exchange of the proper data. First of all, there is the request of the application  protocol. Our SECC send the proper response with the successful negotiation. Then we can start the  communication. We also didn't fuzz the first two messages, which is the application protocol  request and response and session setup response. And then you can see that there is also fuzzing  this service discovery response. It's again invalid values for all of these parameters.  But in this case, we caused the different EXI decoding error, which is specifically  it was thrown the exception by the Java specifically the unmarshal, which  the unmarshal can be vulnerable to XML external entity injection attacks.  So there is also the space for further exploitation of this part. But as I said before,  we only implement like the fuzzing and then we can build also some other modules, which are  like for the exploit exploitation steps. And basically, the unmarshal has some handful  like unmarshal methods that read the source of the XML data and binds its values to the  new instance of the Java object. So that's like this problem that I mentioned that we are aiming  to like the parsing and the decoding. So that was all for the demo slides. And Tom can continue  with the video. So we can slowly conclude. I can see that you're all hungry. And of course,  as you saw, this tool is not perfect. And that's why we're planning to open source it  after our DEF CON talk, which basically, with your help and with our constant support for this tool,  there are several enhancements that can be made, which can result in a really amazing collection of  tools and modules that will help the EV side to get more secure. Some of the enhancements that  we thought of, like when we first all provide the full suite and full control over the whole process,  of the charging communication. And additionally, fuzzing of the PDU structure, discovery of the  manufacturer-specific messages, and many others can be implemented. We will try to include an  exhaustive list of our ideas of how we can extend this tool on our repository. And if someone is  interested, you can, of course, directly contact us and help us build a better future for these  EV vehicles. And from our end, we have to stress that communication in EVs hasn't reached its  assumed potential. With bigger needs in the future, more sensitive data will start to flow  and subsequently parsed by both EVs and chargers. This, alongside the fact that not a lot of open  source tools are available to cover this attack vector, pushed us to build a tool that we would  like to act as an easy way for people to get introduced and start researching both EVs and  chargers in an efficient and modular way. So, thank you.  All right, so thank you for the great talk. Any questions from the audience?  Yeah, thank you for the great talk. And regarding the TLS encryption, how is the  certificate management done in this world? So, what is happening there? Is there somebody around  bringing the certificates to the charging station and into the cars, or can you shed some light on  that? No, usually there is PK infrastructure on the automotive side. So, basically, the manufacturer  has either their own infrastructure or they have some kind of infrastructure that  they can both issue or manage certificates on the EVSE side and on the vehicle itself.  How it's handled on the ECU side internally, this is a bit more tricky and it has to be reviewed  always because it has a lot of points of failure that we can isolate. So, usually it happens from  the PK infrastructure of the manufacturer. Okay, thank you. Further questions?  Maybe I have one. So, maybe this also goes along with the other question about TLS.  Your tool, as I understand, focuses right now on fuzzing the vehicle itself, or is it also capable  of doing the same thing to the charging station? Or would you need to have like a valid certificate  that an automobile has to authenticate yourself to the charging station to even start that?  So, first of all, at the current state, we are only focusing on the fuzzing the EV,  but it's a little bit, let's say, not more difficult, but more complicated because  in this case, you can only fuzz in the responses. So, you have to basically wait for the request  and fuzz only the response. But we also wanted in like the next step to do it like vice versa,  to implement the EVCC side and I think also there is the bigger attack surface to  attack the station. But we have like the base, like the V2G transfer protocol implementation  can be used, so we just will add some new modules which will be like malicious EVCC  and then we can also use that fuzzer for that. And that was also one of the ideas of why we  needed to build it in a modular way, both for extension on the security side, but also for  extension on the EVCC side, as you said, so it's a really good question.  Cool, thank you.  All right, any further questions?  Yes, thanks for the talk. You mentioned one Qualcomm chipset which was used for most of the  EV. Does it mean we have exactly the same behavior on the whole vehicles or is it  something that the EV manufacturer can modify? For example, is it without TLS for all  your tests you perform or did you see someone using TLS?  On the specification, correct me if I'm wrong, but on the specification it's not strictly mentioned  that you have to use TLS, only in specific scenarios that include sensitive data. So,  if you transfer sensitive data like credit card information or any other username and passwords  or anything like this, then you are forced to use the encrypted communication channel.  And also, one part of our malicious station can also try to, in the SDP response, it will say,  I will not support the TLS and one test case is if the EVCC accepts it, although it firstly  tries to initiate the TLS connection. What I mean is that you can try to force with the station that  I'm not supporting the TLS and if the EVCC will accept it and if it will exchange the information,  you can basically, like, it's the vulnerability because it will exchange the payment details into  like plain text or plain TCP. And the TLS, it's used only like, as Tom said, in the specific  scenarios, which is, for example, the plug and charge that you basically plug your vehicle to  the station and then over, there's establishment of TLS connection and over this TLS connection is  everything is done over it, like, identification, what is the need, like, I need this power in,  like, one hour or two hours and then there's exchange of the payment details, like the  station will change the recipe and then it's based over, like, the certificates. And this  certificate will be for every customer of some manufacturer of the electric vehicles  and every car will be, it will have its own certificate and you will basically  manage this payment by this communication. So that's why we need the TLS.  Okay, and it is mutual authentication, so meaning with the certificate at both sides or only one way?  I think that in the standard is that you have this public infrastructure and the verification  is done on the EVCC side. If the EV communicates with, let's say, the proper station,  with the proper certificate. Okay, thanks.  Hi, do you have any information about a station that has been manipulated to grab this  information? Yeah, so basically there are several, there is a lot of research on the EV side,  on the charging, because actually there are, you know, like Linux systems that implement PLC  controllers on top of them. So there are several people that hacked into them in order to manipulate  data like this. From our side, I can say that before we had this and before we had a way to  connect to the port, to the CCS port or to any other port that supports this, we actually had  a charger which was routed and through the PLC module we were able to communicate really easily.  It was like an Ethernet interface that we just managed the communication. So this was our  solution before. Now we needed something more modular which we can edit successfully and we  can build it ourselves, you know, and also for the researchers to not need to buy a whole charger  in order to start researching these kind of things.  Additional question on your hardware. If I'm not mistaken, if I saw it in the slide  correctly, there was just some coax cable on there. Now you said you can plug it in everywhere.  So is the hardware in a state that I can connect a type 2 connector to it and just plug it in  to the EV? It will handle the lower layer initialization and we can go right up to the  fuzzing part? Yeah, so basically we have this solution, but basically the tool and this solution  there is built for the high-level communication. We can implement the lower layers of course, but  this is just for the high-level communication. Also the coax cable is just for the lines that  are handling the PLC. That's why I said you can connect it everywhere because if you see  here, the black box is actually a normal power plug that goes to the power socket in the wall.  So you can perform the same thing over the home network, the home power lines. And at the same  time you have also two normal lines with simple cables and behind that you have the coax cable  which as I said we used it because we want to avoid interference of other signals and like  big current that can flow on these charging cables. But can I start to talk to the vehicle  even before I did all the other communication on the lower layer parts? Yeah, like that's the  one thing that we will need to have something which will be communicated on the low-level  communication which was the basic signaling. So like to send the specific voltage and to measure  it and the EV will add the resistor for example to convert to the state C. I think it was like  six volts. When we measure this six volts, we will send the pulse width modulation signal  with specific five percent duty cycle to inform the vehicle. Okay, now we need this high-level  communication and then we can use like this board and this connection like these two pins like the  CP and PE to create the circuit. And with this module, the physical layer is done over the PLC  and the data link layer is done with the firmware in this module which basically implement the  slack. There is some establishment of the let's say data link and over the MAC addresses and  Ethernet and then on top of that we working with our tool which basically implement the  third layer and above. I see, thank you. And this is a limitation that we will for sure  mention on the tool and we want to build an all-in-one tool that as you said you plug it  and it works. But maybe next year in Troopers or somewhere else. Because first of all we needed  like to prove if there is some space like two mistakes you know like to try the fuzzing and so on.  I think there was another question in the front. Maybe a very short one. So I'm not in  vehicles and so on but was there ever a solution where you put all this into a cable and build a  rogue cable so that people, because people use their own cables on the stations right? So could  we build a cable that steals credit card information and supply it at the shop to the  car so swap them or? Yeah it's similar to the answer from before. It's like because  this uses for example the reference implementation and needs a system behind it we can assume that  this system is a whole charger that is compromised. Like it's the same thing as building the cable.  We have the cable to test it ourselves in our lab but it's not a ready-made solution that I  can present right now because of several restrictions. So this will be like presented  on the tool and I hope that with the help of the community and our effort we will have this final  solution. Not for malicious users but for researchers. All right thank you very much.  I've got two announcements to make but first thanks again for having this great talk. Thank you.