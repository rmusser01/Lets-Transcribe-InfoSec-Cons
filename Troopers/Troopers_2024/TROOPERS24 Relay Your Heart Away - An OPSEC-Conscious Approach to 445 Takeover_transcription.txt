{
  "webpage_url": "https://www.youtube.com/watch?v=e84BtnLSKPQ",
  "title": "TROOPERS24: Relay Your Heart Away - An OPSEC-Conscious Approach to 445 Takeover",
  "description": "Talk by Nick Powers - June 26th, 2024 at TROOPERS24 IT security conference in Heidelberg, Germany hosted by @ERNW_ITSec\n\n#TROOPERS24 #ITsecurity \nhttps://troopers.de/troopers24/talks/zwwkat/\n\nMore impressions:\nhttps://twitter.com/WEareTROOPERS\nhttps://twitter.com/ERNW_ITSec\nhttps://infosec.exchange/@WEareTROOPERS\nhttps://infosec.exchange/@ERNW https://ernw.de",
  "channel_url": "https://www.youtube.com/channel/UCPY5aUREHmbDO4PtR6AYLfQ",
  "duration": 3288,
  "channel": "TROOPERS IT Security Conference",
  "uploader": "TROOPERS IT Security Conference",
  "upload_date": "20240902"
}

This text was transcribed using whisper model: large-v2

 Thank you very much.  Yeah, like was already mentioned, I'm going to be talking about some NTLM relay-related  tradecraft today.  Relay your heart away, but more specifically, an OPSEC conscious approach to taking over  Port 445.  So quick about me, I currently work at Specter Ops.  I was thinking about it right before this presentation, and it's coming up on four years,  which blows my mind that I've been at Specter Ops now.  On the adversary simulation team, I started as a consultant, then senior consultant, and  now I'm a part of the service architect team that we have at Specter Ops, where we primarily  support red team or pin test engagements with creating capabilities like these, or doing  what we refer to as like interrupt, whenever there's an extra set of hands needed on an  assessment or a particularly difficult problem.  So we can put a couple heads targeting the same problem.  I work with the other service architects at Specter Ops.  Most of my career has primarily been focused on red teaming or pin testing, offensive security  in general.  And I'm curious, in the audience, how many folks are in offensive security, okay?  And how many people have done any type of NTLM relay attack before?  And of these people, how many people have done NTLM relay over SOCs or command and control?  Okay, perfect.  Thank you for that.  That helps.  So a little finishing up about me.  Some of my interests, my work-related interests anyways, include initial access techniques.  I'm a big fan of researching potentially new or additional vectors for initial access techniques.  Windows internals in general, as well as, like this talk, authentication relay attacks,  or methods of supporting existing relay attacks.  And my handle on Twitter is Zenergy.  So a quick agenda about what we'll be covering in this talk.  First, why do we even care about taking over port 445 in the first place?  There's plenty of relay scenarios where this isn't relevant, but there's some pretty important  ones where this is incredibly important, especially for us on a lot of our assessments.  We'll be going over some existing solutions to this problem.  So I'm not the first one to experience this problem or take a stab at solving this problem.  We'll go through some existing projects before we get to debugging drivers and presenting  an alternative or a new approach to this problem.  We'll wrap up with a discussion about tooling to automate this technique or just use existing  tools to leverage this technique.  And then we'll wrap up with a demonstration of abusing this.  So I make a couple of assumptions.  During this presentation, just because, as a lot of people in the audience here have  already done NTLM relay attacks, you are probably aware that there's a lot of technologies involved  in doing an NTLM relay attack.  From start to finish.  And more particularly, like we'll be talking about, things like SOCKS and reverse port  forwards will be relevant because this is the problem that we're solving is more specific  to conducting these relays over SOCKS tunnels or over command and control related traffic.  So a somewhat intermediate level of knowledge of SOCKS tunnels or reverse port forwards  will help, but I do have a quick review slide as like a refresher later on in the presentation.  Some entry level knowledge of existing NTLM relay primitives will help, just because this  presentation is specific to taking over port 445 to enable some of those relay primitives,  not specifically doing a deep dive on the primitives themselves.  So we'll kind of rush through in the demo the specifics of the relay primitives themselves,  but I'll elaborate on what will hopefully enable some of those primitives.  And then lastly, some entry level reverse engineering knowledge.  This very entry level is perfectly fine.  I barely consider myself an entry level in terms of reverse engineering knowledge.  So I'll definitely be elaborating on this piece as well.  And before I dig into the meat of the presentation, I always like to start with like a problem  and the solution that we'll hopefully arrive at by the end of the presentation, just so  you can kind of gauge where we're going with this.  So the problem that I would like to solve is while we're conducting NTLM relays specifically  over C2 or command and control, we typically run into a lot of hurdles.  One of which, the one we'll be focusing on in this presentation is the fact that the  Windows kernel by default is bound to port 445 TCP on all interfaces.  There are existing solutions to this problem, but an issue that we often run into is that  there are a significant amount of OPSEC related concerns associated with those existing solutions.  The solution that we'll hopefully arrive at is that we will identify and implement a technique  that results in control over this target port of 445 and is practical to leverage over our  command and control or over an agent that doesn't include the OPSEC concerns associated  with existing solutions.  So why is control over port 445 relevant to this type of NTLM relay attack that we want  to conduct?  And I'll start this slide by stating that my experience is biased towards the assessments  that we conduct at SpectreOps.  A lot of them are red teams.  Most of our engagements take place over command and control.  And that's why the focus for this, or at least the practical examples of abusing this, that  I give are going to be based on targeted NTLM relay attacks.  So several folks in the room are probably familiar with some of these primitives, but  the reason I like to point this out is because these targeted NTLM relay attacks still work  in what I would consider incredibly mature organizations very often.  In some popular examples, some ones that we regularly make use of would be like HCP to  LDAP or LDAP-S for object takeover primitives published by our colleague, Elad, like Shadow  Credentials or Resource-Based Constrained Delegation, RBCD for short, or relay of SMB  or HCP to the HCP protocol.  So popular abuse cases of this would be like ADCS Escalation 8 relaying to that HCP service  or SCCM Takeover 4.2.  We'll talk a little bit about the Misconfiguration Manager project that tracks some of the SCCM  escalation or takeover primitives throughout this presentation.  4.2 Takeover is specifically relaying to the Admin Service API.  Also SMB or HCP to the SMB protocol, which is a lot of the SCCM takeover primitives,  but the one that we'll focus on for the demo will be this last example, which is SMB or  HCP targeting the MSSQL protocol, which is documented as SCCM Takeover 1 in the Misconfiguration  Manager project.  So long story short, depending on your perspective of access in the target network, relay of  inbound SMB authentication, which is what we'll be focusing on, could be more involved.  And what I mean by that is for the traditional pin testing scenario of you land in an environment  by either plugging a physical device into a network or delivering some sort of virtual  machine to your customer or the target network to be deployed, in those circumstances, whether  it's Linux or Windows, you have options for just controlling port 445, and there's a lot  less considerations associated with how you're going to control that inbound traffic.  So if it's a Linux machine, you most likely have root on the device or the VM that you've  delivered to the customer.  You can just bind a 445.  Similarly with Windows, I'll mention this a couple times throughout the slides, you  can just set the Landman Server Service to a disabled start type, reboot the host, 445  is unbound, and then you can do stuff from there.  But if you're operating on a compromised Windows host over C2, there are additional  challenges and what we want to end up with is some type of reverse port forward functionality.  So when the traffic comes to us, whether that's because you've done like LLMNR poisoning,  run responder, or you've used something like PetitPetam or Printerbug, there's going to  be potentially SMB traffic coming inbound to your host that you've compromised and you're  just operating through an agent, and you need to have some way to control that traffic to  conduct your NTLM relay.  And again, like I mentioned before, by default the Windows kernel is bound to this port on  all network interfaces.  So I have a little example, like command prompt here at the bottom of just netstat parsing  the results that have 445 and you can see there is a process currently bound on IPv4  as well as IPv6 listening on 445.  So we can't just as easily bind to that port and control the traffic.  So there are several existing solutions to solve this problem.  I'd say currently what I feel like is the most popularly used approach would be approaches  that are based on leveraging the WinDivert driver, which is an open source driver.  You can find the code on GitHub and it's described as a user mode packet interception library.  The release for this driver is signed in such a way that it can just be loaded on up to  date Windows, so it's likely signed with an EV code signing cert.  And there's a lot of projects over the last 10 years all the way back to, there might  be some before this, but as far back as I found was this HWFW bypass project, which  is a little over 10 years old now if I remember correctly.  But a little bit more recently, Portbender is a popular project, which is written as  a reflective DLL, popularly used with Cobalt Strike and other command and control frameworks.  There's Sharp Relay, which is a .NET project that interacts with the exposed functionality  of this driver.  Stream Divert, Divert TCP Con, which are written in C, C++.  A lot of very creative and useful projects to load a driver, see the inbound SMB traffic,  and then manipulate it from that perspective.  There's also the opportunity to create a custom LSA authentication provider, and the only  example of this that I'm currently aware of is Ethical Chaos, or CCOB's project called  LSA RelayX, and what LSA RelayX does from a very high level is it hooks two authentication  packages, NTLM and the negotiate packages, and it redirects incoming authentication  requests and it will redirect those requests over named pipes.  And then lastly, like I already mentioned a slide or two ago, you can disable the landman  server service and reboot the host.  So basically what you do is you change the start type.  By default it's auto start, if I remember correctly.  You switch that to disabled, you reboot the host, and then all of the associated resources  with binding to that target port will be unloaded, the drivers and everything, and you can bind  reverse port forward and go from there.  But like I mentioned, there are several OPSEC-related concerns associated with these existing approaches.  So leveraging drivers for post-exploitation in general, so like relying on the wind-avert  driver for example.  Anything in kernel mode, there's potential for a blue screen of death, or BSOD, and in  a lot of situations, especially for us, but I would imagine across the board that's just  not an option, especially when you're operating from critical infrastructure, production servers,  things of that nature, or even just simply on a normal workstation where somebody's in  the middle of conducting normal work, you probably don't want to take that risk in some  situations.  There's also a potential single point of failure as it pertains to detection or prevention,  so all it would take is a relatively potentially high fidelity alert for the wind-avert driver,  and then there's only so many ways you can load drivers on Windows, you might have to  get really creative to get around an alert like that.  And then there's everything associated with interacting with the driver, because just  loading the driver is not enough, specifically with wind-avert, you have to interact with  that driver, such as using IOCTLs or other exposed functionality, and then that has all  of its associated considerations.  So if you're doing it with a reflective DLL, how are you loading that DLL?  There's all of these user mode detections that we need to take into consideration if  you're using .NET, like the sharp relay project, there's AMZ, there's all of the things associated  with .NET, unmanaged PEs, position independent shellcode, all of these.  So there's multiple layers of consideration that we need to account for, and it can become  a relatively arduous process in a very locked-down environment.  Loading a custom LSA authentication provider, this is specifically pulled from the README  of this project, but due to limitations on the Microsoft side of how custom LSA authentication  providers work, you can't load a custom authentication provider and then unload it without a reboot.  You could, potentially, he mentions using something like a reflective loader to do something  like that, but going back to the risks associated with loading drivers, there could be stability  issues of the host machine if you don't account for errors appropriately, or there's something  lacking with your error handling, within 60 seconds or so, the machine could reboot because  of instability in the LSAS process.  Another big risk, especially if we're operating in production.  And then lastly, I mentioned you could change the start type of the landman server service  and reboot the host, but as you can imagine, in a lot of practical scenarios, either waiting  for or forcing a reboot is not an option, again, especially on servers, but maybe even  on workstations.  The way that I first started approaching this was digging into some of the drivers associated  with servers that seem to be related to SMB, NetBIOS, anything associated with binding  to this target port of 4.4.5, and what I started with was primarily System Informer, IDAfree,  and WinDebug, all free, publicly accessible, and there's probably a hundred different ways  to obtain the same information that I'm going to step through here, again, reverse engineering  is not my primary focus for work, so there might even be a better way to do this, but  these are the primary tools that I used.  And my goal when I first started doing this was just to do something to release the target  port, which in this case is 4.4.5 TCP, without requiring a reboot, loading a driver, or loading  a module directly into LSAS.  So where can we start?  Well, we've mentioned a couple times already that you can disable the landman server service  after a reboot if you change the start type.  So also, by simply resetting the start type of this service after, so you've disabled  landman server service, you've rebooted the host, 4.4.5 is no longer listening, you can  also change the start type back to auto start, and then within a couple minutes, 4.4.5 will  be rebound because landman server service will restart, all of the other associated  resources will be loaded.  So we kind of have a starting point to reproduce and step through the behavior that we're interested  in.  In this case, it's just binding to 4.4.5, but as we go through the slides, we'll kind  of connect the dots between inspecting what happens when you bind to 4.4.5, and then using  that to step backwards through actually unbinding the port.  So the items of interest for me as I started this was, first, just simply identify the  process bound to the target port.  Secondly, just triage relevant loaded modules, in this case it was mostly drivers, narrow  down an initial list of drivers that we want to start statically reversing in some way,  and lastly, I just put this note because I spent a lot of time stepping through different  versions of drivers when I was doing static analysis.  Probably a relatively junior reverse engineering mistake to make, but if you're doing your  kernel debugging on a remote host that's like a different Windows version, there's a reasonable  chance that the drivers could be different versions, and then when you're doing your  static analysis, the offsets will be different, and then nothing will make sense when you're  doing the debugging.  So using a project like WinBindex can be very helpful just to make sure you have the same  versions of the drivers so when you're doing your static and your dynamic analysis, everything  lines up and you don't have the same problem that I did.  So as a high-level starting point, just did a simple PowerShell cmdlet here to see what  was bound to 4.4.5, list through all the processes, and we see that the PID of 4, which is the  system process representative of a lot of kernel mode-related activity, was bound to  port 4.4.5, which is expected.  And then using ProcessHacker or SystemInformer here in the bottom left, we can look at the  loaded modules, which shows, again, mostly if not all drivers here, along with their  associated descriptions.  So I'm not too proud to admit I copied all of this into ChatGPT and I said, what should  I look at?  And thankfully, it gave me a pretty good list to start with.  So it mentioned looking at the AFD driver, it mentioned looking at TCPIP, netbt.sys.  A lot of these actually ended up being exactly where I needed to look for static analysis.  So like I mentioned before, I used IDAfree to start digging through some of the static  analysis.  And when I say digging through the static analysis, just making basic use of symbols.  So downloaded the Microsoft symbols for these drivers, which are made available to everyone.  And I just started looking for functions associated with behavior like port, or associated with  keywords like port, socket, bind, hopefully start pointing us in the right direction.  And there were a lot of functions, because there were a lot of drivers to look through  that started to fall out.  But it did allow for some initial narrowing down of what might be interesting.  So just like ChatGPT told us, we see some interesting stuff in the AFD driver, like  bind here, we see some references to the TCPIP driver, and a lot more.  So we've stepped through some very, very basic static analysis.  And now that we have some interesting functions, we can attempt to do some also very basic  dynamic analysis.  So we get the target VM configured for kernel debugging, because you're going to do this  remotely most of the time with kernel debugging on Windows.  And you can, like I've mentioned a couple of times, set the landmine server service  to disabled, reboot, now 445 is unbound.  And what I did was just snapshot the VM as 445 is unbound, because what we want to do  some dynamic analysis on is when we re-enable landmine server service, and we know that  the port will be rebound.  So we snapshot when it's unbound.  We write this simple PowerShell one-liner right here.  And I just set a hotkey, so I can revert the snapshot, hotkey, it rebinds.  Revert the snapshot, hotkey, it rebinds, and I can continuously step through using WinDebug  and see kind of what's going on when I hit these breakpoints.  So I set breakpoints for a lot of the functions mentioned in the last slide, and eventually  that led to inspection of the TCPIP inet acquire port function.  And this was reliably hit when I did that, like revert the snapshot and rebind 445.  And every time I did that, I would hit inet acquire port, along with a lot of the other  functions, but this one just looked a little bit more interesting.  But I wanted to be sure that hitting this breakpoint was associated with the functionality  that we're interested in, so stepped through this function in the static analysis.  And you'll notice that, so as a note, there's several people on our team that are significantly  better reverse engineers than I am, and one of them, his name's Evan McBroom, made the  suggestion that I leave as little pseudocode on these slides as possible, because no one  wants to look at what IDAfree thinks the source code looks like.  So I tried to do that, this was as little as I could get down to and still make sense  of this, but hopefully it's not too much.  So in that TCPIP inet acquire port function, basically all I'm doing is looking for a place  that looks, or looking for something in the pseudocode that looks like it might end up  being the port value that is the target of this inet acquire port.  We know something with a port is gonna happen, I'm hoping it's port 445, and I'm looking  through the pseudocode to say, like, where does it look like port 445 is gonna end up,  like a variable, for example.  So I see a subsequent call to is port in exclusion, and the reason this is interesting is because  one of the two parameters for is port in exclusion was of type int16, which is somewhat likely  to be a TCP port number between zero and 65,000, et cetera.  So that's why that specific function that was within the inet acquire port function  call was interesting, because it just seemed like a likely place to verify that what's  happening is associated with port 445.  So the breakpoints are already set, start stepping through the execution of this function,  and because of the fast call calling convention, if the port that we're interested in is actually  port 445, we know that when is port in exclusion is called, it will exist in the RDX register.  So we step through some of the execution of the instructions.  When we finally hit acquire port, we step through, and we see in the RDX register that  it's actually port 445 being leveraged by this function.  So now we know relatively definitively that when this function is called, when we're rebinding  to port 445, that inet acquire port and this is port in exclusion are relevant to that  rebinding behavior.  But we're not really interested in binding to port 445, 445 is already bound by default.  So this was where I kind of initially ended up, and my hope was that I could leverage  a slightly better understanding of the binding process to then understand the unbinding process.  Because we have symbols, we have hopefully similarly named functions that we can kind  of step through this backwards is the hope.  So what can we do to start understanding this unbinding process?  Well initially, with all the bring your own vulnerable driver tradecraft, I was hoping  that I could just look at these relevant drivers and identify like IOCTLs or other exposed  driver behavior and maybe call an IOCTL and say unbind this port.  Thankfully something even more, I don't want to say even more straightforward because that's  not incredibly straightforward, at least to me, but something more straightforward than  that presented itself.  So if we start at the bottom of the call stack, as was mentioned on this previous slide, we  see Servnet is directly responsible for initiating this behavior of binding to port 445.  So if we start in Servnet and we start using just similarly named symbols to identify functions  that might be associated with unbinding behavior, we pretty quickly see some pretty obviously  named functions here.  So for Servnet, Servnet workstation open listen socket, sorry some of these functions are  pretty longly named.  We see a function for close listen socket and for allocate endpoint, we see a function  for close endpoint, add served name, delete served name.  So pretty easy to associate maybe what functions would be unbinding port 445 based on the ones  that we know definitely bind port 445.  And again, just using cross-references here to start at the function I previously mentioned.  This one was Servnet close endpoint from the Servnet.sys driver and go to that function,  check what cross-references are there, so what other functions are called by this function.  That leads me down to Servnet close endpoint, which I'm not even going to try to read this  one, very long function name here, which ultimately again just using cross-references  here leads me to a driver unload function call, which if there are any reverse engineers  here in the room, some people might already see why this could be interesting.  But to dig in a little more, we first want to know how we can determine if this driver  unload code path is ever reached.  So how can we do that?  One, we could just be a good reverse engineer and step through all of this pseudocode and  disassembly until we have a very thorough understanding of what's happening in the  related drivers.  Or two, we can just let Jesus take the wheel and start blindly disabling services.  I'll let everybody take a guess on which approach I took.  But there's a little bit more that we need to consider here, and that is, you can see  at the bottom of this slide, I'm using process hacker, I think, here to attempt just stopping  the Servnet driver, because that's the one we think is relevant.  We might be able to call that driver unload function.  But you'll see in the bottom left of this slide, we can't stop it for some reason related  to service dependence.  So why are we even trying to stop the service?  Well, by stopping the Servnet service, which is responsible for the Servnet driver, you  should be able to call its respective driver unload function.  This is defined in the WDM driver framework.  Most drivers should call the unload function.  They don't all call it, but that will be ideally what will happen.  And why are service dependencies relevant?  Well, MSDN specifies that a service dependent specifies the names of services or group that  must start before the service in question.  So in most cases, in default builds of Windows, the Servnet service is a dependent of the  Serv2 service, which is a dependent of the landman server service.  So there's some nested dependency here.  But we step through those dependencies, and we're starting to connect some dots back to  the beginning of this presentation, where we're disabling the landman server service,  we're rebooting the host, 445 is no longer bound.  So now we've found a path back from this driver unload function that if we can stop  the Servnet service, which is a dependency of Serv2, which is a dependency of landman  server, then potentially we'll reach the code path that is responsible for unbinding the  port of 445.  You can also use System Informer and Process Hacker to pretty easily identify service dependence.  So here you can see I'm looking at, it looks like the Servnet service, and you can see  the dependencies of Serv2 and landman server.  But all of this information just comes from registry.  So for Serv2, for example, you'll see the value of depend on service, which is Servnet  here.  But first we started through binding to 445, now we're trying to take guesses at unbinding  to 445, and also service dependencies are somehow relevant to all this.  But this all comes together by basically working backwards from where we started and interacting  with these services in a specific order where the service dependents are not an issue for  us.  So we can reconfigure the target services that we've talked about by starting with landman  server service.  We do just like we did before, we set that to disabled.  The reason we need to set this to disabled is there's this concept of service triggers  where a service in Windows can be, depending on its start type, can be triggered to be  enabled a number of different ways, like for an example, interacting with an RPC interface.  The landman server service has multiple triggers, those triggers are hit very regularly, so  if you don't set it to a disabled state and then stop the service, one of the service  triggers will just re-enable it.  If you stop it, it'll stop, but only for like 10 seconds maybe, for example.  So you want to disable it, you want to stop it, then you stop the serve to service, and  then you stop the serve net service in that order because of the order of dependencies,  and then the last step is optional, but you can pray that 445 is unbound.  I did also want to note before I move on from this slide that in some versions of Windows,  specifically Windows servers, I haven't done too much digging on this, but it's not always  this specific order of services.  This is what I've personally seen on our assessments, like 90-95% of the time, especially on workstations,  but newer versions of Windows, newer versions of Windows server, there might be like an  additional service sandwiched in here somewhere, but I've always been able to do this, just  maybe there's an additional service that's also a dependent of one of these services,  so that's definitely something to look for if you're targeting newer Windows servers,  for example.  But we don't want to just disable these services and hope that 445 is unbound, just like when  we were binding, I personally wanted to just make sure that 445 was associated with the  functions that we've done some analysis on.  So just like before, inet acquire port, there's a function called inet release port, it has  the same function prototype, so we should just be able to step through some of the instruction  calls, it also has the exact same call to is port an exclusion, so we already know ideally  where the port should be a specific parameter, we know what register that port should be  in, and when we hit that, we stop all of these services with our breakpoint set, we step  through until we reach is port an exclusion, and we see that just like we had hoped, port  445 is in the RDX register, which means that is what these functions are interacting with.  So just to verify, there's a lot of ways you could do this, but just using a PowerShell  commandlet here, we check if 445 is unbound, and after disabling these services in the  specified order, without a reboot, without loading a driver, without loading a custom  LSA authentication provider, we have unbound port 445.  So that was a lot of reverse engineering, and to kind of from a high level describe  what happened, what were the important pieces during the static and dynamic analysis, if  you imagine the service control manager interactions that we just stepped through, that would happen  down here, like below where the graphic starts, so you stop the services, you stop land main  server service, serve 2, and then when you get to serve net, when you stop that service  successfully, the driver unload function is called, driver unload makes a few more calls  within that driver until you eventually reach this function that we briefly mentioned, serve  net workstation close listen socket, which then makes a few virtual function calls, ultimately  to inet release port, which is responsible for unbinding port 445 in this case.  So we have a way to unbind port 445 that meets our previously defined prerequisites, and  to quickly step through, or before we step through automating some of this abuse, I just  wanted to make a couple notes about when you're leveraging this technique.  Probably most importantly, if you're leveraging this remotely, a lot of tools will make use  of RPC over named pipes, and if you're leveraging named pipes, targeting a remote host to disable  these services, that will work, but it won't work after you disable these services, because  you're disabling the services associated with named pipe communication.  So definitely something to consider.  If you want to disable this remotely, or leverage like impact that you're proxying into a network,  by default, like the services.py example script, that uses named pipes.  So you'll be able to disable it on a remote host, you won't be able to re-enable it on  a remote host.  But there is a way to do this, because RPC can also be interacted with, depending on  the interface RPC over TCP, which there's a lot of ways to leverage RPC over TCP as  well.  Some of which are also impact-based solutions, or the SC binary, for example.  Just wanted to make this note, because it's important to understand the tool that you're  using to interact with the service control manager, because if it leverages named pipes,  you won't be able to use it after you disable these services.  If it leverages RPC over TCP, you will be able to use it after these services are disabled.  A bonus, in my opinion, of leveraging this technique to unbind 445, is that you conduct  a series of simple interactions with the service control manager, it's unbound, and then to  rebind it, because of the service triggers that I mentioned a couple slides ago, all  you really have to do is set the start type of landman server service to auto start, what  it was in its default state.  And because of its service triggers, within 10 to 60 seconds is roughly what I've seen  in production, everything will just start again.  Because you set it to auto start, a service trigger starts the landman server service,  and because serve two is a dependent of landman server, it starts the serve two service, and  because serve net is a dependent of serve two, it starts the serve net service, which  binds to port 445.  So you conduct this very simple interaction with service control manager, and service  control manager takes care of the rest for you.  I wrote two pretty simple POCs, one in Python, if you like proxying things into a network,  and another in a BoF, but again, this basically boils down to a series of pretty straightforward  interactions with the service control manager.  So the Python script, which I want to note first, is very heavily based on the WMI Exec  Pro project, I have a link to the author's GitHub here at the bottom of the slide, and  what it does is, just like the BoF I'll show here in a second, it has a stop function,  a check function, and a start function.  So if you want to see if 445's bound, you can run check, if you want to stop it, stop,  and you can see here that it basically just automates those service control manager interactions  that we've talked about.  So start type of disabled, stop, stop, stop, and then hopefully 445 is unbound.  If you want to make sure, you can use the check function, and the root of my logic here  is basically if servnet is stopped, because serv2 and landman server should have to be  stopped to stop servnet, because of the dependencies, if servnet is stopped, 445 is very likely  unbound, so that's the root logic of the check here.  This again, I'm leveraging over proxy chains, because it's written in Python, so if you  like proxying your tools in over socks, this would be a potential option for you.  And then like I mentioned, also wrote a bof, and this is heavily based on the bof registry  tool, again, linked to the author's original code here, but implemented a stop, start,  and check function, which you can see just conducts the exact same service control manager  interactions.  I did also want to note that you don't need to use my tools to do this.  Like I mentioned before, the sc.exe binary, which I'm suggesting first, because this actually  defaults to RPC over TCP, you can leverage that binary.  I know when I mention that, a lot of folks probably think executing that binary on host,  but something that our team and a lot of other red teams in pen testing shops are doing is  proxying in tools from a remote Windows host using a proxy software like Proxifier or Proxycap,  and you can proxy sc.exe from a remote non-domain joined host over socks into the target network  is an option, and you just use these four commands, again, disable, stop, stop, stop,  and then 445 will likely be unbound.  Or if you just want to use the original WMI exec pro project, that defaults to RPC over  TCP, which is why I'm recommending it.  And a little bit longer of commands here, but again, it just boils down to disabling  landman server service, stop, stop, and then stop.  And then if you want to check, you can just use the get info action to see if, like I  mentioned before, the root of the logic previously was checking if servnet was running.  So you can do that with WMI exec pro as well.  I recommend these tools, but any tool that you like to interact with Service Control  Manager, like it's basically four simple interactions to stop and then as little as one to restart  the service.  So I wanted to, before I give a demonstration, give a quick shout out to Garrett, who's not  here, one of our coworkers, but Chris, who is here, for helping me get lab access to  a more production-similar SCCM environment so I could demonstrate some of the impact  associated with this technique.  And also Garrett, Chris, and Diego, and a lot of people in the open source community  as well as our team for the misconfiguration project that helps document a lot of the SCCM  abuse cases, also the one that I'll be demonstrating here with this technique.  But there's a lot of tunneling and reverse port forwarding and SOCKS proxying that happens  in this demo.  So I first wanted to give a very quick review of what tunneling is relevant for folks that  haven't done a lot of proxying before.  Hopefully this will help make a little bit better sense of what's happening in the demo  here in a second.  So the important pieces are we'll need traffic in two directions.  We'll need traffic coming from our attacker machine into the target network.  The reason we need that is because we need to coerce authentication.  That'll be the starting point for our relay.  And then we need traffic coming back from the target network to our attacker host.  That'll be because the authentication that we've coerced, we have to be able to do something  with it.  It comes back to us.  We relay it somewhere else.  That goes back into the network.  So all of that action is happening on our compromised host.  Usually with built-in agent functionality, but you can use Windows SSH, or SSH has been  default on Windows since build 16.07, so SSH is probably there.  You don't need to have this capability built into your agent.  But we'll create a SOCKS tunnel, which will allow us to proxy in from our attacker machine,  do like Petit Patam, Printerbug, whatever your favorite coercion tool is, and that goes  into the network through our compromised host here, and hits whatever our actual target  is.  And the reason that that traffic can make it back to us is because now we have a pretty  convenient way to unbind port 445.  We do some type of reverse port forward on this host, and then when like Petit Patam  or Printerbug hits one of these hosts, whatever we're targeting, it comes back to our host.  We've taken over port 445, which redirects that traffic back to us, and gives like two  ways through the SOCKS and reverse port forward that traffic can bounce back and forth between  our attacker machine and the target network.  So what does that look like in a practical example?  So I've jumped through a couple things because this technique has several steps, and also  it's recorded because every time I do this live, something goes wrong, so I'll save everybody  that trouble.  But what I've started with here is I already have a SOCKS tunnel that's identified here  in the Cobalt Strike interface.  Like I mentioned before, it does not have to be Cobalt Strike.  You can use any C2, you don't even have to use a C2, use SSH, use something else.  I'm just using it as an example.  And I have some sort of access as any domain user that has local admin somewhere.  So I have local admin on a host, I'm a normal domain user, and I already have a SOCKS tunnel  set up.  So the first thing I'm doing is using Garrett's tool called SCCM Hunter.  I've already done some SCCM enumeration, so I show that I've done that enumeration.  I see a site server, I see some interesting SCCM stuff.  And then I also do a port scan, so I'm basically just showing there's also an SCCM site database  here somewhere in the target network.  All of this is happening over that SOCKS tunnel, so I'm using proxy chains.  So there's mssql listening on that SCCM site database.  Now I run SCCM Hunter with this mssql command, and there's a lot happening here, but the  important part is that there's an LDAP query conducted, it gets relevant information like  the SID, and then constructs this SQL statement.  The reason this SQL statement is relevant is because when the relay successfully occurs,  this is what will be executed on the target SQL database.  And what all of this boils down to is add me, my normal domain user, as an administrator  in the SCCM site database.  So this is where we can leverage this technique that we've talked about to unbind 445.  I know this text is probably super small, so I'm going to try to be a little verbose.  First I just run help, so here in the bottom left, an incredibly tiny text that shows just  the check, stop, start commands that we've talked about.  So the output from running check, it just says true, because by default, 445 is going  to be bound.  So next I'm running a shell netstat tack ANO, parsing out 445, and this is just to like  sanity check, don't just trust my tool, actually verify.  Don't know if I'd recommend running a shell command in production, but just a second check  that 445 is bound, then we run stop, it does the service control manager interactions that  we've talked about, oops, and we see that it's now false.  So it's true, and then false after we run stop.  And we run another netstat command to verify that 445 is actually no longer listening.  Again, no reboot, no loading a driver, anything like that.  So now we actually do our reverse port forward, you can do this with SSH.  Another tool, I'm doing it with Cobalt Strike built-in functionality, but I run the rportforward  local command, now I have a SOX tunnel and a reverse port forward, so I have the ability  to send traffic both ways through my agent.  And here on the left, big long ugly command, but all this is is ntlm relay x, I'm targeting  the mssql server that I already verified is there through a proxy to in-map scan, and  I'm saying, hey, when you hit that server, execute that SQL statement that Garrett's  SCCM hunter generated for us already.  So now ntlm relay x is listening on the left, all the tunnels should allow the traffic to  reach it, and petit putam is executed, again, over proxy, targeting the, oops, targeting  the mssql service, and it reaches the site database, it makes it back through the reverse  port forward, you can see that the ntlm relay was successful, that's right here, if you  can see the text, and now, because the SQL statement successfully executed, based on  the SCCM takeover primitive that we're abusing, we should be added to that database as an  administrator, so we go back to SCCM hunter, I want to verify first that I am an admin,  I use SCCM hunter, my domain user is now added as an administrator, so that's basically the  primitive there, but just to kind of take it a half step further to demonstrate what  leveraging this abuse would look like, I do get device, get the relevant kind of metadata  about the primary site server that we're targeting, and then I run the script command to just  see if I can execute code arbitrarily on this primary site server.  I get an error that says alternative approval credentials are required, this is a configuration  that can exist in SCCM deployments, so that's not gonna stop us, Garrett has already accounted  for this in SCCM hunter and added functionality to leverage an additional user as that approver,  so in this command, I'm just specifying my domain user, which is already added as an  admin, any other domain user that will be the approver, and the first thing I do is  I add that other domain user as an admin, we're already an admin, we can add another  admin, so now I have two admins in the site database, and I use that second user that  I've added as the approver, so I again get the device information that I need, then  I interact with the primary site server that we're attempting to get privileged code execution  on, and I list the contents of the public folder, the only reason I'm doing this is  because the scripts that I'll be executing, all it does is drop a text file called we  made it to the public folder, the contents of the file will be the user context that  we're executing in, just because I want to make sure it's privileged, so I list the contents  of the folder, then we run script again, hopefully with the additional approver credentials,  everything works, it looks like based on the results, there's no result because all it's  doing is creating a file, but it says it's successfully executed, so we're going to again  list the public folder, and the we made it file was dropped, but we want to know the  user context that we executed in, we cat that file, we see that we executed on the  primary site server in a system context, and then the last little bit here, because cleaning  up is important, is the second script is just deleting that file, and then we list again,  and we made it has been removed from the public folder of the primary site server, so we've  talked about a lot here between the static and dynamic reversing of the binding process,  how does that relate to unbinding, and then actually implementing the theory that we had,  but to kind of summarize all that, simple interactions with the service control manager  can result in port 445 being unbound, and the demo that we just went through is kind  of an example of why that is important, at least for us on assessments, and then again  the important note, if you're doing this remotely, you probably want to conduct this  over using RPC over TCP, because you'll have connectivity issues once you disable if you're  using named pipes, I will be releasing the both in Python implementations that you saw  in these demos, probably within the next few days, like sometime this week most likely,  but I also want to remind you if you're having a problem with one of my tools, I don't always  write the best code, you don't have to use them, there's an endless number of tools out  there that you can use to interact with service control manager, use your favorite one, maybe  just check if it's using RPC over TCP by default, and hopefully the technique that's presented  here will provide somewhat of a lower touch solution to taking over inbound port 445 TCP  traffic so you can conduct your targeted NTLM relay attacks.  And thank you very much for your time.  I think we have a few minutes.  Yes, we do.  Thank you very much for the presentation, quite interesting.  So do we have any questions?  Nobody?  Any ideas what we can do for detection?  Maybe somehow something starting to listen on that port that is not expected to?  I have no idea how common that is.  Yeah, perfectly timed question, I was just chatting with someone named Lucas, I'm not  sure if they're in here or not, but gave me a couple great ideas that they have already  implemented internally for this, which is from a couple different perspectives, one  kind of specific to the attack is looking for non-standard processes listening on port  445.  So it should be system, it's kernel things happening that is normal.  So if there's a process other than system listening on 445, that should be relatively  high fidelity.  As well as, let's see, there was some RPC filtering potential as well, but I might have  to follow up on that.  Oh, the other one that he also mentioned, that Lucas also mentioned, was the disabling  of services in a particular order.  So I wouldn't imagine on workstations or servers that it would be standard practice for anything  to disable even landmine server service, more specifically all three of these sequentially.  So if that happens in a certain time period threshold or really at all, I think that would  be a pretty reliable way to detect this.  Cool, thanks.  Cool finding, Nick.  The thing I was wondering is, did you notice any instabilities or crashes or other stuff  when you disable three of those services?  I can imagine, of course, a server not being accessible anymore over Samba, whatever.  But did you encounter any other stuff while doing ops?  Yeah, that's a great question, probably something I should have elaborated on more.  We've used this on a lot of assessments, almost every Windows assessment in the last six months,  and we've had no stability issues.  I don't say that with the intention of convincing you that there are no stability issues.  Whenever I drop in on an assessment and somebody is doing this on a production server or something  that's important, I think it would be incredibly important to understand what's running on  the host that relies on things like name pipes.  Because if a critical service relies on name pipes, for example, you're going to cause  massive issues.  So I feel a lot better about doing this on workstations, just because generally, hopefully,  there's not critical services running on somebody's laptop.  But definitely understanding what's happening on the server would be important.  Great question.  Cool, thank you.  There's another one.  Yeah, thanks for the talk.  I was also thinking about detection capabilities and what was your experience during your engagements.  I mean, you mentioned you used it for almost half a year now.  Do you have any scenario where it got detected, like from an EDR or maybe by some kind of monitoring,  which is specifically looking for those kind of services being stopped?  So did you have any experience on this?  Yeah, so the question was, the time that we've been using this, have we had any detections  or preventions associated with the technique?  We have not.  And just my biased opinion, I think a lot of our customers put very heavy emphasis on  their security programs and generally, relatively mature.  We have to work really hard.  I think we have to work really hard to compromise and not be detected while we're doing that.  And in all of those environments, we haven't had detection or prevention.  And again, on the flip side of that, I'm not saying that you're completely evasive, fully  undetectable.  There's obvious telemetry associated with this technique.  And I won't say in six months that there won't be a popular correlation for doing this.  But currently, we've had no problems up to today.  Anyone else?  This does not seem to be the case.  Okay, so this concludes basically our second block.  Thanks again, Nick, for your contribution to Toolbus.  Thank you.