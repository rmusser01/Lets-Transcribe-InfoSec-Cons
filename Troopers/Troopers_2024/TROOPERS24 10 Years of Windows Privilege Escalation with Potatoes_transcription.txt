{
  "webpage_url": "https://www.youtube.com/watch?v=rPZx1zbKJnI",
  "title": "TROOPERS24: 10 Years of Windows Privilege Escalation with \"Potatoes\"",
  "description": "Talk by Andrea Pierini - June 26th, 2024 at TROOPERS24 IT security conference in Heidelberg, Germany hosted by @ERNW_ITSec\n\n#TROOPERS24 #ITsecurity \nhttps://troopers.de/troopers24/talks/cyzbj3/\n\nMore impressions:\nhttps://twitter.com/WEareTROOPERS\nhttps://twitter.com/ERNW_ITSec\nhttps://infosec.exchange/@WEareTROOPERS\nhttps://infosec.exchange/@ERNW https://ernw.de",
  "channel_url": "https://www.youtube.com/channel/UCPY5aUREHmbDO4PtR6AYLfQ",
  "duration": 3272,
  "channel": "TROOPERS IT Security Conference",
  "uploader": "TROOPERS IT Security Conference",
  "upload_date": "20240902"
}

This text was transcribed using whisper model: large-v2

 Hello, and first of all, thank you for joining my talk, which will be about the wonderful  world of the Windows privilege escalations using potatoes.  First of all, you see two names here, myself and Antonio, my friend and partner in crime,  because most of the researches that I will discuss today, we did them together.  And part of this talk was presented by him last November in Seoul.  But I have some news, so it's not the same talk.  Oh, why doesn't it work?  It worked.  Oh, good, yeah.  Two words about me.  I am Andrea Pirini.  I am Italian, but I think that's an easy guess just listening to my bad English.  I work for Semperis in the bridge preparedness and incident response team as a senior security  consultant, senior because I'm old, because I'm not that expert.  But OK, keep on.  During my spare time when I'm not cycling or doing other fun stuff, I like diving into  the world of the mysterious world of offensive security.  And, of course, I am a potato lover.  These are my handles.  If you want to get in contact with me or read my blog post, here you have it.  Why this talk?  In very, very short, we wanted to share our journey in trying to find new potatoes technique.  This is what we did.  And we spent a lot of time, endless times, endless nights.  And we used crazy ideas to find always new vulnerabilities in order to exploit what we  call the potato technique.  So this talk will not go too much in the details, because one, it is boring, and two, it will  take too much time.  So I will keep it, I hope, interesting and just more simple explanations and not going  too much deep in the technical details.  The agenda, after a brief introduction on what is considered by Microsoft a privileged  escalation, so what is a security boundary violation and not, we will delve into the  RPC Decom trigger, which is the trigger which permitted us to find a lot of vulnerabilities  via the potato techniques.  And after this, we will analyze how it was possible to break the boundaries, the safety  boundaries and the security boundaries, local and then also from remote.  You see here three asterisks.  These are the new findings.  This is a total new entry.  So I will, the first time, talk about this in this session.  So I hope you will enjoy it.  And then, obviously, at the end, the conclusions.  So let's start with what is a privileged escalation.  Well, I can say what is not a privileged escalation from Microsoft's point of view.  It's not a privileged escalation from admin to kernel or user account control bypass.  And it is not a privileged escalation when you abuse a service account or you bypass  the Windows service account hardening.  This is considered a safety boundary and it is not considered a security violation.  Alias, the behavior is by default or the behavior is as expected.  And then sometimes they silently fix, but it's up to them.  What is a security boundary violation?  Of course, from standard user to admin and the various sandboxes bypasses.  So this is my personal consideration.  I still don't understand the bounty politics of Microsoft.  But probably I'm an old-seasoned legacy on-prem guy.  So it's difficult for me to understand this decision.  I don't know what you think about it.  But yeah, that's my personal opinion.  And I wanted to share it with you.  Okay, where it all began.  It began 10 years ago.  Therefore, 10 years of potatoes exportations with James Forshaw.  You will hear his name several times because he did a lot of fantastic researches.  And which helped us very much in our researches too.  So we hear his name very, very often.  And it started with the local NTLM reflection attack reported in 2014 and fixed in 2015.  This was the very, very first, let's say, potato technique.  Because then the name potato came after.  But this is the very, very first potato technique.  So how does this work?  I try to keep it very, very simple.  So we have a malicious COM object.  Okay, I have the screen here. Perfect.  We have this malicious COM object, COM client, which tries to trigger a privileged COM server service.  And how does it trigger?  Using a special call, a DCOM call.  It's COGET instance from my storage, blah, blah, blah.  With a class ID.  By triggering this COM server service, what happens is that the client crafts a controlled Marshall object.  Standard REF Marshall object.  And this object contains some important information.  The auxit resolver address he should connect to.  The auxit resolver port.  And this can be controlled by the malicious user.  And this is very, very important.  Because auxit resolution is needed for locating, for the COM server, to locating the binding information on where to contact the COM server.  So think about it as a DNS for DCOM.  And the other funny thing is that this call is authenticated.  So when we trigger this COM server, what happens is that the privileged COM server will perform a resolve auxit 2 call.  And it is an authenticated call.  So we, as a malicious user, can intercept the authentication.  And then use it.  But we can go further.  We can also send to the privileged COM server service a string binding containing the information about a fake RPC server under our control.  And the COM server, which happily contacts us via the IRAM unknown interface, unknown 2 interface call, will contact us.  And again, it is an authenticated call.  So at the end, we have the possibility to intercept this authentication.  And then, depending on the context, we can reflect or relay this authentication.  And this is the whole magic.  So it's not black magic, but it's a behavior by default.  But as usual, there are a lot of behaviors by default which are most of the time ignored.  And then when someone discovers it, they can order it.  But this can also be abused.  And this is the case.  So we have what I call profit 1 and profit 2.  Remember these two?  We have two authentications we can intercept and manipulate.  The second one was implemented by us, starting with the raw potato tool, I think three or four years ago.  And this is the first time we implemented a raw oxide resolver so that we could also abuse this second authentication.  So let's start from the very beginning, from service to system.  So a safety boundary violation.  When I say service, I mean abusing the impersonation privileges.  Because normally, services have at least impersonation privilege.  So it's a matter of abusing this privilege.  I think that you know this tool?  Yes? No?  Ah, good. Okay.  This was the very first implementation.  It was done in 2016.  And it was the first tool which triggered the DECOM server.  And it was somehow limited because it used only the bits CLSID and used a fixed port, which was 666.  And basically what it did is triggered authentication, intercepted authentication, negotiated a system token,  and then impersonated the system token.  So once you have impersonation privileges, you impersonate the system token and your system.  And this implementation worked only with Meterpreter, so it was somehow limited.  And then came our juicy potato.  Juicy potato, you know it, yeah?  Ah, cool.  This was coded by me and my friend Giuseppe in 2018, so many years ago.  And it was what you call the sugared version of raw potato because it permits you.  We found a lot of other interesting CLSID to abuse.  It is possible to specify a port instead of a fixed one.  And also, it is standalone.  So it uses create process as user or create process with logon token to use the token  and then launch a process under the system identity.  And it was heavily used because it was very simple to use.  And once you compromise the system or an IAS account, an MS SQL service account,  it was very easy to perform a safety boundary violation.  This was, let's say, fixed.  We're starting from Windows Server 2019.  And with this version, it was no more possible to specify a custom port.  And then this fix was backported in 2022, also in Windows 2016.  So juicy potato stopped working.  How was this performed without going too much in details?  Simply by escaping the custom port.  Not exactly escaping the custom port.  Escaping the brackets around the custom port.  So once they had escaped, the exploit breaks and it doesn't work anymore.  And so goodbye, definitely, to juicy potato.  But obviously, meantime, we had other ideas.  So we started with raw potato.  In raw potato, instead of using the local port, and we can no more specify a local port,  we used a redirector on a Linux machine, the socket redirector,  which then redirects the calls from port 135 to a custom port  on a service running on our machine.  And this service is the fake auxit resolver.  What does raw potato do?  First of all, it uses name pipe instead of TCP IP.  And it creates a custom fake port mapper endpoint.  This is very important.  The port mapper endpoint is the equivalent, again, of the DNS for RPC.  And the trick was, because we cannot create another mapper endpoint,  because it already exists in the name pipes.  But the trick was to escape somehow the checks,  so that it is possible to create a port mapper under another, let's say, subdirectory.  But because there is a bug, and there is still a bug,  in converting the slash chart, as you can see.  So if I specify localhost slash pipe slash blah blah blah,  it converts it in a real name pipe path.  So once we have the name pipe, it is very easy to impersonate the caller,  which is in this case system.  Once we have impersonated the caller,  we are network service in this case,  because the process is the RPSS service.  Network service is not that interesting,  but in this process, the RPSS service,  we have the authentication ID of the RPSS,  which permits us to access a lot of juicy tokens,  system code tokens, and whatever.  So with a simple token kidnapping,  once we have access to the process,  we kidnap the token of the system user,  and then we authenticate,  and then we use this token for creating new processes.  This is a simple screenshot on how RockPotato works.  Classic web shell with a CMD.  I am the default IIS user,  which has impersonation privileges.  I launch my tool, and I get back a system shell.  So again, a safety boundary violation.  With this idea in mind,  so intercepting the second authentication and abusing profit too,  we also rewrote part of Juicy Potato  so that it is possible to intercept the second authentication,  and in the meantime, using a trick from James Forshaw,  we could also get rid of the socket redirector,  because we are no more interested in the first authentication,  but in the second authentication,  which is returned via the string bindings  by our fake auxit resolver.  So we are able to intercept this authentication,  but sadly, in this case,  we don't have that much CLS ID to abuse,  because most of them return you an identification token,  which is really useless.  Then there was the PrintNotify service,  which was the perfect candidate,  because it returned an impersonation token,  but then it was a problem,  because it needed the interactive seed.  So we used a trick to recover the interactive seed,  and we were able to perform the full escalation.  After some months, Microsoft fixed the possibility to use this trick,  but luckily, starting from Windows 11 and Windows Server 2022,  we have this other service, the MCP management service,  which has its own CLS ID,  and which permits you, again,  to get an authentication from the system  with the impersonation token.  So it's okay.  So basically, what we did,  I called it a juicy potato NG,  so we gave a second chance to a juicy potato.  And this still works,  but again, we are always talking about safety boundary violations.  So in this screenshot, you can see very, very easy  to, once you have an impersonation privilege  or an assigned primary token privilege,  escalate to system,  just launch the tool, and you're done.  Obviously, there are a lot of other contributors  with a lot of other cool potato techniques.  Here are some of them.  Always safety boundary violations,  and there are also other new ones,  so it's up to you.  But there are a lot of other possibilities  to abuse these potato techniques,  so I only describe the one we found in this case.  So let's get it a little bit more interesting.  With rock potato, with the technique of rock potato,  so we thought,  but is it possible to perform a real privilege escalation?  Because we have all the elements.  We have to understand how we can abuse the authentication,  and if you can get another type of authentication.  And here comes remote potato zero,  which is the first security boundary violations.  In this case, we are relaying the NTLM authentication.  It's a local exploit,  but the relay is performed on a remote server,  and what does the remote potato do?  It abuses some com servers,  which impersonates the logged-in user,  and this is interesting,  because the idea is intercept the authentication  of the user connected on another session,  and relay the authentication to an external server.  So imagine that if you have an admin or whatever user  which other privileges connected,  I can trigger his authentication  and forward the authentication via NTLM  to a target server,  where I want to access resources on behalf of this user.  We had the problem because by default signing was enabled,  so this limits somehow,  but with another trick,  we were able to downgrade to RPC-level connect,  which means then signing is no more enabled,  via the Resolve Auxit 2 call.  So the main scenario is obviously  when you have a privileged user  in a multi-user environment,  imagine a remote desktop,  a privileged user,  I trigger his authentication,  and I relate to LDAP.  Imagine a domain admin.  I know that domain admin should never log on on non-tier 0,  but who knows, maybe it could be possible.  So you can relate,  and at this point,  you relay the authentication,  and depending on the user you are relaying,  you can take over the domain.  So in this screenshot,  it's just an example.  We have a standard user,  a domain admin user,  which is connected on another session.  I launch the Remote Potatoes 0 tool,  specifying the session,  and then I forward.  I am able to intercept the NTLMv2 hashes.  I forward the NTLMv2 hashes to an external relay,  for example, NTLM relay,  and then I can do whatever I want.  What we did in Remote Potatoes  is also to perform before a local relay  from DCOM to HTTP  so that it is more easy to interface  with external relay tools,  just like, for example, NTLM relay.  We obviously reported this to Microsoft  before publishing it,  because for us, it's a security boundary violation.  And what Microsoft said,  after a long debate,  a long analysis, and so on,  that server must defend themselves  against relay attacks.  And for this occasion,  we created a special T-shirt for this.  Sadly, I forgot it,  because I wanted to show you this T-shirt,  but I left it at home.  But 18 months later,  kind of unintended fix,  broke Remote Potatoes  because it was no more possible  to control the signing.  So it is always signed,  so the relay versus LDAP, for example,  won't work anymore.  But it still works  where SMB signing is not required.  For example, SMB, HTTP,  SMB signing is not required,  but normally the default is on domain controller, yes,  but on file server and so on,  we leave the default, which is not signed.  So you can do, a malicious actor  can do a lot of nasty things,  still can do a lot of nasty things  with Remote Potatoes 0.  So move on, on Local Potato.  This is a curious story,  because it's kind of,  I wouldn't call it a bug,  but again, it's by design.  In the local and telemetry authentication,  so we are again speaking about local,  local and telemetry authentication is a particular authentication,  it's a loopback local authentication,  there is a reserved field,  which is called reserved field,  that is very interesting,  and thanks to our friend Ilad Shamir,  which gave us this hint,  we tried to understand if it is possible  somehow to abuse this field,  because we had in mind a kind of swapping,  and this is what we did.  So in the local authentication,  the reserved field references the LSAS context,  where the user should,  where the authentication should occur,  associate and occur.  So the idea is,  why not triggering the authentication  of a privileged user,  of a system account,  swap the context with a user under our control,  and then authenticate to another server,  to another service running on the same machine,  because it's always a local privilege escalation,  and that was what we had in mind.  First of all, we trigger a system authentication,  and we know how to do it.  We want to target, for example, the local SMB server,  and perform an arbitrary file write with system privileges,  which is really the key to the kingdom.  We had to overcome some anti-reflection mechanisms,  so we have to specify an SPN,  and once everything is set up,  we intercept this authentication,  we magically swap them,  and then what would happen?  That we are able to authenticate as a system  to the SMB server,  and then once you have an arbitrary file write,  it's up to you to understand how you could abuse it.  For example, we hijacked the printconfig.dll  in the printer service,  and we were able to use our malicious DLL  to get a shell, for example, as a system.  So how does this work?  We have, first of all, our privileged client,  and we trigger the authentication of our privileged client,  and we associate it with context, let's say A.  Then we have also a client process under our control,  which tries to authenticate  versus the server service,  for example, the SMB server,  and our client gets back the context B.  Then we swap the context,  so that the privileged client  will associate with context B,  and our client contacts with context A.  And at the end, if everything works fine,  the privileged client will authenticate  against the server service, SMB in this case,  and the client process  will authenticate against our server service.  Okay, I have also a video demonstrating this.  You see, I have here a standard user  without particular privileges,  and my goal is to overwrite the printconfig.dll.  Okay, I get no output here.  Something strange happening.  No.  Okay, let's do it another way.  Okay.  Okay.  It's not easy now, but...  Ah, sorry.  Okay, we skip the video for now, and then we'll see.  So, extend this display.  Okay.  Hmm.  It's frozen.  Sorry, but...  It's more than the demo effect.  It's always Windows, no problem.  Okay.  Okay.  Something is not working because...  I still...  Okay.  Okay, without showing the video, but here you get it.  I am able, with our local potato exploit,  to overwrite the DLL,  then I instantiate the object,  and I get back a system shell  because in my DLL I put the instruction  for returning a shell.  That's all.  That's clearly...  No problem.  That's clearly a privilege escalation, obviously.  And...  If I can get out of this video.  And clearly Microsoft fixed it with this CVE.  And what Microsoft did is that...  This is the reverse engineering of the fix  which was done in this DLL.  If the caller is from an unverified source,  and this flag is set by the TComp client,  and if the SPN set is set,  the SPN is deleted,  so the anti-reflection mechanism won't work,  because I have no SPN,  and the exploit breaks.  So, but...  It still works against HTTP.  WebDAV, it's a very, very edge case,  but it still works.  Or, versus custom authentication,  which uses the security provider.  And Microsoft did not want to fix the second one,  because we reported already the second one.  They said, no, but this is too complicated,  so it's an edge case,  so you have to protect your endpoint,  you have to use extended protection,  blah, blah, blah, blah, blah, blah,  and it is not fixed.  So, if you go on my blog post,  I think I published also the...  No, the latest local potato source code  is also for HTTP,  so you can try it at home,  and see that it still works.  Then comes fake potato.  Fake potato is the one with the asterisk,  because it was discovered by me  three months ago, let's say so,  and it's a local privilege escalation,  still waiting for Microsoft fix,  so, unfortunately, I cannot spoil that much.  It's not exactly a potato technique,  so it's something a little bit different,  and it's cool, because it's logic pack,  I think it was there from Windows 2000,  so it's something that,  I don't know why it was never found,  and because it requires an unexpected prerequisite,  but which is not that strange,  so, and when I discover this,  no, it's not possible,  it's something that fucked up on my machine,  and Microsoft confirmed that  it is a security boundary violation,  so it has to be fixed.  I have a video, I don't know,  I pray the God,  but before showing you the video,  I obviously asked to Microsoft,  and they told me,  okay, send us the video,  in order to avoid the usual drama,  so send us the video,  and we will tell you if it's okay or not,  and you can see the mail,  they told me,  okay, you can show the video,  but do not spoil other things,  so I will only show you the video,  and I won't talk.  Will it work now?  That's a good question.  Okay.  Oh, okay, okay, great.  Oh, okay.  In the first,  I have an administrator connected on a session,  another session,  I have another user, standard user, okay,  you see two sessions,  now I launch my fake potato tool  against the admin session,  and let's see what's happened.  Oops, desktop changed.  But, okay.  Let's get more serious, okay?  So, I relaunch the tool with another mode, okay?  And let's see what happens.  I get back a shell of the administrator.  This is clearly a privilege escalation.  But, don't ask me anything, please.  Okay?  So, now the last one,  which is the security boundary evaluation from remote.  So, the idea behind is very simple.  Instead of triggering a local com server,  why not triggering a remote com server?  This would be a great remote local privilege escalation.  Okay?  In fact,  obviously an external auxiliary server is required in this case  for the first authentication.  It's very, very simple because  with just a few changes on the code  by specifying the remote server and optional credentials,  I should trigger the authentication of a remote server  because it's in the library.  I can specify all the local or the remote server.  So, that would be great because  once I have captured the authentication NTLM Kerberos,  I could then relay it.  And this is also a great opportunity for Kerberos  because I forgot to tell you that  it is possible to relay Kerberos authentication  under certain conditions.  If you have the control of the service principal name,  you can perform a Kerberos relay.  And this is the perfect scenario because  I am able in my fake OXID resolver to specify the SPN  and so I can relay also the Kerberos authentication.  But there is a great but.  Non-admin users generally cannot instantiate remote objects.  So, to instantiate, to create a COGET instance on the remote,  you need domain admin or local admin rights.  So, any chance?  So, I started looking at the DCOM configurations and so on  in order to find vulnerable DCOM server.  And the first one I found,  I called it ADCS Squares Potato,  which is related to the certification service.  So, on the server where the ADCS services are installed,  there is this group, the Certificate DCOM Access Group,  which contains the authenticated users, everyone.  This is needed because users or computers  should be able to request and enroll certificates via DCOM.  So, this is clearly something by default.  So, users can activate these applications from remote.  As you can see, the Certificate DCOM services  have local and remote activation.  The certification service DCOM application  impersonates the system account.  So, via the network, it's the computer account  and is activable by everyone, every authenticated user.  So, what is the idea behind? Very, very simple again.  It's just activating this object via the potato technique  that requires the authentication of the server  and we will relay this authentication.  So, what can we do when we have the authentication  of the certificate server?  I think we can do a lot of cool things  because this is a Tier 0 computer account.  This one was discovered also before me, some time before,  by another Chinese researcher.  Unfortunately, I'm horrible in spelling,  so I just say Chinese researchers.  It was partially fixed with this CDA.  As you can see, again, the concept is always the same.  I have a standard user.  I request the authentication.  The first IP is the IP address of the certification service.  And then I have my redirector  where also NTLM relay is running.  I pass my credentials and as you can see,  everything was fine.  This is the dump of the NTLM messages  and at the end, I get the authentication  of the certificate server.  So, what can I do now? Relay it.  We have a problem because signing is now enabled,  so we cannot relay versus LDAP or whatever.  And we could relay against the HTTP Web Enroll Service  because we then request a certificate of the ADCS server.  And as you can imagine, if I have the client,  the certificate for authenticating as the certificate server service,  I'm done because I can perform code execution  on the certificate server machine,  back up the public and the private key,  forge fake certificates for whatever user I want,  and take over the domain.  But unfortunately, you cannot relay back NTLM authentication.  So, I cannot relay back the authentication  to the certificate server itself.  So, yeah, it's really limited.  But wait, there is a great opportunity with Kéberos  because with Kéberos, you can relay back the HTTP.  So, the server can relay back the authentication to itself  via the network if I use HTTP.  And this is interesting because if I don't have  extended protection enabled or I do not require SSL,  I can request a certificate.  And this is the screenshot with my modified version  of the great Kéberos relay tool  where I target the Web Enrollment Service.  My DECOM host is, again, the ADCS web server.  So, I trigger the authentication, relay it back,  request a certificate, and obtain the certificate  for client authentication of the certificate server.  And I'm done.  So, yeah.  And therefore, we should always use extended protection,  blah, blah, blah, because this still works.  So, you know if you don't use these countermeasures,  you are at your own risk.  But I didn't stop here because digging further into the DECOM,  I found these two groups.  I call them the forgotten groups,  and this leads me to remote silver potato.  We have these two groups which are built in,  I say not so well-known groups,  which are the distributed com users group  and the performance com users groups.  From Microsoft description, we understand  that they can somehow interact with the DECOM server,  and that is interesting.  So, members of these two groups can launch  and activate DECOM services from local and remote.  So, not only activate, because activate means  that the service needs to be running,  and launch means that I can start the service from remote.  So, the performance local users group  and distributed com users group can do these things.  This is cool.  Now we have to find a service which can be launched,  activated by these users,  and which has an authentication which could be useful for us.  And I found this object, the SPPUI object interactive class.  It's related to the Windows license service,  which is the perfect candidate  because it runs as an interactive user,  and it can be activated and launched by everyone.  That does not mean that it's by everyone,  because then you have the limits by the DECOM  and the members of the DECOM performance local users group.  So, this is a very, very interesting scenario.  So, by triggering this service,  we should get back the authentication  of the interactive user connected on some session.  If you are a member of this group,  it's not correct to call them domain,  but on the domain controllers built-in group,  you can imagine that this could be very, very dangerous  because normally, on a domain controller,  the domain admin logs in.  So, if you could trigger the authentication of the domain admin,  well, that's interesting.  So, how does this work?  We have an attacker,  which is a member of the DECOM users or performance log users group,  and then we have a V Team connected on a domain controller.  So, again, with the potato technique,  I trigger the authentication with the CLS ID of the SPP UI service,  which triggers the V Team connected on a session  to authenticate to my endpoint.  Because, as we saw,  we will perform an authenticated resolve-auxit call.  We are able to intercept this authentication,  in this case from the domain admin,  and use it.  We can also return a string binding,  which contains the port and an optional SPN  of our fake RPC server,  and we have another authenticated call,  and we have the second profit.  So, I did this, I tested this,  and for the first one, it's okay.  I was able to perform an NTLM relay attack  with an impersonation level,  which is what we need.  In the second one, sadly,  you have an identification level,  which is really useless,  because signing is enabled,  so you can't even relay versus LDAP.  I obviously reported this to Microsoft before,  and initially they said it was a critical finding,  but then after some time,  they assessed it as a moderate risk,  and that does not need an immediate servicing.  So, I can talk about this, okay?  Okay, I have the video.  Finger crossed.  It works, great.  So, I have my user,  standard user,  and a member of this, let's say,  domain, distributed com users group.  On the other,  then I am here in the worst scenario,  because I have NTLM V1 enabled.  So, in NTLM relay,  I will remove the message integrity check  and disable signing, okay?  I launch my tool,  where I specify the domain controller address,  again, my redirector and the host  where NTLM relay is running,  and the session, okay?  Once I launch it,  as you can see at the end,  I am able to get authentication administrator.  I will forward that indication to NTLM relay,  which will forward it to LDAP,  which will create a user account  with DC sync rights.  So, from a standard user,  I took over the domain.  That's something that...  I don't know why they did...  They said, no, no, it's not that...  Because in my job,  because this is a hobby,  in my job, I do active directory assessment,  and I found it at least two or three times  that this group was populated by non-tier zero users.  So, therefore,  we should consider these two groups  absolutely tier zero,  until Microsoft decides to fix something.  This works also on a local group,  on a local server,  but obviously a domain controller  is much more interesting, okay?  So, the next step was Kerberos.  Okay, NTLM, I can't relay NTLM.  Why not relaying in Kerberos?  Well, here we have two problems.  The first one is that  original Kerberos relay tool,  which is a great tool,  only intercepts the first authentication,  the second authentication.  And the second prerequisite  for performing Kerberos relay  is that you have to control the SPN.  So, for the first problem,  I recorded Kerberos relay.  It was really a long, tedious, and boring task  because I had to implement a raw socket server,  intercept the authentication,  extract the Kerberos,  and then move back and forth  between DCOM and SMB.  It was really...  I was giving up several times,  but at the end,  I was able to get it working.  And then we have the second one, SPN.  Sadly, in the first authentication,  when we return the string bindings,  even if you return an SPN,  the SPN will always be rpcss  slash the server  where our socket redirector is listening  because it's from where it's coming from.  So, no chance.  Then again,  thanks to a trick from James Forshaw,  we can bypass these SPN limitations  by adding a forged DNS name.  Because the Kerberos security provider extension  supports a special format for the SPN,  which includes the target info.  So, the syntax is the following.  Service class slash server,  which is the classic SPN,  plus the base64 encoded target information.  And Kerberos will ask for a service ticket  service server class,  server class server.  And the auxet resolver will try to contact  a server, which is server  plus the base64 address.  And the shortest base64 target info address  is this one,  which corresponds to a completely empty target information.  But the security provider will happily accept it.  So, what I did is  add the DNS record  with this strange name,  because normally standard domain users  can perform secure DNS updates.  And then relay the application request ticket  to a target server  on behalf of the user,  in this case the domain admin.  Again, this is the scenario.  User, member of these groups.  Victim, connected domain controller.  And the target server, where I want to access resources  on behalf of the victim.  So, what happens?  Again, I perform,  I trigger the authentication  and then in the  socket address I specify  this name, because I created this DNS name.  The victim will ask for a service ticket  RPSS slash target.  It will try to authenticate against me  with this application request ticket.  The attacker will simply forward this ticket  to the destination server.  And relay is successful.  So, just to demonstrate to you  that it does not only work on PowerPoint,  I have another demo.  Okay.  Oh, it works, great.  So, I create IDCS,  dash MyLab is my IDCS server, okay?  And this is the...  Okay, sorry.  Okay.  Okay.  So, with the Invoke DNS update tool  I create this DNS record.  Okay, now I have it.  I capture the traffic just to show you that  it is what was expected.  I launch my Silver Potato tool  targeting...  In this case, I want to target the SMB server  of the IDCS server.  Okay?  With this strange redirect host.  And as you can see, I want to dump  the local sum account database  and I was able to dump the admin hash.  Okay?  And as you can see, the SPN is the one we expected.  And...  This is all the traffic  for the remote registry access,  dumping the sum database, etc.  Once you have, again,  the hash of the local administrator,  you can log on, okay?  Again, perform a backup of the private key.  Elevate to system, perform the backup  of private key, etc.  And you're done.  So, you have, again, another possibility.  So...  We are at the conclusion.  Okay, perfect.  What can I say?  First of all, that with Potatoes,  we break safety and security boundaries.  Okay?  Most MS fixes were already partial  or even not implemented  because it's by default.  Future NTLM disablement  will stop some relay attacks,  but remember that if you have control over SPN,  you can relay cables.  The question is,  will Potatoes be still alive and kicking?  Who knows?  Maybe we should find a Potato in the cloud,  but it's not for me.  So...  Second conclusion for the defenders.  So, because many of these attack paths  at the end lead to relaying the authentication.  So, Microsoft always tells us  you have to disable NTLM  because it's dangerous, etc., etc., etc.  But, as we can see,  Kerberos can be relayed too.  So, the only way is to protect our endpoints.  So, I hope you enjoyed my talk.  Sadly, I had some problems, but...  And...  Thank you!  Thank you very, very much  for this interesting talk.  And I guess there will be questions in the...  Yeah, back there.  Some of the...  Thank you.  So, some of the attacks  which you were talking about  were using the web dev  or web client service.  And, of course, one of the countermeasures  would be to disable this service.  Have you seen any dependencies on this service?  Like, what could go wrong if you disable it?  Okay, probably...  The only attack I performed  via local potato expat, via web dev,  was with local potato to demonstrate that  via HTTP, it was not fixed.  Obviously, it's an edge case.  Via HTTP.  So, I configured a web dev server  in order to have an arbitrary write  via web dev HTTP.  So, this is...  The other attacks have nothing to do with web dev.  It's versus SMB or whatever.  Or versus the web enrollment service.  This is just to show that  there is still a possibility.  Imagine that you have a web application  but you need to have local access  and then you are able to authenticate  on this web application a system account.  So, depending on how it is configured,  you could do nasty things.  But it's really an edge case.  Okay, thanks.  But still, have you seen any dependencies  on the web dev service, web dev client?  Like any Windows component  or third-party application actually  using it, requiring it?  No.  To be honest, no.  Thanks.  But maybe it's just limited to my experience.  Thanks for a great talk.  Are there any other questions?  Okay, then.  Thank you again.  Or it was too complicated or it was really easy.  So, no questions.  I go for the second one.  Thank you.