{
  "webpage_url": "https://www.youtube.com/watch?v=EzKOWIeC-54",
  "title": "TROOPERS24: Deep Dive into Windows Defender: Smart App Control and ETW",
  "description": "Talk by Tillmann O\u00dfwald and Dr. Baptiste David - June 27th, 2024 at TROOPERS24 IT security conference in Heidelberg, Germany hosted by @ERNW_ITSec\n\n#TROOPERS24 #ITsecurity \nhttps://troopers.de/troopers24/talks/msxp97/\n\nMore impressions:\n  / wearetroopers  \n  / ernw_itsec  \nhttps://infosec.exchange/@WEareTROOPERS\nhttps://infosec.exchange/@ERNW https://ernw.de",
  "channel_url": "https://www.youtube.com/channel/UCPY5aUREHmbDO4PtR6AYLfQ",
  "duration": 3654,
  "channel": "TROOPERS IT Security Conference",
  "uploader": "TROOPERS IT Security Conference",
  "upload_date": "20240909"
}

This text was transcribed using whisper model: large-v2

 Hello Troopers, so it's still a great pleasure to be in front of you today.  So as Daniel said, we are supposed to be two, but one of my colleagues is sick today, so  please excuse him.  He has tried his best to be back, but unfortunately, sometimes we cannot.  So the topic of this talk is to go on a journey inside a new feature of Windows, which is  called Smart App Control, and for that, Dr. David Baptiste, I'm French, which explains  my weird English accent, I would say.  I'm working since two years for ENVE, which is the host of the conference, and I'm a security  researcher over there.  I make a couple of conferences, including Troopers, so it's always a great pleasure  to be with you today.  As we said for Thiel, he cannot be here present today, but a very great guy, and also another  person works for us on this topic, which is Dominic Phillips, he works for many years  in ENVE, and he should be mentioned in this talk also.  So Smart App Control.  With Windows 11, especially the version 22572, a new security feature has been introduced,  first in Windows Preview, and then in other operating system versions of Windows 11, which  is called Smart App Control.  And the main idea of this feature, which was new, as announced by Microsoft, is to block  what they consider as unsafe applications.  So more directly, it's just going to focus on what is considered to be safe on your laptop  or your machine, and remove everything else.  Nothing else can be launched except that.  But the point, of course, of such a feature is to be able to define what means a safe  application.  And it's exactly how it's going to work, because from Microsoft documentation, some people  will say marketing stuff, it's written to be the decision of checking which application  is safe or not.  It's an intelligent cloud-powered security service, which is not so meaningful from my  point of view.  So BSC in Germany asked us to study these features and to document how it works to make  an evaluation of what is real behind the stage.  So today we are going to check what is behind the stage of Smart App Control and Windows  Defender, because both are really connected.  A bit of documentation before, just for announcements.  Smart App Control, so it's literally from Microsoft Doc.  Smart App Control works alongside your other security software, such as Microsoft Defender  or non-Microsoft antivirus tools.  Smart App Control is based on a technology which is called WDAC.  WDAC stands for Windows Defender Application Control.  As a notion of application control, it's defined also in the documentation like a feature to  help to mitigate this type of security threat by restricting the application which are allowed  to run on your system or not.  And as it's correctly written, application control is a crucial line of defense, okay?  Which takes inherent advantage of a traditional antivirus solution, so it's not an antivirus  solution, which moves away from the trust model, which is based on applications which  are assumed to be trustworthy or not.  And that's the idea of application control, only to execute the application which are  defined to be safe.  And as an important note, still from Microsoft documentation, they always recommend you to  maintain an antivirus.  So for short, Smart App Control is not an antivirus, just based on what we read in the  documentation.  It's based on WDAC, and it's more or less an involvement of this technology.  And WDAC is used, as we say, to block applications.  A relevant point concerning Smart App Control, this one is only available on Windows 11,  and it's active by definition directly out of the box of Windows.  So the first time you install Windows, it's there.  You can decide if you want to switch it off, say, okay, I don't want Smart App Control,  I want to disable it.  Fine.  But the point is that once you turn these features over, you cannot turn it back.  It's once for all.  Once you have deactivated, it's forever, forever.  You can always reinstall Windows, but it's a clean reinstall of Windows.  This feature is defined by Microsoft so that Smart App Control can only work on the system  if the system is considered as safe, which means, with other words, that there is no  thing before which has already run on your system.  So we can trust the system if it starts from a clean state.  So to do that, Smart App Control has three different stages.  So at the beginning, when Smart App Control is launched, is what we call the evaluation  mode.  So literally, you observe what's happened on your system, which applications are launched,  when do you launch them, is it safe or not, and it makes an evaluation.  Will this application be considered as safe if I will be on, or will it be not considered  as safe?  And it gives you sometimes some feedback just to tell you that maybe you should not use  that application.  So that it tries to educate yourself to use safe application, or what Microsoft considers  a safe application, to be honest, instead of using unsafe one.  And then after 20 days in average, but it can be more or less, that stuff is dependent  of Microsoft because it's based on feedback from Microsoft, SAC can be switched in two  different modes.  The first one is enforcement mode.  So it means that Smart App Control is now active.  Now when you see an application which is launched and considered as unsafe, this application  will be blocked.  And no discussion.  You cannot say, ah, I want this exception.  No, no, no.  There is no exception in this context.  Only untrusted applications are going to be blocked, and all user applications will be  executable.  Or, if Smart App Control considers it cannot help you to define your system, no problem.  It switches off.  And in this situation, it does nothing, it observes nothing else, and it's literally  not here.  But the point is, you cannot turn it back.  You cannot say, okay, but maybe I changed my mind, I would like another evaluation.  You cannot.  It's once for all.  If you want to turn it back to evaluation mode, you need to reinstall Windows.  The interface is very simple, three buttons, on, evaluation, off.  Of course, you can decide by yourself to turn it on, but it's on your own risk.  It's by yourself.  You decide you want to do it, you do it.  But in this context, if your machine cannot be useful because some applications are blocked,  that's for you.  Okay, that's what is Smart App Control.  So Smart App Control just selects applications which can run or not, based on what they call  an intelligent cloud-powered security service.  Well, cloud analysis, it's just giving samples to the cloud, and the cloud answers you yes  or no.  Just a question.  If you do not have internet connection, what happens?  In this context, the documentation is very clear.  By default, applications are blocked when Smart App Control is not able to make the  disclosure to the cloud analysis.  So Smart App Control is a feature which really requires hard requirements, which means internet  connection, evaluation from the beginning, the evaluation period should be fine so that  it turns on, and so on.  Well, it's big stuff.  There is one exception, which is very meaningful.  If one application is signed with a certificate issued by a certificate authority within the  trusted programs, so VeriSign, Bogo, and so on, so a certificate you can buy from different  providers and trusted by Microsoft.  In this case, applications are executable, and of course, Microsoft applications are  signed, all of them on the system, so your system is safe.  So that's how it works.  So Smart App Control is nothing else than an automatic and optionless security feature.  You can deactivate it, but it's forever.  That's all.  So that's, in a nutshell, what we can have from the documentation.  Now let's make a little journey inside.  At the beginning, from explorer.exe, when you execute an application, the application  has a long path over the system, and it goes to the kernel, so to create a new process.  In the kernel, there is a notification which is performed to a DLL which is called ci.dll,  code integrity.dll, to check if your application could be allowed to run on the system or not.  In other words, that's literally the home of WDAC features.  Then ci.dll checks on Windows policies, which define which application can run or not.  Windows policies is just something like, it can be used on command line, of course, but  in the end, it's just an XML file which defines which application can do what based on signature,  metadata, and so on.  Windows policies say yes or no to ci.dll, and then the kernel allows the execution or  refuses it.  Very simple.  As we said on the documentation, WDAC, sorry, smart app control is based on WDAC, so it's  based on ci.dll, so let's dive in ci.dll.  At the beginning, when you have an application which is notified to smart app control from  kernel point of view, it's going to match this function, ci.validate image header.  The first thing it's going to do is to check if your application is going to be analysed  by smart app control or not.  In this table, I represent all applications which are notified to ci.dll, regular executable  file, installer, and so on, script, they take another path.  Drivers and installer, msi or setup.exe, if you prefer.  That's what goes in ci.dll, but when we check later what goes really in the analysis process  of smart app control, we have a slightly difference.  First, all the driver line has disappeared.  It makes sense because it's technically kernel mode code signing requirements, so this check  is only done in ci.dll, and more exactly, it can be done on the VTL1, the virtual base  security system of Windows where trusted code is executed in a parallel environment, so  that makes sense that we do not need to come back in another system analysis, but the application  from Microsoft sign are also never notified to ci.dll, probably for optimization purposes,  or also if you want something done, do it yourself.  That's a good way to escape their own security.  So we are going to focus on sub-party signatures, untrusted sub-party signatures when you sign  yourself your application, and un-signaled application and installer software.  Once we have selected which image or which kind of image are concerned by SAC, smart  app control SAC, that's a shortcut, signature check and get hash image.  So the goal is to extract from your binary any signatures, and the system is quite simple.  First, you have an indication of signing level.  We are always in ci.dll.  Validate page hash or file hash.  We take the hash page of memory per page of memory, or we take the hash per file.  Then we select which algorithm we want.  Usually, it's SHA256, but for legacy and backward compatibility, you have SSR1.  Then you've got the embedded signature and first match, so it's literally extracting  all the signatures from your binary.  One match, we stop, and it doesn't match anything.  We continue if there is another signature in your binary.  We calculate the image hash, and we find a matching hash, and in the end, you have a  couple of possibilities, different functions, I would say, but you have something which  is usually linked to the notion of catalogues.  Catalogues is a kind of file on Windows which regroups all the signatures of different binaries  so that your binary doesn't hold the signatures, but it's all in another file.  This verification is performed by a sub-party component of Windows which is a service in  user mode.  That's a regular process, I would say, of CI.dll.  Until now, we are not exactly in smart app control.  It's regular WDAC stuff.  Then we are going to apply the WDAC policy matching.  The first thing that the kernel does is to check the system of cache.  In fact, if the application has already been analysed and nothing has changed from that,  no need to remake a verification.  Nothing has changed, so it should be the same result every time.  To do that, the system has what we call a kernel extended attribute, so it's a sort  of metadata which is added to your file via the file system to know that there is already  something which has been analysed, there is a cryptosystem inside, signature stuff, to  be accurate, and the goal is to say it has been checked, it could be launched.  So that's a cache system, file per file for optimisation purpose.  If you do not have anything like that, if you do not have a cache system, or by the  way, just talking about the cache system, this kind of extended attributes starting  by $kernel, it means it's a kernel extended attribute.  You can only modify it if you are a driver.  Administrator is not enough, so you really need to be the kernel.  So if you do not have any cache, we are going to call the function cipapplysipolicyexit.  This function takes many elements.  First, the validation context.  The validation context literally provides all the detail you need concerning your application.  The path of your application, the signature, et cetera, everything which concerns what  you want to execute.  Then you have policy objects.  That's the number of policies you have in the system regarding WDAC.  And then you have a validation procedure, so linked to every policy, if there is a special  treatment for this policy, we can execute a specific callback doing a specific feature  for that policy.  What is SAC?  Technically speaking, it's just, well, after the policy, we have a yes or no, of course,  but SAC is only that.  One specific procedure which is called CIP, external authorization callback, and the SAC  policy which says to the system, use SAC or not.  That's what is technically SAC.  At least from the kernel point of view.  Okay?  Let's check what does this callback have to work.  This callback is not so complex.  First, it checks what they call a security attribute token.  It's also for optimization purpose and cache system, but it's not so relevant for what  we want to see.  Then it's going to check if the extension of the file you want to check or you want  to use is considered as dangerous.  So we have a lot in this list of extensions.  Of course, executable is by default included.  Makes sense.  You started to execute an executable file.  And also installer, MSI, in this list.  And then, once the callback has performed this check, it's going to do a little bit  more.  The goal is to make the transition from the kernel to the user mode where the analysis  will apply.  So as I said, first, file check extension, and then there is a call to a function which  is called CI cat DB smart locker defender check.  We have this notion of smart locker.  Smart app control.  So inside, when we reverse Windows, we have access to symbols in this context.  And we have different names.  Probably all code names used by the project during the development.  So smart locker was one of the code names.  Also another one is night wash, was another code name used by Microsoft regarding this  feature.  It's going to ask to the rest of the system what to do with the file.  Manage the answer.  And if the answer is positive or negative, put something in the cache file system we  mentioned just before.  So we are going to dive in the procedures of smart locker.  This one first starts by making a connection, RPC connection.  So RPC, remote procedure call, is just a way to make interprocess communication, a very  convenient way to execute function in another process, which is used for decades by Microsoft.  So the goal is to make an interface which is called key SVC.  And that's the UID of this RPC interface.  And when we look for in the system which process is that, it's a service which is called Krip  cat service.  Okay?  Good.  So the first is to make the connection.  Then there is a way for synchronization.  It checks that the service is there and the RPC connection is correct.  And then it tries to call this function.  Really, the names are very long.  SS, cat, DB, smart locker, check two.  The two is important.  Apparently there was a one before.  Why not?  And when this function has been called, it is going to pass the answer, which means more  or less manage the answer, and so on.  So all the heavy stuff is performed in this function.  And what does this function?  It's very simple.  It directly makes an RPC call to a function inside this service.  So this is how the WDAC makes the transition for smart app control between the kernel and  the user mode in Windows.  Krip cat service.  Krip cat service is literally launched at the execution of Windows, at booting time,  to be correct.  So you see Windows system 32 is in svcos.exe, and its codename from argument point of view  is Krip service.  But it really mostly relies on that DLL, Krip cat service, and the name of the service internally  registered is this one, Krip cat service.  This service, when we reverse it, is quite simple in a way.  It's literally there to manage catalog file.  You remember the catalog file where all the signatures of all binaries in Windows are  drivers are present so that we know which one is signed and how it's signed.  So that service is literally responsible to check all the chain of certificates when a  binary is signed on Windows.  Makes sense when you think about CI.DLL is there to check signatures and policy, actually.  So in this RPC interface, you have the old function used usually by this Krip cat services.  But you have four more functions which are definitively related to smart app control.  So it's very interesting to see the mix between the service which was clearly identified before  to make interaction, I would say, with only signature and catalog file, and now, in between,  you have smart app control.  You have two kinds of functions.  The two last is about app control block toaster, switch on for a small post.  It's more or less to display something to user eyes.  So it's green interface.  It's so important.  But the two most important are this one.  Cat DB smart blocker defender check one and two.  One is not written, but it's like that.  But in the end, both functions rely on the same function, which is this big function,  which always has smart app blocker defender check helper.  This function is literally responsible to make the transition from the Krip cat service  to Windows Defender.  So it's just a proxy, if you want, between the catalog services analysis and Windows  Defender.  WD, sometimes I miss some size in my presentation.  So WD is a shortcut I use.  To proceed, Krip cat service is going to load a DLL, which is called MP client from .DLL.  This DLL is the interface that any application can use to interface with Windows Defender.  When I say any application, I will say Microsoft application, because it's undocumented stuff.  So you are not supposed to use it.  It is going to find the DLL based on the registry key.  And once the DLL is loaded, it's loaded once for all.  The first time it's loaded, you have a specific initialization which is performed by the service,  which is called MP smart blocker enable, just to enable smart app control.  Otherwise, it's just stored in memory.  You remember you have function two, function one.  So they are going to follow their path in parallel.  But when the function two doesn't work, it always tries a legacy function.  So invoke MP query trust by .DLL is going to call MP query file trust by .DLL, and so on.  These functions are responsible to do two things.  The first thing is to load the targeted file in memory, because at the beginning, the target  file is on your disk.  And to be analyzed, it needs to be put in memory somewhere.  So this is a service, which is going to load it in memory.  Interesting, because it's not that service which is going to analyze it.  And then it's definitely making the transition with Windows Defender via its RPC interface.  The RPC interface of Windows Defender is totally undocumented, but it's very, very interesting  from my point of view.  The function which is responsible to do it is this one.  I give you the name for people who are interested to check how it's possible to interface directly  with Windows Defender.  As any RPC interface, you have a UID, which is provided over there.  And the access to this RPC interface is more or less controlled.  First you need to make the interface via MP client .DLL.  Well, technically you could try without, but there is some check.  So when you call some API, sometimes Windows Defender goes in your memory space and checks  who is really calling you.  To check if the code is using regular stuff or not.  Also, there is RPC impersonation.  So technically, Windows Defender is full power on the system.  And to avoid to do bad things, it's going to behave with the same privilege as the calling  process.  So that it avoids when it tries to reduce privilege escalation.  So that's the interface.  You have a lot of functions, but some are very interesting.  Query statute.  Disable feature.  I like disable feature a lot.  Demand start scan.  You've got demand thread open.  You have RPC control.  You have quarantine control.  You have elevation on DLL open, signature thread open.  You have Spinet.  Spinet is used to make reports to Microsoft Cloud to ask the cloud of Microsoft to give  you feedback.  We have also thread close, production checklist, fast memory scan, if you want to make a scan  which is faster than the usual memory scan start.  And you have literally the remote control over all the features of Windows Defender.  You have the possibility to update the signature the way you like.  Everything is there.  Check for drag and drop operation.  You have also one for IMSI in the list somewhere.  Well, you have a lot of stuff over there.  That's the interface of Windows Defender.  That's the remote control of Windows Defender.  Make a short parenthesis, just trying to explain how it works, Windows Defender, in a very  simplified way, because Windows Defender is a big antivirus, big software, and it involves  a lot of components.  At the beginning, the service is launched from that registry key, hklm, Microsoft, Windows  Defender.  If the service is not found directly in that registry key, the system tries Microsoft anti-malware.  Then we try to execute the most recent version of Windows Defender.  So that's why the path of Windows Defender includes a version number over there.  If by default you cannot find the most recent version of Windows, no problem.  We take back the last version known to be correctly executed.  So that way, Windows Defender has also a mechanism of, I would say, which tries to avoid any  mistakes.  In case of mistakes, it can always roll back from the beginning.  So we start with the executable msmp-engine.exe.  It's literally more or less like svcost, which is a process which is going to host the service  of Windows Defender.  The name of the engine inside is called Asimov.  That's the code name for the analysis engine of Windows Defender.  And the first thing it's going to do is going to load the DLL, which is called mpsvc.dll,  which is literally the service which has a service CRT main function.  This one is going to check which is the last drop location and if there is any update in  the system to use.  If not, the service is going to create the regular stuff for service.  So it has an on startup procedures, on asynchronous startup procedures.  This one is very interesting from my point of view because it creates what we call a  thread pool.  A thread pool is literally a set of threads which are waiting for works and tasks to do.  So that everything is asynchronous.  So you can have a module dedicated to, I would say, memory analysis, for instance, which  are waiting for tasks to do, and you have another module, I don't know which is for  network analysis, which has another thread pool.  And that way, when you ask for something to Windows Defender, it's going to push a task  to one thread pool or another thread pool, and everything is performed in parallel in  a more or less optimal way.  Well, it's quite optimal, actually.  You have also a service dispatcher for any service.  It's always the same.  And then the service main function is going to call initmp service, which is a real initialization  of Windows Defender.  This is where you can have all the information you like on Windows Defender.  Everything it does.  The capability to make network scanning is there.  It's how it's initialized.  The capability how it makes an update of the system, an update of the signatures, how it's  going to initialize the scan memory, engine, et cetera.  Everything is there.  And in the end, it's going to load the DLL, which is called mpclient.dll, which is used  by the service.  So it's also used internally by Windows Defender, but more or less for support purpose, to under  thread pool, for instance.  It's a good way to do that.  Then you have mpengine.dll.  So this is exactly the analysis engine of Windows where all the heavy work from analysis  point of view is performed.  You have also mpcommu.dll for communication, to communicate with the cloud of Microsoft.  You have mpoiv.dll for everything which is linked to Office document.  And you have also mprtp, real time protection.  This is the DLL which is in connection to the drivers of Windows Defender, wdfilter.sys,  from my memory, which is supposed to hold all the system events in real time.  And then, when you want to interface with, as a reminder, you always need to have the  mpclient, which is in connection to mpsvc.dll.  That's the architecture of Windows Defender, at least a simplified one.  Well, let's come back to the transition between prep cap service and smart app control within  Windows Defender.  So we have that function, which is called mpcheckmapitfiltrust, which is going to call  that number in the hexadecimal RPC function from Windows Defender.  And the function which is targeted is server mprpcmemoriescanstart.  So you see, we have removed the notion of smart, we have removed the notion of local,  we have removed the notion of Defender.  Now it's regular scanstart.  Interesting.  The analysis is performed asynchronously, as we have said, with thread pool.  It's interesting because all the operations are performed asynchronously, and in the end,  the client which asks for the analysis needs to have a return.  And because it's asynchronous, you need to synchronize to know when the answer will be  provided.  And to do that, Windows Defender uses a global event, which is named with a grid.  That's interesting, in fact, because grids are designed to be unique, not random.  So I think, in a way, if we are a bit smart, we could try to make a denial of service.  You are attacking yourself.  It's not so interesting.  But that could be a possibility.  Duplicate handle in memory would have been a better approach from my point of view.  But that's literally a side note.  So how was the evaluation?  Let's make the journey.  We are only going to focus on the main relevant function, and you will see there are a lot.  First of all, we are in the service DLL, which is about to create some stuff with C++ programming  to create an object, which is called a CMP memscan context memory.  And we are going to initialize it.  And when we are doing the initialization, we are literally doing the analysis.  We are switching to mpClient.  It's just a call of function, and there is no mystery in between.  It's just a function call to another function call.  And we have the submit process.  I like this word, provider, vista.  It gives all the literature and history concerning Windows Defender.  In fact, it's just pushing something in a thread pool.  But we know this thread pool from the initialization, and we know it's going to be back.  So that's still mpClient, which manages the thread pool at the beginning just to dequeue  the task to do from the thread pool.  And then back in mpService, doAction, onAction, doScan.  We will talk about doScan in a few seconds.  And then we have rSignalWrapper.  rSignalWrapper is a function to communicate asynchronously, again, with mpEngine.  And we give this special value, rcScanStreamBuffer, in rSignal.  And then the engine is going to continue to process that signal.  CastSignal is the important function, which makes a translation from that value to this  function, scanStreamBuffer.  Makes sense because the buffer is in memory.  So we are going to scan the file in memory.  And then the most important function in all this scanning operation from our point of  view, because it does a lot, really a lot, is this function, generateBMSpyNetReport,  which is communicating with mpCommu.dll.  So literally, it's a code notification to Microsoft.  As a side note, I have a couple of minutes, so it's okay.  For the record, coming back to this doScan function, this function is a C++ function,  so it literally holds a set of methods in the object from where it has been called.  And in the set of functions, I would like just to focus on vfzRead operation.  And inside this one, you have a call to that function, readProcessMemory.  What does it mean?  It means that when Windows defenders like to scan a file in memory, it doesn't load  it by the file by itself.  It's going to act as a debugger.  It's literally reading in your memory space of the calling process your file.  I think it's maybe for optimization purpose not to reload twice the same file in memory,  but actually, that's quite odd.  That's original, I would say, to act as a debugger for an antivirus, but why not?  So it's how it works.  So when you want to submit a file to Windows defender, don't send him the path of the file,  just load it in memory, call the right function, and Windows defender will take it by himself.  Okay, that was a parenthesis.  Let's come back to the communication, because it's very interesting for us.  MPCom is going to generate a spy net report.  Spy net report is the name of the kind of report which are used internally by Windows  defender to make submission literally to the rest of the code of Microsoft.  This is the name of the function which is doing it.  It's very, very long, but submit report is the most important stuff.  And this request is made to that domain, wdcp.microsoft.com.  That's that IP from us in Germany.  The full URL is given there, boom, submit report.  You have the user agent, MP communication, you have the version of the operating system,  the platform version, and the online version of Windows defender.  That's all you need to provide to make the communication with the server, and you accept  it very fine.  So security is present, there is a way to prevent man in the middle, it's just regular  certificate pinning inside this function, check certificate Microsoft root, based on  query option, so it's correctly done.  So you cannot too easily intercept the communication if you are not already on the machine at least.  The content of the spy net request is packed, so it means it's not easily readable.  Well, with reverse engineering, it becomes readable.  So we have the possibility to extract all the information from a spy net report, and  we have very interesting information.  When you make a smart app control request, at least Windows defender does it for you,  it provides the machine information, engine report with machine and product with platform,  a lot of information about your current machine.  Also in Windows defender information, it provides all the defenders version number, signature,  engine, database of signatures, quarantine, and so on, everything is provided.  Windows defender configuration value, how the services start, tamper protection state,  all the configuration and policy for Windows defender is sent automatically and every time.  Trust mode state, if there is different sub-mode in Windows defender which is included or not.  So literally, every time you disclose something for malware analysis, Microsoft knows exactly  how it's configured in Windows defender.  You have a signature request, from my point of view, it's just to track the request we  are going to send, but it's very interesting to have a history so that it gives information  to the previous submission you could have done by yourself.  And of course, you have the file content query.  So you have the real path, the hash of that path, the file name, SHR1, SHR256, MD5 also,  why not, CRC, the file size, PE attributes, file tip settings, imp hash, name, original  name, version of the software, that's unknown hash for us, it's hash more or less of some  section I would say.  I like this one, modwrefurl, it's when you download the file, Microsoft keeps track of  from which website it has been downloaded, or if you have extracted the file to a zip  archive, it keeps track to the archive where the file is from.  Kind, isn't it?  And then you have the mark of the web and so on, this is exactly the NTFS attribute  which is used in download directory when you download something to Windows and you execute  from download directory.  That's exactly the same stuff, same logic at least.  Mostly this is metadata concerning the file.  At the best of our knowledge, this is not directly the content of the file.  The only stuff from the content of the file is PE attributes, but it's more from compilation  point of view interesting than what really your executable does.  So you don't have any disclosure like that.  If you want to have another see of how it looks like after reverse engineering and parsing  the content, so it's literally a lot of values I would say, and you can see the path, the  name of the application, and so on, and you have also the name of the zip application  which was a zip archive where we have extracted the software which has been used for test  purpose.  So everything is not everything, but at least from file query you have more or less everything.  So the answer from Microsoft, so we send information to Microsoft, Microsoft answers us, nice.  Once the answer is received, this one is parsed by this very long name function.  The goal of this function is to extract all the information provided by Microsoft to know  what to do with that executable because in the end, Smart App Control is going to say  that this app is trusted by Microsoft, you can execute it, this app is untrusted by Microsoft,  it's blocked.  So it's exactly the stuff which it's going to do.  So a feedback about the analysed file, and also the potential information, so it's not  always present but it can be present, about the current mode in which Smart App Control  is running.  So you remember at the beginning, Smart App Control has three states, evaluation, which  was Smart App Control observes the system, enforcement, where Smart App Control really  blocked or not application, and off.  So the transition, the way to switch from one state to another state, is driven remotely  by Microsoft from every answer it provides to you.  So that's Microsoft which can decide, yes or no, you are going to do it or not.  So we do not have the logic because the logic of this choice is on server side.  And for obvious reason, we don't have access to the server where this algorithm of choice  is performed.  But it's driven remotely.  The answer is personalised for Smart App Control.  Despite the fact that Spidenet is used as a very generic stuff for all the application  and everything where my Windows Defender needs to disclose something to Microsoft Cloud Analysis,  Smart App Control has specific attributes so that the answer is personalised for Smart  App Control analysis.  So that's how it works, at least from the feedback.  If you really want to have a deep look on the feedback, so it's still packed, so we  need to unpack it.  And then you have many blobs in the answer.  One blob is a signature so that the answer is correctly signed and we know that it's  going from Microsoft.  You see?  You have the man in the middle protection and also a signature of the answer.  The goal is always to improve the security.  So the message is signed.  The message contains information related to the original request so that we have a track  down.  We know from which request we have the answer because everything is asynchronous.  In practice, we have also very three interesting blobs which all start by a magic number which  are provided over there and which gives a decision to do.  If SAC is in enforcement mode, so it means it's going to block or not, or it's going  to allow your application or block your application.  If SAC is in evaluation mode, you have just a notification sort of WNF toast.  Sometimes when you receive a mail, you have a pop-up which comes from the bottom right  of your screen in Windows.  It's exactly the same kind of notification.  And it can change the status case of SAC, enforcement mode, on, off.  That's how it works.  The changing procedures is more we can describe it for short, very for short.  So that Microsoft Defender Antivirus which receives the information is going to disclose  it with CI.dll which has a specific procedure for that.  The first is to change the configuration because it's impact CI.dll which doesn't need  any more to notify services.  We are going to update policy in SAC and WDAC to stop it correctly.  And then we have two kind of procedures.  On the one side, we have an RPC toast notification, so we are going to talk with RPCSVC, and if  you remember in the RPC interface of service, you have the regular service features for  catalog file, but you have also four features, four functions for smart app controls.  The two first are for notification, analysis, and the two last are for display control,  GUI.  That's exactly these two functions which are going to be called here to inform you that  something has changed concerning SAC, or the application would have been blocked if SAC  would have been in enforcement mode.  And the other one, it doesn't use any more RPCs, so the notification is performed via  WNF notification, which is another kind of inter-process communication from kernel mode  to user mode, and user mode to user mode also.  Which seems to inform to Microsoft Defender on T-Virus that, okay, I've correctly taken  it into account, the fact that SAC is now in that mode or in the other mode.  Now you, your turn, you can switch your configuration also.  So it's not Microsoft Defender which changed it before, it's really CI.dll which changed  it before, and then it informs Microsoft Defender on T-Virus, so Windows Defender, to do it  by itself.  So that's sort of ping pong.  Okay, so we have seen how works smart app control.  For those we are interested by, we have the possibility also to have a tracking of what  happens in Windows Defender, a sort of printf, but for Windows Defender to check what are  the logs inside.  Windows Defender has two kinds of logs internally.  The first one is a regular log txt file.  It's very old school, but it's very convenient.  By default, they are generated all in the same place, C, Program Data, Microsoft, Windows  Defender, Support, prefix log file, and the date.  The date describes the date and time where the file has been generated, and the prefix  can be mplog, mpsomething, and so on and so on, depending on the different features.  I really advise you to check it, because it's very interesting.  For those we are interested by, it's initialized by this function, which is called at the end  of init mpservice function, you remember, at the end of the initialization of Windows  Defender.  And also, Windows Defender, in not all of these functions, but in a lot of its functions,  has ETW or WPP tracing within the code, and it's a very gold mine if you want to track  what this function does without having to reverse engineering everything.  But there is a little problem concerning it.  First of all, regarding Smart App Control, we do not have a specific ETW provider.  So it means that we need to deal with all the Windows Defender stuff, which is a very  interesting clue, because it says, without saying it, that Smart App Control is just  a feature which is a lego of different existing components.  It's not something by itself, you see?  When I say in the kernel that it's only about the notification and the change in the policy  and the specific procedure callback which is provided for that policy, I mean it.  That sucks.  What is really Smart App Control?  But in Windows Defender, it doesn't make a huge difference.  It's not big enough to have their own ETW provider.  And in ETW provider, talking about it, Windows Defender uses it for getting information and  providing information.  So providing information, as I said, is a printf of the process.  So it's very cool.  We have literally line by line what does it do.  And for information retrieving, so that ETW is also used by the kernel to say that this  function has been called, this stuff has been created, this event is now a trigger, that  file is accessed, and so on.  So it's a very good way to track what's happening in the system.  And Windows Defender uses it as a source of information.  The problem is that this source of information, which is very interesting, is protected.  Of course.  If it's interesting, it's protected.  So we would like to access it.  And we are going to share with you how to disable the security to access it.  We need to be with a debugger, Winbag debugger, in kernel debug.  It's not a hack.  So you are already full power on the machine to do it.  But the goal is to track what happens, right?  It's not to break the system.  So the first thing to do is to use this command line in Winbag, wmi-trust-str-dump.  It's going to list for you all the logger contexts which are related to ETW provider  in the system.  And the one which is interesting to know what's happening in the system is Defender API logger.  Okay?  We select it.  And we know by a previous study we did for the CZspoos project, which was also on the  behalf of the BSE, how it works.  So internally, it's a wmi-logger-context structure.  So I just shot some part of the structure because it's a very big structure.  We have the name of the logger.  We have also a file where it contains all the ETL events.  You have the protection, which is stored in a very specific variable, which is a flag.  And the flag is just a four-byte value, integer value, for those who like to see, which is  an hexadecimal value, 4000F.  And if you check, it's documented.  It's very kind at Microsoft.  They provide all the information from symbols.  You have the persistent, autologger, FS3D, real-time.  You have all the information.  And you have one flag, one bit in that four-byte value, which is called security trace and  is set to one.  And all the security matters for it.  Let's remove it.  So for those who don't want to use directly the full structure, which provides two verbose  texts, you can directly use DX.  I provide also the slide.  We will share it so that you will get access to this command line.  And then what you can do is to transform this flag and remove the four, because that's the  bit equivalent to be removed.  So we need literally to remove it.  So with the debugger, we have ED, E for edit, D for DWORD, for integer value in Windows  Word.  You have the address of your ETW context.  That stuff is a bit quirky, to be honest.  It's just to have something which is independent of the structures and the offset in the structures.  In the end, it will provide exactly the offset where the flag value is.  But I don't want to compute it every time I'm using this stuff.  So I'm using directly the structures from the symbol.  We are just going to keep the last part of that value, removing by definition the bit  which was about the security, and ta-da!  The security is gone.  So let's take a DLL injection attack just to check how Windows Defender detectives step  by step.  So we have open process, virtual log, process memory, remote thread, everything classic  I will say.  Let's go.  So we have our own tool for the display, but you can use any ETL or WPP, ETW reader.  This will be exactly the same.  You have the provider width.  So which one is providing information?  That's the one we have targeted from the beginning.  And then you have the name of our process, the command line of our process, relevant  arguments for that process, and even ID.  And the even ID tells us in this context it's an open process action.  After open process, we have the allocation of memory with page execute read-write, because  we have everything over there.  We have also the name of the process.  Then we have the write into a remote process.  So write process memory to write remotely.  Then we have the create a thread in the target process.  So you have the thread ID and process ID of the target process.  Then we have the load the DLL, which is a DLL injection.  So it's going to load it.  So perfect.  And we have from somewhere the name of the DLL.  You see the payload, device, R volume 2, user.  We see that device R volume 2 is managed by the kernel, because that's the way the kernel  likes to use the file.  And the desktop, run command from DLL, and DLL for command execute.  Process ID, mesh size, all the information we like.  And in the end, we have the detection, Microsoft Defender antivirus reports and authorizes access  to local security system.  We have tried to make the injection in LSS.exe to be accurate.  And you see, platform, HTTPS detection, and so on.  So we have all the step-by-step detection of Windows Defender.  Sometimes reverse engineering is cool.  It's time for conclusion, so that normally everything will be on time.  The big picture of our work is smart app control.  Just as a reminder, first we check which kind of image are relevant or not, reminding you  that not all images are relevant.  And by the way, from the documentation of Microsoft, if you are correctly signed, it  will be okay.  So, well.  Signature check and get image is still WDAG.  WDAG policy matching, which has a specific policy, which makes an external authorization.  That's the name from the Windows symbols.  The external authorization is actually Kripket service, which makes the interface.  It's going to start if it's not already done, the smart locker enable.  Then it's going to open a file so that Windows Defender can read it remotely from Kripket  service, but that's implementation detail.  Then we are going to scan this file in memory, more or less parse it to extract all the information  which are going to be sent via the Spinet communication to Microsoft.  Microsoft provides us a feedback.  We parse the information from the feedback.  We close the handle, and we take a decision in CI.dll.  That's all.  What does it mean?  Well, you remember that we talked at the beginning of what is SAC and what is not SAC.  If I take a picture of a very simplified version of SAC, it's just CI.dll, notify Kripket  service, notify Windows Defender, notifying Microsoft.  Now let's consider the case where I take a regular antivirus, for instance, Windows Defender.  You see, it's making directly the notification to Windows Defender, and it goes to Microsoft.  That part, comparing to what it already had before, it's really an open question from  my point of view.  Why doing that?  It's so complex, actually.  Because from an antivirus point of view, we have this routine, ps set load image notify  routine, which means that a driver-supplied callback is provided every time an image,  DLL executable, is loaded into memory.  And if it's not enough, you have mini-filter driver, which are able to notify you every  time a file is accessed on the disk.  So everything was already there from an antivirus point of view.  But remember, SAC is not an antivirus.  It's not because it behaves like an antivirus, it has almost the same architecture, a bit  more complex, but it has the same architecture from a physical point of view of an antivirus,  and it blocks applications like antivirus or not, that it is an antivirus.  Well, at least in Microsoft logic, I would say.  So it has everything to do it, and the best argument to say that smart app control is  in a way an antivirus, that is literally rely on Windows Defender.  At the end, in Windows Defender, when the scan analysis really starts, you don't have  any more the name of smart app control or smart locker and so on, it's just regular  notification stuff.  And the difference relies, in fact, between antivirus and smart app control in the fact  that smart app control doesn't block known applications to be malicious.  It blocks unknown applications that it doesn't trust.  Well, Microsoft just replaced the notion of exclusion list, blacklist, in a more direct  language, to inclusion list, whitelist.  The antivirus made whitelisting, smart app control made whitelisting, blacklisting, whitelisting.  The cloud analysis mostly relied on executable signatures.  As I remember from the documentation, smart app control will block unless those files  are code-signed with a certificate issued by a certificate authority within the trusted  root program.  Nothing new.  That's literally a sack which doesn't allow applications which are unsigned to be executed,  more or less, if they are not trusted by Microsoft.  The learning phase, technically speaking, is more or less about to check how many applications  with an unknown reputation from Microsoft you use.  That's why they call the cloud analysis intelligent blah, blah, blah.  It's literally like that.  But we can have also another point of view on this stuff, because it just, I mean, it's  one point of view, but we can try to fit in the shoes of Microsoft for a couple of seconds.  The architecture of smart app control is unnecessarily complex.  But why is it unnecessary complex?  Because it relies on WDAC.  And maybe we should think that smart app control is just an involvement of WDAC.  I mean by that, that WDAC is supposed to protect your system by applying policy on what kind  of application can be executed and which application cannot be executed on your system.  But to be able to define the policy to say, ah, that application will be blocked, ah,  not this application, this one, not this one, ah, we have the update now.  It's a huge and complex process to do it, especially in very big organizations.  And maybe Microsoft, it's just a guess, might have thought about the fact that we have the  feature which is called cloud intelligent reputation, and maybe we can make a mix between  all this automatic reputation we already have for application and WDAC, so that WDAC is  automatically configured for anyone.  So that we don't have to define policy and per application and so on.  So that could have been the idea and explaining what smart app control relies on WDAC and  not directly on the antivirus because it's from the antivirus.  But in the end, it's white listing, sign-in, globally shared application execution policy.  And it should be done, and it should be seen from an evolution from Windows Vista with  code integrity, patch guard for those who prefer, and kernel mode application signing.  AppLocker in Windows 7, which has disappeared to become something else.  We have WDAC in Windows 10, ESG, Intelligent Secure Graph from Windows 10 also to check  the application reputation, and in Windows 11, you have SAC.  So you have the evolution, step-by-step, of this technology.  But the main conclusion I would like to share with you is maybe that smart app control raises  questions.  One is that the notification is about HTTPS request.  Okay.  To be able to make it correctly, we will need to have access to the victim's machine to  get all the serial number and so on.  But nothing prevents us to take the request from the machine and spoofing it or spamming  it to another machine, pretending that you are the other machine to deactivate SAC on  the other machine by pretending you launched a lot of untrusted applications.  That could be an idea to deactivate remotely SAC on another machine.  And it's just HTTPS requests coming from everywhere.  So it's very hard to control from Microsoft point of view.  But there is another question.  As I said, antivirus, if you remember, they have a dedicated driver or service and they  communicate and so on.  But it's a standalone element.  If you want to remove an antivirus, right-click and install.  You can remove it.  But now that SAC is literally embedded on CI.dll, which is a key component feature of  Windows, which cannot be removed, otherwise Windows will not work.  That's why the question concerning the position of Windows Defender in the system.  Because even if Windows Defender is in passive or side-by-side passive mode, Windows Defender  can always be notified by SAC.  So even if you have another antivirus installed or even if you say to Windows Defender being  passive mode does nothing, it does something.  And that's why the question of the control of the application and the antivirus which  are running on your system.  And it's not just blocking something.  It's also disclosure information to Microsoft.  So if you wanted to disable Windows Defender, well, it's not so disabled with smart app  control.  And also it shortcuts other antivirus products because it's not the regular path of notification  from antivirus to antivirus with different altitude, all of them correctly defined.  It's literally another path.  So that's why the question.  And there is also no documented possibility until now for third party to interface with  smart app control.  It's always Windows Defender and no one else.  So that raises a real question for our point of view concerning the position of Windows  Defender in the system.  And on that word, I need to mention some reference, especially the work from N4R1B blogs, which  has made a very good analysis of what happens in the kernel for CI.dll for smart app control.  We reversed it another time by ourself on our own just to check that nothing had changed.  Some very small detail change, but the logic is always the same.  It stopped before Windows Defender.  We have continued for Windows Defender.  A detailed report of smart app control is present on the BSC website.  And for those interested by OTW, there is another one also from BSC.  We have written for them.  And all these words, thank you for your attention.  It was my pleasure to be with you today.  Thank you.  Thank you.  Thank you.  Thank you.  Should be okay.  We have a little battery issue, but I suppose if there is any question in the room, maybe  we can hold one or two.  All right, now that works.  Well, thank you for the talk.  Very interesting.  Do we have any questions?  Right, I come down because the other mic is also empty.  Yeah, thanks for the talk.  You mentioned that if you turn SAC off, then you cannot turn back on, right?  But can you switch between the enforcement mode and the learning mode?  I'm not sure about the exact names.  Yeah, when you are in learning mode, evolution mode, but that's the same stuff.  When you are in this context, you can only go to two directions, off or on faucet.  So active mode, if you prefer.  But once you are active, you cannot come back to learning mode.  It's one way.  At the same, when you are off, you cannot come back to learning mode, and you cannot  go also to direct active mode.  If it's off, you cannot say, okay, but just put it on, the evaluation doesn't matter.  So which is a bit risky.  We are losing control with this kind of application, because it's Microsoft which provides us a  feedback, yes or no.  We have just a toast notification, and that's all.  You cannot say, ah, no, I want to change my mind or give me an extra time.  No, no, no.  It's choose, and that's all.  And if you want to retry, retest, or change your behavior, it's too late.  You need to reinstall your Windows.  Nice perspective.  That's also the point with SAG.  It's more and more everything and nothing software.  You use it, you've got everything.  You don't use it, you have nothing.  All right, any more questions?  Well then, thank the speaker again.  Thank you.