{
  "webpage_url": "https://www.youtube.com/watch?v=-uHNcz3CF8s",
  "title": "TROOPERS24: Exploiting Token-Based Authentication: Attacking and Defending Identities in the 2020s.",
  "description": "Talk by Dr Nestori Syynimaa - June 27th, 2024 at TROOPERS24 IT security conference in Heidelberg, Germany hosted by @ERNW_ITSec\n\n#TROOPERS24 #ITsecurity \nhttps://troopers.de/troopers24/talks/lx7rvf/\n\nMore impressions:\n  / wearetroopers  \n  / ernw_itsec  \nhttps://infosec.exchange/@WEareTROOPERS\nhttps://infosec.exchange/@ERNW https://ernw.de",
  "channel_url": "https://www.youtube.com/channel/UCPY5aUREHmbDO4PtR6AYLfQ",
  "duration": 3064,
  "channel": "TROOPERS IT Security Conference",
  "uploader": "TROOPERS IT Security Conference",
  "upload_date": "20240909"
}

This text was transcribed using whisper model: large-v2

 Thank you, thank you. Can you hear me okay? Is this on?  Yeah, okay, good.  Yes, so welcome everybody to my talk about exploiting token-based authentication.  My name is Dr. Nestor Sinema, that's why I'm wearing this doctor gown.  This is my first corporate talk, so I decided that I could at least look funny.  So I work for Microsoft as a principal identity security researcher in an organization called Mystic,  or Microsoft Threat Intelligence Center. And I've been there like six months now.  And today I'm going to cover these kind of things.  Basically, what is token-based authentication attacks? Why and how?  This is not that much about any product, so this is like a product agnostic.  So these are more about concepts.  But I'm showing some demos, and obviously because I've got a background on Microsoft identity,  I'm using Microsoft Cloud Stack here for demos.  So let's start with introduction, and let's start with the very basics.  So usually when you are like authenticating using browser, for instance, we have two things.  We have the client and we have the server.  And when client wants to access some resource from server, it is saying, give me something, okay?  And now if service notices, okay, you are not authorized, it is sending back a message.  And in the header it says that you are unauthorized.  So you need to authorize with something.  And by the way, I support these kind of schemes, authentication schemes.  So that's all in here.  And then the client does something, ask password from user or do whatever it does.  And it sends again the request to get the thing, but now it includes a header authorization  with the scheme and then the payload.  And the payload depends on the scheme.  And then the server will return whatever the client was asking, if the authorization is okay.  And here, well, usually after the initial authentication, usually session cookies are used, but it depends.  So because you can do this in many ways, but this is just a basic thing that if I want to access something,  I need to authenticate.  And here are some schemes.  I'm going to kind of, well, going to cover some of these.  Who remembers the basic scheme?  That was very nice thing.  So basically it's your plain text username and password.  Encrypted with Base64.  And then we have Bearer and NTLM and that kind of stuff.  But this is the kind of thing what I'm going to talk about today.  How can we do the authorization and stuff?  Okay, key concepts of the talk.  So we have a user who is consuming services.  So it can be me, you, it can be a client, it can be browser, whatever.  Then we have a service provider who provides the actual services.  And then we have the identity provider who provides identity and access management.  And those are kind of roles and service can have both.  You can have different organizations providing services, one identity services and so on.  But these are the concepts.  And before we deep dive into the current, let's go what was in the past.  So I call that the silo model.  So we had a user who wanted to consume some service.  User had to authenticate and then consume the service.  And then if you want to use another service, you also need to authenticate there.  That means that you have a different username and password in worst case on each of those services.  That also meant that each of the service provider had to implement their own IDP.  What can go wrong?  So you are basically trusting that the service provider knows how to store password hashes  or maybe plain text passwords you don't know.  And if the service provider is breach, not only your data or your content is lost,  also your identity might have been lost, like a username and password.  Who uses the same password in different services?  I know you do.  So if you compromise that service provider, you compromise the identity.  But now things are better, kind of.  So now we use the federated model.  So you authenticate to identity provider, which is a separate entity.  It could be like, I don't know, Microsoft, Google.  Some use Facebook.  I don't know if that's a good thing.  But you authenticate to identity provider, and then you consume those services using tokens.  So that's why it's called also sometimes single sign-on.  So now if somebody compromises this service provider, you only lose your data, not your identity.  So that's a kind of a good thing.  And this is based on trust.  So as a user, you trust the identity provider, and also the service provider trusts the identity provider.  So who trusts Microsoft?  Couple.  Who is using Teams?  Aha!  So you trust Microsoft, actually.  And that's a good thing. Nothing has ever happened to us.  Yeah, but anyways, if you go back a bit, what happens here is that the token is the one that identifies who you are.  So you don't need to send your passwords to service provider.  Because in the best case, or well, in some cases, identity provider is inside your corporate network,  and the service providers are outside.  So nothing leaves your on-prem network if you don't want to.  Okay, then some technical stuff.  I had to drink because Andy is sitting in the front row.  This was vodka.  Yeah, so Kerberos, authentication flow.  So just the basic how this works.  And this is used in Windows, and I'm using the roles or concepts I told you earlier.  So we have a user who wants to access something.  So you need to provide your proof of identity to identity provider, which in this case is a domain controller.  Or the service is running a domain controller, right?  And then you will get a ticket granting ticket.  And with that, you can go back to the ID provider and ask, I want to have a service ticket for this certain service.  And then it will send you a service ticket.  And then with that, you can consume the service.  So this is the token, actually, you are providing to service provider.  So now how this technically works.  So this request here, it contains this kind of a KRB AP request message.  And it's constructed like this.  So here we have a ticket part, and that is encrypted using the server secret.  So the identity provider, in this case domain controller, knows all the secrets.  So when you as a user, you authenticate using your secret, domain controller verifies that.  And it sends you the service ticket.  And because domain controller knows the secret of the server, it can encrypt this.  And then you get the ticket, you send it to the server, and server knows its own secrets.  So it can decrypt this.  So that's how this works.  So we have the ticket.  Then you have the server secret.  You use server secret to calculate the checksum of PAC, which is Privileged Account Certificate.  And then there's another checksum, but we don't care about this this time.  Because usually the server doesn't send the ticket back to TC and confirm that.  And then we have the authorization data, which is encrypted using checksum key, which was in here.  So basically, to be able to use these or create these, you need to have the server secret.  Okay? Does this make any sense?  Okay.  Then another protocol.  Well, SAML is not actually a protocol.  It's just a format, but anyways.  So the actual protocol is usually SAMLP or WSFED, Federation.  So what happens here is that, again, user...  Well, now it goes to service provider.  Service provider says, okay, you need to authenticate.  Please go to the ID provider.  And now you go there.  You provide your proof of identity.  It can be, well, username, password, username and password, certificate, whatever.  And then the identity provider gives you back SAML token.  And then it redirects you to the service provider.  And then you go there and you consume the service with that token.  And now, in this case, it's just the SAML token.  And we have two flavors.  So we have the service provider-initiated flow.  Or you can also use the identity provider-initiated flow.  And Golden SAML attack is using this one, actually.  So it makes things easier.  So now, how this works.  So what we have here.  So we have the SAML response inside that assertion.  And there you have your attribute statements, which means properties of you.  What's your name? What's your email? Whatever.  Then you have authentication statement.  Which, if I remember correctly, is about how you did the authentication.  So what's your username, password, or whatever.  Then we have the signature.  And that is signed using private key of IDP for this certain service.  So if you have that secret, you can forge those.  But this is not encrypted.  So this is plain text, usually.  So everything you can see here.  So it's just XML, basically.  So you can open that and see that.  And the signature is that verifies that this is really the thing.  It's like a passport. You can see what text is there.  But it's just stamped by your government.  And you trust that, right?  And by the way, when was Kerberos invented?  Anyone?  1998, yeah. So I'm older than Kerberos.  And this? SAML, roughly.  2002 or something like that.  And this one, OAuth, roughly 2007.  And this is kind of what we use.  So it's JSON Web Signature.  Somebody called it JSON Web Token.  It's a type of JSON Web Token.  But we just do the signature.  So basically it's pretty much the same as SAML.  But it's in a different format.  So it's in JSON.  So first we have a header which says,  okay, which kind of key we use to sign this.  And what kind of token this is.  Then we have the payload, which has claims.  Again, like attribute statements for who you are.  What is your email address and so on.  Depending on the service, whatever you put out there.  And then we have the signature.  And that is signed, again, using the IDP secret key.  So that's how you can verify that.  And in Entra, and also in other OAuth providers,  there are certain, let's say, flows.  How to get access token.  This is one ROTC.  Resource Owner Password Credentials.  So here you just provide your credentials  to identity provider, like Entra ID.  You will get back access token and refresh token, usually.  And then with those, you can go and consume service.  Whatever that is.  In case of Entra ID, it can be Entra ID itself.  Because that's also service.  But usually, we are using thing called  Authorization Code Flow.  That's OAuth Authorization Code Flow,  where you are using a certain client application.  So you, as a user, you provide your proof of identity  to identity provider.  Then you will get back SP.  Well, redirect to service provider and the code.  Authorization code.  And now that code proves who user is.  So technically, we don't know what's inside that,  because it's encrypted stuff.  Well, I might know. You don't.  And then you are going to consume the service  with that code.  And then the service provider adds the client credentials  to that request and sends that to IDP.  And finally, you will get back access token and refresh token.  Now, depending on how you have implemented the web application,  it may or may not send you the access token to the browser.  But it depends.  But anyway, after that, you can consume the service  with access token.  Yeah, this is very hot here.  OK.  Then Enter ID hybrid authentication flow.  So this is a conceptual flow.  So basically, as a user, you try to consume service.  Enter ID is OK.  You need to go to identity provider.  It could be your ADFS.  It could be Okta.  It could be Ping.  It doesn't matter.  You need to prove your identity to the identity provider.  Then you will get back redirect to service provider  and then some proof of identity.  So it can be that SAML token.  It can be JWT.  But you provide that to provider.  And now it checks the identity or signature or whatever,  depending on what you are using.  And then you will have an access token and refresh token.  Token types in Enter ID.  So we have ID tokens, access tokens.  They are alive, like, one hour.  We have refresh tokens, which are valid for 90 days or so.  So these kind of things is that the bad guys want to steal.  Yeah, so sum up the FerroEdit method.  So we have the Kerberos.  It's been there since 1989.  And I think the first public version came out, like, 93  or something like that.  Then we have the SAML.  And then we have the OAuth.  Okay.  Then to the beef of the talk.  So we're going to talk about attacks.  And talent with these tokens, which are called bearer tokens,  means that whoever has that token can use it as that person  who that token was, like, created for.  Without providing proof of possession of any cryptographic keys  or anything like that.  And as the RFC said, that to prevent misuse,  bearer tokens need to be protected from disclosure in storage  and in transport.  And just to prove my point, I found a token yesterday  that you shouldn't share, because that's bound to me,  but you never know what happens.  Okay.  So I made up a graph about token-based authentication attacks.  So we have, like, two parts here.  The first is that do you have access to secrets to create those tokens?  If you don't, only option you have is to steal the tokens, right?  So that's the only option in that case.  But if you are a very, very bad guy, like from Russia, China, Iran,  you might be able to steal the secrets.  And then you can forge tokens.  And then you finally use tokens.  And the format here is BBMN 2.0, if you are wondering why it looks like that.  But that's just a notation.  Okay.  So if we want to steal secrets for Kerberos, what do we need?  What do we need to steal?  Secret of what?  The service, what we want to use.  Or KB, RTP, whatever that was.  Then you can be whoever you want to.  And for SAML?  Certificate, right?  And also for JSON or OAuth, you need to have a certificate.  So let's map this, like, to MITRE ATT&CK techniques.  So we have a T1552.004, which is unsecured credentials for private keys.  So it can be the service secret or the certificates.  And then we have forged web credentials,  so where you use those secrets to create those web credentials,  like SAML tokens or JSON tokens or Kerberos tickets.  Then we have this access token manipulation,  so you do the token theft thing.  And then we have the profit part, where you can actually use those tokens.  Okay.  Then I put these in kind of realms.  So we have the endpoints where the stealing happens.  So it can be either your users' computers or devices,  or it can be your servers, where you run your IDPs.  And then we have cloud.  And cloud just means that it's outside of the endpoints.  So everything starts here.  And these are the only things that we can actually control.  So we can put some restrictions, firewalls,  and configure your laptops to be more safe and so on.  And what happens there in cloud, we can't really do anything.  Well, we can. You can't.  And, yeah, so the stealing happens here,  but what happens after that, it's out there.  For instance, you forge tokens outside your endpoints.  So after you have stolen those secrets,  you don't need to be in your on-prem anymore or the endpoints.  You can forge those outside, and we can detect that.  Nobody can detect forging the tokens,  but you can detect when they are used, if you understand what I mean.  Because that forging happens in a very dark place  where nobody can access.  You just then take the result or the token  and then use that somewhere else.  Okay, now then put the roles in the map.  So you steal tokens from users.  You steal secrets from IDP.  And then you use those tokens in service provider.  And what do you think is more hard to steal?  User tokens or the secrets, IDP secrets?  Which ones? Yeah.  And that's usually done by those very, very bad actors.  Okay.  So let's show some demos at this point.  So I was planning to do something nice,  like using evil things for this,  but Tirkan already did that in his conference talk  in Area 41 conference, right?  So there's a video on that, so go see that.  So I'm just going to do this in a boring way.  So I'm now logged in as an admin to my tenant.  Now I open or press the hacking button or F12.  And then I go and refresh.  And then go to this view here.  And then I'm going to hit that button.  E-Y-J-T-J.  Nothing. Okay. Now it's better.  So now we have token here.  So I'll just copy that.  Then I go back here and go to, let's say, JWT.ms.  That service provided by us.  You can paste it here, and then you can see what's inside the token.  So this is actually the JSON access token.  So it's for graph.microsoft.com.  It has nice scopes, so you can do a lot of things.  So you just basically copy that.  And then you can see that, and you can also use that.  So I have my toolkit somewhere here.  AD internals.  Where's my mouse there?  So I'm just going to show it to you.  So get AD int tenant.  I think that is using graph. Yeah.  Access token.  And that's it.  So you can use the token as well.  So that was like a very short demonstration of how you can steal tokens  and how you can use them.  So basically, if bad actors have access to users' computers,  they can get the tokens.  And that was just access token.  You can also get the refresh token, which is valid for 90 days and so on.  And you can use them also outside that computer.  Because it's a bearer token.  If you bear that token, you are the one who the bearer token says you are.  Okay.  Then another demo.  Yes.  So stealing and forging tokens.  Now I have a little bit of limited time,  so I'm not going to show all the ways how you can steal tokens.  So if you want to see my talk from 2022,  I show eight ways how you can do that with AD FS.  And there's a lot of other talk out there  who can show you how you can steal those secrets.  So I'm just going to show you how you can use them.  So let's go back to my toolkit here.  And I haven't done that stealing part already.  So the first one is for Kerberos tickets.  So I have a secret for the service.  And in this case, it's enter ID,  and it's configured to use desktop single sign-on  or seamless single sign-on.  And I'm just going to forge a Kerberos ticket.  So it's the first row here.  And now in the variable KT, we have the ticket.  And I just copy that to clipboard.  Set clipboard.  Okay.  And I go to browser.  And there's a great tool created,  who was the guy, Lapo or something.  Lapo Lucini.  And he has a tool which can decrypt ASN.1  or there or there or whatever.  So you just paste it there and you hit decode.  And what we have here is...  Can I zoom this? Yes.  So here we have first the realm,  if you remember from the Kerberos ticket.  And then we have encrypted stuff.  So this was the ticket, I suppose.  And this was the realm or whatever that was called.  So it's all encrypted.  But I can't see that because I don't have those things in here.  But just to show you that it is there.  And just to make sure, I'm going to run this again.  Because the Kerberos ticket had a lifetime.  And then I'm going to exchange that Kerberos ticket to access token.  And then I'm going to dump the token.  So I'm just going to hit this.  And now it shows you the token.  So I had a secret to Kerberos service,  which in this case is Android ID.  I stole that from the domain controller of that environment.  And then I was able to use that to create Kerberos ticket  and then exchange that to access token.  Okay, and the second one, I created a backdoor to my environment.  And I gave the backdoor information about my certificate,  the public part of that.  And then, yeah, the public part.  And then I have the private key myself.  So I can now craft SAML tokens and sign that.  So let's do that now.  I'll do that.  And now we have the service ticket here again.  Like this.  Looks nice.  And I copy that to clipboard, and I can show you what it looks like.  Nice, right?  Let's format that a bit.  So that's how it looks like.  So we have the attribute statement,  and then we have the authentication statement,  and then we finally have the signature.  And actually what is funny, I found out this a couple of years ago.  So when you craft SAML tokens for EntroID,  the only thing that it cares about is the immutable ID.  Is there anybody from Finland here?  Nobody?  Well, my wife is, yeah.  Well, you can see the UPN I'm using here.  So that's Santa Claus at NorthPole.fi, basically.  So that's actually one tip for detection.  If you can see this kind of token, you know it's made by eight internals.  But anyway, that's the structure.  All you need to have then is the secret,  which in this case is a certificate,  and you can sign that.  Okay.  So then let's move forward.  So detecting and preventing.  So detection sources, where can we detect stuff?  Stealing the secret.  You can detect that only on IDP, right?  So that's the only place where you can see that,  the actual action of stealing something.  Somebody accesses your computer.  They are accessing some storages where your secrets are stored.  So that can only happen on the IDP side.  Same with the users.  Like if you steal tokens,  you can detect them from the user's devices or endpoints.  When using tokens, you need to have locks from service provider.  Why there's IDP also is that if you want to detect,  like using stolen secrets,  sorry, if you want to detect that somebody is using secrets  that are forged using stolen secrets,  you need to have also locks from the IDP.  Because that's the only way you can compare that.  Somebody locks in IDP, there's always lock event.  And if there is no corresponding lock event there,  you can be quite sure that somebody has forged that token.  I'll show some scenarios for that.  So for instance, in your on-prem identity,  you have your logon events in your on-prem domain controller.  And then you have your on-prem web server.  They are usage locks.  So whenever there's some entry here  that Nestor used something,  there has to be corresponding logon event somewhere here.  Does it make any sense?  So you need to have these two kinds of sources for telemetry  for this to work.  Okay, now if you are using hybrid identity.  So you have your on-prem AD.  There's logon events.  If you are using ADFS, you may have ADFS audit events.  You need to enable those.  Then in EntroID, you have sign-in locks.  The challenge here is that this is not like in real time.  It takes about 15 minutes or so.  It depends for things to appear there.  But anyways, if there is sign-in event here,  there has to be corresponding event here and here.  Okay.  And then next scenario, we have even like a demo for this.  So if you are using cloud-only identity.  Oh, let's go back here.  So this here is like if you steal ADFS certificate.  So this is for that scenario.  If somebody is now forging those tokens,  there has to be a sign-in event here too.  And this is like for if you have a cloud-only identity.  Well, also hybrid, but usually cloud-only identity.  So from EntroID, you have the sign-in locks.  Okay, that's by default.  But then if you are running your own Azure web app,  the locks doesn't have anything about the identity.  There's only locks which you can enable easily.  That, okay, somebody accessed from this IP address and so on.  So there's no identity information per se.  But that's why I made a little example about that.  So I have a...  Oh, how does this work?  That's better. Okay.  So what you are seeing here is Visual Studio.  It's a C-sharp application here.  And I did a little bit of research,  and I found out that whenever...  Well, this application is using EntroID for authentication.  And whenever you are receiving ticket for this app,  this callback function is called.  And I made a little bit of things there.  So first of all, I'm going to extract the ID token.  Then I'm going to extract the IP address where the request comes from.  And then I'm going to log that.  Certain parts from the ID token.  And then, well, I'll show the next one after this.  So I'll just show the app first.  So I go to...  Yeah.  Let's go here.  EntroID.  Okay.  Oh, yeah, this is like a...  Now it's better.  So we should have apps here.  Yep.  We have a token test application.  Let's zoom a bit.  And...  Okay.  Go back. Go back.  Manage.  And authentication.  Just wanted to show you that this is configured to use ID tokens.  So when I try to access the application,  it redirects me to my EntroID.  I log in.  And then I send the access token back to the application.  So that happens when I click this.  And because the user is already logged in, it happens automatically.  So I'm logged in as Diego.  And now I will go here to logs.  I update that.  I can see that there's a log event.  Let's zoom that a bit.  Not before, not after of the ID token.  Then we have the user principal name.  Then we have the...  Well, it's empty now.  Then we have the source, where the request came from.  Then we have a user object ID.  And finally, this was a...  What was it called?  Well, it's a logging event identity.  Well, I'll check the name, whatever that is, in just a second.  So I'm just going to copy these.  Because I'm going to emulate that I have integrated my web app to Log Analytics,  which I have not done here.  I didn't have that much time.  So I go to...  There it is. Log Analytics.  I have a query here.  Test token.  No, it's token test.  Yeah.  I'm just going to double-click here, and it should appear.  Yes.  So now I'm just going to paste my log here, so I can emulate that.  So basically what I'm now doing is that I have now web logs.  And then I have access to signing logs.  And then I'm going to find events from my usage log  that has no corresponding event in signing logs.  Okay.  So I'm just going to run this.  And it's showing a lot of events, because I need to change this to one hour.  Or seven days. That's better.  So let's see if I can make it any bigger.  So it found out two events.  So one is like what I did a couple of minutes ago.  And why is that?  Because that signing event is not yet populated to EntriD signing logs.  But here I found another one.  So this means that somebody has been able to craft a token.  So somebody has stolen my token signing secret from EntriD.  But that doesn't happen, as you know.  So, yeah.  And then I made another thing here.  So this is like a demo of how you can detect if somebody has stolen the signing key.  Okay.  And another thing is that I go back to apps.  Where are my apps?  Apps, apps, apps.  There.  Okay.  I go to token configuration.  I'm going to add an optional claim to my ID token.  And that is going to be IP address.  So if I want to, I can add different information that access token that EntriD has.  And this one is like the IP address where the user created or authenticated.  So now that is included in the access token.  Sorry, the ID token in this case.  So now I go back to my application.  And if you can see here, I am actually now comparing that if the token IP is different than the request IP.  Which means that now somebody is logging in from different IP where that token was first created.  It's going to throw an exception.  So now when I run this, it authenticates automatically, but there should be an exception.  Yeah.  So it says that the IP address doesn't match the request IP address.  So this way you can detect that.  Is this token stolen from a user?  Now, if you are running your own web app, that's quite easy.  But if you are running a service like, let's say, Microsoft EntriD, it's not that easy.  Because people might be traveling in trains, so the IP address might change all the time.  So it wouldn't be that nice to always send an exception if that happens.  But I just wanted you to know that this is possible.  There are techniques that you can use to make sure that nobody can use this.  Or you can detect, at least, those stolen tokens.  Okay. So that was that.  And then let's go to Cloud Owner Identity 2.  So that was if you have, like, your own apps.  But what about if you don't have your own apps?  You are using third-party apps, like, let's say, Microsoft 365.  What you can do?  So you have the...  No. That's better.  So you have the sign-in logs. You can access those, obviously.  But what about if you are using Microsoft 365?  Is there anything that you can see somebody's using something?  Anybody?  Audit logs shows you if somebody is doing something. So yes.  So if you can see some audit event happening, yes.  So unified audit log is one good way.  But there's a new one. This isn't relatively new.  But it happens at least within a year.  So there's another log source.  Yeah.  So if you can see, like, a graph activity,  and there's no corresponding sign-in event,  you can be pretty sure that somebody has stolen our key.  But that doesn't happen, as you know.  Okay. Well, it happened, actually.  So China-based threat actor Storm0558.  So it was about a year ago, April, July last year.  So they actually were able to steal a secret token sign-in key  for an expired Microsoft account.  Not for, like, Android or the business side.  How they stole that, we don't know.  But we know that it was stolen.  And then there were some misconfiguration incidents online.  Which allowed them to use tokens signed with this expired key.  So they were able to access about emails of 25 organizations or something like that.  So it can happen.  We are doing our best that it won't happen again.  But it can happen.  And if I understood correctly by reading those blog posts,  some customers noticed that there's some activity in their exchange.  But there's no corresponding sign-in events.  So it was actually, I think it was this case.  So they see or saw something in Unified Audit Log that shouldn't be there.  And that's how we were able to detect that also and mitigate.  How much time do I have?  A little bit more than 10 minutes.  Okay.  So we're going to end up a little bit early so we can get lunch.  Faster.  So preventing.  How, in theory, you can prevent stuff?  Okay.  How you can prevent stealing tokens?  Well, you need to harden those components that are having those secrets.  Like, they should be tier 0.  For ADFS, you should use your custom certificates  and store the private keys in HSM or hardware security module.  So nobody can get access to those then.  On tokens theft side, from your user endpoints,  you should always use the zero trust.  Well, that means a lot of things.  But what I'm meaning here is that you should not allow access  to your corporate network from bringing your own devices.  So only from managed, compliant devices,  if you want to prevent that token theft.  If you don't, well, there's nothing you can do.  And then in using side,  so if you are writing your web applications, always verify.  So if there's an IP address stamp in your access token or ID token,  compare that to where the request actually comes from.  Also, because you can access, not in all cases,  live data from your sign-in logs,  whatever the source is, EntroID, your on-prem AD, whatever,  compare still those logs every now and then,  like once a day or something,  so that you can see that if there are that kind of things happening,  like somebody's using your stealing secrets to vote stokers.  Okay, so to sum up,  stealing tokens gives temporary access as a one person.  So if you steal something from one user,  you can be that person for an hour or 90 days or forever,  depending what you are stealing.  And then if you steal a secret, you can be anybody,  and usually quite a long time.  So they are more valuable, they are more persistent.  And detecting and preventing this is a team sport.  So as an admin, you can detect anything,  unless your developers are providing you  something where you can detect stuff.  So you need to have logs.  And also you need to protect your different parts,  like your endpoints and then your secret also.  And with that, thank you.  That was all.  Oh dear.  Great, great presentation. I have three questions.  Okay.  So can you go to the slide where it showed the Chinese theft  of the Microsoft private keys?  Okay.  So my first question is, the scope of what those keys cover,  is that per tenant, is it per geography,  is it the entire Azure platform?  Per entire Azure platform.  Okay.  Okay.  My second question is, if we don't work at Microsoft,  is there a way that somebody can tell whether Microsoft  has cycled these keys?  According to those blocks, we have recycled them.  Is there a technical way to tell that?  Click the link.  Okay.  My final question is, do you know whether Microsoft currently  or plans to support bring your own key?  You mean like for Android?  Yeah, for like the security tokens.  There is this concept called external identity,  but I haven't researched or studied that.  But probably is my answer.  Any more questions?  I have a question about the detection part,  because it seems like the mapping, like the query mapping,  maybe you're missing one in the identity provider  or service provider.  The complete login log can find maybe there's an attack  has been occurred, happened.  There's a challenging about when we implement this kind  of a detection, any kind we need to consider,  like maybe there's some trick or some user scenario  we might have overlooked.  Yeah.  So what was the actual question part?  I mean, if we implement the detection,  do any point or we need to consider if maybe there,  because you mentioned based on the IP detection,  then maybe IP will be changing.  There's other scenario will happen if you query detection,  do we need to consider about other point?  Well, if I understood correctly,  so you were asking about there's an IP,  you can detect if it comes from different IP,  what else there is.  Well, it could be, for instance,  it is using different, let's say, user agent.  So in your web app logs, you can see that it is using,  let's say, Internet Explorer.  But usually when the user signed in,  they were using like Edge or something like that.  So you can compare different things.  So whatever you can look in both sites, you can compare those.  So there's a lot of other things, not just IP,  but other things.  So it's still near time to tune in the role.  Yeah, you need to have a look.  Okay, thank you.  I was wondering what about protocol improvements?  I think you're working on it.  What's that, protocol?  Yeah, the protocol improvements, token binding or other.  Yeah, well, yes, those are like a new technical stuff,  and I didn't cover those, but they are things like token binding.  And there was last year a good talk in this same space  about token binding.  And we have also some token binding.  And then we have this thing called continuous access evaluation.  We also help on that.  But my talk was more like generic stuff.  But they are things.  But they are not like standards yet.  It's not good that everybody has their own standard.  That's a bad thing.  Hopefully there will be a standard for that.  Well, actually, PRT is kind of that.  So it's bind on your computer.  Or basically, actually, to certificate which is on your computer.  But yeah, good point.  Are there any plans to protect primary refresh tokens via VBS, for example?  I don't know what is VBS.  Virtualization-based security.  I have no idea.  But PRTs, well, they are kind of stored.  Well, you saw one of the talks yesterday,  so you know where the PRTs are stored in your disk.  But I don't have any knowledge about that.  Thank you.  Hi.  Thanks for the talk.  It was great.  I just have a question.  Like, if an attacker has taken access to the IDP,  I would assume that it has elevated privileges in order to seal the secret.  So at that point, they can inject a memory.  So my question is, if an attacker has access to the IDP anyway,  they might be able to just intercept request and response flow from and to the IDP.  At that point, they can do something that happens naturally.  So they can just block the request, steal the token that is generated for any user,  and then just decide if give them back a token or not.  At that point, the user can just take and do another authentication to get a new token.  So now you have two valid tokens.  And one is of the attacker.  The other one goes to the user.  Now, in that case, you have just a duplicate.  It's not duplicated, but you just have two tokens for two clients, two different clients.  At that point, there is any kind of detection strategies we can use in that case.  And the second question is, do the token binding that is in development would be enough to detect this kind of attack?  Token binding would help you to make sure that the token comes from the correct person.  So it would solve that.  But for the other thing, I don't know if there's anything to do with that.  I don't know.  But I remember there was one threat actor that was able to access the IDP,  though they didn't steal anything.  They just injected a DLL that did stuff.  So if you used a certain username, they always gave you admin rights or added the domain admins to the ticket and so on.  I don't know if I answered your question, but I said something.  Okay. Anybody else?  Okay. That's it.  Thank you.  Thank you.