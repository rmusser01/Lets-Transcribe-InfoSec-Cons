{
  "metadata": {
    "webpage_url": "https://www.youtube.com/watch?v=z-ug2dwcSz8",
    "title": "TROOPERS24: From ASCII to UTF-16: Leveraging Encodings to Break Software",
    "description": "Talk by Stefan Schiller - June 26th, 2024 at TROOPERS24 IT security conference in Heidelberg, Germany hosted by @ERNW_ITSec\n\n#TROOPERS24 #ITsecurity \nhttps://troopers.de/troopers24/talks/r3hxdq/\n\nMore impressions:\nhttps://twitter.com/WEareTROOPERS\nhttps://twitter.com/ERNW_ITSec\nhttps://infosec.exchange/@WEareTROOPERS\nhttps://infosec.exchange/@ERNW https://ernw.de",
    "channel_url": "https://www.youtube.com/channel/UCPY5aUREHmbDO4PtR6AYLfQ",
    "duration": 3565,
    "channel": "TROOPERS IT Security Conference",
    "uploader": "TROOPERS IT Security Conference",
    "upload_date": "20240902"
  },
  "segments": {
    "metadata": {
      "webpage_url": "https://www.youtube.com/watch?v=z-ug2dwcSz8",
      "title": "TROOPERS24: From ASCII to UTF-16: Leveraging Encodings to Break Software",
      "description": "Talk by Stefan Schiller - June 26th, 2024 at TROOPERS24 IT security conference in Heidelberg, Germany hosted by @ERNW_ITSec\n\n#TROOPERS24 #ITsecurity \nhttps://troopers.de/troopers24/talks/r3hxdq/\n\nMore impressions:\nhttps://twitter.com/WEareTROOPERS\nhttps://twitter.com/ERNW_ITSec\nhttps://infosec.exchange/@WEareTROOPERS\nhttps://infosec.exchange/@ERNW https://ernw.de",
      "channel_url": "https://www.youtube.com/channel/UCPY5aUREHmbDO4PtR6AYLfQ",
      "duration": 3565,
      "channel": "TROOPERS IT Security Conference",
      "uploader": "TROOPERS IT Security Conference",
      "upload_date": "20240902"
    },
    "segments": [
      {
        "Time_Start": 0.0,
        "Time_End": 19.04,
        "Text": "This text was transcribed using whisper model: large-v2\n\n Thank you. Hi, all, and thank you for joining. This talk will be about character encodings."
      },
      {
        "Time_Start": 19.04,
        "Time_End": 25.96,
        "Text": " ASCII, UTF-8, UTF-16. Unfortunately, character encodings in general are pretty boring and"
      },
      {
        "Time_Start": 25.96,
        "Time_End": 32.08,
        "Text": " mainly annoying. So, for example, this. Probably a lot of you, at least non-native English"
      },
      {
        "Time_Start": 32.08,
        "Time_End": 36.44,
        "Text": " speakers have seen something similar. Some name contains a special character like an"
      },
      {
        "Time_Start": 36.44,
        "Time_End": 41.72,
        "Text": " umlaut character or a character with an accent, and they're totally messed up when being displayed."
      },
      {
        "Time_Start": 41.72,
        "Time_End": 46.28,
        "Text": " Admittedly, this guy here, J\u00fcrgen Gro\u00dfm\u00fcller, is pretty unfortunate with his names in terms"
      },
      {
        "Time_Start": 46.28,
        "Time_End": 52.64,
        "Text": " of encoding, but this is not the only annoying thing about encoding. Are there any pen testers"
      },
      {
        "Time_Start": 52.64,
        "Time_End": 59.92,
        "Text": " or red teamers here? Yes? Okay. Maybe you also did something like this. A small script"
      },
      {
        "Time_Start": 59.92,
        "Time_End": 66.0,
        "Text": " in Python 2 back then that uses a good old RQTXT to perform some brute forcing. When"
      },
      {
        "Time_Start": 66.0,
        "Time_End": 71.12,
        "Text": " running the script with Python 2, everything was fine. However, Python 2 was replicated"
      },
      {
        "Time_Start": 71.12,
        "Time_End": 76.82,
        "Text": " and Python 3 was released. With Python 3, the incomprehensible decision was made to"
      },
      {
        "Time_Start": 76.82,
        "Time_End": 82.12,
        "Text": " handle strings as actual strings, which is super annoying. When running the script now,"
      },
      {
        "Time_Start": 82.12,
        "Time_End": 86.80000000000001,
        "Text": " Python 3 just throws an error message that says something weird about UTF-8. The script"
      },
      {
        "Time_Start": 86.80000000000001,
        "Time_End": 92.92,
        "Text": " doesn't work anymore. Pretty annoying, isn't it? But hold on. There is more annoying stuff."
      },
      {
        "Time_Start": 92.92,
        "Time_End": 99.60000000000001,
        "Text": " Are there any people with forensic skills here? Yeah. My forensic skills are quite limited."
      },
      {
        "Time_Start": 99.60000000000001,
        "Time_End": 103.92,
        "Text": " If I want to search for a specific string in some files, I usually do something like"
      },
      {
        "Time_Start": 103.92,
        "Time_End": 110.12,
        "Text": " this. A simple grab. Recursively look for files with a string matrix in it. Works like"
      },
      {
        "Time_Start": 110.12,
        "Time_End": 115.48,
        "Text": " a charm and outputs this Linux binary which contains the string. Unfortunately, though,"
      },
      {
        "Time_Start": 115.48,
        "Time_End": 119.96000000000001,
        "Text": " I missed the second occurrence of the string in this Windows binary. It also contains a"
      },
      {
        "Time_Start": 119.96000000000001,
        "Time_End": 125.16000000000001,
        "Text": " string, but it's encoded with Studio 16. Because of that, there are plenty of annoying null"
      },
      {
        "Time_Start": 125.16000000000001,
        "Time_End": 130.20000000000002,
        "Text": " bytes here in the string, and my simple grab command just didn't find it. I don't know"
      },
      {
        "Time_Start": 130.20000000000002,
        "Time_End": 133.92000000000002,
        "Text": " about you, but that's already enough for me, and we are on a tight schedule, so let's come"
      },
      {
        "Time_Start": 133.92000000000002,
        "Time_End": 140.08,
        "Text": " to a final conclusion. Character encodings are boring. Dealing with them is very annoying."
      },
      {
        "Time_Start": 141.04000000000002,
        "Time_End": 145.28,
        "Text": " They keep us from doing our actual job in various situations, and, after all, if some"
      },
      {
        "Time_Start": 145.28,
        "Time_End": 149.64000000000001,
        "Text": " strange umlaut character is not displayed correctly, this does not have any security"
      },
      {
        "Time_Start": 149.64000000000001,
        "Time_End": 158.76000000000002,
        "Text": " impact at all. However, I want to quickly show you something, a small demo. So we have"
      },
      {
        "Time_Start": 158.76000000000002,
        "Time_End": 164.52,
        "Text": " some website here where you can enter a text. The text is reflected on the website itself."
      },
      {
        "Time_Start": 164.52,
        "Time_End": 172.8,
        "Text": " So what we do, of course, try our usual XSS payload. It's reflected. It does not trigger."
      },
      {
        "Time_Start": 172.8,
        "Time_End": 179.84,
        "Text": " Having a look at the HTTP response, we can see that the brackets are probably HTML encoded,"
      },
      {
        "Time_Start": 179.84,
        "Time_End": 185.92000000000002,
        "Text": " so the payload doesn't trigger. What we can notice is a script tag here with a lang variable"
      },
      {
        "Time_Start": 185.92000000000002,
        "Time_End": 191.16000000000003,
        "Text": " which is obviously populated from the query parameter we can also set in the URL. Let's"
      },
      {
        "Time_Start": 191.16,
        "Time_End": 196.92,
        "Text": " try to escape the string by inserting a double quote and adding some payload here, but, again,"
      },
      {
        "Time_Start": 196.92,
        "Time_End": 203.04,
        "Text": " we can see it doesn't trigger. The double quote escaped with a backslash. So the string"
      },
      {
        "Time_Start": 203.04,
        "Time_End": 208.76,
        "Text": " context cannot be escaped. Now we enter some magic sequence, boom, the payload triggers,"
      },
      {
        "Time_Start": 208.76,
        "Time_End": 216.24,
        "Text": " and we see some weird Japanese characters here. So let's have a look at the HTTP response."
      },
      {
        "Time_Start": 216.24,
        "Time_End": 222.84,
        "Text": " Our double quote is still escaped with a backslash. So it's pretty strange. The payload"
      },
      {
        "Time_Start": 222.84,
        "Time_End": 228.64000000000001,
        "Text": " is here. But if you now have a look at the DOM tree, you can notice that there's no backslash"
      },
      {
        "Time_Start": 228.64000000000001,
        "Time_End": 233.64000000000001,
        "Text": " any more. Instead of a backslash, there's now a yen sign. So the double quote we inserted"
      },
      {
        "Time_Start": 233.64000000000001,
        "Time_End": 242.44,
        "Text": " actually escaped the string context, and our payload triggered. So what the heck is going"
      },
      {
        "Time_Start": 242.44,
        "Time_End": 248.76,
        "Text": " on here? Maybe this last point about security impact is not totally valid. With some weird"
      },
      {
        "Time_Start": 248.76,
        "Time_End": 253.94,
        "Text": " character encoding behavior in the browser, we were able to inject JavaScript code. Before"
      },
      {
        "Time_Start": 253.94,
        "Time_End": 259.15999999999997,
        "Text": " we explore what's happening here, a quick slide. My name is Stefan. You can find me"
      },
      {
        "Time_Start": 259.15999999999997,
        "Time_End": 267.96,
        "Text": " on Twitter on X. I'm a vulnerability researcher in the R&D team. Our vulnerability research"
      },
      {
        "Time_Start": 267.96,
        "Time_End": 272.96,
        "Text": " team discovers zero-day vulnerabilities in popular open source software that we responsibly"
      },
      {
        "Time_Start": 272.96,
        "Time_End": 279.28,
        "Text": " disclose to the vendors, and they use to strengthen our product with innovation ideas. So character"
      },
      {
        "Time_Start": 279.28,
        "Time_End": 285.96,
        "Text": " encodings. I think these emojis here describe pretty well how my attitude towards character"
      },
      {
        "Time_Start": 285.96,
        "Time_End": 290.71999999999997,
        "Text": " encodings changed over time, the more and more I learned about them. I hope that after"
      },
      {
        "Time_Start": 290.71999999999997,
        "Time_End": 296.56,
        "Text": " the demo, we are already in this mood. Obviously, there is more to characters encodings than"
      },
      {
        "Time_Start": 296.56,
        "Time_End": 303.84,
        "Text": " just all this annoying stuff. So let's start very simple. What even is an encoding? There"
      },
      {
        "Time_Start": 303.84,
        "Time_End": 308.96,
        "Text": " are different assets that we would like to store and process with a computer. For example,"
      },
      {
        "Time_Start": 308.96,
        "Time_End": 313.68,
        "Text": " image, sound, text. The problem is that a computer cannot process these assets out of"
      },
      {
        "Time_Start": 313.68,
        "Time_End": 318.92,
        "Text": " the box. The only thing a computer can process are ones and zeros. Thus, we need a way to"
      },
      {
        "Time_Start": 318.92,
        "Time_End": 326.8,
        "Text": " map these assets to ones and zeros. The process of this mapping is called encoding. After"
      },
      {
        "Time_Start": 326.8,
        "Time_End": 332.64000000000004,
        "Text": " the assets have been encoded to bits and bytes, a computer can process these. For an image,"
      },
      {
        "Time_Start": 332.64000000000004,
        "Time_End": 338.04,
        "Text": " for example, we start with the first pixel and use some colour module, usually RGB, which"
      },
      {
        "Time_Start": 338.04,
        "Time_End": 344.44,
        "Text": " defines how specific colours map to bytes. In case of RGB, three bytes are used to represent"
      },
      {
        "Time_Start": 344.44,
        "Time_End": 350.04,
        "Text": " the colour of a single pixel. We just need to look up the RGB value for our pixel, and"
      },
      {
        "Time_Start": 350.04,
        "Time_End": 354.88,
        "Text": " we get the corresponding three-byte sequence which represents the colour of this pixel."
      },
      {
        "Time_Start": 354.88,
        "Time_End": 359.68,
        "Text": " This byte can then be processed and stored by a computer. The same process is also required"
      },
      {
        "Time_Start": 359.68,
        "Time_End": 364.28,
        "Text": " for a string. So, we take the first character, and this time, we don't want to map colours"
      },
      {
        "Time_Start": 364.28,
        "Time_End": 370.52,
        "Text": " to bytes but characters to bytes, so we use some encoding scheme, for example, ASCII,"
      },
      {
        "Time_Start": 370.52,
        "Time_End": 374.88,
        "Text": " which provides a mapping between characters and bytes. We now only need to look up the"
      },
      {
        "Time_Start": 374.88,
        "Time_End": 379.44,
        "Text": " character in this table, and we get the bytes that represent this character. This byte can"
      },
      {
        "Time_Start": 379.44,
        "Time_End": 385.24,
        "Text": " then again be processed and stored by a computer. So generally, very straightforward. So, time"
      },
      {
        "Time_Start": 385.24,
        "Time_End": 396.96,
        "Text": " for a small quiz. What do you think does this byte sequence represent here? I think I heard"
      },
      {
        "Time_Start": 396.96000000000004,
        "Time_End": 406.56000000000006,
        "Text": " it somewhere there, so, yes, it looks like the string hello! But in this case, it's not."
      },
      {
        "Time_Start": 406.56000000000006,
        "Time_End": 411.56000000000006,
        "Text": " These are the RGB values of two pixels from this image. They just happen to have byte"
      },
      {
        "Time_Start": 411.56000000000006,
        "Time_End": 417.40000000000003,
        "Text": " values which are also valid ASCII characters. The obvious conclusion from this is that we"
      },
      {
        "Time_Start": 417.40000000000003,
        "Time_End": 422.68000000000006,
        "Text": " cannot decode a byte stream if you don't know what was encoded. However, we are really used"
      },
      {
        "Time_Start": 422.68,
        "Time_End": 428.72,
        "Text": " to ASCII. Take a look at this hex dump, for example. There's obviously an A character"
      },
      {
        "Time_Start": 428.72,
        "Time_End": 434.0,
        "Text": " here. The byte hex for one is always A. That's how it is. But, in fact, the byte hex for"
      },
      {
        "Time_Start": 434.0,
        "Time_End": 439.28000000000003,
        "Text": " one here has nothing to do with a character at all. This is part of an executable file,"
      },
      {
        "Time_Start": 439.28000000000003,
        "Time_End": 444.76,
        "Text": " and the byte hex for one introduces an x64 opcode. Of course, hex dump is just the wrong"
      },
      {
        "Time_Start": 444.76,
        "Time_End": 449.6,
        "Text": " tool here, and we should have used a disassembler, but there's an unofficial rule which states"
      },
      {
        "Time_Start": 449.6,
        "Time_End": 454.84000000000003,
        "Text": " when in doubt, it's ASCII. Instead of mapping single bytes to ASCII characters, hex dump"
      },
      {
        "Time_Start": 454.84000000000003,
        "Time_End": 460.74,
        "Text": " could also map three byte sequences to a colour, and that's how this would look like. It's"
      },
      {
        "Time_Start": 460.74,
        "Time_End": 466.02000000000004,
        "Text": " just as valuable as looking at the ASCII characters decoded from binary data which is not encoded"
      },
      {
        "Time_Start": 466.02000000000004,
        "Time_End": 472.76000000000005,
        "Text": " in ASCII. So, of course, we need to know what data we are handling with. But in most cases,"
      },
      {
        "Time_Start": 472.76000000000005,
        "Time_End": 477.84000000000003,
        "Text": " this should be very obvious, especially for image files with different file extensions"
      },
      {
        "Time_Start": 477.84000000000003,
        "Time_End": 485.14000000000004,
        "Text": " that indicate what kind of data to expect. We have PNGs, BMPs, JPEGs, all of these three"
      },
      {
        "Time_Start": 485.14000000000004,
        "Time_End": 490.40000000000003,
        "Text": " with different file extensions. This file extension indicates that this is an image,"
      },
      {
        "Time_Start": 490.40000000000003,
        "Time_End": 495.64000000000004,
        "Text": " and what specific encoding should be used. But what about strings? We don't really have"
      },
      {
        "Time_Start": 495.64000000000004,
        "Time_End": 499.64000000000004,
        "Text": " different file extensions, and strings are also used in memory and as part of network"
      },
      {
        "Time_Start": 499.64000000000004,
        "Time_End": 507.28000000000003,
        "Text": " protocols. Do we even have different kinds of strings? Let's have a look at an application"
      },
      {
        "Time_Start": 507.28000000000003,
        "Time_End": 512.8000000000001,
        "Text": " everyone here is using. Every day, probably for hours, a web browser. These are just"
      },
      {
        "Time_Start": 512.8000000000001,
        "Time_End": 518.6,
        "Text": " a few of the character encodings supported by all modern browsers. But what is the big"
      },
      {
        "Time_Start": 518.6,
        "Time_End": 525.08,
        "Text": " difference? Let's have a look at two of the more common ones, UTF-8 and UTF-16. Imagine"
      },
      {
        "Time_Start": 525.08,
        "Time_End": 530.6800000000001,
        "Text": " we receive this byte sequence, and we know that it's a string, but which specific character"
      },
      {
        "Time_Start": 530.6800000000001,
        "Time_End": 536.4,
        "Text": " encoding was used? Is it UTF-8, and the sender just wanted to warmly welcome us with this"
      },
      {
        "Time_Start": 536.52,
        "Time_End": 544.56,
        "Text": " two emojis here? Or could it be UTF-16, and the sender is heavily insulting us in, I guess,"
      },
      {
        "Time_Start": 544.56,
        "Time_End": 550.0799999999999,
        "Text": " Chinese? We don't know if we don't know the character encoding. And the fact that we usually"
      },
      {
        "Time_Start": 550.0799999999999,
        "Time_End": 555.36,
        "Text": " try to stay in our Esky comfort zone blinds us from the truth which is very well summarised"
      },
      {
        "Time_Start": 555.36,
        "Time_End": 561.4,
        "Text": " by this quote. There ain't no such thing as plain text. The quote is from Jules Bolski"
      },
      {
        "Time_Start": 561.4,
        "Time_End": 566.28,
        "Text": " who wrote a great article about Unicode and character sets in 2003 which is still"
      },
      {
        "Time_Start": 566.28,
        "Time_End": 572.04,
        "Text": " absolutely relevant today. If you have a string in memory or in file, you need to know"
      },
      {
        "Time_Start": 572.04,
        "Time_End": 577.1999999999999,
        "Text": " the encoding or it cannot be correctly mapped to the information it's holding, the characters."
      },
      {
        "Time_Start": 577.1999999999999,
        "Time_End": 582.24,
        "Text": " The false assumption of the existence of plain text also hides where character encoding and"
      },
      {
        "Time_Start": 582.24,
        "Time_End": 589.04,
        "Text": " decoding actually happens. Let me give you a very simple example. Imagine this simple"
      },
      {
        "Time_Start": 589.04,
        "Time_End": 595.36,
        "Text": " website where you can submit a comment. What actually happens if you push the submit button?"
      },
      {
        "Time_Start": 595.44,
        "Time_End": 601.6800000000001,
        "Text": " Well, the text free your mind is submitted to the server which stores it. But wait, it"
      },
      {
        "Time_Start": 601.6800000000001,
        "Time_End": 607.8000000000001,
        "Text": " submits the text free your mind. How does free your mind look like on a network wire?"
      },
      {
        "Time_Start": 607.8000000000001,
        "Time_End": 612.92,
        "Text": " We only have ones and zeros. So there needs to be some encoding. And this encoding is"
      },
      {
        "Time_Start": 612.92,
        "Time_End": 617.96,
        "Text": " performed by the browser when we push the submit button. The browser encodes the text"
      },
      {
        "Time_Start": 617.96,
        "Time_End": 623.48,
        "Text": " free your mind, puts it in an HTTP request and sends it over the wire. Now the web server"
      },
      {
        "Time_Start": 623.48,
        "Time_End": 628.08,
        "Text": " receives the byte stream containing our encoded text and can decode it back to the text free"
      },
      {
        "Time_Start": 628.08,
        "Time_End": 633.88,
        "Text": " your mind. The logic and functionality of a web server is usually implemented in PHP,"
      },
      {
        "Time_Start": 633.88,
        "Time_End": 639.28,
        "Text": " Java, Python, JavaScript or a similar language. All of these languages differ in terms of"
      },
      {
        "Time_Start": 639.28,
        "Time_End": 644.64,
        "Text": " how they handle strings. But what they have all in common is that they need to store strings"
      },
      {
        "Time_Start": 644.64,
        "Time_End": 650.4,
        "Text": " in memory. Yeah, and guess what? We cannot store a text in memory. We can only store"
      },
      {
        "Time_Start": 650.4,
        "Time_End": 655.36,
        "Text": " bits and bytes. Thus the text needs to be encoded again. And the encoding used here"
      },
      {
        "Time_Start": 655.36,
        "Time_End": 660.24,
        "Text": " differs from language to language and is totally independent of the encoding used by the browser"
      },
      {
        "Time_Start": 660.24,
        "Time_End": 665.0,
        "Text": " when sending the request on the wire. So now the string is loaded into memory, the application"
      },
      {
        "Time_Start": 665.0,
        "Time_End": 669.48,
        "Text": " can perform some string manipulation on the comment, and once this is done, the comment"
      },
      {
        "Time_Start": 669.48,
        "Time_End": 674.48,
        "Text": " should be stored in a database. Thus it needs to be submitted over the wire again. And the"
      },
      {
        "Time_Start": 674.48,
        "Time_End": 679.0,
        "Text": " encoding used here is again totally independent of the encoding internally used by the programming"
      },
      {
        "Time_Start": 679.0,
        "Time_End": 684.88,
        "Text": " language. So the bytes in memory needs to be decoded and reencoded before they can be"
      },
      {
        "Time_Start": 684.88,
        "Time_End": 689.96,
        "Text": " sent over the wire. Now the database server receives this byte stream, can decode it back"
      },
      {
        "Time_Start": 689.96,
        "Time_End": 695.84,
        "Text": " to the text free your mind. Yet again, the database server needs to store the string"
      },
      {
        "Time_Start": 695.84,
        "Time_End": 701.96,
        "Text": " in memory and thus needs to encode the text independent of the on the wire encoding. At"
      },
      {
        "Time_Start": 701.96,
        "Time_End": 706.8,
        "Text": " last the text should be stored on the hard disk of a database server. Thus it's decoded"
      },
      {
        "Time_Start": 706.8000000000001,
        "Time_End": 712.0400000000001,
        "Text": " from memory and reencoded with a character encoding used for the file storage. Again"
      },
      {
        "Time_Start": 712.0400000000001,
        "Time_End": 718.6800000000001,
        "Text": " an independent encoding. So that's it. Finally the comment made its way from the browser"
      },
      {
        "Time_Start": 718.6800000000001,
        "Time_End": 723.1600000000001,
        "Text": " to the hard disk of the database server. And this is quite an adventurous journey for the"
      },
      {
        "Time_Start": 723.1600000000001,
        "Time_End": 729.44,
        "Text": " little comment. It passed through plenty of encoding and decoding steps. All these steps"
      },
      {
        "Time_Start": 729.44,
        "Time_End": 736.2800000000001,
        "Text": " pose the risk of potential character encoding issues. But what even are character encoding"
      },
      {
        "Time_Start": 736.28,
        "Time_End": 741.48,
        "Text": " issues from a security point of view? If you're a pen tester, you've probably seen"
      },
      {
        "Time_Start": 741.48,
        "Time_End": 747.22,
        "Text": " strange payloads like this. For example, for path traversal, there are these payloads which"
      },
      {
        "Time_Start": 747.22,
        "Time_End": 753.1999999999999,
        "Text": " use some weird non-ASCII characters. And also for SQL injection, there are similar strange-looking"
      },
      {
        "Time_Start": 753.1999999999999,
        "Time_End": 760.28,
        "Text": " payloads. You should always test these sequences. They just never work. But if we can figure"
      },
      {
        "Time_Start": 760.28,
        "Time_End": 766.48,
        "Text": " out what the fundamental problem here is, we might be able to discover similar issues."
      },
      {
        "Time_Start": 766.48,
        "Time_End": 770.9599999999999,
        "Text": " So we already know the basics of encoding in general. So let's have a look at character"
      },
      {
        "Time_Start": 770.9599999999999,
        "Time_End": 776.4,
        "Text": " encoding specifically. In fact, character encodings are quite old and were even used"
      },
      {
        "Time_Start": 776.4,
        "Time_End": 783.16,
        "Text": " before the digital age. This is one of the first kind of chat application. A telegraph"
      },
      {
        "Time_Start": 783.16,
        "Time_End": 788.72,
        "Text": " and the Morse code for character encoding. The core principle is straightforward. Characters"
      },
      {
        "Time_Start": 788.72,
        "Time_End": 794.12,
        "Text": " and numbers are mapped to a sequence of dots and dashes. This way it's possible to transmit"
      },
      {
        "Time_Start": 794.12,
        "Time_End": 800.4,
        "Text": " these via telegraph. Now fast forward to the digital age and to the rise of computers."
      },
      {
        "Time_Start": 800.4,
        "Time_End": 806.4,
        "Text": " Computers are awesome. And manufacturers are eager to provide great products. As with all"
      },
      {
        "Time_Start": 806.4,
        "Time_End": 810.88,
        "Text": " fast evolving technologies, though, there is a lot of competition and not much time"
      },
      {
        "Time_Start": 810.88,
        "Time_End": 817.32,
        "Text": " for coordination. So each manufacturer came up with their own character encoding solution."
      },
      {
        "Time_Start": 817.32,
        "Time_End": 824.0400000000001,
        "Text": " These solutions work perfectly fine as long as everything stayed within an isolated environment."
      },
      {
        "Time_Start": 824.0400000000001,
        "Time_End": 829.12,
        "Text": " But as soon as data needs to be exchanged, this became kind of a problem since these"
      },
      {
        "Time_Start": 829.12,
        "Time_End": 834.24,
        "Text": " solutions were incompatible. It also slowly appeared that these connecting of computers"
      },
      {
        "Time_Start": 834.24,
        "Time_End": 841.1600000000001,
        "Text": " might be a thing in the future. So we need some standard. The answer to this was ASCII."
      },
      {
        "Time_Start": 841.1600000000001,
        "Time_End": 845.94,
        "Text": " All letters are covered. All numbers are covered. There are additional symbols. And we even"
      },
      {
        "Time_Start": 845.94,
        "Time_End": 851.74,
        "Text": " have control characters. Pretty solid solution. Unfortunately, somebody realized that there"
      },
      {
        "Time_Start": 851.74,
        "Time_End": 856.34,
        "Text": " are more languages in English. And these use kind of weird other characters which are not"
      },
      {
        "Time_Start": 856.34,
        "Time_End": 862.5,
        "Text": " covered by ASCII. So it became obvious that ASCII is not enough. But no worries. ASCII"
      },
      {
        "Time_Start": 862.5,
        "Time_End": 867.7,
        "Text": " is a seven bit encoding. This means that the most significant bit is always zero. Let's"
      },
      {
        "Time_Start": 867.7,
        "Time_End": 873.22,
        "Text": " just set this bit to one, which allows us to encode another 128 characters. This is"
      },
      {
        "Time_Start": 873.22,
        "Time_End": 877.58,
        "Text": " not enough for all languages, but we can map the bit sequences where the most significant"
      },
      {
        "Time_Start": 877.58,
        "Time_End": 882.6600000000001,
        "Text": " bit is one to different characters for each language. And that's how the result of this"
      },
      {
        "Time_Start": 882.6600000000001,
        "Time_End": 888.62,
        "Text": " looks like. The ISO 8859 standard. For each language, there are different substandards"
      },
      {
        "Time_Start": 888.62,
        "Time_End": 894.5400000000001,
        "Text": " that are compatible with ASCII and just use the additional 128 code points to encode the"
      },
      {
        "Time_Start": 894.5400000000001,
        "Time_End": 900.86,
        "Text": " language specific characters. But again, in terms of compatibility, this was not the perfect"
      },
      {
        "Time_Start": 900.86,
        "Time_End": 907.82,
        "Text": " solution. When exchanging data between systems, there was still a lot of potential for confusion."
      },
      {
        "Time_Start": 907.82,
        "Time_End": 914.14,
        "Text": " Also in the 1980s, additional character encodings emerged which cover Asian characters for China,"
      },
      {
        "Time_Start": 914.14,
        "Time_End": 920.54,
        "Text": " Korea, and Japan. These encodings, too, were limited to these specific languages. So the"
      },
      {
        "Time_Start": 920.54,
        "Time_End": 926.66,
        "Text": " confusion was perfect and the situation seemed pretty hopeless. But then the savior emerged."
      },
      {
        "Time_Start": 926.66,
        "Time_End": 932.42,
        "Text": " Unicode. Unicode assigns code points to practically every character from all major languages and"
      },
      {
        "Time_Start": 932.42,
        "Time_End": 940.14,
        "Text": " writing systems. The latest version roughly contains 150,000 characters. It includes control"
      },
      {
        "Time_Start": 940.14,
        "Time_End": 944.66,
        "Text": " characters, additional symbols, emojis, so pretty much everything covered when it comes"
      },
      {
        "Time_Start": 944.66,
        "Time_End": 951.6999999999999,
        "Text": " to a stream. This is the character set used today and probably also during the next decades."
      },
      {
        "Time_Start": 951.7,
        "Time_End": 957.58,
        "Text": " Unicode itself only maps characters or symbols to code points. So whenever you see this U"
      },
      {
        "Time_Start": 957.58,
        "Time_End": 964.82,
        "Text": " plus followed by a hex value, that's a code point. You can map a code point to a character,"
      },
      {
        "Time_Start": 964.82,
        "Time_End": 970.38,
        "Text": " but it does not tell you how it looks like on the wire or memory or on a file. For this"
      },
      {
        "Time_Start": 970.38,
        "Time_End": 976.5,
        "Text": " purpose, we need a specific character encoding. And for Unicode, the major encodings are UTF-8,"
      },
      {
        "Time_Start": 976.5,
        "Time_End": 986.1,
        "Text": " UTF-16, UTF-32. Let's start with the most simple one, UTF-32. UTF-32 is the most straightforward"
      },
      {
        "Time_Start": 986.1,
        "Time_End": 992.98,
        "Text": " encoding because it uses 32 bits or 4 bytes for each character. Because of that, it can"
      },
      {
        "Time_Start": 992.98,
        "Time_End": 997.7,
        "Text": " directly use the code point values. So the A character, for example, is encoded with"
      },
      {
        "Time_Start": 997.7,
        "Time_End": 1002.82,
        "Text": " a 4-byte sequence, hex for 1 followed by 3 zero bytes. This directly matches the code"
      },
      {
        "Time_Start": 1002.82,
        "Time_End": 1007.74,
        "Text": " point value. The other bytes in memory are just reversed because in most cases, the little"
      },
      {
        "Time_Start": 1007.74,
        "Time_End": 1012.2600000000001,
        "Text": " engine is used. The second character is also encoded with a byte sequence that matches"
      },
      {
        "Time_Start": 1012.2600000000001,
        "Time_End": 1016.7,
        "Text": " the code point value. The same thing can be applied to the third character. The byte sequence"
      },
      {
        "Time_Start": 1016.7,
        "Time_End": 1022.22,
        "Text": " just matches the code point value. So UTF-32 is very straightforward, but the downside"
      },
      {
        "Time_Start": 1022.22,
        "Time_End": 1027.98,
        "Text": " is that we always use 4 bytes for each character. If a string only contains ASCII characters"
      },
      {
        "Time_Start": 1028.02,
        "Time_End": 1033.9,
        "Text": " like the symbol A character, there are 3 zero bytes that are totally wasted. UTF-16 tries"
      },
      {
        "Time_Start": 1033.9,
        "Time_End": 1039.26,
        "Text": " to partially solve this with a more memory efficient approach. It uses a fixed amount"
      },
      {
        "Time_Start": 1039.26,
        "Time_End": 1045.54,
        "Text": " of 2 bytes per character. So for the A character, the code point value is taken again and put"
      },
      {
        "Time_Start": 1045.54,
        "Time_End": 1050.7,
        "Text": " into a 2-byte sequence. This also works fine for the second character. The code point value"
      },
      {
        "Time_Start": 1050.7,
        "Time_End": 1055.54,
        "Text": " fits into 2 bytes. However, for the third character, we have kind of a problem. The"
      },
      {
        "Time_Start": 1055.58,
        "Time_End": 1060.1399999999999,
        "Text": " code point value does not fit into 2 bytes. This is true for all code points that are"
      },
      {
        "Time_Start": 1060.1399999999999,
        "Time_End": 1066.1,
        "Text": " not part of the basic multilingual plane and have more than 4 hex digits. So, for example,"
      },
      {
        "Time_Start": 1066.1,
        "Time_End": 1071.98,
        "Text": " this emoji rocket here. These characters are encoded with something called a surrogate"
      },
      {
        "Time_Start": 1071.98,
        "Time_End": 1078.62,
        "Text": " pair. A surrogate pair consists of a high surrogate and a low surrogate. These surrogates"
      },
      {
        "Time_Start": 1078.62,
        "Time_End": 1083.3,
        "Text": " are just specific code points designated for the purpose of encoding characters that don't"
      },
      {
        "Time_Start": 1083.3,
        "Time_End": 1088.82,
        "Text": " fit into 2 bytes. Each of the surrogates itself can be stored in 2 bytes. That's the"
      },
      {
        "Time_Start": 1088.82,
        "Time_End": 1094.1399999999999,
        "Text": " total amount of bytes required to store this character in UTF-16 is 4. And that's everything"
      },
      {
        "Time_Start": 1094.1399999999999,
        "Time_End": 1099.58,
        "Text": " you need to know about UTF-16. Fixed amount of 2 bytes per character and characters with"
      },
      {
        "Time_Start": 1099.58,
        "Time_End": 1105.06,
        "Text": " a code point that does not fit into 2 bytes are encoded as a surrogate pair. For ASCII"
      },
      {
        "Time_Start": 1105.06,
        "Time_End": 1110.22,
        "Text": " characters, UTF-16 is still not the perfect solution. Not as bad as UTF-32, but there"
      },
      {
        "Time_Start": 1110.22,
        "Time_End": 1116.82,
        "Text": " is still one completely wasted null byte. And a lot of strings only contain ASCII characters."
      },
      {
        "Time_Start": 1116.82,
        "Time_End": 1122.74,
        "Text": " UTF-8 tries to solve this with an even more flexible approach that uses 1, 2, 3, or 4"
      },
      {
        "Time_Start": 1122.74,
        "Time_End": 1129.7,
        "Text": " bytes per character. How does this work? We already mentioned that ASCII is a 7-bit encoding"
      },
      {
        "Time_Start": 1129.7,
        "Time_End": 1135.66,
        "Text": " and the most significant bit is always 0. For these bytes, UTF-8 does not change anything"
      },
      {
        "Time_Start": 1135.66,
        "Time_End": 1142.18,
        "Text": " and simply matches ASCII. So the A character is encoded with a single byte hex for 1."
      },
      {
        "Time_Start": 1142.18,
        "Time_End": 1146.22,
        "Text": " The great advantage of this is that you can take an ASCII-encoded byte stream and decode"
      },
      {
        "Time_Start": 1146.22,
        "Time_End": 1152.22,
        "Text": " it with UTF-8, it will still result in the same characters. A 1 is the most significant"
      },
      {
        "Time_Start": 1152.22,
        "Time_End": 1158.22,
        "Text": " byte is used to introduce a longer byte sequence required for all other characters. Two leading"
      },
      {
        "Time_Start": 1158.22,
        "Time_End": 1163.74,
        "Text": " ones in the 0 designates a leading byte which introduces a 2-byte sequence. Three ones in"
      },
      {
        "Time_Start": 1163.74,
        "Time_End": 1170.02,
        "Text": " the 0 introduces a 3-byte sequence. Four ones in the 0 introduces a 4-byte sequence."
      },
      {
        "Time_Start": 1170.02,
        "Time_End": 1174.42,
        "Text": " And all bytes falling in such a sequence are called continuation bytes and always begin"
      },
      {
        "Time_Start": 1174.42,
        "Time_End": 1180.06,
        "Text": " with a single 1 and a 0. So we can either have a 1-byte character which is equal to"
      },
      {
        "Time_Start": 1180.06,
        "Time_End": 1187.02,
        "Text": " ASCII, we can have a 2-byte sequence, a 3-byte sequence, or a 4-byte sequence. All these"
      },
      {
        "Time_Start": 1187.02,
        "Time_End": 1191.3,
        "Text": " remaining yellow bits here are not used for meta information and can be used to encode"
      },
      {
        "Time_Start": 1191.3,
        "Time_End": 1196.34,
        "Text": " the actual code point value. This allows UTF-8 to encode over 2 million code point"
      },
      {
        "Time_Start": 1196.34,
        "Time_End": 1202.1,
        "Text": " values, so far more than are actually assigned by the current Unicode standard. For example,"
      },
      {
        "Time_Start": 1202.1,
        "Time_End": 1207.94,
        "Text": " let's have a look at this non-ASCII character. This character is encoded with a 3-byte sequence."
      },
      {
        "Time_Start": 1207.94,
        "Time_End": 1214.86,
        "Text": " This is a binary representation of these bytes. The first byte begins with three 1s and a"
      },
      {
        "Time_Start": 1214.86,
        "Time_End": 1221.02,
        "Text": " 0, so it's a leading byte for a 3-byte sequence. Thus, the next byte begins with a single 1"
      },
      {
        "Time_Start": 1221.02,
        "Time_End": 1227.54,
        "Text": " and a 0, thus it's a continuation byte. And also the third byte is a continuation byte."
      },
      {
        "Time_Start": 1227.54,
        "Time_End": 1232.66,
        "Text": " Each of these bytes contains three yellow bits which can be used to encode the actual"
      },
      {
        "Time_Start": 1232.66,
        "Time_End": 1240.3,
        "Text": " code point. So this byte sequence matches the bytes 0x7D, 0x20, which is the code point"
      },
      {
        "Time_Start": 1240.3,
        "Time_End": 1246.18,
        "Text": " of this character. And that's everything for UTF-8. Single ASCII characters are just taken"
      },
      {
        "Time_Start": 1246.18,
        "Time_End": 1251.18,
        "Text": " as they are. The most significant bit is used to introduce a multi-byte sequence of"
      },
      {
        "Time_Start": 1251.18,
        "Time_End": 1256.9,
        "Text": " 2, 3, or 4, and all these byte sequences start with a leading byte followed by a continuation"
      },
      {
        "Time_Start": 1256.9,
        "Time_End": 1262.3400000000001,
        "Text": " byte. If that still feels a little bit confusing to you, I recommend to give a look at this"
      },
      {
        "Time_Start": 1262.3400000000001,
        "Time_End": 1267.98,
        "Text": " UTF-8 visualiser I built to help understand how UTF-8 works internally. The tool allows"
      },
      {
        "Time_Start": 1267.98,
        "Time_End": 1274.66,
        "Text": " you to enter text binary hex and decode your input with UTF-8. This way, you can play around"
      },
      {
        "Time_Start": 1274.66,
        "Time_End": 1284.02,
        "Text": " with UTF-8 directly on a bit level. I will share the link later. Okay, so that's basically"
      },
      {
        "Time_Start": 1284.02,
        "Time_End": 1290.14,
        "Text": " all we need to know to finally break something. I've picked four major security issues that"
      },
      {
        "Time_Start": 1290.14,
        "Time_End": 1294.9,
        "Text": " you may encounter when dealing with character encodings. These are definitely not the only"
      },
      {
        "Time_Start": 1294.9,
        "Time_End": 1299.42,
        "Text": " issues that exist, but this choice should give you a very good understanding of what"
      },
      {
        "Time_Start": 1299.42,
        "Time_End": 1304.94,
        "Text": " can go wrong. We will cover overlong UTF-8 sequences, invalid byte sequences, string"
      },
      {
        "Time_Start": 1304.94,
        "Time_End": 1309.88,
        "Text": " names issues, and encoding differentials. If you listen carefully, you might be able"
      },
      {
        "Time_Start": 1309.88,
        "Time_End": 1315.22,
        "Text": " to understand what was going on in the demo I showed at the beginning. Let's start with"
      },
      {
        "Time_Start": 1315.22,
        "Time_End": 1320.0600000000002,
        "Text": " overlong UTF-8 sequences and have a look at one of the weird paths, traversal payloads"
      },
      {
        "Time_Start": 1320.06,
        "Time_End": 1329.3799999999999,
        "Text": " we already mentioned. This one. In binary, the first byte looks like this. There are"
      },
      {
        "Time_Start": 1329.3799999999999,
        "Time_End": 1334.74,
        "Text": " two ones and a zero at the beginning. Thus, this is a leading byte for a two-byte sequence,"
      },
      {
        "Time_Start": 1334.74,
        "Time_End": 1340.26,
        "Text": " so we need another byte. This is the next byte in binary with a single one and a zero"
      },
      {
        "Time_Start": 1340.26,
        "Time_End": 1345.98,
        "Text": " at the beginning. Thus, this is a valid continuation byte. Both bytes complete the two-byte sequence"
      },
      {
        "Time_Start": 1345.98,
        "Time_End": 1352.34,
        "Text": " and we can now combine them to the resulting code point. In this case, the code point is"
      },
      {
        "Time_Start": 1352.34,
        "Time_End": 1358.22,
        "Text": " hex 2E, which is a dot character, but this character is a simple ASCII character which"
      },
      {
        "Time_Start": 1358.22,
        "Time_End": 1364.1,
        "Text": " can be encoded with a single byte. These leading zeros here are not necessary. Still, this"
      },
      {
        "Time_Start": 1364.1,
        "Time_End": 1369.34,
        "Text": " two-byte sequence resides in a dot character. The next two bytes in the payload are the"
      },
      {
        "Time_Start": 1369.34,
        "Time_End": 1375.26,
        "Text": " same. Again, a zero-padded leading byte and a continuation byte which both represent the"
      },
      {
        "Time_Start": 1375.26,
        "Time_End": 1381.26,
        "Text": " dot character. The next two bytes are also similar, only this time, they encode a slash"
      },
      {
        "Time_Start": 1381.26,
        "Time_End": 1387.74,
        "Text": " character which is padded with zeros to form a two-byte sequence. This payload is just"
      },
      {
        "Time_Start": 1387.74,
        "Time_End": 1394.58,
        "Text": " a common path traversal sequence. The problem is that the flexible approach of UTF-8 allows"
      },
      {
        "Time_Start": 1394.58,
        "Time_End": 1400.94,
        "Text": " ambiguous mappings. An A character, for example, can be encoded with a single byte like ASCII."
      },
      {
        "Time_Start": 1400.94,
        "Time_End": 1406.42,
        "Text": " It's what we would expect, but it can also be when padded with zeros encoded as a two-byte"
      },
      {
        "Time_Start": 1406.42,
        "Time_End": 1412.14,
        "Text": " sequence, or we can pad it with even more zeros and make it a three-byte sequence, or"
      },
      {
        "Time_Start": 1412.14,
        "Time_End": 1418.54,
        "Text": " we can add even more zeros and make it a four-byte sequence. It always resides in the same A character."
      },
      {
        "Time_Start": 1418.54,
        "Time_End": 1425.3400000000001,
        "Text": " Okay, but is this even a problem? Let's determine in which scenarios this could be exploited."
      },
      {
        "Time_Start": 1425.9399999999998,
        "Time_End": 1431.3799999999999,
        "Text": " Imagine we have a web application which accepts a query parameter called path. Before the"
      },
      {
        "Time_Start": 1431.3799999999999,
        "Time_End": 1436.22,
        "Text": " query parameter is processed, it's verified that the value does not contain a path traversal"
      },
      {
        "Time_Start": 1436.22,
        "Time_End": 1443.3799999999999,
        "Text": " sequence. In this case, it's fine, and the check is passed. Now, after this check, the"
      },
      {
        "Time_Start": 1443.3799999999999,
        "Time_End": 1451.1799999999998,
        "Text": " value is UTF-8 decoded. In this case, the two-byte sequence, CS3, A9, is probably decoded"
      },
      {
        "Time_Start": 1451.18,
        "Time_End": 1459.02,
        "Text": " to the accent E character. Now the application processes the string to access some file."
      },
      {
        "Time_Start": 1459.02,
        "Time_End": 1464.0600000000002,
        "Text": " If we try to use the classical path traversal sequence, the path traversal check fails,"
      },
      {
        "Time_Start": 1464.0600000000002,
        "Time_End": 1470.7,
        "Text": " and our input is rejected. If we instead use the overlong UTF-8 path traversal sequence,"
      },
      {
        "Time_Start": 1470.7,
        "Time_End": 1476.8600000000001,
        "Text": " the check succeeds. Now the input is UTF-8 decoded, and the resulting string actually"
      },
      {
        "Time_Start": 1476.8600000000001,
        "Time_End": 1482.94,
        "Text": " contains the dot dot slash sequence. This string is now processed by the application"
      },
      {
        "Time_Start": 1482.94,
        "Time_End": 1490.22,
        "Text": " and may allow us to use, to access arbitrary files. And this exact vulnerability affected"
      },
      {
        "Time_Start": 1490.22,
        "Time_End": 1495.98,
        "Text": " Microsoft's IIS web server. In that case, it was even worse because you could actually"
      },
      {
        "Time_Start": 1495.98,
        "Time_End": 1503.42,
        "Text": " traverse to system 32 and run cmd.exe with a single get request. So, I won't guarantee"
      },
      {
        "Time_Start": 1503.42,
        "Time_End": 1506.78,
        "Text": " that something like this couldn't happen today, but to be fair, it was in the year"
      },
      {
        "Time_Start": 1506.78,
        "Time_End": 1515.3400000000001,
        "Text": " 2001, so 23 years ago. And the vulnerability was even added to the RC of UTF-8. The RC"
      },
      {
        "Time_Start": 1515.3400000000001,
        "Time_End": 1521.6200000000001,
        "Text": " explicitly mentions this overlong sequence and also defines sequences like these illegal."
      },
      {
        "Time_Start": 1521.6200000000001,
        "Time_End": 1527.18,
        "Text": " It also mentions that this is a real threat and was used to attack web servers in 2001."
      },
      {
        "Time_Start": 1527.18,
        "Time_End": 1533.3000000000002,
        "Text": " So generally, you would assume that this is not a thing at all nowadays. But the reality"
      },
      {
        "Time_Start": 1533.34,
        "Time_End": 1538.4199999999998,
        "Text": " is that there are plenty of custom UTF-8 paths out there, and a lot of them are not compliant"
      },
      {
        "Time_Start": 1538.4199999999998,
        "Time_End": 1547.06,
        "Text": " with the RC. Let's have a look at an example for Java itself, specifically Java's deserialisation."
      },
      {
        "Time_Start": 1547.06,
        "Time_End": 1552.62,
        "Text": " Let's imagine we have a simple class called EvilClass. The class is serialisable and has"
      },
      {
        "Time_Start": 1552.62,
        "Time_End": 1559.78,
        "Text": " a private attribute called cmd. We can create an instance of this class and set the cmd"
      },
      {
        "Time_Start": 1559.78,
        "Time_End": 1565.54,
        "Text": " attribute to some malicious value. When this instance is serialised, the resulting byte"
      },
      {
        "Time_Start": 1565.54,
        "Time_End": 1573.8999999999999,
        "Text": " stream looks like this. We've got the class name here, here's the name of the attribute,"
      },
      {
        "Time_Start": 1573.8999999999999,
        "Time_End": 1580.7,
        "Text": " followed by the type of the attribute, string in this case, and also its value. So, obviously,"
      },
      {
        "Time_Start": 1580.7,
        "Time_End": 1588.1,
        "Text": " all these strings are encoded in ASCII. Or maybe not. This is the open JDK implementation"
      },
      {
        "Time_Start": 1588.1000000000001,
        "Time_End": 1593.5400000000002,
        "Text": " of the object input stream which is used for deserialisation. The message used to decode"
      },
      {
        "Time_Start": 1593.5400000000002,
        "Time_End": 1601.18,
        "Text": " a single character is called read UTF char. This is kind of UTF-8 but slightly different."
      },
      {
        "Time_Start": 1601.18,
        "Time_End": 1607.8200000000002,
        "Text": " At the beginning, the first byte is read. Based on the upper bits of this byte, one"
      },
      {
        "Time_Start": 1607.8200000000002,
        "Time_End": 1613.9800000000002,
        "Text": " of the following switch case statements applies. We can either have a single byte character,"
      },
      {
        "Time_Start": 1613.98,
        "Time_End": 1618.26,
        "Text": " a two-byte sequence, or a three-byte sequence. Four-byte sequences are not supported. This"
      },
      {
        "Time_Start": 1618.26,
        "Time_End": 1625.02,
        "Text": " is different from actual UTF-8. In the single byte case, the byte value is just taken as"
      },
      {
        "Time_Start": 1625.02,
        "Time_End": 1630.94,
        "Text": " is since this is equal to ASCII. In the two-byte sequence case, there's a check that the second"
      },
      {
        "Time_Start": 1630.94,
        "Time_End": 1636.9,
        "Text": " byte is a valid continuation byte. However, when the code point is calculated, there is"
      },
      {
        "Time_Start": 1636.9,
        "Time_End": 1642.7,
        "Text": " no check for the long sequences. The same thing is also true for three-byte sequences."
      },
      {
        "Time_Start": 1642.7,
        "Time_End": 1647.9,
        "Text": " There is no check for overlong sequences. So let's assume we have an application that"
      },
      {
        "Time_Start": 1647.9,
        "Time_End": 1653.5,
        "Text": " is prone to a deserialisation vulnerability but we cannot get our class through because"
      },
      {
        "Time_Start": 1653.5,
        "Time_End": 1659.54,
        "Text": " a firewall or IPS detects the payload and blocks it. In order to bypass this, we can"
      },
      {
        "Time_Start": 1659.54,
        "Time_End": 1664.5800000000002,
        "Text": " simply take our deserialised payload and change the first character of the class name to an"
      },
      {
        "Time_Start": 1664.5800000000002,
        "Time_End": 1671.42,
        "Text": " overlong UTF-8 sequence. We could also hide any other string like the malicious command."
      },
      {
        "Time_Start": 1671.42,
        "Time_End": 1677.66,
        "Text": " The modified data still deserialises to the exactly same evil class instance as before."
      },
      {
        "Time_Start": 1677.66,
        "Time_End": 1682.1000000000001,
        "Text": " When we send this payload to the application now, the firewall inspects it and doesn't"
      },
      {
        "Time_Start": 1682.1000000000001,
        "Time_End": 1688.38,
        "Text": " find any malicious input. Thus, the payload is passed through and is eventually deserialised."
      },
      {
        "Time_Start": 1688.38,
        "Time_End": 1693.8600000000001,
        "Text": " In summary, if you notice that a custom UTF-8 parser is used, check for overlong sequences"
      },
      {
        "Time_Start": 1693.8600000000001,
        "Time_End": 1700.66,
        "Text": " and determine where in the data processing chain the parser is used. You can also use"
      },
      {
        "Time_Start": 1700.7,
        "Time_End": 1706.0600000000002,
        "Text": " the UTF-8 visualiser to craft specific overlong sequences. It recognises these sequences and"
      },
      {
        "Time_Start": 1706.0600000000002,
        "Time_End": 1714.3000000000002,
        "Text": " shows you what character such a sequence would represent. Okay, an overlong sequence is technically"
      },
      {
        "Time_Start": 1714.3000000000002,
        "Time_End": 1719.66,
        "Text": " possible but just forbidden by the standard. However, there are also byte sequences that"
      },
      {
        "Time_Start": 1719.66,
        "Time_End": 1728.66,
        "Text": " directly violate the way UTF-8 is working. For example, this byte sequence here. In binary,"
      },
      {
        "Time_Start": 1728.66,
        "Time_End": 1734.18,
        "Text": " the sequence looks like this. The first byte is a leading byte which introduces a four-byte"
      },
      {
        "Time_Start": 1734.18,
        "Time_End": 1739.98,
        "Text": " sequence. Thus, three continuation bytes should follow. The second byte is a valid continuation"
      },
      {
        "Time_Start": 1739.98,
        "Time_End": 1747.8600000000001,
        "Text": " byte, but the third byte, it's not. It's a single byte which represents a character itself."
      },
      {
        "Time_Start": 1747.8600000000001,
        "Time_End": 1753.7,
        "Text": " How should we handle this? Discard the incomplete sequence, decode the single byte, or assume"
      },
      {
        "Time_Start": 1753.7,
        "Time_End": 1758.7,
        "Text": " that it's a corrupted continuation byte and fix it? A lot of questions when dealing with"
      },
      {
        "Time_Start": 1758.7,
        "Time_End": 1765.8600000000001,
        "Text": " an invalid sequence. What does the RC say about this? Implementations of decoding algorithms"
      },
      {
        "Time_Start": 1765.8600000000001,
        "Time_End": 1773.02,
        "Text": " must protect against decoding invalid sequences. Sounds like a plan. Let's see how this works"
      },
      {
        "Time_Start": 1773.02,
        "Time_End": 1778.82,
        "Text": " in real life and have a look at a popular web application, Joomla. It's not as famous"
      },
      {
        "Time_Start": 1778.82,
        "Time_End": 1783.26,
        "Text": " as WordPress but with roughly 2 per cent of all websites on the internet, there are"
      },
      {
        "Time_Start": 1783.26,
        "Time_End": 1788.22,
        "Text": " still millions of deployments out there. At the beginning of this year, we disclosed a"
      },
      {
        "Time_Start": 1788.22,
        "Time_End": 1793.46,
        "Text": " critical cross-site scripting vulnerability in Joomla's core module that was caused by"
      },
      {
        "Time_Start": 1793.46,
        "Time_End": 1801.3799999999999,
        "Text": " a bug in PHP itself. So, to prevent against XSS attacks, Joomla sanitises all input. Let's"
      },
      {
        "Time_Start": 1801.3799999999999,
        "Time_End": 1807.54,
        "Text": " assume we have this string with a malicious script tag. Before the string is displayed,"
      },
      {
        "Time_Start": 1807.54,
        "Time_End": 1813.58,
        "Text": " Joomla removes all HTML tags. The resulting string is safe to be displayed. So how is"
      },
      {
        "Time_Start": 1813.58,
        "Time_End": 1820.3799999999999,
        "Text": " this sanitisation performed? At first, Joomla is unaware of the structure of the input string."
      },
      {
        "Time_Start": 1820.3799999999999,
        "Time_End": 1825.6599999999999,
        "Text": " Now the position of the first opening angle bracket is determined. Each character before"
      },
      {
        "Time_Start": 1825.6599999999999,
        "Time_End": 1832.26,
        "Text": " it is considered safe since it is outside of an HTML tag. All following characters up"
      },
      {
        "Time_Start": 1832.26,
        "Time_End": 1837.22,
        "Text": " until the closing angle brackets are inside the HTML tag. This portion of the input is"
      },
      {
        "Time_Start": 1837.22,
        "Time_End": 1842.46,
        "Text": " dangerous and is removed. The following characters up until the next opening angle brackets are"
      },
      {
        "Time_Start": 1842.46,
        "Time_End": 1848.78,
        "Text": " safe again, and, at last, the characters under the closing angle brackets are also removed."
      },
      {
        "Time_Start": 1848.78,
        "Time_End": 1855.3799999999999,
        "Text": " The resulting string does not contain any HTML tags and is safe to be displayed. Now,"
      },
      {
        "Time_Start": 1855.38,
        "Time_End": 1866.8600000000001,
        "Text": " have a look at this part of the implementation. It uses PHP's string functions to process"
      },
      {
        "Time_Start": 1866.8600000000001,
        "Time_End": 1873.7800000000002,
        "Text": " the input string. These functions probably handle UTF-8 and allow the usage of all Unicode"
      },
      {
        "Time_Start": 1873.7800000000002,
        "Time_End": 1879.3400000000001,
        "Text": " characters. For example, it is possible to correctly determine the index of this evil"
      },
      {
        "Time_Start": 1879.3400000000001,
        "Time_End": 1884.14,
        "Text": " emoji here. In this case, index 2 is returned because there are two other emojis before"
      },
      {
        "Time_Start": 1884.14,
        "Time_End": 1891.3000000000002,
        "Text": " it. For this to work, the function needs to pass UTF-8 multi-byte sequences. In the Joomla"
      },
      {
        "Time_Start": 1891.3000000000002,
        "Time_End": 1897.2200000000003,
        "Text": " case, mbStringPos is used to determine the position of an opening angle bracket. If this"
      },
      {
        "Time_Start": 1897.2200000000003,
        "Time_End": 1903.18,
        "Text": " character is present, the index is passed as the length to mbSubstring to extract all"
      },
      {
        "Time_Start": 1903.18,
        "Time_End": 1908.0200000000002,
        "Text": " characters before it. So, exactly what we've just seen. First, determine the position of"
      },
      {
        "Time_Start": 1908.02,
        "Time_End": 1912.78,
        "Text": " an opening angle bracket with mbStringPos, and then extract all characters before it"
      },
      {
        "Time_Start": 1912.78,
        "Time_End": 1920.58,
        "Text": " with mbSubstring. The extracted characters are outside of an HTML tag and are thus safe."
      },
      {
        "Time_Start": 1920.58,
        "Time_End": 1926.9,
        "Text": " Now let's see how mbStringPos and mbSubstring handle invalid UTF-8 sequences. We've got"
      },
      {
        "Time_Start": 1926.9,
        "Time_End": 1933.46,
        "Text": " this byte sequence, and there is an opening angle bracket here. When mbStringPos processes"
      },
      {
        "Time_Start": 1933.6200000000001,
        "Time_End": 1938.54,
        "Text": " input, it starts to pass the sequence from the beginning. The first byte is a leading"
      },
      {
        "Time_Start": 1938.54,
        "Time_End": 1944.3400000000001,
        "Text": " byte which introduces a four-byte sequence. Thus, three continuation bytes should follow."
      },
      {
        "Time_Start": 1944.3400000000001,
        "Time_End": 1950.14,
        "Text": " Here's the first continuation byte, but the next byte is not a continuation byte. mbStringPos"
      },
      {
        "Time_Start": 1950.14,
        "Time_End": 1956.82,
        "Text": " still needs to somehow map the byte sequence to an index. So, it considers the invalid"
      },
      {
        "Time_Start": 1956.82,
        "Time_End": 1963.46,
        "Text": " sequence one character. This character is assumed to have the index zero. The next byte"
      },
      {
        "Time_Start": 1963.46,
        "Time_End": 1967.74,
        "Text": " is a valid single byte, so it gets the index one. The next byte is also a single byte,"
      },
      {
        "Time_Start": 1967.74,
        "Time_End": 1973.74,
        "Text": " so it receives the index two, and so forth. So, from the mbStringPos perspective, the"
      },
      {
        "Time_Start": 1973.74,
        "Time_End": 1980.1799999999998,
        "Text": " input string looks like this. The opening angle bracket is at index four. Now let's"
      },
      {
        "Time_Start": 1980.1799999999998,
        "Time_End": 1985.7,
        "Text": " have a look at mbSubstring. It operates on the same byte sequence and starts to pass"
      },
      {
        "Time_Start": 1985.78,
        "Time_End": 1991.02,
        "Text": " it from the beginning. The first byte is a leading byte for a four-byte sequence, so"
      },
      {
        "Time_Start": 1991.02,
        "Time_End": 1997.26,
        "Text": " three continuation bytes should follow. But, at this point, mbSubstring takes a little"
      },
      {
        "Time_Start": 1997.26,
        "Time_End": 2003.6200000000001,
        "Text": " small shortcut. After all, it only needs to cut off the string at a specific offset, so"
      },
      {
        "Time_Start": 2003.6200000000001,
        "Time_End": 2008.78,
        "Text": " it doesn't really care about the value of the continuation bytes. Thus, it simply skips"
      },
      {
        "Time_Start": 2008.78,
        "Time_End": 2014.42,
        "Text": " over the next three bytes. These should be continuation bytes, right? This means that"
      },
      {
        "Time_Start": 2014.42,
        "Time_End": 2019.5,
        "Text": " the four-byte sequence is considered one character and gets index zero. Now a single"
      },
      {
        "Time_Start": 2019.5,
        "Time_End": 2025.1000000000001,
        "Text": " byte follows which gets the next one, another one, and so forth. So, from the perspective"
      },
      {
        "Time_Start": 2025.1000000000001,
        "Time_End": 2031.54,
        "Text": " of mbSubstring, the input string looks like this. The opening angle bracket is at index"
      },
      {
        "Time_Start": 2031.54,
        "Time_End": 2038.18,
        "Text": " two. So there's a significant difference between both functions. The invalid byte sequence"
      },
      {
        "Time_Start": 2038.18,
        "Time_End": 2045.18,
        "Text": " can be used to shift the index used to extract the safe input beyond the opening angle bracket."
      },
      {
        "Time_Start": 2046.02,
        "Time_End": 2052.46,
        "Text": " The result is that the safe data can actually contain an opening angle bracket and also"
      },
      {
        "Time_Start": 2052.46,
        "Time_End": 2059.1,
        "Text": " a whole HTML tag when adding more of these invalid byte sequences. Since admins can customise"
      },
      {
        "Time_Start": 2059.1,
        "Time_End": 2063.78,
        "Text": " journalist PHP templates, it only takes a single click from an admin to achieve remote"
      },
      {
        "Time_Start": 2063.78,
        "Time_End": 2070.78,
        "Text": " code execution with the Spark. So, let's see this in action. So, here, the attacker"
      },
      {
        "Time_Start": 2070.78,
        "Time_End": 2079.0600000000004,
        "Text": " prepares a Python web server to host the JavaScript payload and also starts the Netcat listener,"
      },
      {
        "Time_Start": 2079.0600000000004,
        "Time_End": 2085.1400000000003,
        "Text": " and now only an admin needs to be tricked into basically just clicking on a malicious"
      },
      {
        "Time_Start": 2085.2599999999998,
        "Time_End": 2092.2599999999998,
        "Text": " link, so here in this case via mail. Very obscure. So, of course, the admin clicks,"
      },
      {
        "Time_Start": 2093.94,
        "Time_End": 2100.46,
        "Text": " and now it goes pretty far. A PHP template is changed, and arbitrary PHP code is executed,"
      },
      {
        "Time_Start": 2100.46,
        "Time_End": 2107.46,
        "Text": " and the attacker basically immediately receives the reverse shell."
      },
      {
        "Time_Start": 2107.46,
        "Time_End": 2114.46,
        "Text": " Okay, so far, we've looked at overlong and"
      },
      {
        "Time_Start": 2115.06,
        "Time_End": 2121.02,
        "Text": " invalid byte sequences, but things can go even badly wrong for perfectly valid byte"
      },
      {
        "Time_Start": 2121.02,
        "Time_End": 2127.46,
        "Text": " sequences when it comes to string length calculation. This works very differently from what you"
      },
      {
        "Time_Start": 2127.46,
        "Time_End": 2134.26,
        "Text": " might have expected. We just had some PHP code, so let's have a look at some Python."
      },
      {
        "Time_Start": 2134.26,
        "Time_End": 2139.98,
        "Text": " In Python, the function len can be used to determine the length of a string. Unsurprisingly,"
      },
      {
        "Time_Start": 2139.98,
        "Time_End": 2146.98,
        "Text": " a single A character has a length of one. The same thing is true for an umlaut character,"
      },
      {
        "Time_Start": 2147.18,
        "Time_End": 2154.18,
        "Text": " and also this single cup of coffee, and also this bug character. We can do the same experiment"
      },
      {
        "Time_Start": 2154.46,
        "Time_End": 2161.46,
        "Text": " with Java, a single A character has a length of one, same here, same here, same here, wait,"
      },
      {
        "Time_Start": 2162.5,
        "Time_End": 2169.06,
        "Text": " what? The single bug character suddenly has a length of two. And when doing the same experiment"
      },
      {
        "Time_Start": 2169.06,
        "Time_End": 2174.66,
        "Text": " with JavaScript, we can see that the bug character also has a length of two here. How"
      },
      {
        "Time_Start": 2174.66,
        "Time_End": 2181.66,
        "Text": " can a single character have a length of two? To understand this, let's go back to our initial"
      },
      {
        "Time_Start": 2181.98,
        "Time_End": 2188.2999999999997,
        "Text": " example. This time, we are specifically interested in this part, the internal encoding used by"
      },
      {
        "Time_Start": 2188.2999999999997,
        "Time_End": 2193.74,
        "Text": " the programming language. As already mentioned, a programming language needs to store strings"
      },
      {
        "Time_Start": 2193.7400000000002,
        "Time_End": 2200.7400000000002,
        "Text": " in memory, and the memory can only hold 1s and 0s. Thus, the string needs to be encoded."
      },
      {
        "Time_Start": 2200.86,
        "Time_End": 2206.94,
        "Text": " And the internal encoding also affects how a programming language usually defines the"
      },
      {
        "Time_Start": 2206.94,
        "Time_End": 2213.94,
        "Text": " length of a string. Python 3, which uses an encoding, returned one for the single bug"
      },
      {
        "Time_Start": 2214.0600000000004,
        "Time_End": 2220.1800000000003,
        "Text": " character. Java and JavaScript returned two. The reason for this is that they define the"
      },
      {
        "Time_Start": 2220.18,
        "Time_End": 2226.94,
        "Text": " string length as the amount of code units, not characters. A simple A character is encoded"
      },
      {
        "Time_Start": 2226.94,
        "Time_End": 2233.94,
        "Text": " with the two bytes. These two bytes are one code unit, so the length is one. If you now"
      },
      {
        "Time_Start": 2234.74,
        "Time_End": 2240.14,
        "Text": " take the bug character, for example, two bytes are not sufficient any more. This character"
      },
      {
        "Time_Start": 2240.14,
        "Time_End": 2246.58,
        "Text": " is encoded with a surrogate pair. Each of these surrogates is encoded in one code unit."
      },
      {
        "Time_Start": 2247.06,
        "Time_End": 2254.06,
        "Text": " Thus, we have two code units and also a length of two. This behaviour can also be observed"
      },
      {
        "Time_Start": 2254.1,
        "Time_End": 2260.58,
        "Text": " in calling split on a string in JavaScript. So, for an A character, split returns an array"
      },
      {
        "Time_Start": 2260.58,
        "Time_End": 2267.58,
        "Text": " with one element, the A character, so no big surprise here. But, for the bug character,"
      },
      {
        "Time_Start": 2267.94,
        "Time_End": 2272.58,
        "Text": " split returns an array with two elements, the high surrogate and the low surrogate,"
      },
      {
        "Time_Start": 2272.58,
        "Time_End": 2278.8199999999997,
        "Text": " so it makes sense that the string length is two. When an application does not account"
      },
      {
        "Time_Start": 2278.8199999999997,
        "Time_End": 2283.66,
        "Text": " for the specific behaviour of string length calculations, it might introduce severe security"
      },
      {
        "Time_Start": 2283.66,
        "Time_End": 2289.8199999999997,
        "Text": " vulnerabilities. One of these is an interesting partial differential in Apache Guacamole which"
      },
      {
        "Time_Start": 2289.8199999999997,
        "Time_End": 2295.86,
        "Text": " I already presented at Hexacon last year. The gist of it is that Guacamole has a client"
      },
      {
        "Time_Start": 2295.86,
        "Time_End": 2299.9,
        "Text": " component and a server component. The client is written in Java and the server is written"
      },
      {
        "Time_Start": 2299.9,
        "Time_End": 2306.6600000000003,
        "Text": " in C. Both components communicate via the custom Guacamole protocol. The protocol is"
      },
      {
        "Time_Start": 2306.6600000000003,
        "Time_End": 2312.1800000000003,
        "Text": " pretty simple. A single method consists of different elements. The first element is the"
      },
      {
        "Time_Start": 2312.1800000000003,
        "Time_End": 2317.34,
        "Text": " op code which specifies which instruction should be executed, and the following elements"
      },
      {
        "Time_Start": 2317.34,
        "Time_End": 2322.9,
        "Text": " are arguments to this instruction. Each element on its own consists of a length followed by"
      },
      {
        "Time_Start": 2322.9,
        "Time_End": 2328.94,
        "Text": " a value which contains five characters in this case. A user is restricted and cannot"
      },
      {
        "Time_Start": 2328.94,
        "Time_End": 2335.86,
        "Text": " send arbitrary instructions. However, there is one instruction called image where user-controlled"
      },
      {
        "Time_Start": 2335.86,
        "Time_End": 2343.1,
        "Text": " data is put into the arguments of this instruction. So, these strings can be controlled. If an"
      },
      {
        "Time_Start": 2343.1,
        "Time_End": 2348.7000000000003,
        "Text": " attacker now places four bug characters here, the length field will be populated with eight"
      },
      {
        "Time_Start": 2348.7000000000003,
        "Time_End": 2355.1,
        "Text": " because four bug characters are encoded with eight code units. The attacker can now place"
      },
      {
        "Time_Start": 2355.1,
        "Time_End": 2362.5,
        "Text": " this usual string in the following argument. From the perspective of the Guacamole client,"
      },
      {
        "Time_Start": 2362.5,
        "Time_End": 2368.6,
        "Text": " the message looks like this. One op code with two arguments. This message is now submitted"
      },
      {
        "Time_Start": 2368.6,
        "Time_End": 2375.2599999999998,
        "Text": " to the Guacamole server. The server is unaware of the structure and begins to pass a sequence."
      },
      {
        "Time_Start": 2375.2599999999998,
        "Time_End": 2381.38,
        "Text": " The first digit here denotes that five characters should be read. So, one, two, three, four,"
      },
      {
        "Time_Start": 2381.38,
        "Time_End": 2387.6600000000003,
        "Text": " five. Op code is complete. Read next digit. This time, eight. So, one character is read,"
      },
      {
        "Time_Start": 2387.6600000000003,
        "Time_End": 2391.42,
        "Text": " two characters are read, three characters are read, four characters are read, and all"
      },
      {
        "Time_Start": 2391.42,
        "Time_End": 2396.9,
        "Text": " bug characters have already been read, but only four characters were consumed so far."
      },
      {
        "Time_Start": 2396.9,
        "Time_End": 2403.86,
        "Text": " So, more characters are read. Six, seven, eight. Now, the argument is complete, and"
      },
      {
        "Time_Start": 2403.86,
        "Time_End": 2408.98,
        "Text": " the semicolon designates the end of the whole instruction. However, there is still data"
      },
      {
        "Time_Start": 2408.98,
        "Time_End": 2413.78,
        "Text": " in the buffer, so the next instruction is read. The length field is eight, so eight"
      },
      {
        "Time_Start": 2413.78,
        "Time_End": 2419.26,
        "Text": " characters are read, one, two, three, four, five, six, seven, eight, and the instruction"
      },
      {
        "Time_Start": 2419.26,
        "Time_End": 2425.86,
        "Text": " is complete. This is a whole new instruction which can be set to an arbitrary value. This"
      },
      {
        "Time_Start": 2425.86,
        "Time_End": 2431.34,
        "Text": " vulnerability could be used to leverage specific Guacamole instructions to read arbitrary files"
      },
      {
        "Time_Start": 2431.34,
        "Time_End": 2439.78,
        "Text": " and even combine it with another vulnerability to get remote code execution. Okay, last topic,"
      },
      {
        "Time_Start": 2439.78,
        "Time_End": 2447.1400000000003,
        "Text": " but really my favourite one. Encoding differentials. Let's assume we have the string real which"
      },
      {
        "Time_Start": 2447.1400000000003,
        "Time_End": 2455.06,
        "Text": " is encoded using UTF-8. The resulting bytes can be seen here at the bottom. When these"
      },
      {
        "Time_Start": 2455.06,
        "Time_End": 2460.58,
        "Text": " bytes are sent over the wire, loaded into memory, or stored in a file, the string should"
      },
      {
        "Time_Start": 2460.58,
        "Time_End": 2467.5,
        "Text": " be decoded at some point again which should result in the same string. This way, the very"
      },
      {
        "Time_Start": 2467.5,
        "Time_End": 2474.94,
        "Text": " same string is restored. It contains exactly the same characters as the string before."
      },
      {
        "Time_Start": 2474.94,
        "Time_End": 2480.94,
        "Text": " This works fine because for encoding and decoding the same character coding, UTF-8 in this case"
      },
      {
        "Time_Start": 2480.94,
        "Time_End": 2487.2999999999997,
        "Text": " was used. If instead of UTF-8, UTF-6 would have been used to decode the byte stream,"
      },
      {
        "Time_Start": 2487.3,
        "Time_End": 2493.1800000000003,
        "Text": " the resulting characters were totally different from the original string. This mismatch between"
      },
      {
        "Time_Start": 2493.1800000000003,
        "Time_End": 2498.6600000000003,
        "Text": " the character encoding used for encoding and decoding is what I'm referring to as encoding"
      },
      {
        "Time_Start": 2498.6600000000003,
        "Time_End": 2504.82,
        "Text": " differential here. Such an encoding differential can basically happen everywhere. But let's"
      },
      {
        "Time_Start": 2504.82,
        "Time_End": 2511.5800000000004,
        "Text": " have a look at a popular example. The browser and the web server. Our initial example outlines"
      },
      {
        "Time_Start": 2511.5800000000004,
        "Time_End": 2516.42,
        "Text": " how a comment was submitted from the browser to the web server to the database server."
      },
      {
        "Time_Start": 2517.34,
        "Time_End": 2522.14,
        "Text": " This is the direction we've been considering. Of course, all of this encoding and decoding"
      },
      {
        "Time_Start": 2522.14,
        "Time_End": 2527.26,
        "Text": " steps are also required when viewing the comment. Just the other way around. The comment needs"
      },
      {
        "Time_Start": 2527.26,
        "Time_End": 2531.06,
        "Text": " to be read from the hard disk of the database server, it's sent to the web server, and the"
      },
      {
        "Time_Start": 2531.06,
        "Time_End": 2537.34,
        "Text": " web server serves the comment in form of an HTTP response to the browser. Now we are specifically"
      },
      {
        "Time_Start": 2537.34,
        "Time_End": 2543.02,
        "Text": " interested in the part where the web server encodes the HTTP body and the browser decodes"
      },
      {
        "Time_Start": 2543.02,
        "Time_End": 2549.5,
        "Text": " it. We've already seen that there are a lot of character encodings supported by a modern"
      },
      {
        "Time_Start": 2549.5,
        "Time_End": 2555.18,
        "Text": " browser. When the browser receives an HTTP response from a web server, it needs to know"
      },
      {
        "Time_Start": 2555.18,
        "Time_End": 2561.22,
        "Text": " which of those encodings it should use to decode the HTTP body. How does the browser"
      },
      {
        "Time_Start": 2561.22,
        "Time_End": 2566.94,
        "Text": " decide which encoding to use? The most common approach probably all of you are familiar"
      },
      {
        "Time_Start": 2566.94,
        "Time_End": 2573.1,
        "Text": " with is the content type header in the HTTP response. This header does not only contain"
      },
      {
        "Time_Start": 2573.1,
        "Time_End": 2579.14,
        "Text": " the MIME type but also an optional attribute which indicates which character encoding should"
      },
      {
        "Time_Start": 2579.14,
        "Time_End": 2588.94,
        "Text": " be used to decode the body. Okay, but what if the attribute is not present? In that case,"
      },
      {
        "Time_Start": 2588.94,
        "Time_End": 2594.9,
        "Text": " the browser can check the HTML document in the body itself. There might be a meta text"
      },
      {
        "Time_Start": 2594.9,
        "Time_End": 2600.7000000000003,
        "Text": " that indicates which charset to use. This is already kind of a weird way to indicate"
      },
      {
        "Time_Start": 2600.7000000000003,
        "Time_End": 2605.42,
        "Text": " a charset, because, in order to read the HTML document, the browser needs to decode the"
      },
      {
        "Time_Start": 2605.42,
        "Time_End": 2611.38,
        "Text": " body. It needs to assume some encoding, try to decode the body, check what the HTML document"
      },
      {
        "Time_Start": 2611.38,
        "Time_End": 2617.42,
        "Text": " says is the actual encoding, and then potentially re-decode the body. But there are even more"
      },
      {
        "Time_Start": 2617.42,
        "Time_End": 2622.78,
        "Text": " ways to tell the browser which character encoding should be used. There's a special Unicode"
      },
      {
        "Time_Start": 2622.78,
        "Time_End": 2627.7000000000003,
        "Text": " character which can be put at the beginning of a byte stream to indicate the character"
      },
      {
        "Time_Start": 2627.7000000000003,
        "Time_End": 2632.9,
        "Text": " encoding. This character is called zero white snow break space but is better known as byte"
      },
      {
        "Time_Start": 2632.9,
        "Time_End": 2639.46,
        "Text": " order mark. Let's assume we want to encode the string new. These are the related Unicode"
      },
      {
        "Time_Start": 2639.46,
        "Time_End": 2645.6200000000003,
        "Text": " points, and, at the beginning, we put the additional Unicode byte order mark. Now we"
      },
      {
        "Time_Start": 2645.62,
        "Time_End": 2653.74,
        "Text": " use some encoding, for example, to turn the code points into a byte sequence. When the"
      },
      {
        "Time_Start": 2653.74,
        "Time_End": 2659.3399999999997,
        "Text": " byte sequence is decoded again, the corresponding parser only needs to check the first byte"
      },
      {
        "Time_Start": 2659.3399999999997,
        "Time_End": 2666.18,
        "Text": " to notice that we used UTF-16. Changing both of these bytes would result in an undefined"
      },
      {
        "Time_Start": 2666.18,
        "Time_End": 2672.74,
        "Text": " character. The byte order marker can be used to determine the byte and also the encoding."
      },
      {
        "Time_Start": 2672.7400000000002,
        "Time_End": 2677.5400000000004,
        "Text": " For UTF-8, for example, the first byte would look like this, which can be distinguished"
      },
      {
        "Time_Start": 2677.5400000000004,
        "Time_End": 2685.2200000000003,
        "Text": " from UTF-16. This also works for UTF-32. The byte order marker is not specific to HTTP"
      },
      {
        "Time_Start": 2685.2200000000003,
        "Time_End": 2691.0200000000004,
        "Text": " or HTML and is commonly used in files, but it also works for HTTP response bodies and"
      },
      {
        "Time_Start": 2691.0200000000004,
        "Time_End": 2695.86,
        "Text": " modern browsers support it. So, there are three different approaches we've seen so far"
      },
      {
        "Time_Start": 2695.86,
        "Time_End": 2702.1800000000003,
        "Text": " that tell a browser which encoding should be used. However, the char set attribute and"
      },
      {
        "Time_Start": 2702.18,
        "Time_End": 2708.2999999999997,
        "Text": " the content type header is not always present, especially for partial HTML responses, there's"
      },
      {
        "Time_Start": 2708.2999999999997,
        "Time_End": 2716.02,
        "Text": " usually no meta tag, and the byte order mark is generally quite uncommon. So, what should"
      },
      {
        "Time_Start": 2716.02,
        "Time_End": 2722.1,
        "Text": " the browser do when there is no information on what encoding should be used? Well, it"
      },
      {
        "Time_Start": 2722.1,
        "Time_End": 2727.8599999999997,
        "Text": " just tries to make an educated guess based on the content which is called auto-detection."
      },
      {
        "Time_Start": 2727.86,
        "Time_End": 2733.98,
        "Text": " If it looks like UTF-8, then it probably is UTF-8. However, an attacker can easily"
      },
      {
        "Time_Start": 2733.98,
        "Time_End": 2739.58,
        "Text": " influence the judgement of auto-detection by intentionally adding bytes that would result"
      },
      {
        "Time_Start": 2739.58,
        "Time_End": 2745.1600000000003,
        "Text": " in a reasonable character in another encoding. By the way, if you want to figure out which"
      },
      {
        "Time_Start": 2745.1600000000003,
        "Time_End": 2750.26,
        "Text": " encoding the browser assumes, you can just enter document.char set in the web dev concept"
      },
      {
        "Time_Start": 2750.26,
        "Time_End": 2755.82,
        "Text": " that will output the character encoding assumed by the browser. So, let's quickly summarise"
      },
      {
        "Time_Start": 2755.82,
        "Time_End": 2759.5800000000004,
        "Text": " the techniques that can be used to force an encoding between the browser and the web"
      },
      {
        "Time_Start": 2759.5800000000004,
        "Time_End": 2765.5800000000004,
        "Text": " server. If you can control the first bytes of the body, you can insert a byte order mark."
      },
      {
        "Time_Start": 2765.5800000000004,
        "Time_End": 2770.26,
        "Text": " If you've got a header injection or can control the char set in the content type, you can"
      },
      {
        "Time_Start": 2770.26,
        "Time_End": 2775.06,
        "Text": " directly set the encoding this way. If you've got an HTML injection, you can insert an HTML"
      },
      {
        "Time_Start": 2775.06,
        "Time_End": 2781.86,
        "Text": " meta tag, and if no char set information is provided at all, which is really bad, you"
      },
      {
        "Time_Start": 2781.86,
        "Time_End": 2788.6200000000003,
        "Text": " can leverage the auto-detection of the browser. Okay, so now we can make the browser use an"
      },
      {
        "Time_Start": 2788.6200000000003,
        "Time_End": 2794.94,
        "Text": " arbitrary character encoding. And there are quite a lot to choose from. However, most"
      },
      {
        "Time_Start": 2794.94,
        "Time_End": 2801.26,
        "Text": " of these are ASCII-compatible and not really useful from an attacker's point of view. There"
      },
      {
        "Time_Start": 2801.26,
        "Time_End": 2809.7000000000003,
        "Text": " is one specific encoding, though, which is very interesting. ISO 2022 JP. This encoding"
      },
      {
        "Time_Start": 2809.7000000000003,
        "Time_End": 2815.5400000000004,
        "Text": " is a Japanese character encoding that supports four different alphabets. It's an official"
      },
      {
        "Time_Start": 2815.5400000000004,
        "Time_End": 2822.1800000000003,
        "Text": " part of the HTML standard, and it's supported by all modern browsers. What's really special"
      },
      {
        "Time_Start": 2822.1800000000003,
        "Time_End": 2827.7400000000002,
        "Text": " about this encoding is that it supports certain escape sequences to switch between different"
      },
      {
        "Time_Start": 2827.7400000000002,
        "Time_End": 2833.9,
        "Text": " character sets. So, if a byte stream contains these three bytes here, they are not decoded"
      },
      {
        "Time_Start": 2833.9,
        "Time_End": 2839.26,
        "Text": " to a character, but instead indicate that all following bytes should be decoded using"
      },
      {
        "Time_Start": 2839.26,
        "Time_End": 2845.94,
        "Text": " ASCII. If a byte stream contains these three bytes here, the following bytes should be"
      },
      {
        "Time_Start": 2845.94,
        "Time_End": 2853.3,
        "Text": " decoded using JISX0201, and there are two more escape sequences which can be used to"
      },
      {
        "Time_Start": 2853.3,
        "Time_End": 2861.06,
        "Text": " change the character set to two different versions of the JISX0208 character set. One"
      },
      {
        "Time_Start": 2861.18,
        "Time_End": 2866.58,
        "Text": " thing worth noting here is that common browsers like Chrome and Firefox will auto-detect this"
      },
      {
        "Time_Start": 2866.58,
        "Time_End": 2873.58,
        "Text": " encoding if the char set information is missing and the body contains such a sequence. Another"
      },
      {
        "Time_Start": 2873.58,
        "Time_End": 2879.2999999999997,
        "Text": " interesting aspect is that the later two character sets use two bytes per character, so these"
      },
      {
        "Time_Start": 2879.2999999999997,
        "Time_End": 2887.18,
        "Text": " are not ASCII-compatible. Let's have a look at an example. The default mode is ASCII."
      },
      {
        "Time_Start": 2887.18,
        "Time_End": 2892.8599999999997,
        "Text": " If we decode this ASCII byte stream, we don't recognise any difference. In this case, the"
      },
      {
        "Time_Start": 2892.8599999999997,
        "Time_End": 2898.54,
        "Text": " byte stream encodes the string do not try and bend the spoon, that's impossible. Now,"
      },
      {
        "Time_Start": 2898.54,
        "Time_End": 2905.1,
        "Text": " let's insert a few additional bytes in between this byte sequence. The byte sequence we inserted"
      },
      {
        "Time_Start": 2905.1,
        "Time_End": 2913.98,
        "Text": " is the escape sequence to switch to the JISX0208 character set. This means that all bytes following"
      },
      {
        "Time_Start": 2913.98,
        "Time_End": 2920.22,
        "Text": " which when decoded with ASCII represents the string bend the spoon, now are decoded"
      },
      {
        "Time_Start": 2920.22,
        "Time_End": 2926.42,
        "Text": " with JISX and become these Japanese characters at the bottom. There are also some question"
      },
      {
        "Time_Start": 2926.42,
        "Time_End": 2932.54,
        "Text": " marks here because a few of these two-byte sequences are invalid. So that's how our string"
      },
      {
        "Time_Start": 2932.54,
        "Time_End": 2939.5,
        "Text": " looks like now. The text beginning from bend the spoon changed to some Japanese characters."
      },
      {
        "Time_Start": 2939.5,
        "Time_End": 2945.02,
        "Text": " Let's insert another escape sequence here. This switches the character set back to ASCII."
      },
      {
        "Time_Start": 2945.02,
        "Time_End": 2952.18,
        "Text": " Thus, the bytes representing the text that's impossible are correctly decoded again. This"
      },
      {
        "Time_Start": 2952.18,
        "Time_End": 2959.18,
        "Text": " interesting feature of ISO2022JP seems very handy but it can break some fundamental assumptions."
      },
      {
        "Time_Start": 2959.18,
        "Time_End": 2963.26,
        "Text": " I want to show you two different attacks that you can apply to any target for which you"
      },
      {
        "Time_Start": 2963.26,
        "Time_End": 2968.86,
        "Text": " are unable to force an encoding differential via the outline techniques. The first one"
      },
      {
        "Time_Start": 2968.86,
        "Time_End": 2974.94,
        "Text": " is breaking HTML context. Let's assume we have a website where the user can enter text"
      },
      {
        "Time_Start": 2974.94,
        "Time_End": 2981.02,
        "Text": " in markdown. The markdown is converted to HTML but only a basic set of HTML elements"
      },
      {
        "Time_Start": 2981.02,
        "Time_End": 2988.9,
        "Text": " is allowed. Thus, no JavaScript code can be injected. A user can, for example, enter this"
      },
      {
        "Time_Start": 2988.9,
        "Time_End": 2997.06,
        "Text": " markdown text. It contains a bold text and also an image. The resulting HTML code looks"
      },
      {
        "Time_Start": 2997.06,
        "Time_End": 3001.94,
        "Text": " like this. For the bold text, the strong text is used, and the image was added via"
      },
      {
        "Time_Start": 3001.94,
        "Time_End": 3009.66,
        "Text": " an IMG tag with the corresponding source and alt attribute. If a malicious user tries to"
      },
      {
        "Time_Start": 3009.66,
        "Time_End": 3014.38,
        "Text": " inject the JavaScript handler, this does not work because special characters like a double"
      },
      {
        "Time_Start": 3014.38,
        "Time_End": 3019.98,
        "Text": " quote are HTML encoded and cannot be used to escape the attribute context. Now let's"
      },
      {
        "Time_Start": 3019.98,
        "Time_End": 3027.82,
        "Text": " consider this markdown text. Just two images with a text in between. The resulting HTML"
      },
      {
        "Time_Start": 3027.82,
        "Time_End": 3032.9,
        "Text": " code looks like this. Again, the images are added via an IMG tag with the corresponding"
      },
      {
        "Time_Start": 3032.9,
        "Time_End": 3040.58,
        "Text": " source and alt attributes. When the byte stream is decoded with ISO2022JP, the default mode"
      },
      {
        "Time_Start": 3040.58,
        "Time_End": 3047.46,
        "Text": " is ASCII and everything is working as intended. We don't even notice any difference. Now let's"
      },
      {
        "Time_Start": 3047.46,
        "Time_End": 3053.58,
        "Text": " insert an escape sequence in the description of the first image. This escape sequence"
      },
      {
        "Time_Start": 3053.58,
        "Time_End": 3059.26,
        "Text": " will be placed in the value of the alt attribute. Thus, all bytes following until the end of"
      },
      {
        "Time_Start": 3059.26,
        "Time_End": 3067.34,
        "Text": " the document will be decoded using JSX. This breaks the HTML document. Although this is"
      },
      {
        "Time_Start": 3067.34,
        "Time_End": 3072.5,
        "Text": " already a denial-of-service attack, it does not yield the ability yet to execute JavaScript"
      },
      {
        "Time_Start": 3072.5,
        "Time_End": 3079.26,
        "Text": " code. But we can switch the encoding back to ASCII by inserting another escape sequence"
      },
      {
        "Time_Start": 3079.26,
        "Time_End": 3087.04,
        "Text": " between both images. So, now, only two strange characters appear in the resulting stream."
      },
      {
        "Time_Start": 3087.04,
        "Time_End": 3092.42,
        "Text": " If you look at the HTML syntax, though, we can notice something different. The beginning"
      },
      {
        "Time_Start": 3092.42,
        "Time_End": 3099.9,
        "Text": " of the second IMG tag is now part of the attribute value. So, what happened here? We inserted"
      },
      {
        "Time_Start": 3099.9,
        "Time_End": 3105.34,
        "Text": " the first escape sequence within the attribute value, and the second escape sequence outside"
      },
      {
        "Time_Start": 3105.34,
        "Time_End": 3111.1800000000003,
        "Text": " of the HTML text and the plain text. The four bytes in between the escape sequences are"
      },
      {
        "Time_Start": 3111.1800000000003,
        "Time_End": 3118.3,
        "Text": " decoded with JSX. This also includes a closing double quote of the attribute value which"
      },
      {
        "Time_Start": 3118.3,
        "Time_End": 3124.54,
        "Text": " is now simply not present any more. This means that all following characters are also considered"
      },
      {
        "Time_Start": 3124.54,
        "Time_End": 3130.5,
        "Text": " to be part of the attribute value. The opening double quote of the second IMG tag now becomes"
      },
      {
        "Time_Start": 3130.5,
        "Time_End": 3136.54,
        "Text": " a closing double quote of this attribute value. This also means that the second IMG source"
      },
      {
        "Time_Start": 3136.54,
        "Time_End": 3141.58,
        "Text": " attribute is not an attribute value any more. Thus, an attacker can replace the file name"
      },
      {
        "Time_Start": 3141.58,
        "Time_End": 3147.5,
        "Text": " of the second image within JavaScript error handler. This error handler is now part of"
      },
      {
        "Time_Start": 3147.5,
        "Time_End": 3156.1,
        "Text": " the first IMG tag. This allows an attacker to inject arbitrary JavaScript code. The second"
      },
      {
        "Time_Start": 3156.1,
        "Time_End": 3162.34,
        "Text": " technique can be leveraged to negate backslash escaping. The scenario for this attack is"
      },
      {
        "Time_Start": 3162.34,
        "Time_End": 3168.14,
        "Text": " that some user input is placed in a JavaScript stream. Double quotes and backslashes in the"
      },
      {
        "Time_Start": 3168.14,
        "Time_End": 3174.18,
        "Text": " input are probably escaped, so it's not possible to break out of the stream context. So let's"
      },
      {
        "Time_Start": 3174.1800000000003,
        "Time_End": 3178.1800000000003,
        "Text": " imagine we have a website that accepts two query parameters, the search parameter and"
      },
      {
        "Time_Start": 3178.1800000000003,
        "Time_End": 3184.5800000000004,
        "Text": " the lang parameter. You might be roughly familiar with this example. The search parameter is"
      },
      {
        "Time_Start": 3184.5800000000004,
        "Time_End": 3189.4600000000005,
        "Text": " reflected here in the response, and the lang parameter is inserted into this string in"
      },
      {
        "Time_Start": 3189.4600000000005,
        "Time_End": 3195.5400000000004,
        "Text": " a JavaScript context. Both parameters are probably sanitised, so, for the search parameter,"
      },
      {
        "Time_Start": 3195.5400000000004,
        "Time_End": 3201.0600000000004,
        "Text": " all HTML tags are HTML encoded, and for the lang parameter, double quotes are escaped"
      },
      {
        "Time_Start": 3201.06,
        "Time_End": 3207.62,
        "Text": " with a backslash. Thus, it's not possible to inject JavaScript code. One of the possible"
      },
      {
        "Time_Start": 3207.62,
        "Time_End": 3215.5,
        "Text": " char sets which we have not covered so far is the JSX-02-01 character set. In contrast"
      },
      {
        "Time_Start": 3215.5,
        "Time_End": 3223.2999999999997,
        "Text": " to both other JSX character sets, it uses only one byte instead of two. And that's how"
      },
      {
        "Time_Start": 3223.2999999999997,
        "Time_End": 3230.18,
        "Text": " the corresponding code table looks like. The upper bytes here are used for some Japanese"
      },
      {
        "Time_Start": 3230.1800000000003,
        "Time_End": 3237.9800000000005,
        "Text": " characters, and the lower bytes are as usual equivalent to ASCII. But, if we look closely,"
      },
      {
        "Time_Start": 3237.9800000000005,
        "Time_End": 3245.1400000000003,
        "Text": " there are two exceptions here. Both of these highlighted characters don't match with ASCII."
      },
      {
        "Time_Start": 3245.1400000000003,
        "Time_End": 3251.78,
        "Text": " For ASCII, the byte hex 5C represents the backslash character, and the byte hex 7E represents"
      },
      {
        "Time_Start": 3251.78,
        "Time_End": 3258.26,
        "Text": " the tilt character. For JSX-02-01, both of these characters are mapped differently. Decoding"
      },
      {
        "Time_Start": 3258.26,
        "Time_End": 3264.34,
        "Text": " the byte hex 5C results in a yen character, and decoding the byte hex 7E results in an"
      },
      {
        "Time_Start": 3264.34,
        "Time_End": 3272.7000000000003,
        "Text": " overline character. So, back to our web application. By default, all bytes are decoded using ASCII."
      },
      {
        "Time_Start": 3272.7000000000003,
        "Time_End": 3277.7400000000002,
        "Text": " If you try to inject JavaScript code by escaping the string context with a double quote, this"
      },
      {
        "Time_Start": 3277.7400000000002,
        "Time_End": 3284.0600000000004,
        "Text": " does not work because our double quote is escaped with a backslash. But now, let's insert"
      },
      {
        "Time_Start": 3284.06,
        "Time_End": 3289.34,
        "Text": " this escape sequence in the search query parameter. This switches the character set"
      },
      {
        "Time_Start": 3289.34,
        "Time_End": 3297.46,
        "Text": " for all bytes following to JSX-02-01, and this is how the browser sees the HTML document"
      },
      {
        "Time_Start": 3297.46,
        "Time_End": 3303.98,
        "Text": " now. There is no backslash character here any more, just the yen sign within the string."
      },
      {
        "Time_Start": 3303.98,
        "Time_End": 3309.54,
        "Text": " This means that the double quote we inserted actually designates the end of the string,"
      },
      {
        "Time_Start": 3309.54,
        "Time_End": 3315.74,
        "Text": " and we can add arbitrary JavaScript code outside of the string context. Another ugly"
      },
      {
        "Time_Start": 3315.74,
        "Time_End": 3323.38,
        "Text": " but yet so beautiful pop-up. So, if you can make the browser assume an ISO 2022 JP character"
      },
      {
        "Time_Start": 3323.38,
        "Time_End": 3329.7,
        "Text": " encoding, you can use these two techniques to get an XSS. What makes this so powerful"
      },
      {
        "Time_Start": 3329.7,
        "Time_End": 3335.94,
        "Text": " is the auto-detection feature of the browser. An application with missing char set information"
      },
      {
        "Time_Start": 3335.94,
        "Time_End": 3341.34,
        "Text": " is very likely to be vulnerable because you only need to insert an escape sequence to"
      },
      {
        "Time_Start": 3341.34,
        "Time_End": 3348.5,
        "Text": " make the browser assume an ISO 2022 JP char set. From a security point of view, I hope"
      },
      {
        "Time_Start": 3348.5,
        "Time_End": 3353.3,
        "Text": " that browsers will disable auto-detection for this encoding, and that's also what I"
      },
      {
        "Time_Start": 3353.3,
        "Time_End": 3361.7400000000002,
        "Text": " suggested. Still, these techniques could be applied if you can control the character set"
      },
      {
        "Time_Start": 3362.7400000000002,
        "Time_End": 3372.2200000000003,
        "Text": " means. Okay, I hope by now your mood changed to this. At least, for me, it did. So, let's"
      },
      {
        "Time_Start": 3372.2200000000003,
        "Time_End": 3378.1000000000004,
        "Text": " give it another try and summarise character encodings. The first major observation is"
      },
      {
        "Time_Start": 3378.1000000000004,
        "Time_End": 3383.34,
        "Text": " character encodings are basically everywhere. For all these places, there is potential for"
      },
      {
        "Time_Start": 3383.34,
        "Time_End": 3389.0200000000004,
        "Text": " something to break. UGF-8 is the most common encoding, especially in the world wide web."
      },
      {
        "Time_Start": 3389.02,
        "Time_End": 3396.34,
        "Text": " However, there are plenty of legacy encodings which are still supported by all modern browsers."
      },
      {
        "Time_Start": 3396.34,
        "Time_End": 3401.46,
        "Text": " Not so much present in the world wide web but still very popular is UGF-16. It's commonly"
      },
      {
        "Time_Start": 3401.46,
        "Time_End": 3405.5,
        "Text": " used on Windows and also internally by a lot of programming languages to store strings"
      },
      {
        "Time_Start": 3405.5,
        "Time_End": 3412.78,
        "Text": " in memory. At last, we barely stretched the surface here. There are so much more vulnerabilities"
      },
      {
        "Time_Start": 3412.78,
        "Time_End": 3418.18,
        "Text": " to be discovered, and I hope that this talk inspires you to don't just look away if you"
      },
      {
        "Time_Start": 3418.34,
        "Time_End": 3424.7400000000002,
        "Text": " see some weird encoding stuff, but instead dive into it. It's really worth it. So, thank"
      },
      {
        "Time_Start": 3424.7400000000002,
        "Time_End": 3428.78,
        "Text": " you very much for attending and listening to my talk. If you're interested in more of"
      },
      {
        "Time_Start": 3428.78,
        "Time_End": 3433.0600000000004,
        "Text": " this kind of content, feel free to follow us on X or Mastodon, and also check out our"
      },
      {
        "Time_Start": 3433.0600000000004,
        "Time_End": 3438.42,
        "Text": " blog post where we regularly release new articles on our vulnerability research. Furthermore,"
      },
      {
        "Time_Start": 3438.42,
        "Time_End": 3446.86,
        "Text": " you can find the UGF-8 visualiser via the QR code here on the right. Thank you very"
      },
      {
        "Time_Start": 3446.86,
        "Time_End": 3447.86,
        "Text": " much."
      },
      {
        "Time_Start": 3447.86,
        "Time_End": 3462.86,
        "Text": " All right. Thank you very much for the great talk. I think we still have time for one question."
      },
      {
        "Time_Start": 3462.86,
        "Time_End": 3471.9,
        "Text": " So, is there anyone wanting to ask something?"
      },
      {
        "Time_Start": 3471.9,
        "Time_End": 3477.14,
        "Text": " Maybe I can start with a question, and you've got some ideas. So, after your research, I"
      },
      {
        "Time_Start": 3477.14,
        "Time_End": 3483.14,
        "Text": " get you're probably pretty sensitive to finding some partial differential bugs and stuff in"
      },
      {
        "Time_Start": 3483.14,
        "Time_End": 3488.98,
        "Text": " the applications you look at. How do you usually start looking into this? Do you usually just"
      },
      {
        "Time_Start": 3488.98,
        "Time_End": 3494.86,
        "Text": " try some certain sequences, or do you directly look into code? What decoder do they use?"
      },
      {
        "Time_Start": 3494.86,
        "Time_End": 3496.94,
        "Text": " What is your typical approach?"
      },
      {
        "Time_Start": 3496.94,
        "Time_End": 3503.06,
        "Text": " Mainly two approaches. One is a more dynamic approach to just get a feeling that something"
      },
      {
        "Time_Start": 3503.06,
        "Time_End": 3511.26,
        "Text": " is decoded with some familiar stuff. This is also probably based on experience. And"
      },
      {
        "Time_Start": 3511.26,
        "Time_End": 3516.5,
        "Text": " the second approach is to, if you are looking at white box targets where you have source"
      },
      {
        "Time_Start": 3516.5,
        "Time_End": 3523.02,
        "Text": " code access, then specifically search for things like UGF-8, UGF-16. It's also like"
      },
      {
        "Time_Start": 3523.74,
        "Time_End": 3529.42,
        "Text": " you can also, if you want to look for UGF-8 custom parsers, there are some constants which"
      },
      {
        "Time_Start": 3529.42,
        "Time_End": 3534.34,
        "Text": " are used when calculating the code pound value using UGF-8, and you can just search for those"
      },
      {
        "Time_Start": 3534.34,
        "Time_End": 3540.86,
        "Text": " specific constants, and then you can quickly find places where custom UGF-8 parsers are"
      },
      {
        "Time_Start": 3540.86,
        "Time_End": 3541.86,
        "Text": " used."
      },
      {
        "Time_Start": 3542.86,
        "Time_End": 3544.86,
        "Text": " Any other questions?"
      },
      {
        "Time_Start": 3547.86,
        "Time_End": 3555.86,
        "Text": " All right. So then, thank you. We'll just change a little bit, and then we'll be back in a minute with the next talk. Thank you."
      }
    ]
  }
}