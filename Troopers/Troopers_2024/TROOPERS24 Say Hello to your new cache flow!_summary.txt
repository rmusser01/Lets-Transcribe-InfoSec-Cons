**Introduction**
- Talk presented by **Geoffrey Bertoli**, **Rémi Jullian**, and **Théo Gordyjan** at **TROOPERS24**
- Focuses on **Windows Hello for Business** and **Tri-ID** cache information

**Windows Hello for Business and Tri-ID**
- Windows Hello for Business is an **asymmetric authentication** method
- Utilizes a **pin** to create a **private** and **public key**
- Pin acts as **entropy** to **protect the private key**
- If a **TPM** is used, the pin accesses the private key stored on the TPM
- Without a TPM, the process is similar but data is stored locally

**Authentication Process**
- **Winlogon** requests credentials and sends them to the **Cloud App Provider**
- Cloud App Provider requests a **nonce** from **Entry ID**
- Nonce is **signed** with the private key and sent back to Entry ID for validation
- Upon successful validation, a **PRT** (equivalent to access token) is sent back
- PRT is used to **decrypt the session key** and **import it into the TPM**

**Cache Data File**
- Located in the **system32 directory** with unique identifiers for each user
- Contains **encrypted secrets** and can be used for **brute-force attacks**
- Can be used to **retrieve passwords and pins**
- **PRTutil.ps** and **ngc-cryptodeck.py** are scripts related to cache data file decryption

**Reverse Engineering**
- Targeted **CloudAPI.dll** using **static** and **dynamic analysis**
- Static analysis performed with **IDA** and **X-Ray decompiler**
- Dynamic analysis involved creating a **TTD trace** of the **LSASS process** using **WinDbg**
- Trace allowed for extraction of individual **DLLs** for further static analysis

**Cache Data File Format**
- Starts with a **header** containing version, GUID, checksum, and number of nodes
- Followed by an array of **cached node headers** describing node type and sizes of crypto and encrypted blobs
- Crypto blob is used to **check user credentials** while encrypted blob contains **encrypted DPAPI equate key** and **PRT**
- **deserializeCloudAPcache** function populates a **CloudAPcache structure** with error information
- Error structure contains node type and pointers to crypto and encrypted blobs

**DPAPI Query Key**
- Stored in a **credential key structure** with a GUID and 0x40 byte buffer
- Used to derive the **latest master key** using the **HMAKE function** and user ID
- In memory, it's **encrypted using symmetric cryptography** with keys generated by **LSA initialized protect memory function**

**Offline Authentication**
- Microsoft prefers **pin-based authentication** over password-based due to security
- When a password is used, the **PRT is encrypted** with an **ES key derived from the password**
- Pin-based authentication involves **asymmetric cryptography** and **NGC (Next-Gen Cryptography)**
- NGC provides APIs for **encrypting and decrypting content** with **providers, protectors, and items**
- Two types of providers: **Key Storage Provider** and **Cryptographic Service Provider**
- Protector is the **method** or **technique** used for encrypting and protecting data

**Key Storage Provider**
- Microsoft Platform Crypto Provider uses a **TPM chip** to store the protector
- Microsoft Software Key Storage Provider stores the protector **locally**
- Other providers include the **SmartCard Key Storage Provider**

**Protectors and Items**
- Protectors are stored in **encrypted .dat files** within the NGC folder
- One protector is stored in **15.dat** and contains **three different PINs**
- Items are also stored in .dat files and include the **name of the item** and **provider name**

**Decrypting Cache Data File**
- Without a TPM, the process is complex and involves multiple encryption steps
- First, an **RSA private key** is constructed from an **encrypted blob**
- This key is used to decrypt the **15.dat file** to obtain the **decrypt PIN**
- A second RSA private key is then constructed using the decrypt PIN and another cryptobob
- These keys are used to **decrypt the PRT file** and **DPAPI code key**

**TPM Implementation**
- With a TPM, the **private key is stored directly on the TPM** and protected by the pin
- Brute-forcing the pin is much harder with a TPM
- TPM 2.0 can be configured to **lock after 32 authorization failures** and **forget one failure every 10 minutes**

**Tools and Further Research**
- A **Python script** has been released to brute force pins and passwords
- The script can be used to obtain the **PRT** and **DPAPI query key**
- Further research is needed to understand cache data for other authentication methods
- The discovery of the **DPAPI cred key** could lead to interesting future research

**Conclusion**
- Cache data file can be used for **offline brute-force attacks** if the user has used a password recently
- With a TPM, brute-forcing the pin is much more difficult
- The DPAPI cred key is **device-bound** and may change over time, requiring further investigation