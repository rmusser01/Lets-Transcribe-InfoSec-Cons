{
  "webpage_url": "https://www.youtube.com/watch?v=jMwH98vtxJM",
  "title": "TROOPERS24: Hitchhiker's Guide to Automotive Container Security using eBPF",
  "description": "Talk by Reinhard Kugler - June 27th, 2024 at TROOPERS24 IT security conference in Heidelberg, Germany hosted by @ERNW_ITSec\n\n#TROOPERS24 #ITsecurity \nhttps://troopers.de/troopers24/talks/vkb3bs/\n\nMore impressions:\n  / wearetroopers  \n  / ernw_itsec  \nhttps://infosec.exchange/@WEareTROOPERS\nhttps://infosec.exchange/@ERNW https://ernw.de",
  "channel_url": "https://www.youtube.com/channel/UCPY5aUREHmbDO4PtR6AYLfQ",
  "duration": 3095,
  "channel": "TROOPERS IT Security Conference",
  "uploader": "TROOPERS IT Security Conference",
  "upload_date": "20240909"
}

This text was transcribed using whisper model: large-v2

 Thank you, thank you.  Just a while ago I was sitting in my car and I was a bit worried because at the time my  infotainment system was like this.  And I was a bit scared at first because, okay, what's going on?  Is my car broken?  Do I have to repair it?  Is somebody hacking into my car?  Do I have a virus?  And this left a bit of scarcity in my mind.  And what did I do?  I tried to push the button to turn it off, but it didn't turn off.  So I did what every administrator does.  I turned it off and on again and it was all fine again.  But still I was a bit concerned if something happens to me what happened some years ago,  almost 10 years ago, right, with the cheap hack.  And many of you may know that the cheap hack was very impactful for the automotive industry  because it showcased the first time how you can attack a car remotely from the internet  and enter it and change its driving functions and its behavior.  For example, to steer to the left or to brake or to turn up your music volume very, very  loud.  But if you don't, if you're not following the developments at that time, let me quickly  or briefly present it to you.  So they came from the internet, from the network and found a port 6667, nothing nasty, but  there was a port on the internet available and they found a service they were able to  attack.  And with that attack, they were able to access the infotainment system of this cheap Cherokee.  Right, so this was a Unix system, a QNX system.  And what they were able, first was just very limited, to have very limited control over  the vehicle, like changing the climate system.  But a little bit later, they were also able to expand that control because on or within  this infotainment system, there were two chips, one is running this Unix system and the second  one is governing the internal network of the car, right?  And what they have been doing is they came in, then they tried to manipulate the car  functions, then they overwrote over a bus system the second chip and this gained them  the control over the whole car or the whole internal driving functions.  And this was super impressive and it's still impressive to this day.  And for me as a security practitioner and I'm really into defences also and offensives,  I was wondering, okay, how can this attack be mitigated with modern techniques?  And so I dug into containers, right?  And this is what I'm wanting to present to you because I hope you all brought your towels  with you because I want to take you with the Hitchhiker's Guide, so this very brief and  short guide through this container security where I found some areas where you can contribute  to security using container technologies.  But what is the car using to drive you around?  Mostly it's using things like this, a metal case with electronics in it and it's more  or less a component, a Lego piece in your car that is, for example, controlling your  engine or your brakes or you name it.  So there are several of those in your car and they're all interconnected.  So you have all those pieces in your car distributed, for example, there's one for your rear camera  or your trunk that it opens automatically as you push your button and it's all interconnected  with networks and usually most prevalent network is the CAN bus, right?  Have you heard about the CAN bus?  Yes, cool.  So I will mainly focus on the CAN bus, there's also others like yesterday you presented FlexRay  as well and Ethernet.  But what about this bus system and how is it laid out in your car?  So mainly you need to keep in mind that if you produce a network like this as a car manufacturer,  you have your components and you interconnect them and in the end you have a working car.  But you also need to consider how it's laid out inside your vehicle, right?  Because you have to manufacture also the cabling inside and you have to manufacture the cable  harnesses and you have to build instructions how to fiddle them in your chassis and how  to maintain it.  And therefore you have usually a very limited number of internal network systems and not  in the IT where you have 20,000 different segments.  So you are very limited in that regard with the CAN bus because it's a bus in the end,  right?  It's broadcasting the information around your car.  So the current development right now is you have many of those metal pieces and that's  very heavy and very labor-intensive to produce because it's mostly software as well.  And you want to centralize all the software functions, not all of them but many of them,  into one central piece, the high-performance computer.  And it's not a supercomputer in your car, it's just an ARM chip that has more power  than something like those old metal boxes.  All right, so this is also pressured by regulation or driven by regulation.  You have to maintain it, you have to update it, you have to assess it for cybersecurity.  So all your software has to be somehow cybersecurity right now.  Or you have some pressure from the EU as well as the United Nations.  And of course this summoned some of the cloud and Linux people and companies.  For example, the known suspects like Red Hat and Canonical is joining the show and is now  producing in-vehicle operating systems, so Linux for your car.  And this was for me a good starting point as well to jump into it because also two years  ago, almost two years ago, at Black Hat there was a talk on dissembling such a high-performance  computer in an ID4 vehicle and they have shown that there are already several Linux systems  running on such a system and it's segmented and governed by a hypervisor.  So virtualization is still in a modern car, in electric cars, there is a push to use hypervisors  and virtualization to solve the problem of resources.  So where do we start?  How can we learn how it's done?  And here I want to say, you have to think of virtualization like a burger, like a hamburger,  because I'm very hungry usually.  And the hamburger has different layers, you have your meaty application bun in the middle  and you have an operating system layer and you have a hypervisor and you have a Big Mac,  you have two stacks and you have a plate where your hardware is and it's all running  on there and you have your libraries, your pickles inside your burger.  So you have different ways to structure from app to hardware and we will be looking at  the most right version where you're using the operating system virtualization functions  to do the isolation.  So just the operating system, your Linux kernel is doing the isolation, not a hypervisor or  something else.  And we will be taking again from the cloud native map.  So there's this huge, huge map of stuff that's going on on the cloud and we will be using  this one, the runtimes to create the containers.  So if you never have seen a container or if you ever worked with a container, it's usually  just a Linux process and the namespaces and control groups are isolating you from the  rest of the world, right?  You're getting a different view on processes on your mount list, right?  On your mounted file systems, you get a different network and this is all governed by the kernel  and the control groups, a concept in the Linux kernel that is like shifting your resources  and what process gets how many computing power and how much memory, that's the control groups.  So as you do a little breakdown here, if you are a process inside a container, if you want  to get to your hardware, you go through many layers, you want to like touch a device and  then you get routed to the different drivers in your kernel and on that path, you have  to have special capabilities, so the powers, so to say, like the root, the old root is  now split into the capabilities and you need to have specific file system permissions and  you need to address the right kernel feature and then you're ending up down on the hardware,  which is the holy grail for attackers.  Who of you worked with capabilities before?  Seven and a half.  So capabilities is more or less the root split into many pieces, so now you don't have to  be root to, for example, just browsing all your file system or you're creating a new  network device, you have to have a split of it or a different capability.  So for example, to administer the network, you have to have this cap net admin and this  is usually shown by this mask because it's just a bit mask.  But that's more a sidestep.  So what do we want to do?  We want to get rid of this whole Docker stuff because it's clunky and we don't want to focus  on communities, we want only to focus on the container creation and let's look at an example  how to do this.  I hope you are a Docker person who spun up a container on its own, almost everybody.  So what I'm doing here is just building an image just to slip you into the topic and  after that, you can also not use the image, you can export it to your file system.  And after it's exported, you can create a container from it, like with Docker run.  And in this case, we're using the CRUN run, this little piece that's below Docker, right?  Docker uses it, Kubernetes uses it and OpenShift is using it.  So this little runtime is creating out a container and we're ending up in a little environment  with a different network, namespace, and a different process structure and a different  mounting table.  So that's all fine, but what about eBPF?  You read about eBPF in the title.  So what's eBPF?  eBPF is, or who worked with eBPF, just a quick show of hands.  So I will explain it a little bit more thoroughly.  It's like JavaScript for your kernel.  So you can create a program, a C program, for example, compile it, and then you have  a little bytecode and this you can take and put into the kernel.  So you ask the kernel, hey, please load that program and then you can attach it to an event.  What are the events?  For example, a system call or an incoming network packet or something that's involved  with tracing.  And you can imagine that's quite powerful because you can extend the kernel by loading  new features into the kernel, but it's running in a little small environment on its own to  be somehow protected.  This little thing can't take over the complete kernel, but only the thing, the event you're  attaching it to it.  And usually you are already using eBPF.  Most of you who are using a Linux box, those are also implicitly using eBPF because the  system D is already loading some programs to govern, for example, the network traffic  that you have only limited throughputs in a specific slice.  So for example, let's stop here a bit.  The system D uses it for this governing of resources and containers are using it as well  to this day.  So what they are doing is they create another eBPF program.  So here in the front, I listed all the eBPF programs on your machine.  You can do this on your home machine as well or on an IoT gateway.  And then you see a list of programs that are already loaded.  Your machine will look very similar to that.  And as you spin up new containers, this list gets bigger because the containers themselves  are creating programs themselves and loading them into the kernel and hooking them.  But why do they do that?  And the answer is if you're inside such a container, you usually want to have an environment  that's like a VM.  Some people think it's a VM.  It uses virtualization, but it's not a fully blown VM, right?  So you still don't want the people to have access to the hardware like here.  Here we say, okay, we want to create our block device ourselves to access it from inside  the container.  And I think six years ago, this worked.  Nowadays, it's blocked because an eBPF program is jumping in the thing on the bottom and  catching this call saying, hey, you're not allowed to touch this specific hardware.  And it's sending us the deny.  And this is the interaction where we already see eBPF in action.  You can also prove that, for example, if I go a bit forward here, you can unload it  or detach it from the container.  So it's still in the kernel, but it's not attached to the container anymore.  And let's try to read from the disk again.  And we can read from the disk because it's not attached to the event anymore.  And that's all eBPF is doing, loading the kernel, an event is triggered, it's run, it  makes a decision or changes something, and back to normal.  We can't mount the device from inside the container, even if we have full read access  to the disk.  Anybody knows why?  Because of the capability, right?  Missing the power to mount it, but we can read from it.  So that's the basics I want to give you here to jump into the containers to finish up with  eBPF.  You can say there's a huge list how to attach an eBPF program to what event.  You can read that up.  It's in the slides.  I will provide them to you.  And now, how can we talk use cases here?  Because till now we have the containers covered, but we didn't talk about automotive, right?  What about automotive containers?  How can they protect themselves using eBPF?  So again, our starting point is the GPAC.  We have control over, for example, an infotainment system, and we want to get to the driving  functions.  And we use the CAN bus to reach them, right?  to say, hey, car, drive to the right, or do an emergency brake.  And for those of you, you all know the CAN bus, right?  So you all maybe have seen that.  You're seeing every time you're transmitting information on the CAN bus, it's encoded in  this signal.  And if you decode it again, you see just IDs here, the arbitration, and the data that's  transmitted for short.  There's more to it.  There's a lot of safety features going on and redundancy checks.  But let's do things simple.  We need an ID, and we need data to transmit.  And the question is, what is the problem with such devices?  And let's see if we can do some party trick here.  So if you, for example, want to talk to such a device, you can send CAN frames to it and  watch what it's doing.  For example, if you have a friend and you need to lower his price on his vehicle, you  just run the script and see how your car is aging over time, right?  Let me quickly wake that up again.  So that's a good party trick.  You can show your friends.  Or you can either flashing all the things and let the needle jump, or you set the speed  to a specific value and say, hey, I'm only driving 50 kilometers an hour in the city.  Or you're showing your friends how you can drive 280 on the German Autobahn, which maybe  you already can.  But how can we do this in containers?  Because right now, we're just pumping network traffic, CAN network traffic, from a computer  inside this device, right?  How can we isolate this?  For example, we have an application, a seat heating application, that needs a license.  And we want to isolate it from the rest.  And the usual container approach is to create a whole separate network and isolate it and  put a cable in between.  So you usually take a virtual network cable and put one side inside the container and  the other side on your host.  And with the other side, you can add it to a bridge or to a bigger network or pump it  out to the physical network.  And thanks to Oliver Hartkopp and other contributors, CAN also has this inside the Linux kernel  in the networking infrastructure, which is amazing.  So you have network interfaces for CAN, and you have those virtual ethernet cables for  CAN.  And therefore, you can create your own script to automatically spin up a container and put  in a CAN interface, take a cable out, and put it, for example, in your HPC on the host.  And that's amazing, because you can do this all by yourself with a script.  If you're interested, I can send it to you.  It looks like this.  It's just IP commands.  And that's really cool.  So you, in the end, ending up in a scenario where you have a CAN interface inside a container,  and the process can use it as any other process, right?  So it can open a socket and just write to it.  That's cool.  In the end, it gets routed to the CAN driver that's addressing the transceiver on board.  And this is producing the signal again out, the electrical signal that your car is needing,  for example, right?  So how can we improve that situation by EPPF?  Because now you have the problem, everybody inside the container can pump out stuff.  And in the end, you can't really govern it, because it's a broadcast, right?  It's a CAN bus.  The bus is like a broadcast.  So what we do with EPPF is we look at the network infrastructure of Linux, see that  there is usually something that also in the cloud is very heavily used.  For example, this express data path, which is, you don't need to know all the details,  but in the end, your packet is routed through the networking stack to your program in the end.  And this XDP is just one layer in between, right?  It gets received, it gets checked, and then it gets routed, right?  So what we can do here is, again, we create a little program here.  This is how an EPPF program for CAN, using this XDP feature, is looking like.  So we say, OK, every time this packet comes in, we take that, we print it so we can inspect it.  And we can also check it if it has a special ID.  And if we don't like the ID, or if we don't like the data, as a security person or a defense person,  then we can drop it.  Otherwise, we let it pass.  And this is quite cool, because you can now load this program.  On the right, you see the different commands to do it.  You can load this program, and then you can push information again into this CAN bus.  And if this program triggers, for example, in this case, I write one frame.  And if I'm sending a frame that doesn't have the right ID, it gets blocked.  Only by the kernel inside the container, and without anything else.  You don't need a user space program, you don't need a gateway, you didn't need nothing, right?  And for me, that's a big benefit by producing applications, because now you can improve  the security stance from CAN, because this was always a huge problem with CAN manufacturers.  Because you need to split your CAN bus.  I'm not a super expert in CAN manufacturing, but I'm coming from a security perspective.  But you have to split this CAN bus in different domains, like segments, in order to fulfill  real-time requirements, you need to do safety in this regard, and you don't want to have  too many participants in one domain.  So you're ending up in a scenario where you have been splitting your CAN bus and putting  again a domain controller, a thing that routes from one side to the other, and then in the  end you need again a central gateway, where again you need switches that are routing the  traffic in between.  And on the left, you just have one ECU, one platform, you're running the containers and  placing the Bs, the eBPF programs, as guards.  So cool.  We could have prevented this problem with, okay, your infotainment system is taking over  and it's sending arbitrary information, your CAN injection messages, out into your car.  So this one you could prevent.  What about the updates?  And again, concerning updates, you want to govern this way from your main chip of your  infotainment system, your Unix system, to the other chip, right?  And in the cheap hack, it was connected via an SPI bus, which is just some wires where  you can transfer data and you can use the SPI bus for reading temperature data.  You can also do software updates.  And this is what they did.  So if you look closer at the SPI bus, if you're an electronics person like me, I like that,  and it's looking like this.  You have some chips on your main board, right?  And you connect them with wires, and then you have to have a protocol where two wires  are for receive and transmit, and one is the clock, and one is the, okay, now it's your  turn to send data.  And in Linux, it's again represented as a device, device node, like your SDA hard disk, right?  Here it looks like SDEV, SPIDEV, and this is using two drivers, the SPIDEV driver and  the SPI driver to, in the end, write to those chips.  Again, you have some guards in between, but what about eBPF?  What can we do with eBPF to prevent that?  So if the attacker is able to write to those SPIDEV 01 and 00 devices, whoopsie, we're  not done yet, here we go.  So if the attacker is able to write to those SPIDEV features, what can we do to catch that?  And usually, in user space, there's not very much to it.  You can do, of course, the permissions and remove the device, but maybe you need it because  on the bus is another component and some program inside the container needs to communicate  with that.  So what can we do else?  We could use the kernel tracing to catch that, right?  So we can, or the kernel tracing is huge and super cool.  If you have never heard about it, please look into it because it's so cool.  You can create some traps or you can say, okay, you're interested to do specific tracing  features like watching what's going on on the SPI bus and it's printing it out.  And you can also attach an eBPF program to that.  Let's see if we can show that here.  So we have here an SPIDEV device with a device node and a major and minor number.  This is what you want to keep an eye on, so they're 1, 5, 3, and 0.  And you create, again, an eBPF program where you quickly say, hey, every time you trace  an SPI transaction, you want to print the content, right?  So you gain traceability in that regard.  So you, again, compile it, you load it, you load it again, you load it with sudo because  I'm very tired usually as I do this in the night.  And then you can write to the SPI bus, and this is a toy example.  I write AAA and I can watch what's going on on the bus.  And that's cool because now I can make decisions from that, right?  For example, if a firmware update is written to that SPI bus to update a component, I can  check a signature or look at the header or at the length or whatever.  You name it.  What is possible in this specific scenario?  And take action from that, right?  So for example, here we can also create a little write blocker ourselves.  So on the right, there is a logic analyzer hooked on our SPI bus.  And it's reading, reading, reading.  So on the right, there's SPI messages going on, going on, flying around.  And here, we're writing a little program to block it.  So we, again, watch at the 153 and 0.  And if it's in the right command, we block it.  We say 0.  And we load the command.  Boom, it's gone.  Boom, it's back again here.  And this is happening just in the kernel, right?  You don't touch the application.  You don't touch anything else.  Just the kernel underneath without changing something inside the environment.  This is why I find this is super cool.  All right, so that was the two use cases I wanted to show you,  because we can now prevent the injection of CAN messages  and also could prevent software update if we do the implementation right.  And yesterday, I got an idea, because one of your talks  was about rootkits.  And I was thinking, this could be a chance to use eBPF in rootkits.  And I was researching that quite briefly.  And indeed, there is also super cool resources out there.  So if you want to get into eBPF rootkits, watch those.  That are really, really great talks about everything you know.  There are also GitHub repositories how to build your own rootkits.  For example, every time you get a specific network packet,  you drop it, because it's not the attacker.  But I wanted to also create a little rootkit myself.  So for example, I created, again, a little different application.  And that one is also using the CAN bus.  Let me quickly put that away from you.  OK, my thing is still going bonkers here.  All right, quickly patch it up.  And here we go.  So, uh-oh, should I pull it out again?  Reconnect it again.  Boom.  Boom.  This one is working.  This one is working, so we have to go over there, right?  Again, something doesn't work.  Reboot it.  Thank you.  Woo!  And we're back online.  So I try this real quick.  OK, so here I'm creating a rootkit for CAN.  And it's a bit different.  It's not a blocking thing.  So in this case, we are attaching to the traffic control of Linux,  so how Linux is mangling the packets through the network stack.  And we can, again, drop some packets if we don't like it.  But on the bottom, it's more interesting,  because we can also overwrite the packet  and push it back into the network interface.  And if we load that thing, you can watch it on the top here,  FFFF, so you can change real time what  your packets are looking like.  And you put it out again, and it's back to normal.  And this, we should also keep in mind  as we're dealing with Linux, containers,  EPPF on cars, production systems,  you name it, also in IoT devices.  Because try to catch that, right?  It's where people not thoroughly look.  So I put also the little get skilled or get owned slogan  here.  And to wrap things up here, in my opinion,  it's very important also to keep up  with the technologies that are now evolving into the cloud  space.  Because in the last years, EPPF and containers  have reached a level which is quite impressive.  So for example, the whole networking infrastructure  is usually nowadays done by EPPF programs.  And this is now slowly also taking place  on the edge, so on our devices as well.  So those devices, as well as IoT devices,  will in the future, in my opinion,  also be able to be fully running in containers  and also using EPPF.  And we see also that the attackers are already ahead.  So there have been also incidents using EPPF  offensively.  So what is the answer?  What did we achieve?  Well, what we achieved is we saw some possibilities  how we can improve a system like this, where  an infotainment system is getting hacked,  where we can improve the virtualization using EPPF,  to very, on a detailed level, improve the security.  And we can do this without changing anything  about the application themselves.  It's all done in the kernel.  And that is a real thing here.  What's the state of the art?  If you ask me, we're also working  with customers in industrial and automotive.  So we're seeing some parts of that already in place,  but not in full concert.  So what I showed you in full concert,  we have never seen right now.  But we're seeing Linux.  We're seeing virtualization.  We're seeing containers.  So all this is already there and in place  and will evolve further.  So this maybe could be an outlook for you.  If you look closer also in the cloud domain,  there are two cool things that are missing in the IoT domain  right now.  For example, Tetragon and Falco that  are EPPF-enabled programs that are automating this.  So you don't have to code it yourself.  Hey, this interface should be enabled with that filter.  And this syscall should be blocked.  And this does the heavy lifting for you.  So this is still missing in your IoT space  and automotive space.  But in the end, we can place our safeguards there.  Thank you also for the people who  are helping to build up this talk  and giving the money to fund it.  So also for SPR Research and Matris,  as well as my direct neighbor, Dimi and Oliver Hartkopf,  who created the Linux kernel part,  and Christoph, who was sitting as well with Dimi long hours  to debug this stuff.  All right.  So in the end, my car was just triggered  by my own little computer inside my car.  I put a computer inside my car myself.  And this was triggering the problem  with the infotainment system.  So sorry for that.  But in the end, it was a quite cool journey to be on.  So don't panic if you go into container security.  Thank you.  All right.  Thank you for your interesting talk.  I'm happy to announce that the badges have, I think,  already arrived.  And we are currently working on finalizing them.  As it stands now, you can probably  expect to stand in line to collect them during the lunch break I think and after  that of course if you if you prefer eating and now we have a and now we have  a few minutes for Q&A so does anybody have any questions?  Hi so my question is you showed us how you can potentially block a can message  through ABPF based on the idea of the message but can you expand that in the  context of whether the car is driving or like over a certain speed block some  sort of messages? Yeah that's a very good one so how can we do this in real  operations and with more complex scenarios right so one thing is sure you  can not only use the ID you can use the data as well and do calculations on them  or inspections on them right so you could for example check if what's used  in the automotive industry a parody bit is set correctly and the attacker if he  or she missed doing that then you block it then there's also the problem of  fragmentation so if information is split into more messages you can't keep track  in ABPF right now as I researched it can't so you have to like do something  and push it out into the user space and usually this is done in real scenarios  to push things out into user space and keep the state there and decision-making  there. Make sense? All right we had another question in the back. Thank you  and actually that's two questions the first one did you gain more trust doing  your research when it comes to isolation features of virtual namespaces and C  groups there were some exploits in the past that were able to escape these  isolations and the second question is it possible to apply namespace a  virtual namespace and C group features to restrict the capabilities of ABPF  yeah that's just two questions. I try to the last one first ABPF is governed by a  syscall the ABPF syscall so everything you're doing with ABPF has gone through  needs to go through that and that capability is tied to the to the syscall  so in my opinion it the only way to really tie it down is to keep an eye  what capabilities does your application have and now I'm thinking about the  first one what's my trust on namespaces and C groups in my own research I found  it's quite hard to make things all things right so I stumbled upon some  hiccups myself where I misconfigured something and then I could have was able  to break out over that. Linux or from Linux side it's my opinion quite nice or  good as it is. All right do we have any more questions oh sorry perfect. Okay  it's a two-part question hmm so the first question is what are your  assumptions like the pre requirements for a system because one part of the  cheap hack was that they were able to flash new software because cheap at that  point were lagging like any security measures like secure boot and signatures  and whatever and so if you can modify the software I can just overwrite  whatever rules you add so what are your like pre assumptions so do you say okay  the system is already safe by secure boot and another stuff and the second  question would be because we have several thousand can messages and IDs  have you done like a latency test so how much more latency is brought up to the  system because in your example it was just one or two IDs but if you have to  check like 5,000 IDs it changes so that would my second question be again last  one first so the my I didn't do any load testing myself but if you look at work  from others they did load tests for EPF versus kernel module versus some user  space function versus IP tables net filter and EPF came always out first so  it was much better but it's very interesting do to follow up on that  because I'm most interested how it can be employed in real scenarios and the  first one my assumptions would be sure this is all runtime right so this is all  as as the things are moving and I didn't do the here the like what's the  secure system to provide that of course we also had one scenario where it's  very hard to have a intact container infrastructure without the trusted  system underneath right it still holds and as you as you pointed out it's very  abbreviated what the GPEC was right they also gained a lot or the GPEC also  gained a lot of information on forensics  all right sadly we do not have any more time for any more questions if you still  have follow-up questions I'm sure you can feel free to I'm happy to yes to  approach Reinhardt thank you again for the talk and please give one last round  of applause and have fun