{
  "webpage_url": "https://www.youtube.com/watch?v=KsTsQV3fyeM",
  "title": "TROOPERS24: So I became a node: Kubernetes bootstrap tokens and AKS",
  "description": "Talk by Paul Barb\u00e9 and K\u00e9vin Schouteeten - June 27th, 2024 at TROOPERS24 IT security conference in Heidelberg, Germany hosted by @ERNW_ITSec\n\n#TROOPERS24 #ITsecurity \nhttps://troopers.de/troopers24/talks/cu79qu/\n\nMore impressions:\n  / wearetroopers  \n  / ernw_itsec  \nhttps://infosec.exchange/@WEareTROOPERS\nhttps://infosec.exchange/@ERNW https://ernw.de",
  "channel_url": "https://www.youtube.com/channel/UCPY5aUREHmbDO4PtR6AYLfQ",
  "duration": 2977,
  "channel": "TROOPERS IT Security Conference",
  "uploader": "TROOPERS IT Security Conference",
  "upload_date": "20240909"
}

This text was transcribed using whisper model: large-v2

 So, welcome everyone, welcome to our presentation, So I Became a Node.  During this presentation, we are going to talk about vulnerabilities that we described  during an assessment for one of our clients.  These vulnerabilities rely on Azure Kubernetes Service and more specifically on a TLS bootstrap  token.  So a bit about us, this is Paul Barbet and I am Kevin Skuteten.  We are both pen testers and red teamers at Synactive.  Synactive is a French security company.  We are four departments with pen test, reverse engineering, vulnerability research, development  and the response.  Here is an overview of what we are talking about today.  First I will give you some basic presentation about Kubernetes and give you some definition.  Then we will talk about Kubernetes authentication, TLS and node joining process.  Then we will expose how you can exploit this enrollment process in Azure Kubernetes cluster  and why it is not a really good idea to share the host network namespace when you create  a port inside a Kubernetes cluster.  Then we will proceed with a demo and give you some insight about mitigation.  So exploiting TLS bootstrap token is not really a new technique.  There is a lot of blog posts and documentation on the internet, but especially in Google  Kubernetes engine or Elastic Kubernetes Service.  But when it comes to Azure Kubernetes Service, there is nothing.  So that's why with Paul we decided to present this topic here.  So what is Kubernetes?  Kubernetes is an open source service for automating the deployment, the scaling and  the management of containerized applications.  So if you look at the screen, this is a basic Kubernetes cluster.  At the top you have the control plane with some components like scheduler, etcd, Kubernetes  cluster manager and the IPI server.  All these components are here to handle the overall state of the cluster.  If you look at the bottom, you have nodes.  It's where your applications are running.  Each node runs a container runtime like Docker, for instance.  And nodes run also pods.  Pods is the smallest unit in a Kubernetes environment.  And if we look inside the pod, there is one or multiple containers.  And it's inside this container that your application is running.  In the node, there is also a component called kubelet.  So this component talks with the control plane.  And the kubelet receives from the control plane some information, some specification.  And its goal is to apply this specification to the node.  Then if we look at the control plane, I will not describe the scheduler and etcd.  However, I will give you some details about the kubectl manager.  The kubectl manager runs several controllers.  And each controller has a specific goal, like deploy a pod or generate a new certificate  or sign a certificate.  As you will see later, certificates are a huge part of authentication and authorization  in Kubernetes.  And then I will present you the kubepi server, which is a really important component in the  control plane, because this component exposes the Kubernetes API.  Now I will let Paul talk about authentication and authorization in Kubernetes.  Thank you, Kevin.  So before delving into the exploit itself, we will need to understand some mechanisms  inside Kubernetes, starting by authentication and authorization.  So authentication and authorization are two distinct steps.  When you want to perform an action, you will send an HTTP request to the API server.  Then the caller identity will be extracted, thanks to the authentication part, inside  either HTTP headers or through mutual TLS authentication.  This identity will be extracted as a username and a list of groups that will be used by  the authorization part to resolve whether or not you can perform the action.  So you can implement these two mechanisms in different ways.  Regarding authentication, you have mainly three kinds of identities.  First of all, you will have a normal user, your administrator, for example.  You will have service accounts and also infrastructure components.  For regular users, they are not stored inside the cluster as a resource.  You can't list them, you can't create them directly inside the cluster.  So all of their identifying information needs to be contained inside their credential.  And that's why you will find ways like X.509 certificates, OpenID Connect with ID token,  or an authenticating proxy in front of the API server.  So then you will have service accounts that are used inside pods.  And for your workflow to be able to speak with the API server, they will use JWT mainly.  And for infrastructure components, they are mainly treated as a regular user and will  be using X.509 certificates.  For the authorization part, you can use mainly three different methods.  There is attribute-based access control, where for each identity you will list all the privileges.  Then you have the most used, the airbox method, where you will group your privileges inside  roles that you will be able to bind to your identities.  And then in CloudProvider, you will find a lot of webhook authorization methods, where  an external API will be called to respond whether or not your identity can perform the action.  And then you will also have ad-hoc special authorization plugin, like the notarization  mode that we'll be speaking in this talk.  And we'll also focus on X.509 and airbox.  So how do you authenticate with X.509 certificates?  Firstly, you will have a client certificate that will be signed by a cluster certificate  authority, by the cluster certificate authority, and you will present it to the API server.  The API server will also have a serving certificate, which is also signed by this certificate authority.  And so each end of the communication will verify the other end's certificate.  As I said earlier, normal users are not stored inside the cluster, so all of their identifying  information are in the certificate, in this case.  And it is as simple as the common name will be used for the username, and the different  organization attributes will be used for the group.  So in this example, I will be logging as Paul in the group admin and troopers.  For infrastructure components, this is almost the same, but you have to respect some conditions.  And in particular for kubelets, as we will speak about it a bit later, you need to be  inside the system-clone-nodes group, and with a username starting with system-clone-node-colon  and the node name, which is really important.  So now we know how we can authenticate with a certificate, how can we grant some privileges  to our identity using airbox?  So first of all, you will have roles that are typically just a list of rules granting  privileges over their own namespace, they live inside a namespace, a Kubernetes namespace.  It is just a way to logically isolate and group resources together inside a cluster.  And you will bind this role to different identities that will, in fact, just grant this privilege  to these identities, so service account, external user.  You will also have other namespaces with their own role and role binding, and you will also  find cluster role and cluster role binding, which function as namespace counterparts,  but at the cluster level, granting privileges everywhere.  So by putting the two mechanisms together, if I log in with my certificate and I want  to get a pod, so listing the pod, the API server will extract my identity from my certificate  and resolve each role that is bind to me to see if I have the needed privileges.  In this case, here, this role gives all privileges on all resources, so I will be able to perform  this action.  Okay, so TLS is quite important inside a cluster.  Let's have another look of all the different communications that are opening and the needed  certificates.  First of all, you will find the certificate authority that will be used to sign every  certificate, almost every certificate inside the cluster, and the API server will have  its serving certificate to expose the API.  Then, all different elements will have its own client certificate to authenticate to  the API server, and also they will need the certificate authority to be able to verify  the serving certificate of the API server.  For the etcd database, it is almost the same, but with a different certificate authority  and the etcd database will have a serving certificate and the API server will be the  client.  And it's not all, we'll add some more certificates, so you will have your normal user authenticating  with their client certificate, and each kubelet will also expose an API, and so they will  need a serving certificate that will be also signed by the cluster authority and the API  server will need a client certificate for these APIs, the kubelet APIs.  Moreover, the different kubelets need to have a very specific certificate for the node authorization  mode to be working.  So the purpose of the node authorization mode is to restrict the privileges of the kubelets  inside a cluster, because if you have a node which is compromised, the client certificate  will also be compromised, and so if you only add RBAC, you will not be able to restrict  a kubelet to access information for resources that are deployed elsewhere inside the cluster.  So that's a problem, it will lead to lateral movement.  And so the role of the node authorization mode is to restrict what a kubelet can do  to just access resources that are deployed on the related node.  So this is a special authorization mode, it will only work on kubelet identities, so inside  the system-colon-nodes group and with the system-colon-node-colon-node-name, and it  will prevent mostly action regarding secrets, configuration, and volumes.  With the diagram, you will have here a node where there are some resources deployed inside  the pod, your kubelet with its certificate, and you will find the name of the node inside  the certificate.  And so if you want to perform an action on a resource, the API server will check whether  or not the resource is deployed inside a pod that is also deployed on the node by  checking the node-name attributes of the pod.  If they match, the action will be granted, else it will be rejected.  So there is a lot of complexity with all these TLS certificates, you have to provide them  on sometimes different servers, you have a lot of them, you have different kinds of certificates,  client certificates, serving certificates, certificate authority to provide, you need  to have strict conditions on your kubelet certificates for the node authorization mode,  and what about auto-scaling clusters, where nodes come and go, how do you provide certificates  on the fly for them?  That's why we have certificate signing requests, this is a built-in way to sign certificates  inside a cluster.  You will send a certificate signing request that can be automatically approved or manually  by an administrator, we will see a little bit later, and it will use special controllers  which are called signers, and in our case, we will be interested by the kube-api-server-client-kubelets.  So how does it work?  I want to authenticate to the API server, but I don't have my certificate yet, I will  create a private key and a signing request that I will send to the API server, there  it will be approved by an administrator or automatically, if I check some conditions  that we'll be speaking a little bit later, it will be signed by a signer, and I will  be able to retrieve it and use it to authenticate.  But what is missing in this example is that you need some privileges to do that.  You need the create-get-list-watch on the certificate-signing-request object, and for  the kubelet-client-certificate, it's better if they are auto-approved because you want  an easy deployment process, and so you need a specific permission for that.  You need the create permission on this resource that will be only calling node-client.  So you can grant all of these privileges to anonymous users, but as we will see later,  it's bad and it will lead to trigger compromise.  So bootstrap tokens were introduced.  Bootstrap tokens are credentials that are stored inside the cluster as a secret.  They give all the different needed permissions for you to be able to create and retrieve  your CSR, and they will also give the special permission for node-client-kubelet-certificate.  And also, as we will see, you will be able to verify the certificate authority of the  cluster before any further exchange, thanks to this bootstrap token to prevent man-in-the-middle  attack.  So this is what it looks like.  It's an example from the Kubernetes documentation.  So it's a secret, so you will find the kind of secrets that live inside the kubesystem  namespace with their name.  You will have two different parts, the token ID and the token secret.  Both are needed if you want to use it, and only the token secret is secret as the name  in place.  And you can also have an expiration date for them, meaning that after this date, it will  no longer work.  And as we will speak a little bit later, this is not the case in AKS.  So what's the overall flow?  You want to enroll a new kubelet, so you provide it with the bootstrap token.  It will retrieve a publicly available config map containing the cluster authority, and  this config map will be signed by the secret part of the bootstrap token.  So it will verify the signature, and if it's matched, it will use it for further exchanges.  It will create a private key, a CSR, send the CSR to the API server.  There the control manager will verify that it is a valid kubelet certificate and that  you have the special permission for it to be auto-approved.  If so, it will approve the CSR.  It will be signed by the signer, the kube-api-server-client-kubelet-signer, and the kubelet will be able to retrieve  this certificate and use it, and start to be working.  So now that we know all of these different mechanisms, I will let Kevin present the attack  on Azure.  Thank you, Paul.  So to perform a proof of concept, we set up a cluster in Azure Kubernetes service.  So sorry for the size, I will try to zoom a little.  So our cluster runs one node pool.  In this node pool, there is two nodes.  Regarding the version of Kubernetes, we use the version 1.28.5.  It's not really the last version of Kubernetes cluster.  However, we performed some tests and the last version of Kubernetes cluster is still vulnerable.  For the authentication and the authorization, we use Airback.  And for the networking, we are using a Calico network policy.  We will see why it's important just after.  During this demo, we will often show the kubectl command line.  So kubectl is the official CLI to communicate with the Kubernetes API.  This tool allows us to, for instance, list nodes inside our cluster or list ports inside  our cluster.  In our lab and in our cluster, there is two nodes and we will deploy a pod, the pod host  network in our case.  This pod will run on the node on the left.  And one important thing, this pod has the host network namespace properties set to true.  When you set true to these properties in your pod definition, this means that this  pod will share the host network namespace of the host.  In other words, the pod and the host will have the same network stack.  And you will see later why it's important.  In other side, we will create another pod named pod target.  This pod will run in another node and this pod will have a secret.  During our demo, our goals will be to add access to this secret from the other pod.  One more important thing, when you deploy an infrastructure in Azure, there is two specific  components named wire server and WAA agent.  These agents are deployed to share configuration and data when you set a new virtual machine.  And one important thing to say about the wire server, when you want to access protected  settings, you can go to the URL slash VM settings and the wire server will respond  with this response.  And inside this response, there is a property named protected settings.  And inside this protected settings are encrypted with a key that will call the wire server  key.  So if the WAA agent wants to access the protected settings, it will have to decrypt these settings.  So I will describe how the WAA agent will describe the protected settings.  Everything starts with the goal state endpoint.  So I made a schema.  I don't know if everyone saw or if I will zoom a little.  So first, the WAA agent will contact the goal state endpoint, as we said just before.  The wire server will give to the WAA agent the URL for the certificate endpoint.  Then the WAA agent will generate a self-sign-in certificate.  With this self-sign-in certificate, it will contact the certificate endpoint and provide  its self-sign-in certificate.  Then the wire server will put the wire server key inside an envelope.  This envelope is a .p7m file.  And after that, the WAA agent will decrypt this envelope to retrieve the wire server  key.  And with this wire server key, the WAA agent can decrypt the protected settings that we  saw in the VM settings endpoint.  In our case, why is it important?  Because for instance, if a node cluster wants to join a cluster, as Paul said before, it  needs the TLS bootstrap token.  And the TLS bootstrap token is in the VM settings, in the protected settings that are encrypted.  So if we want to elevate our privilege from a compromised pod, we have to retrieve this  TLS bootstrap token.  So we have to mimic the comportment of the WAA agent to retrieve the bootstrap token.  So there is one limitation that we saw during our research.  If you try to access the goal state endpoint from a pod that doesn't share the host network  namespace, you will have a timeout error.  And our feeling about that with Paul is that Microsoft thinks it will be a bad thing to  allow an unprivileged pod to access the wire server key.  And if we look on the host, there is an IP table rule that drops every packet forward  to the wire server.  So if a pod wants to talk to the wire server, the packet from the pod will be forwarded,  so the IP table rules will deny the connection.  But if a pod shares the host network namespace, in this case the packets are not forwarded  at all, because when you share the host network namespace, you access directly the host interfaces.  So these rules don't apply and you can access the wire server.  So during this demo, I will describe all steps we will perform during this demo.  First, we will leak the TLS bootstrap token from our pod host network and we will decrypt it.  Then we'll use this bootstrap token to create a new pod inside the cluster.  Using this certificate, we will be able to list other nodes and other pods.  And then we will sign a certificate for nodes where the pod with the secret is deployed.  And then we can retrieve the secret inside the pod.  So it's time to open our shell.  So first, we will deploy our lab.  So here I just authenticate to the cluster.  So as you can see on this cluster, there is two nodes, the node 1 and the node 3.  Then I will deploy a new pod.  This pod is named pod host network and it shares the host network namespace.  So I will create this pod.  Then I will create another pod.  This pod runs on the node 3 and its name is pod target and this pod has a secret.  So if we list pods inside our cluster, we see the both pods, host network and target.  And we can have more information, the pod host network is running on the node 1 and  the pod target is running on the node 3.  Then to simulate the compromise, the compromise, sorry, of the first pod, we will open a shell  inside this pod with this command line.  Here normally, when you open a shell inside a pod, the host name of the pod is always  the name of the pod.  But when you share the host network namespace, the host name of the pod is the host name  of the node.  So it's a first sign that this pod shares the host network namespace.  We can confirm this information by listing all interfaces of the pod.  As you can see here, all interfaces starting with AZV are all bridged to other pods inside  the cluster.  So here we will try to contact the goal state endpoint.  So we can contact the goal state endpoint, so this is fine.  If we try to do the same thing on the other pod that don't share the host network namespace,  the command will hang and we can't exploit, we can't access this information.  So we return to the first pod and our goal here is to retrieve the TLS bootstrap token  from the protected setting we saw just before.  To do that, we will use a certificate that has been shared on the CyberCX blog post.  So this script will mimic the WAA agent to retrieve the TLS bootstrap token first.  It will generate a self-signing certificate, then it will retrieve the certificate endpoint  from the goal state endpoint.  Then it will send its own self-certificate to this endpoint.  After that, this endpoint will return an envelope.  Then this script will decrypt this envelope, it will unpack the archive inside this envelope  and inside this archive there is a wire server key.  After that, the script will call the VM setting endpoint and decrypt all settings that are  encrypted inside the protected settings.  So we will run this script and there it is.  We have the TLS bootstrap token and now we will use this token to elevate our privileges  inside the Kubernetes cluster.  So first we will use this token, we will create an alias with kubectl using this token.  You may notice the server parameters, this parameter is the URL of the Kubernetes API.  If you are completely blind and you just arrived inside a pod, you can find this value inside  the environment variable of the pod.  So we'll use the new bootstrap token to authenticate to the Kubernetes API.  If we list, we are part of the group bootstrapper, which is nice.  Then if we list our privileges, there is two important things, Paul already described this  before, this resource before, the certificate signing request, we can create get-list-watch  and the create-certificate-signing-request, not client.  With the combination of these two resources, we will be able to become every kubelet on  the cluster, so it's really nice.  So to remember, our goal here is to extract secrets from other pods.  To do that, we have to list other pods because we don't have the information.  So we will create a new certificate-signing-request.  There is some important things to respect.  First, the certificate name, it has to start with the string system-column-node, and then  the name, and the group has to be system-column-nodes.  So to generate the certificate, we use a tool named CFSSL, and after executing the tool,  we have the CSR file, just here, and the associate private key.  Then we will contact the Kubernetes API, we will tell him we want to perform a certificate-signing-request,  we'll give a name to the certificate-signing-request, we'll use a signer, kube-ipiserver-client-kubelet,  and inside the request, we will provide the CSR file.  So here, our certificate-signing-request is well-created.  We can list all certificate-signing-requests inside the cluster, and as you can see, there  is our certificate-signing-request.  And more important thing, this certificate-signing-request is approved and issued.  From there, we can print the details of this certificate-signing-request, and inside this,  we have the property certificate, and this property is the sign-in certificate.  And we will use this certificate to authenticate as a new node to the API server.  So here I save the certificate, you can see the content of the certificate, and I create  a new alias, canyounode, and this time, instead of using the bootstrap token, we use the certificate  and the private key.  And if we list our new privileges, we are now a node, and we are part of the nodes group,  which is really nice.  Then I will list the privileges, and as you can see here, there are new resource nodes,  and we can get, list, and watch, which means we can list other nodes of the cluster.  And what would we do?  So here, if I use my old privileges, and I ask to the Kubernetes API, can you give me  all the nodes, I have a forbidden error message.  But if I use my new privileges, it prints all nodes that are running inside my cluster.  We can do exactly the same with pod, so we can list pod host network and pod target.  And now we want to extract secrets from pod, but we don't know where are the secrets.  So what we can do is print all details for all pods inside the cluster, and grep for  the string secret.  So here, what we can see, inside the pod target, there is a secret named my secret, and our  goal is to retrieve this secret.  So naively, I can try to access the secret directly, but I have a forbidden error message,  because as you can see on the error message, there is no relationship between the new node  node and the my secret secret.  So to extract the secret, we have to become the node that is running the pod that holds  the secret.  Here is a pod, pod free.  So I will do the same, I will create a certificate sending request for the pod free.  Then I will send my command to the Kubernetes API.  So as you can see here, just here, the certificate sending API is approved and issued.  So I can retrieve the certificate and save it.  And then I will use my new certificate, my private key, and I ask the Kubernetes API  to give me the content of my secret.  And here, everything works, we have the content of the secret.  Now I will let Paul lead us to Cluster Admin.  Hello, do you hear me?  So yeah, we saw that we can sign a certificate for any kubelet, and so we'll be able to access  any secrets or config maps used inside any pod inside the cluster.  In a real-life scenario, this is often enough because we'll be able to retrieve database  credentials, server credentials, user credentials, and yeah, it will be often enough.  As we will see, you can also access any service accounts which are used inside a pod because  you will be able to create a new JWT and in a real cluster, you will find some of them  which are quite privileged.  So it will be a fine way to escalate to Cluster Admin.  But we are not in a real cluster and we wanted to find an out-of-the-box privileged escalation.  So if I can, yeah.  So that's why when we create a cluster, we use the Calico network policies inside the  cluster because, as we'll see, it will come with a lot of pre-deployed resources that  we will be able to exploit.  So for our privileged escalation, we will be starting by enumerating all the different  resources that are present by default in this cluster.  And in particular, we will be focusing on the Tigera Operator pod and service account.  Then we'll be exploiting the previous exploit to retrieve the certificate for the nodes  where the Tigera Operator pod is running.  And we will retrieve a JWT for this service account.  So we'll see that with that, we'll be able to become Cluster Admin.  OK, so this is the same cluster, but there is a lot of things that we didn't find earlier  because now we are listing the resources inside all the different namespaces.  You can find our two pods that we deployed for the first one here in the default namespace.  There is a lot of things regarding Calico, which is normal because we are using Calico.  A lot of different pods that are here for Azure environment.  Then you will see here the Tigera Operator pod, and inside this pod, we can check by  getting the details of this pod, there is a service account which is named Tigera Operator.  Then by listing the different cluster role binding, we can find that for this Tigera  service account, there is a cluster role which is bind to it, which is a Tigera Operator  cluster role.  And if we check all the different permissions for this service account, for this cluster  role, this is quite a lot.  It is a lot of permissions.  So again, inside a real-life cluster, it will often be enough because, for example, here  if we list just some permissions for this, regarding pods, we will be able to create  any new pods.  So by creating a new privileged pod on every node, we will be able to escape on every node  and compromise any server.  But we want to be cluster-aligned, so we will check on other resources, the cluster role  and cluster role bindings, and you can see here that we will be able to create a new  one and bind cluster role binding.  This is a special security feature in Kubernetes.  By default, you can't bind roles that are granting more privileges that you already  have to prevent privilege escalation.  But if you have the bind permission, you can do what you want.  So we will exploit that.  We'll reuse our new node certificate that we made earlier.  We will check where the Tigera Operator pod is running.  So here it is on the node number one.  As we hear, we will get the pod UID.  We'll see why it's relevant later, but we will need that.  So we grab it.  And so we will create, as before, a certificate for our node number one.  We'll send our certificate signing request and retrieve our certificate.  We will make another new aliases for this node with our certificate that we just signed.  And we can ask for a JWT token for any service accounts that run on this node.  So here we want the Tigera Operator, and we used the pod name here and the object UID,  so the pod UID here.  This is for another security mechanism that we didn't speak about.  This is to validate the node admission plugin, which will restrict some other thing.  And so we need to bound this JWT to a running pod.  So we have a JWT.  It's fine.  We'll put it inside a variable, and we'll be using it to authenticate to the API server.  And we can see that, yeah, in fact, we are well authenticated as Tigera Operator service account.  And we can check also that we have all the privileges that we are expecting, so quite a lot.  Yeah, but we're not cluster admin yet, and we want to do that.  So we will create a new cluster role binding, just binding the cluster admin cluster role  to the Tigera service account.  So we just apply this cluster role binding, and here we have all right on every resources.  That's what does a start mean.  We can do anything inside the cluster, and so we are cluster admin.  OK, that's all for our demo.  Now let's talk a little bit about what Microsoft has to say about it, and what can you do yourself.  So this is a quick timeline of our disclosing.  We'll just pause it because it's not really important.  Microsoft states that, yeah, it is a security boundary bypass, but we will not act immediately  on it because it's just at the cluster level.  You can't bounce between multiple clusters, so yeah, maybe one day.  So they start to work on something after our disclosing, but for the moment, we didn't  show anywhere where you can activate it or use it, so maybe one day.  So what can you do yourself to protect your cluster?  Not so much.  Just don't choose pod sharing as a host network namespace.  There is really, really few use cases where this is useful, and if you do that, maybe  you can do it in a better way.  And if you think that you were compromised in the past, Bootstrap tokens are a really  good way to have persistence inside an AKS cluster.  As I said, you can have an expiration date, but during our test, we didn't find any.  So your Bootstrap tokens don't have this in the manifest, and they can be used at least  for some weeks during our test.  So it can be a good way to come back in a cluster that you compromised.  If you try to delete a Bootstrap token, it will be ineffective because it will be automatically  recreated by a control plane element that we don't see and we don't have any control  over, and it seems to be bound to the node pool.  So if you want to rotate your Bootstrap token, just delete your node pool and recreate a  new one.  And so to prevent that, maybe monitor your CSR if you see some strange stuff, some strange  certificates or nodes that are signing new certificates.  But maybe you should look a little bit deeper.  So to conclude, AKS is not less secure than other cloud providers.  There are some attacks for GCP, AWS, DigitalOcean.  Just learn how your cloud provider works so that you will be able to understand the risk  and defend yourself.  We'll be adding this method to the Kubelet-Main tool.  This is a tool made by Mark Wickeden, which is used to automate all of these node attacks.  And if you want to know more, or if our French accent was a little bit too complicated to  understand, you can find our blog post describing all of our research.  Thank you very much.  Thank you to the staff.  And yeah, if you have any questions.  I have a question.  I'm not fully familiar with Kubernetes, but we saw that whenever you are not in the host  namespace, there is a firewall rule blocking you from contacting the wire server.  Would it be possible as a mitigation to implement a firewall rule directly on the wire server  in order to block the request from a node?  The node has to be able to speak with the wire server.  No, you can't.  No other questions?  Thank you everyone.  Thank you.